<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析 | zhoujinjian</title><meta name="keywords" content="Camera,Android,Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190109/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg">
<meta property="article:published_time" content="2019-01-09T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.968Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Camera">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190109/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-09T01:25:00.000Z" title="发表于 2019-01-09 09:25:00">2019-01-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.968Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Camera/">Camera</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/category/6282972">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775897/article/category/7112759">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/guming-camera.html">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p>
<hr>
<p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p>
<p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p>
<p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p>
<p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p>
<p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p>
<p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p>
<hr>
<h4 id="（一）、Camera-System-startPreview流程分析"><a href="#（一）、Camera-System-startPreview流程分析" class="headerlink" title="（一）、Camera System startPreview流程分析"></a>（一）、Camera System startPreview流程分析</h4><h5 id="1-1、Camera2-startPreview的应用层-Java-流程分析"><a href="#1-1、Camera2-startPreview的应用层-Java-流程分析" class="headerlink" title="1.1、Camera2 startPreview的应用层(Java)流程分析"></a>1.1、Camera2 startPreview的应用层(Java)流程分析</h5><p>preview流程都是从startPreview开始的，所以来看startPreview方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">(Surface previewSurface, CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mPreviewSurface = previewSurface;</span><br><span class="line">    <span class="comment">//根据Surface以及CaptureReadyCallback回调来建立preview环境</span></span><br><span class="line">    setupAsync(mPreviewSurface, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中有一个比较重要的回调CaptureReadyCallback，先分析setupAsync方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupAsync</span><span class="params">(<span class="keyword">final</span> Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mCameraHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//建立preview环境</span></span><br><span class="line">            setup(previewSurface, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过CameraHandler来post一个Runnable对象，它只会调用Runnable的run方法，它仍然属于UI线程，并没有创建新的线程。所以，继续分析setup方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaptureSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCaptureSession.abortCaptures();</span><br><span class="line">            mCaptureSession = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Surface&gt; outputSurfaces = <span class="keyword">new</span> ArrayList&lt;Surface&gt;(<span class="number">2</span>);</span><br><span class="line">        outputSurfaces.add(previewSurface);</span><br><span class="line">        outputSurfaces.add(mCaptureImageReader.getSurface());</span><br><span class="line">        <span class="comment">//创建CaptureSession会话来与Camera Device发送Preview请求</span></span><br><span class="line">        mDevice.createCaptureSession(outputSurfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//如果配置失败，则回调CaptureReadyCallback的onSetupFailed方法</span></span><br><span class="line">                listener.onSetupFailed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                mCaptureSession = session;</span><br><span class="line">                mAFRegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mAERegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mZoomValue = <span class="number">1f</span>;</span><br><span class="line">                mCropRegion = cropRegionForZoom(mZoomValue);</span><br><span class="line">                <span class="comment">//调用repeatingPreview来启动preview</span></span><br><span class="line">                <span class="keyword">boolean</span> success = repeatingPreview(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    <span class="comment">//若启动成功，则回调CaptureReadyCallback的onReadyForCapture，表示准备拍照成功</span></span><br><span class="line">                    listener.onReadyForCapture();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若启动失败，则回调CaptureReadyCallback的onSetupFailed，表示preview建立失败</span></span><br><span class="line">                    listener.onSetupFailed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onClosed(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Could not set up capture session&quot;</span>, ex);</span><br><span class="line">        listener.onSetupFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，调用Device的createCaptureSession方法来创建一个会话，并定义了会话的状态回调CameraCaptureSession.StateCallback()，其中，当会话创建成功，则会回调onConfigured()方法,在其中，首先调用repeatingPreview来启动preview，然后处理preview的结果并调用先前定义的CaptureReadyCallback来通知用户进行Capture操作。先分析repeatingPreview方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">repeatingPreview</span><span class="params">(Object tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过CameraDevice对象创建一个CaptureRequest的preview请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">                CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        <span class="comment">//添加预览的目标Surface</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//设置预览模式</span></span><br><span class="line">        builder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line">        <span class="comment">//利用会话发送请求，mCaptureCallback为</span></span><br><span class="line">        mCaptureSession.setRepeatingRequest(builder.build(), mCaptureCallback,mCameraHandler);</span><br><span class="line">        Log.v(TAG, String.format(<span class="string">&quot;Sent repeating Preview request, zoom = %.2f&quot;</span>, mZoomValue));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Could not access camera setting up preview.&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用CameraDeviceImpl的createCaptureRequest方法创建类型为TEMPLATE_PREVIEW 的CaptureRequest，然后调用CameraCaptureSessionImpl的setRepeatingRequest方法将此请求发送出去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setRepeatingRequest</span><span class="params">(CaptureRequest request, CaptureCallback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler handler)</span> <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;request must not be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.isReprocess()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;repeating reprocess requests are not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    handler = checkHandler(handler, callback);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将此请求添加到待处理的序列里</span></span><br><span class="line">    <span class="keyword">return</span> addPendingSequence(mDeviceImpl.setRepeatingRequest(request,createCaptureCallbackProxy(</span><br><span class="line">        handler, callback), mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此应用层的preview的请求流程分析结束，继续分析其结果处理，如果preview开启成功，则会回调CaptureReadyCallback的onReadyForCapture方法，现在分析CaptureReadyCallback回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Could not set up preview.&quot;</span>);</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Camera closed, aborting.&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mCamera.close();</span><br><span class="line">                mCamera = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Ready for capture.&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Camera closed, aborting.&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                onPreviewStarted();</span><br><span class="line">                onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                mCamera.setReadyStateChangedListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                mUI.initializeZoom(mCamera.getMaxZoom());</span><br><span class="line">                mCamera.setFocusStateListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的分析，预览成功后会回调onReadyForCapture方法，它主要是通知主线程的状态改变，并设置Camera的ReadyStateChangedListener的监听，其回调方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyStateChanged</span><span class="params">(<span class="keyword">boolean</span> readyForCapture)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readyForCapture) &#123;</span><br><span class="line">        mAppController.getCameraAppUI().enableModeOptions();</span><br><span class="line">    &#125;</span><br><span class="line">    mAppController.setShutterEnabled(readyForCapture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，当其状态变成准备好拍照，则将会调用CameraActivity的setShutterEnabled方法，即使能快门按键，此时也就是说预览成功结束，可以按快门进行拍照了，所以，到这里，应用层的preview的流程基本分析完毕，下图是应用层的关键调用的流程时序图： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-01-preview_java_flow.png" alt="Alt text"></p>
<h5 id="1-2、Camera2-startPreview的Native层流程分析"><a href="#1-2、Camera2-startPreview的Native层流程分析" class="headerlink" title="1.2、Camera2 startPreview的Native层流程分析"></a>1.2、Camera2 startPreview的Native层流程分析</h5><p>分析Preview的Native的代码真是费了九牛二虎之力，若有分析不正确之处，请各位大神指正，在第一小节的后段最后会调用CameraDeviceImpl的setRepeatingRequest方法来提交请求，而在android6.0源码分析之Camera API2.0简介中，分析了Camera2框架Java IPC通信使用了CameraDeviceUser来进行通信，所以看Native层的ICameraDeviceUser的onTransact方法来处理请求的提交：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.aidl]</span><br><span class="line">status_t BnCameraDeviceUser::onTransact(uint32_t code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, </span><br><span class="line">        uint32_t flags)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">//请求提交</span></span><br><span class="line">        <span class="keyword">case</span> SUBMIT_REQUEST: &#123;</span><br><span class="line">            CHECK_INTERFACE(ICameraDeviceUser, data, reply);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg0 = request</span></span><br><span class="line">            sp&lt;CaptureRequest&gt; request;</span><br><span class="line">            <span class="keyword">if</span> (data.readInt32() != <span class="number">0</span>) &#123;</span><br><span class="line">                request = <span class="keyword">new</span> CaptureRequest();</span><br><span class="line">                request-&gt;readFromParcel(const_cast&lt;Parcel*&gt;(&amp;data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg1 = streaming (bool)</span></span><br><span class="line">            bool repeating = data.readInt32();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return code: requestId (int32)</span></span><br><span class="line">            reply-&gt;writeNoException();</span><br><span class="line">            int64_t lastFrameNumber = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将实现BnCameraDeviceUser的对下岗的submitRequest方法代码写入Binder</span></span><br><span class="line">            reply-&gt;writeInt32(submitRequest(request, repeating, &amp;lastFrameNumber));</span><br><span class="line">            reply-&gt;writeInt32(<span class="number">1</span>);</span><br><span class="line">            reply-&gt;writeInt64(lastFrameNumber);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraDeviceClientBase继承了BnCameraDeviceUser类，所以CameraDeviceClientBase相当于IPC Binder中的client，所以会调用其submitRequest方法，此处，至于IPC Binder通信原理不做分析，其参照其它资料：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::submitRequest</span><span class="params">(sp&lt;CaptureRequest&gt; request,<span class="keyword">bool</span> streaming,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span>* lastFrameNumber)</span> </span>&#123;</span><br><span class="line">    List&lt;sp&lt;CaptureRequest&gt; &gt; requestList;</span><br><span class="line">    requestList.push_back(request);</span><br><span class="line">    <span class="keyword">return</span> submitRequestList(requestList, streaming, lastFrameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的调用，继续分析submitRequestList：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::submitRequestList</span><span class="params">(List&lt;sp&lt;CaptureRequest&gt; &gt; requests,<span class="keyword">bool</span> streaming, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int64_t</span>* lastFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Metadata链表</span></span><br><span class="line">    List&lt;<span class="keyword">const</span> CameraMetadata&gt; metadataRequestList;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;sp&lt;CaptureRequest&gt; &gt;::iterator it = requests.begin(); it != requests.end(); ++it) &#123;</span><br><span class="line">        sp&lt;CaptureRequest&gt; request = *it;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化Metadata数据</span></span><br><span class="line">        <span class="function">CameraMetadata <span class="title">metadata</span><span class="params">(request-&gt;mMetadata)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//设置Stream的容量</span></span><br><span class="line">        Vector&lt;<span class="keyword">int32_t</span>&gt; outputStreamIds;</span><br><span class="line">        outputStreamIds.setCapacity(request-&gt;mSurfaceList.size());</span><br><span class="line">        <span class="comment">//循环初始化Surface</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; request-&gt;mSurfaceList.size(); ++i) &#123;</span><br><span class="line">            sp&lt;Surface&gt; surface = request-&gt;mSurfaceList[i];</span><br><span class="line">            <span class="keyword">if</span> (surface == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">int</span> idx = mStreamMap.indexOfKey(IInterface::asBinder(gbp));</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> streamId = mStreamMap.valueAt(idx);</span><br><span class="line">            outputStreamIds.push_back(streamId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        metadata.update(ANDROID_REQUEST_OUTPUT_STREAMS, &amp;outputStreamIds[<span class="number">0</span>],</span><br><span class="line">                        outputStreamIds.size());</span><br><span class="line">        <span class="keyword">if</span> (request-&gt;mIsReprocess) &#123;</span><br><span class="line">            metadata.update(ANDROID_REQUEST_INPUT_STREAMS, &amp;mInputStream.id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        metadata.update(ANDROID_REQUEST_ID, &amp;requestId, <span class="comment">/*size*/</span><span class="number">1</span>);</span><br><span class="line">        loopCounter++; <span class="comment">// loopCounter starts from 1</span></span><br><span class="line">        <span class="comment">//压栈</span></span><br><span class="line">        metadataRequestList.push_back(metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    mRequestIdCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streaming) &#123;</span><br><span class="line">        <span class="comment">//预览会走此条通道</span></span><br><span class="line">        res = mDevice-&gt;setStreamingRequestList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStreamingRequestList.push_back(requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Capture等走此条通道</span></span><br><span class="line">        res = mDevice-&gt;captureList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setStreamingRequestList和captureList方法都调用了submitRequestsHelper方法，只是他们的repeating参数一个ture,一个为false，而本节分析的preview调用的是setStreamingRequestList方法，并且API2.0下Device的实现为Camera3Device，所以看它的submitRequestsHelper实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Device::submitRequestsHelper</span><span class="params">(<span class="keyword">const</span> List&lt;<span class="keyword">const</span> CameraMetadata&gt; &amp;requests, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> repeating,<span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RequestList requestList;</span><br><span class="line">    <span class="comment">//在这里面会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，即后面要分析的重要的回调</span></span><br><span class="line">    res = convertMetadataListToRequestListLocked(requests, <span class="comment">/*out*/</span>&amp;requestList);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (repeating) &#123;</span><br><span class="line">        <span class="comment">//眼熟不，这个方法名和应用层中CameraDevice的setRepeatingRequests一样</span></span><br><span class="line">        res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不需重复，即repeating为false时，调用此方法来讲请求提交</span></span><br><span class="line">        res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-02-preview_native_architecture.png" alt="Alt text"></p>
<p>从代码可知，在Camera3Device里创建了要给RequestThread线程，调用它的setRepeatingRequests或者queueRequestList方法来将应用层发送过来的Request提交，继续看setRepeatingRequests方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::RequestThread::setRepeatingRequests(<span class="keyword">const</span> RequestList &amp;requests,</span><br><span class="line">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber) &#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mRequestLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lastFrameNumber != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *lastFrameNumber = mRepeatingLastFrameNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    mRepeatingRequests.clear();</span><br><span class="line">    <span class="comment">//将其插入mRepeatingRequest链表</span></span><br><span class="line">    mRepeatingRequests.insert(mRepeatingRequests.begin(),</span><br><span class="line">            requests.begin(), requests.end());</span><br><span class="line"></span><br><span class="line">    unpauseForNewRequests();</span><br><span class="line"></span><br><span class="line">    mRepeatingLastFrameNumber = NO_IN_FLIGHT_REPEATING_FRAMES;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Native层的preview过程基本分析结束，下面的工作将会交给Camera HAL层来处理，先给出Native层的调用时序图： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-03-preview_native_flow.png" alt="Alt text"></p>
<h5 id="1-3、Camera2-startPreview的HAL层流程分析"><a href="#1-3、Camera2-startPreview的HAL层流程分析" class="headerlink" title="1.3、Camera2 startPreview的HAL层流程分析"></a>1.3、Camera2 startPreview的HAL层流程分析</h5><p>本节将不再对Camera的HAL层的初始化以及相关配置进行分析，只对preview等相关流程中的frame metadata的处理流程进行分析，具体的CameraHAL分析请参考前一篇分析，在第二小节的submitRequestsHelper方法中调用convertMetadataListToRequestListLocked的时候会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，所以Native层在request提交后，会回调此captureResultCb方法，首先分析captureResultCb：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QCamera3HardwareInterface::captureResultCb</span><span class="params">(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">camera3_stream_buffer_t</span> *buffer, <span class="keyword">uint32_t</span> frame_number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata_buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBatchSize) &#123;</span><br><span class="line">            <span class="comment">//批处理模式，但代码也是循环调用handleMetadataWithLock方法</span></span><br><span class="line">            handleBatchMetadata(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* mBatchSize = 0 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;mMutex);    </span><br><span class="line">            <span class="comment">//处理元数据</span></span><br><span class="line">            handleMetadataWithLock(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">        handleBufferWithLock(buffer, frame_number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种是通过循环来进行元数据的批处理，另一种是直接进行元数据的处理，但是批处理最终也是循环调用handleMetadataWithLock来处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QCamera3HardwareInterface::handleMetadataWithLock</span><span class="params">(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> free_and_bufdone_meta_buf)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Partial result on process_capture_result for timestamp</span></span><br><span class="line">    <span class="keyword">if</span> (urgent_frame_number_valid) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i =mPendingRequestsList.begin(); </span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;frame_number == urgent_frame_number &amp;&amp;i-&gt;bUrgentReceived == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">                i-&gt;partial_result_cnt++;</span><br><span class="line">                i-&gt;bUrgentReceived = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//提取3A数据</span></span><br><span class="line">                result.result =translateCbUrgentMetadataToResultMetadata(metadata);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//对Capture Result进行处理</span></span><br><span class="line">                mCallbackOps-&gt;process_capture_result(mCallbackOps, &amp;result);</span><br><span class="line">                <span class="comment">//释放camera_metadata_t</span></span><br><span class="line">                free_camera_metadata((<span class="keyword">camera_metadata_t</span> *)result.result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">            i != mPendingRequestsList.end() &amp;&amp; i-&gt;frame_number &lt;= frame_number;) &#123;</span><br><span class="line">        <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;frame_number &lt; frame_number) &#123;</span><br><span class="line">            <span class="comment">//清空数据结构</span></span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">            <span class="comment">//定义消息类型</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            notify_msg.message.shutter.frame_number = i-&gt;frame_number;</span><br><span class="line">            notify_msg.message.shutter.timestamp = (<span class="keyword">uint64_t</span>)capture_time (urgent_frame_number - </span><br><span class="line">                i-&gt;frame_number) * NSEC_PER_33MSEC;</span><br><span class="line">            <span class="comment">//调用回调通知应用层发生CAMERA3_MSG_SHUTTER消息</span></span><br><span class="line">            mCallbackOps-&gt;notify(mCallbackOps, &amp;notify_msg);</span><br><span class="line">            ...</span><br><span class="line">            CameraMetadata dummyMetadata;</span><br><span class="line">            <span class="comment">//更新元数据</span></span><br><span class="line">            dummyMetadata.update(ANDROID_SENSOR_TIMESTAMP,</span><br><span class="line">                    &amp;i-&gt;timestamp, <span class="number">1</span>);</span><br><span class="line">            dummyMetadata.update(ANDROID_REQUEST_ID,</span><br><span class="line">                    &amp;(i-&gt;request_id), <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到元数据释放结果</span></span><br><span class="line">            result.result = dummyMetadata.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send shutter notify to frameworks</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//从HAL中获得Metadata</span></span><br><span class="line">            result.result = translateFromHalMetadata(metadata,</span><br><span class="line">                    i-&gt;timestamp, i-&gt;request_id, i-&gt;jpegMetadata, i-&gt;pipeline_depth,</span><br><span class="line">                    i-&gt;capture_intent);</span><br><span class="line">            saveExifParams(metadata);</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;blob_request) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (enabled &amp;&amp; metadata-&gt;is_tuning_params_valid) &#123;</span><br><span class="line">                    <span class="comment">//将Metadata复制到文件</span></span><br><span class="line">                    dumpMetadataToFile(metadata-&gt;tuning_params, mMetaFrameCount, enabled,</span><br><span class="line">                        <span class="string">&quot;Snapshot&quot;</span>,frame_number);</span><br><span class="line">                &#125;</span><br><span class="line">                mPictureChannel-&gt;queueReprocMetadata(metadata_buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Return metadata buffer</span></span><br><span class="line">                <span class="keyword">if</span> (free_and_bufdone_meta_buf) &#123;</span><br><span class="line">                    mMetadataChannel-&gt;bufDone(metadata_buf);</span><br><span class="line">                    <span class="built_in">free</span>(metadata_buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，首先会调用回调的process_capture_result方法来对Capture Result进行处理，然后会调用回调的notify方法来发送一个CAMERA3_MSG_SHUTTER消息，而process_capture_result所对应的实现其实就是Camera3Device的processCaptureResult方法，先分析processCaptureResult：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::processCaptureResult</span><span class="params">(<span class="keyword">const</span> camera3_capture_result *result)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//对于HAL3.2+,如果HAL不支持partial，当metadata被包含在result中时，它必须将partial_result设置为1</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInFlightLock)</span></span>;</span><br><span class="line">        <span class="keyword">ssize_t</span> idx = mInFlightMap.indexOfKey(frameNumber);</span><br><span class="line">        ...</span><br><span class="line">        InFlightRequest &amp;request = mInFlightMap.editValueAt(idx);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;partial_result != <span class="number">0</span>)</span><br><span class="line">            request.resultExtras.partialResultCount = result-&gt;partial_result;</span><br><span class="line">        <span class="comment">// 检查结果是否只有partial metadata</span></span><br><span class="line">        <span class="keyword">if</span> (mUsePartialResult &amp;&amp; result-&gt;result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;<span class="comment">//HAL版本高于3.2</span></span><br><span class="line">                <span class="keyword">if</span> (result-&gt;partial_result &gt; mNumPartialResults || result-&gt;partial_result &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//Log显示错误</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                isPartialResult = (result-&gt;partial_result &lt; mNumPartialResults);</span><br><span class="line">                <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                    <span class="comment">//将结果加入到请求的结果集中</span></span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//低于3.2</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                <span class="comment">// Fire off a 3A-only result if possible</span></span><br><span class="line">                <span class="keyword">if</span> (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;result != <span class="literal">NULL</span> &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                <span class="comment">//发送Capture Result</span></span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, </span><br><span class="line">                    frameNumber, hasInputBufferInRequest,request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果处理好了，将请求移除</span></span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; <span class="comment">// scope for mInFlightLock</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，它会处理局部的或者全部的metadata数据，最后如果result不为空，且得到的是请求处理的全部数据，则会调用sendCaptureResult方法来将请求结果发送出去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::sendCaptureResult</span><span class="params">(CameraMetadata &amp;pendingMetadata,CaptureResultExtras </span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;resultExtras,CameraMetadata &amp;collectedPartialResult,<span class="keyword">uint32_t</span> frameNumber,<span class="keyword">bool</span> reprocess,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> AeTriggerCancelOverride_t &amp;aeTriggerCancelOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingMetadata.isEmpty())<span class="comment">//如果数据为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">    CaptureResult captureResult;</span><br><span class="line">    captureResult.mResultExtras = resultExtras;</span><br><span class="line">    captureResult.mMetadata = pendingMetadata;</span><br><span class="line">    <span class="comment">//更新metadata</span></span><br><span class="line">    <span class="keyword">if</span> (captureResult.mMetadata.update(ANDROID_REQUEST_FRAME_COUNT(<span class="keyword">int32_t</span>*)&amp;frameNumber, <span class="number">1</span>) </span><br><span class="line">            != OK) &#123;</span><br><span class="line">        SET_ERR(<span class="string">&quot;Failed to set frame# in metadata (%d)&quot;</span>,frameNumber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append any previous partials to form a complete result</span></span><br><span class="line">    <span class="keyword">if</span> (mUsePartialResult &amp;&amp; !collectedPartialResult.isEmpty()) &#123;</span><br><span class="line">        captureResult.mMetadata.append(collectedPartialResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    captureResult.mMetadata.sort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that there&#x27;s a timestamp in the result metadata</span></span><br><span class="line">    camera_metadata_entry entry = captureResult.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    ...</span><br><span class="line">    overrideResultForPrecaptureCancel(&amp;captureResult.mMetadata, aeTriggerCancelOverride);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的结果，将其插入Buffer</span></span><br><span class="line">    List&lt;CaptureResult&gt;::iterator queuedResult =mResultQueue.insert(mResultQueue.end(), </span><br><span class="line">        CaptureResult(captureResult));</span><br><span class="line">    ...</span><br><span class="line">    mResultSignal.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，它将Capture Result插入了结果队列，并释放了结果的信号量，所以到这里，Capture Result处理成功，下面分析前面的notify发送CAMERA3_MSG_SHUTTER消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::notify</span><span class="params">(<span class="keyword">const</span> camera3_notify_msg *msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    NotificationListener *listener;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mOutputLock)</span></span>;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_ERROR: &#123;</span><br><span class="line">            notifyError(msg-&gt;message.error, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_SHUTTER: &#123;</span><br><span class="line">            notifyShutter(msg-&gt;message.shutter, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SET_ERR(<span class="string">&quot;Unknown notify message from HAL: %d&quot;</span>,</span><br><span class="line">                    msg-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了notifyShutter方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::notifyShutter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">camera3_shutter_msg_t</span> &amp;msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        NotificationListener *listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set timestamp for the request in the in-flight tracking</span></span><br><span class="line">    <span class="comment">// and get the request ID to send upstream</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInFlightLock)</span></span>;</span><br><span class="line">        idx = mInFlightMap.indexOfKey(msg.frame_number);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            InFlightRequest &amp;r = mInFlightMap.editValueAt(idx);</span><br><span class="line">            <span class="comment">// Call listener, if any</span></span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//调用监听的notifyShutter法国法</span></span><br><span class="line">                listener-&gt;notifyShutter(r.resultExtras, msg.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将待处理的result发送到Buffer</span></span><br><span class="line">            sendCaptureResult(r.pendingMetadata, r.resultExtras,</span><br><span class="line">                r.partialResult.collectedResult, msg.frame_number,</span><br><span class="line">                r.hasInputBuffer, r.aeTriggerCancelOverride);</span><br><span class="line">            returnOutputBuffers(r.pendingOutputBuffers.<span class="built_in">array</span>(),</span><br><span class="line">                r.pendingOutputBuffers.size(), r.shutterTimestamp);</span><br><span class="line">            r.pendingOutputBuffers.clear();</span><br><span class="line">            removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先它会通知listener preview成功，最后会调用sendCaptureResult将结果加入到结果队列。它会调用listener的notifyShutter方法，此处的listener其实是CameraDeviceClient类，所以会调用CameraDeviceClient类的notifyShutter方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CameraDeviceClient::notifyShutter</span><span class="params">(<span class="keyword">const</span> CaptureResultExtras&amp; resultExtras,<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Thread safe. Don&#x27;t bother locking.</span></span><br><span class="line">    sp&lt;ICameraDeviceCallbacks&gt; remoteCb = getRemoteCallback();</span><br><span class="line">    <span class="keyword">if</span> (remoteCb != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用应用层的回调(CaptureCallback的onCaptureStarted方法)</span></span><br><span class="line">        remoteCb-&gt;onCaptureStarted(resultExtras, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的ICameraDeviceCallbacks对应的是Java层的CameraDeviceImpl.java中的内部类CameraDeviceCallbacks，所以会调用它的onCaptureStarted方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(<span class="keyword">final</span> CaptureResultExtras resultExtras, <span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> requestId = resultExtras.getRequestId();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> frameNumber = resultExtras.getFrameNumber();</span><br><span class="line">    <span class="keyword">final</span> CaptureCallbackHolder holder;</span><br><span class="line"></span><br><span class="line">    synchronized(mInterfaceLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteDevice == null) <span class="keyword">return</span>; <span class="comment">// Camera already closed</span></span><br><span class="line">        <span class="comment">// Get the callback for this frame ID, if there is one</span></span><br><span class="line">        holder = CameraDeviceImpl.<span class="keyword">this</span>.mCaptureCallbackMap.get(requestId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Dispatch capture start notice</span></span><br><span class="line">        holder.getHandler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">if</span> (!CameraDeviceImpl.<span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">                    holder.getCallback().onCaptureStarted(CameraDeviceImpl.<span class="keyword">this</span>,holder.getRequest(</span><br><span class="line">                        resultExtras.getSubsequenceId()),timestamp, frameNumber);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会调用OneCameraImpl.java中的mCaptureCallback的onCaptureStarted方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="comment">//Common listener for preview frame metadata.  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.CaptureCallback mCaptureCallback =</span><br><span class="line">    <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onCaptureStarted(CameraCaptureSession session,CaptureRequest request, </span><br><span class="line">            <span class="keyword">long</span> timestamp,<span class="keyword">long</span> frameNumber) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getTag() == RequestTag.CAPTURE&amp;&amp; mLastPictureCallback != null) &#123;</span><br><span class="line">                mLastPictureCallback.onQuickExpose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>camera工作时，存在了５中流处理线程和一个专门向hal发送请求的request线程。线程之间通过信号来同步，稍不注意就搞不明白代码是如何运行的了。其中很容易让我们忽视的就是在流发送之前的parent-&gt;registerInFlight()该操作将当前的请求保存到一个数组(可以理解成)中。这个数组对象在后续回帧操作中，会将相应帧的shutter,时间戳信息填充到对应的request中，紧接着就把对应帧的信息返回给app。好了先到这吧，下一篇分析Camera recording流程。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-04-preview_hal_architecture.png" alt="Alt text"></p>
<p>注意：Capture,preview以及autoFocus都是使用的这个回调，而Capture调用的时候，其RequestTag为CAPTURE，而autoFocus的时候为TAP_TO_FOCUS,而preview请求时没有对RequestTag进行设置，所以回调到onCaptureStarted方法时，不需要进行处理，但是到此时，preview已经启动成功，可以进行预览了，其数据都在buffer里。所以到此时，preview的流程全部分析结束，下面给出HAL层上的流程时序图 </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-05-preview_hal_flow.png" alt="Alt text"></p>
<h4 id="（二）、Camera-System-takePicture流程分析"><a href="#（二）、Camera-System-takePicture流程分析" class="headerlink" title="（二）、Camera System takePicture流程分析"></a>（二）、Camera System takePicture流程分析</h4><p>与TakePicture息息相关的主要有4个线程CaptureSequencer,JpegProcessor,Camera3Device::RequestThread,FrameProcessorBase如下面的代码可以发现，在Camera2client对象初始化后，已经有３个线程已经run起来了，还有有一个RequestThread线程会在Camera3Device初始化时创建的。他们工作非常密切，如下大概画了一个他们的工作机制，４个线程都是通过Conditon条件变量来同步的。 </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-06-Camera3Device-RequestThread.png" alt="Alt text"></p>
<p>前面分析preview的时候，当预览成功后，会使能ShutterButton，即可以进行拍照，定位到ShutterButton的监听事件为onShutterButtonClick方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutterButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Camera未打开</span></span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> countDownDuration = mSettingsManager.getInteger(SettingsManager</span><br><span class="line">        .SCOPE_GLOBAL,Keys.KEY_COUNTDOWN_DURATION);</span><br><span class="line">    <span class="keyword">if</span> (countDownDuration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始倒计时</span></span><br><span class="line">        mAppController.getCameraAppUI().transitionToCancel();</span><br><span class="line">        mAppController.getCameraAppUI().hideModeOptions();</span><br><span class="line">        mUI.setCountdownFinishedListener(<span class="keyword">this</span>);</span><br><span class="line">        mUI.startCountdown(countDownDuration);</span><br><span class="line">        <span class="comment">// Will take picture later via listener callback.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//即刻拍照</span></span><br><span class="line">        takePictureNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，读取Camera的配置，判断配置是否需要延时拍照，此处分析不需延时的情况，即调用takePictureNow方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Not taking picture since Camera is closed.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Capture会话并开启会话</span></span><br><span class="line">    CaptureSession session = createAndStartCaptureSession();</span><br><span class="line">    <span class="comment">//获取Camera的方向</span></span><br><span class="line">    <span class="keyword">int</span> orientation = mAppController.getOrientationManager()</span><br><span class="line">        .getDeviceOrientation().getDegrees();</span><br><span class="line">    <span class="comment">//初始化图片参数</span></span><br><span class="line">    PhotoCaptureParameters params = <span class="keyword">new</span> PhotoCaptureParameters(</span><br><span class="line">            session.getTitle(), orientation, session.getLocation(),</span><br><span class="line">            mContext.getExternalCacheDir(), <span class="keyword">this</span>, mPictureSaverCallback,</span><br><span class="line">            mHeadingSensor.getCurrentHeading(), mZoomValue, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//装配Session</span></span><br><span class="line">    decorateSessionAtCaptureTime(session);</span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    mCamera.takePicture(params, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先调用createAndStartCaptureSession来创建一个CaptureSession并且启动会话,这里并且会进行初始参数的设置，譬如设置CaptureModule(此处实参为this)为图片处理的回调(后面再分析)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> CaptureSession <span class="title">createAndStartCaptureSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取会话时间</span></span><br><span class="line">    <span class="keyword">long</span> sessionTime = getSessionTime();</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    Location location = mLocationManager.getCurrentLocation();</span><br><span class="line">    <span class="comment">//设置picture name</span></span><br><span class="line">    String title = CameraUtil.instance().createJpegName(sessionTime);</span><br><span class="line">    <span class="comment">//创建会话</span></span><br><span class="line">    CaptureSession session = getServices().getCaptureSessionManager()</span><br><span class="line">           .createNewSession(title, sessionTime, location);</span><br><span class="line">    <span class="comment">//开启会话</span></span><br><span class="line">    session.startEmpty(<span class="keyword">new</span> CaptureStats(mHdrPlusEnabled),<span class="keyword">new</span> Size(</span><br><span class="line">        (<span class="keyword">int</span>) mPreviewArea.width(), (<span class="keyword">int</span>) mPreviewArea.height()));</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，获取会话的相关参数，包括会话时间，拍照的照片名字以及位置信息等，然后调用Session管理来创建CaptureSession，最后将此CaptureSession启动。到这里，会话就创建并启动了，所以接着分析上面的拍照流程，它会调用OneCameraImpl的takePicture方法来进行拍照：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">(<span class="keyword">final</span> PhotoCaptureParameters params, <span class="keyword">final</span> CaptureSession session)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 除非拍照已经返回，否则就广播一个未准备好状态的广播，即等待本次拍照结束</span></span><br><span class="line">    broadcastReadyState(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    mTakePictureRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//拍照</span></span><br><span class="line">            takePictureNow(params, session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//设置回调，此回调后面将分析，它其实就是CaptureModule,它实现了PictureCallback</span></span><br><span class="line">    mLastPictureCallback = params.callback;</span><br><span class="line">    mTakePictureStartMillis = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要自动聚焦</span></span><br><span class="line">    <span class="keyword">if</span> (mLastResultAFState == AutoFocusState.ACTIVE_SCAN) &#123;</span><br><span class="line">        mTakePictureWhenLensIsStopped = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拍照</span></span><br><span class="line">        takePictureNow(params, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拍照里，首先广播一个未准备好的状态广播，然后进行拍照的回调设置，并且判断是否有自动聚焦，如果是则将mTakePictureWhenLensIsStopped 设为ture，即即刻拍照被停止了，否则则调用OneCameraImpl的takePictureNow方法来发起拍照请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">(PhotoCaptureParameters params, CaptureSession </span></span></span><br><span class="line"><span class="function"><span class="params">        session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> dt = SystemClock.uptimeMillis() - mTakePictureStartMillis;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造JPEG图片拍照的请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">            CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        builder.setTag(RequestTag.CAPTURE);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable lens-shading correction for even better DNGs.</span></span><br><span class="line">        <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.RAW_SENSOR) &#123;</span><br><span class="line">            builder.set(CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE,</span><br><span class="line">                CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_ON);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.JPEG) &#123;</span><br><span class="line">            builder.set(CaptureRequest.JPEG_QUALITY, JPEG_QUALITY);</span><br><span class="line">                .getJpegRotation(params.orientation, mCharacteristics));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于preview的控件</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//用于图片显示的控件</span></span><br><span class="line">        builder.addTarget(mCaptureImageReader.getSurface());</span><br><span class="line">        CaptureRequest request = builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_WRITE_CAPTURE_DATA) &#123;</span><br><span class="line">            <span class="keyword">final</span> String debugDataDir = makeDebugDir(params.debugDataFolder,</span><br><span class="line">                        <span class="string">&quot;normal_capture_debug&quot;</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Writing capture data to: &quot;</span> + debugDataDir);</span><br><span class="line">            CaptureDataSerializer.toFile(<span class="string">&quot;Normal Capture&quot;</span>, request, </span><br><span class="line">                <span class="keyword">new</span> File(debugDataDir,<span class="string">&quot;capture.txt&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拍照，mCaptureCallback为回调</span></span><br><span class="line">        mCaptureSession.capture(request, mCaptureCallback, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Could not access camera for still image capture.&quot;</span>);</span><br><span class="line">        broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">        params.callback.onPictureTakingFailed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCaptureQueue) &#123;</span><br><span class="line">        mCaptureQueue.add(<span class="keyword">new</span> InFlightCapture(params, session));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与preview类似，都是通过CaptureRequest来与Camera进行通信的，通过session的capture来进行拍照，并设置拍照的回调函数为mCaptureCallback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capture</span><span class="params">(CaptureRequest request,CaptureCallback callback,Handler handler)</span><span class="keyword">throws</span> CameraAccessException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    handler = checkHandler(handler,callback);</span><br><span class="line">    <span class="keyword">return</span> addPendingSequence(mDeviceImpl.capture(request,createCaptureCallbackProxy(</span><br><span class="line">        handler,callback),mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码与preview中的类似，都是将请求加入到待处理的请求集，现在看CaptureCallback回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.CaptureCallback mCaptureCallback = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(CameraCaptureSession session,CaptureRequest request,<span class="keyword">long</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            timestamp,<span class="keyword">long</span> frameNumber)</span></span>&#123;</span><br><span class="line">　　　　　<span class="comment">//与preview类似</span></span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE&amp;&amp;mLastPictureCallback!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mLastPictureCallback.onQuickExpose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(CameraCaptureSession session,CaptureRequest request</span></span></span><br><span class="line"><span class="function"><span class="params">            ,TotalCaptureResult result)</span></span>&#123;</span><br><span class="line">        autofocusStateChangeDispatcher(result);</span><br><span class="line">        <span class="keyword">if</span>(result.get(CaptureResult.CONTROL_AF_STATE) == <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　<span class="comment">//检查自动聚焦的状态</span></span><br><span class="line">            AutoFocusHelper.checkControlAfState(result);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(mCaptureQueue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mCaptureQueue.getFirst().setCaptureResult(result).isCaptureComplete())&#123;</span><br><span class="line">                    capture = mCaptureQueue.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(capture != <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">//拍照结束</span></span><br><span class="line">                OneCameraImpl.<span class="keyword">this</span>.onCaptureCompleted(capture);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCaptureCompleted(session,request,result);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Native层在处理请求时，会调用相应的回调，如capture开始时，会回调onCaptureStarted,具体的在preview中有过分析，当拍照结束时，会回调onCaptureCompleted方法，其中会根据CaptureResult来检查自动聚焦的状态，并通过TAG判断其是Capture动作时，再来看它是否是队列中的第一个请求，如果是，则将请求移除，因为请求已经处理成功，最后再调用OneCameraImpl的onCaptureCompleted方法来进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(InFlightCapture capture)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isCaptureImageFormat == ImageFormat.RAW_SENSOR)&#123;</span><br><span class="line">        ...</span><br><span class="line">        File dngFile = <span class="keyword">new</span> File(RAW_DIRECTORY,capture.session.getTitle()+<span class="string">&quot;.dng&quot;</span>);</span><br><span class="line">        writeDngBytesAndClose(capture.image,capture.totalCaptureResult,mCharacteristics,dngFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//解析result中的图片数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] imageBytes = acquireJpegBytesAndClose(capture.image);</span><br><span class="line">        <span class="comment">//保存Jpeg图片</span></span><br><span class="line">        saveJpegPicture(imageBytes,capture.parameters,capture.session,capture.totalCaptureResult);</span><br><span class="line">    &#125;</span><br><span class="line">    broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用回调</span></span><br><span class="line">    capture.parameters.callback.onPictureTaken(capture.session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，首先，对result中的图片数据进行了解析，然后调用saveJpegPicture方法将解析得到的图片数据进行保存，最后再调用里面的回调(即CaptureModule，前面在初始化Parameters时说明了，它实现了PictureCallbak接口)的onPictureTaken方法，所以，接下来先分析saveJpegPicture方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveJpegPicture</span><span class="params">(<span class="keyword">byte</span>[] jpegData,<span class="keyword">final</span> PhotoCaptureParameters captureParams,CaptureSession session,CaptureResult result)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ListenableFuture&lt;Optional&lt;Uri&gt;&gt; futureUri = session.saveAndFinish(jpegData,width,</span><br><span class="line">            height,rotation,exif);</span><br><span class="line">    Futures.addCallback(futureUri,<span class="keyword">new</span> FutureCallback&lt;Optional&lt;Uri&gt;&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Optional&lt;Uri&gt; uriOptional)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(mOptional.orNull());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最后会回调onPictureSaved方法来对图片进行保存，所以需要分析CaptureModule的onPictureSaved方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureSaved</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    mAppController.notifyNewMedia(uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mAppController的实现为CameraActivity，所以分析notifyNewMedia方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyNewMedia</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeVideo(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果拍摄的是video</span></span><br><span class="line">        sendBroadcast(<span class="keyword">new</span> Intent(CameraUtil.ACTION_NEW_VIDEO,uri));</span><br><span class="line">        newData = mVideoItemFactory.queryContentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeImage(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果是拍摄图片</span></span><br><span class="line">        CameraUtil.broadcastNewPicture(mAppContext,uri);</span><br><span class="line">        newData = mPhotoItemFactory.queryCotentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;FilmstripItem,Void,FilmstripItem&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> FilmstripItem <span class="title">doInBackground</span><span class="params">(FilmstripItem... Params)</span></span>&#123;</span><br><span class="line">            FilmstripItem data = params[<span class="number">0</span>];</span><br><span class="line">            MetadataLoader.loadMetadata(getAndroidContet(),data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，这里有两种数据的处理，一种是video，另一种是image。而我们这里分析的是capture图片数据，所以首先会根据在回调函数传入的参数Uri和PhotoItemFactory来查询到相应的拍照数据，然后再开启一个异步的Task来对此数据进行处理，即通过MetadataLoader的loadMetadata来加载数据，并返回。至此，capture的流程就基本分析结束了，下面将给出capture流程的整个过程中的时序图： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-07-capture_over_flow.png" alt="Alt text"></p>
<h4 id="（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）"><a href="#（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）" class="headerlink" title="（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）"></a>（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）</h4><p>ZSL(zear shutter lag)即零延时，就是在拍照时不停预览就可以拍照.由于有较好的用户体验度，该feature是现在大部分手机都拥有的功能。<br>面不再贴出大量代码来描述过程，直接上图。下图是画了2个小时整理出来的Android5.1 Zsl的基本流程，可以看到与ZSL密切相关的有5个线程frameprocessor、captureSequencer、ZslProcessor3、JpegProcessor、Camera3Device:requestThread。其实还有一个主线程用于更新参数。针对Android5.1看代码所得，ZSL过程中大概分成下面7个流程.</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-08-ZSL_takepicture.png" alt="Alt text"></p>
<p>更正：图中左上角的FrameProcessor线程起来后会在waitForNextFrame中执行mResultSignal.waitRelative()，图中没有更改过来。</p>
<h5 id="3-0、注册帧监听对象"><a href="#3-0、注册帧监听对象" class="headerlink" title="3.0、注册帧监听对象"></a>3.0、注册帧监听对象</h5><h5 id="3-0-1、captureSequence线程注册帧监听对象"><a href="#3-0-1、captureSequence线程注册帧监听对象" class="headerlink" title="3.0.1、captureSequence线程注册帧监听对象"></a>3.0.1、captureSequence线程注册帧监听对象</h5><h5 id="3-0-1-1、注册时机"><a href="#3-0-1-1、注册时机" class="headerlink" title="3.0.1.1、注册时机"></a>3.0.1.1、注册时机</h5><p>当上层发出ZSL拍照请求时，底层就会触发拍照捕获状态机，改状态机的基本流程图在上篇笔记中已经整理出来过，这里就不多说了。由于camera2Client与其它处理线程对象基本符合金字塔形的架构，可以看到这里是通过camera2Client的对象将帧可用监听对象注册到FrameProcess对象中的List<RangeListener> mRangeListeners;对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="function">CaptureSequencer::CaptureState <span class="title">CaptureSequencer::manageZslStart</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;Camera2Client&gt; &amp;client)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;ZslProcessorInterface&gt; processor = mZslProcessor.promote();</span><br><span class="line">    <span class="comment">// We don&#x27;t want to get partial results for ZSL capture.</span></span><br><span class="line">    client-&gt;registerFrameListener(mCaptureId, mCaptureId + <span class="number">1</span>,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Actually select the right thing here.</span></span><br><span class="line">    res = processor-&gt;pushToReprocess(mCaptureId);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别注意：可以看到在注册帧监听对象时，传入的两个参数是mCaptureId, mCaptureId + 1,为什么会是这样呢,因为这个就是标记我们想抓的是哪一帧,当拍照buffer从hal上来之后,Camera3Device就会回调帧可用监听对象，然后得到拍照帧的时间戳，紧接着根据时间戳从ZSL RingBuffer中找到最理想的inputBuffer，然后下发给hal进行Jpeg编解码。对比下面ZSL线程的CaptureId,应该就理解了.</p>
<h5 id="3-0-1-2、捕获时机"><a href="#3-0-1-2、捕获时机" class="headerlink" title="3.0.1.2、捕获时机"></a>3.0.1.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaptureSequencer::onResultAvailable</span><span class="params">(<span class="keyword">const</span> CaptureResult &amp;result)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;%s: New result available.&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        .signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面即是拍照状态机注册的回调函数，其中当ZSL拍照帧上来之后，机会激活正在等待中的CaptureSequencer线程，以进行后续的操作。</p>
<h5 id="3-0-2、ZslProcess3线程注册帧监听对象"><a href="#3-0-2、ZslProcess3线程注册帧监听对象" class="headerlink" title="3.0.2、ZslProcess3线程注册帧监听对象"></a>3.0.2、ZslProcess3线程注册帧监听对象</h5><h5 id="3-0-2-1、注册时机"><a href="#3-0-2-1、注册时机" class="headerlink" title="3.0.2.1、注册时机"></a>3.0.2.1、注册时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ZslProcessor::updateStream</span><span class="params">(<span class="keyword">const</span> Parameters &amp;params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mZslStreamId == NO_STREAM) &#123;</span><br><span class="line">        <span class="comment">// Create stream for HAL production</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Sort out better way to select resolution for ZSL</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that format specified internally in Camera3ZslStream</span></span><br><span class="line">        res = device-&gt;createZslStream(</span><br><span class="line">                params.fastInfo.arrayWidth, params.fastInfo.arrayHeight,</span><br><span class="line">                mBufferQueueDepth,</span><br><span class="line">                &amp;mZslStreamId,</span><br><span class="line">                &amp;mZslStream);</span><br><span class="line">        <span class="comment">// Only add the camera3 buffer listener when the stream is created.</span></span><br><span class="line">        mZslStream-&gt;addBufferListener(<span class="keyword">this</span>);<span class="comment">//这里是在BufferQueue注册的callback，暂时不用关心。</span></span><br><span class="line">    &#125;</span><br><span class="line">    client-&gt;registerFrameListener(Camera2Client::kPreviewRequestIdStart,</span><br><span class="line">            Camera2Client::kPreviewRequestIdEnd,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的即为更新zsl流时调用的函数,可以看到其中使用registerFrameListener注册了RingBuffer可用监听对象，这里我们要特别注意的是下面2个宏。这个是专门为预览预留的requestId，考虑这样也会有录像和拍照的requestId,每次更新参数后，这个requestId会有+1操作，没有参数更新，则不会+1，这个可以在各自的Debug手机上发现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/Camera2Client.h]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdStart = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdEnd   = <span class="number">20000000</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-0-2-2、捕获时机"><a href="#3-0-2-2、捕获时机" class="headerlink" title="3.0.2.2、捕获时机"></a>3.0.2.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZslProcessor::onResultAvailable</span><span class="params">(<span class="keyword">const</span> CaptureResult &amp;result)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;%s:&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">    entry = result.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp = entry.data.i64[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT);</span><br><span class="line">    <span class="keyword">int32_t</span> frameNumber = entry.data.i32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corresponding buffer has been cleared. No need to push into mFrameList</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt;= mLatestClearedBufferTimestamp) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mFrameList.editItemAt(mFrameListHead) = result.mMetadata;</span><br><span class="line">    mFrameListHead = (mFrameListHead + <span class="number">1</span>) % mFrameListDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去掉错误检查代码，上面由于CaptureID是下面2个，也就是ZSL的所有预览Buffer可用之后都会回调这个方法,当队列满之后，新buffer会覆盖旧buffer位置。上面可以看到mFrameList中会保存每一帧的metadata数据，mFrameListHead用来标识下一次存放数据的位置。</p>
<h5 id="3-1、查找ZSL拍照最合适的buffer"><a href="#3-1、查找ZSL拍照最合适的buffer" class="headerlink" title="3.1、查找ZSL拍照最合适的buffer"></a>3.1、查找ZSL拍照最合适的buffer</h5><p>一开始我以为是是根据想要抓取那帧的captureId来找到zsl拍照buffer的，但是现在看来就是找时间戳最近的那个buffer来进行jpeg编解码(而且google工程师在源码中注释也是这样说的).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ZslProcessor::pushToReprocess</span><span class="params">(<span class="keyword">int32_t</span> requestId)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;%s: Send in reprocess request with id %d&quot;</span>,</span><br><span class="line">            __FUNCTION__, requestId);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line">    <span class="comment">//下面是就是在mFrameList查找时间戳最近的帧。</span></span><br><span class="line">    <span class="keyword">size_t</span> metadataIdx;</span><br><span class="line">    <span class="keyword">nsecs_t</span> candidateTimestamp = getCandidateTimestampLocked(&amp;metadataIdx);</span><br><span class="line">   <span class="comment">//根据上一次查找的时间戳，从ZSL BufferQueue中查找时间最接近的Buffer，并将</span></span><br><span class="line">   <span class="comment">//buffer保存到mInputBufferQueue队列中。</span></span><br><span class="line">    res = mZslStream-&gt;enqueueInputBufferByTimestamp(candidateTimestamp,</span><br><span class="line">                                                    <span class="comment">/*actualTimestamp*/</span><span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">//-----------------</span></span><br><span class="line">    &#123;<span class="comment">//获取zsl 编解码的metadataId，稍后会传入给hal编解码。</span></span><br><span class="line">        CameraMetadata request = mFrameList[metadataIdx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the frame is reasonable for reprocessing</span></span><br><span class="line">        <span class="keyword">camera_metadata_entry_t</span> entry;</span><br><span class="line">        entry = request.find(ANDROID_CONTROL_AE_STATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_CONVERGED &amp;&amp;</span><br><span class="line">                entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_LOCKED) &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;%s: ZSL queue frame AE state is %d, need full capture&quot;</span>,</span><br><span class="line">                    __FUNCTION__, entry.data.u8[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//这中间会更新输入stream的流ID、更新捕获意图为静态拍照、判断这一帧是否AE稳定、</span></span><br><span class="line">       <span class="comment">//获取jpegStreamID并更新到metadata中、更新请求ID，最后根据更新后的request metadata</span></span><br><span class="line">       <span class="comment">//更新jpeg metadata。最后一步启动Camera3Device抓取图片。</span></span><br><span class="line">        <span class="comment">// Update post-processing settings</span></span><br><span class="line">        res = updateRequestWithDefaultStillRequest(request);</span><br><span class="line">        mLatestCapturedRequest = request;</span><br><span class="line">        res = client-&gt;getCameraDevice()-&gt;capture(request);</span><br><span class="line">        mState = LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 还记得在启动状态机器时，注册的帧监听对象吧。这里参数requestId就是我们想要抓拍的图片的请求ID,目前发现该请求ID后面会更新到metadata中。这里只要知道该函数功能就可以了。</p>
<p>☯ 1、从mFrameList中查找时间戳最小的metadata。<br>☯ 2、根据从第一步获取到时间戳，从ZSL BufferQueue选择时间最接近Buffer.<br>☯3、将Buffer放到mInputBufferQueue中，更新jpeg编解码metadata，启动Capture功能。</p>
<h5 id="3-2、设置zsl-input-buffer和-jpeg-out-buffer"><a href="#3-2、设置zsl-input-buffer和-jpeg-out-buffer" class="headerlink" title="3.2、设置zsl input buffer和 jpeg out buffer"></a>3.2、设置zsl input buffer和 jpeg out buffer</h5><p>  其实这一步之前已经讨论过，inputBuffer是ZslProcess3线程查找到最合适的用于jpeg编解码的buffer。outputBuffer为JpegProcessor线程更新的buffer用于存放hal编解码之后的jpeg图片。其中准备jpeg OutBuffer的操作就是在下面操作的。可以看到将outputStream的ID，保存到metadata中了。这样就会在Camera3Device中根据这项metadata来添加outputBuffer到hal。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ZslProcessor::pushToReprocess</span><span class="params">(<span class="keyword">int32_t</span> requestId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Shouldn&#x27;t we also update the latest preview frame?</span></span><br><span class="line">        <span class="keyword">int32_t</span> outputStreams[<span class="number">1</span>] =</span><br><span class="line">                &#123; client-&gt;getCaptureStreamId() &#125;;</span><br><span class="line">        res = request.update(ANDROID_REQUEST_OUTPUT_STREAMS,</span><br><span class="line">                outputStreams, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、归还jpeg-Buffer干了什么"><a href="#3-3、归还jpeg-Buffer干了什么" class="headerlink" title="3.3、归还jpeg Buffer干了什么."></a>3.3、归还jpeg Buffer干了什么.</h5><p>  当framework将ZSL inputBuffer和jpeg outputBuffer,传给hal后，hal就会启动STLL_CAPTURE流程，将inputBuffer中的图像数据，进行一系列的后处理流程。当后处理完成后，hal则会将临时Buffer拷贝到outPutBuffer中(注意：这里要记得做flush操作，即刷新Buffer,要不然图片有可能会出现绿条).<br>  因为JpegBuffer也是从BufferQueue Dequeue出来的buffer,而且在创建BufferQueue时，也注册了帧监听对象(即：onFrameAvailable()回调).这样的话当帧可用(即：进行了enqueue操作），就会回调onFrameAvailable()方法，这样当hal归还jpegBuffer时就是要进行enqueue()操作。在onFrameAvailable()方法中，会激活jpegproces线程，进行后续的处理，最后激活captureSequeue拍照状态机线程。</p>
<h5 id="3-4、保存ZSLBuffer"><a href="#3-4、保存ZSLBuffer" class="headerlink" title="3.4、保存ZSLBuffer."></a>3.4、保存ZSLBuffer.</h5><p>  这里由于ZSL Buffer一直会从hal上来，所以当zslBuffer上来后，就会激活FrameProcesor线程保存这一ZslBuffer，目前FrameWork那边默认是4个buffer，这样的话当队列满之后，就会覆盖之前最老的buffer,如此反复操作。</p>
<h5 id="3-5、获取拍照jpeg-Buffer"><a href="#3-5、获取拍照jpeg-Buffer" class="headerlink" title="3.5、获取拍照jpeg Buffer"></a>3.5、获取拍照jpeg Buffer</h5><p>  当hal上来jpeg帧后，就会激活jpegProcess线程,并从BufferQueue中拿到jpegbuffer，下面可以发现进行lockNextBuffer,unlockBuffer操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">JpegProcessor::processNewCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    res = mCaptureConsumer-&gt;lockNextBuffer(&amp;imgBuffer);</span><br><span class="line">    mCaptureConsumer-&gt;unlockBuffer(imgBuffer);</span><br><span class="line">    sp&lt;CaptureSequencer&gt; sequencer = mSequencer.promote();</span><br><span class="line">   <span class="comment">//...... </span></span><br><span class="line">    <span class="keyword">if</span> (sequencer != <span class="number">0</span>) &#123;</span><br><span class="line">        sequencer-&gt;onCaptureAvailable(imgBuffer.timestamp, captureBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面可以发现最后回调了captureSequencer线程的onCaptureAvailable()回调方法。该回调方法主要作用就是将时间戳和jpeg buffer的传送到CaptureSequencer线程中,然后激活CaptureSequencer线程。最后将Buffer CallBack到应用层。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaptureSequencer::onCaptureAvailable</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;MemoryBase&gt; captureBuffer)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mCaptureTimestamp = timestamp;</span><br><span class="line">    mCaptureBuffer = captureBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!mNewCaptureReceived) &#123;</span><br><span class="line">        mNewCaptureReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewCaptureSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-6、拍照帧可用回调"><a href="#3-6、拍照帧可用回调" class="headerlink" title="3.6、拍照帧可用回调"></a>3.6、拍照帧可用回调</h5><p>当拍照帧回到Framework后，就会回调CaptureSequencer的onResultAvailable()接口，用于设置captureSequencer状态机的标志位和条件激活,如下代码所示。条件变量和标志位的使用可以在状态机方法manageStandardCaptureWait()看到使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CaptureSequencer::onResultAvailable</span><span class="params">(<span class="keyword">const</span> CaptureResult &amp;result)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;%s: New result available.&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewFrameSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-7、jpeg-buffer回调到app"><a href="#3-7、jpeg-buffer回调到app" class="headerlink" title="3.7、jpeg buffer回调到app"></a>3.7、jpeg buffer回调到app</h5><p>该callback是应用注册过来的一个代理对象，下面就是通过binder进程间调用将jpeg Buffer传送到APP端，注意这里的msgTyep = CAMERA_MSG_COMPRESSED_IMAGE,就是告诉上层这是一个压缩的图像数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="function">CaptureSequencer::CaptureState <span class="title">CaptureSequencer::manageDone</span><span class="params">(sp&lt;Camera2Client&gt; &amp;client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = OK;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mCaptureId++;</span><br><span class="line">        ......</span><br><span class="line">            Camera2Client::SharedCameraCallbacks::Lock</span><br><span class="line">            l(client-&gt;mSharedCameraCallbacks);</span><br><span class="line">        ALOGV(<span class="string">&quot;%s: Sending still image to client&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">            l.mRemoteCallback-&gt;dataCallback(CAMERA_MSG_COMPRESSED_IMAGE,</span><br><span class="line">                    mCaptureBuffer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;%s: No client!&quot;</span>, __FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（四）、Camera-System-Recorder流程分析"><a href="#（四）、Camera-System-Recorder流程分析" class="headerlink" title="（四）、Camera System Recorder流程分析"></a>（四）、Camera System Recorder流程分析</h4><p>camera Video.虽然标题是recording流程分析，但这里很多和preview是相似的(包含更新，创建Stream,创建Request)，这里主要分析MediaRecorder对象创建、video帧监听对象注册、帧可用事件以及一系列callback流程分析。</p>
<h5 id="4-1、认识video-mediaRecorder-状态机"><a href="#4-1、认识video-mediaRecorder-状态机" class="headerlink" title="4.1、认识video(mediaRecorder)状态机"></a>4.1、认识video(mediaRecorder)状态机</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-09-mediaRecorder-status.png" alt="Alt text"></p>
<blockquote>
<p>Used to record audio and video. The recording control is based on a<br>simple state machine (see below).状态机请看上面源码中给的流程图。<br>A common case of using MediaRecorder to record audio works as follows:<br>1.MediaRecorder recorder = new MediaRecorder();<br>2.recorder.setAudioSource(MediaRecorder.AudioSource.MIC);<br>3.recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);<br>4.recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);<br>5.recorder.setOutputFile(PATH_NAME);<br>6.recorder.prepare();<br>7.recorder.start(); // Recording is now started<br>8….<br>9.recorder.stop();<br>10.recorder.reset(); // You can reuse the object by going back to setAudioSource() step<br>recorder.release(); // Now the object cannot be reused<br>  Applications may want to register for informational and error<br>events in order to be informed of some internal update and possible<br>runtime errors during recording. Registration for such events is<br>done by setting the appropriate listeners (via calls<br>(to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or<br>{@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).<br>In order to receive the respective callback associated with these listeners,<br>applications are required to create MediaRecorder objects on threads with a<br>Looper running (the main UI thread by default already has a Looper running).</p>
</blockquote>
<p>上面是googole工程师加的注释，最权威的资料。大概意思就是说“使用mediaRecorder记录音视频，需要一个简单的状态机来控制”。上面的1,2,3…就是在操作时需要准守的步骤。算了吧，翻译水平有限，重点还是放到camera这边吧。</p>
<h5 id="4-2、Camera-app如何启动录像"><a href="#4-2、Camera-app如何启动录像" class="headerlink" title="4.2、Camera app如何启动录像"></a>4.2、Camera app如何启动录像</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码路径:pdk/apps/TestingCamera/src/com/android/testingcamera/TestingCamera.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;Starting recording&quot;</span>);</span><br><span class="line">        logIndent(<span class="number">1</span>);</span><br><span class="line">        log(<span class="string">&quot;Configuring MediaRecoder&quot;</span>);</span><br><span class="line">        <span class="comment">//这里会检查是否打开了录像功能。这里我们省略了，直接不如正题</span></span><br><span class="line"><span class="comment">//上面首先创建了一个MediaRecorder的java对象(注意这里同camera.java类似，java对象中肯定包含了一个mediaRecorder jni本地对象，继续往下看)</span></span><br><span class="line">        mRecorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line">        <span class="comment">//下面就是设置一些callback.</span></span><br><span class="line">        mRecorder.setOnErrorListener(mRecordingErrorListener);</span><br><span class="line">        mRecorder.setOnInfoListener(mRecordingInfoListener);</span><br><span class="line">        <span class="keyword">if</span> (!mRecordHandoffCheckBox.isChecked()) &#123;</span><br><span class="line">    <span class="comment">//将当前camera java对象设置给了mediaRecorder java对象。</span></span><br><span class="line">    <span class="comment">//这里setCamera是jni接口，后面我们贴代码在分析。</span></span><br><span class="line">            mRecorder.setCamera(mCamera);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将preview surface java对象设置给mediaRecorder java对象，后面贴代码</span></span><br><span class="line">    <span class="comment">//详细说明。</span></span><br><span class="line">        mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());</span><br><span class="line">　　　　<span class="comment">//下面２个是设置音频和视频的资源。</span></span><br><span class="line">        mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">        mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line">        mRecorder.setProfile(mCamcorderProfiles.get(mCamcorderProfile));</span><br><span class="line">        <span class="comment">//从app控件选择录像帧大小，并设置给mediaRecorder</span></span><br><span class="line">        Camera.Size videoRecordSize = mVideoRecordSizes.get(mVideoRecordSize);</span><br><span class="line">        <span class="keyword">if</span> (videoRecordSize.width &gt; <span class="number">0</span> &amp;&amp; videoRecordSize.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从app控件选择录像帧率，并设置给mediaRecorder.</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoFrameRates.get(mVideoFrameRate) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoFrameRate(mVideoFrameRates.get(mVideoFrameRate));</span><br><span class="line">        &#125;</span><br><span class="line">        File outputFile = getOutputMediaFile(MEDIA_TYPE_VIDEO);</span><br><span class="line">        log(<span class="string">&quot;File name:&quot;</span> + outputFile.toString());</span><br><span class="line">        mRecorder.setOutputFile(outputFile.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">        log(<span class="string">&quot;Preparing MediaRecorder&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//准备一下，请看下面google给的使用mediaRecorder标准流程</span></span><br><span class="line">            mRecorder.prepare();</span><br><span class="line">            ready = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//------异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">&quot;Starting MediaRecorder&quot;</span>);</span><br><span class="line">                mRecorder.start();<span class="comment">//启动录像</span></span><br><span class="line">                mState = CAMERA_RECORD;</span><br><span class="line">                log(<span class="string">&quot;Recording active&quot;</span>);</span><br><span class="line">                mRecordingFile = outputFile;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//-----异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到应用启动录像功能是是符合状态机流程的。在应用开发中，也要这样来做。</p>
<p>☯ 1.创建mediaRecorderjava对象，mRecorder = new MediaRecorder();<br>☯ 2.设置camera java对象到mediaRecorder中，mRecorder.setCamera(mCamera);<br>☯ 3.将preview surface对象设置给mediaRecorder,mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());<br>☯ 4.设置音频源，mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);<br>☯ 5.设置视频源，mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);<br>☯ 6.设置录像帧大小和帧率，以及setOutputFile<br>☯ 8.准备工作，mRecorder.prepare();<br>☯ 9.启动mdiaRecorder,mRecorder.start();</p>
<h5 id="4-3、与MediaPlayerService相关的类接口之间的关系简介"><a href="#4-3、与MediaPlayerService相关的类接口之间的关系简介" class="headerlink" title="4.3、与MediaPlayerService相关的类接口之间的关系简介"></a>4.3、与MediaPlayerService相关的类接口之间的关系简介</h5><h5 id="4-3-1、mediaRecorder何时与MediaPlayerService发送关系"><a href="#4-3-1、mediaRecorder何时与MediaPlayerService发送关系" class="headerlink" title="4.3.1、mediaRecorder何时与MediaPlayerService发送关系"></a>4.3.1、mediaRecorder何时与MediaPlayerService发送关系</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-10-MediaRecorder.png" alt="Alt text"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/media/java/android/media/MediaRecorder.java</span><br><span class="line">MediaRecorder::MediaRecorder() : mSurfaceMediaSource(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp; <span class="title">service</span><span class="params">(getMediaPlayerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaRecorder = service-&gt;createMediaRecorder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMediaRecorder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mCurrentState = MEDIA_RECORDER_IDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    doCleanUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jni中创建mediaRecorder对象时，其实在构造函数中偷偷的链接了mediaPlayerService，这也是Android习惯用的方法。获取到MediaPlayerService代理对象后，通过匿名binder获取mediaRecorder代理对象。 </p>
<h5 id="4-3-2、mediaPlayerService类和接口之间关系"><a href="#4-3-2、mediaPlayerService类和接口之间关系" class="headerlink" title="4.3.2、mediaPlayerService类和接口之间关系"></a>4.3.2、mediaPlayerService类和接口之间关系</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-11-mediaPlayerService.png" alt="Alt text"></p>
<table>
<thead>
<tr>
<th align="left">接口类型</th>
<th>接口说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">virtual sp createMediaRecorder() = 0;</td>
<td>创建mediaRecorder录视频服务对象的接口</td>
</tr>
<tr>
<td align="left">virtual sp create(const sp&amp; client, int　audioSessionId = 0) = 0;</td>
<td>创建mediaPlayer播放音乐服务对象的接口，播放音乐都是通过mediaPlayer对象播放的</td>
</tr>
<tr>
<td align="left">virtual status_t decode() = 0;</td>
<td>音频解码器</td>
</tr>
</tbody></table>
<h5 id="4-3-3、MediaRecorder类和接口之间关系"><a href="#4-3-3、MediaRecorder类和接口之间关系" class="headerlink" title="4.3.3、MediaRecorder类和接口之间关系"></a>4.3.3、MediaRecorder类和接口之间关系</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-12-IMediaRecorder.png" alt="Alt text"></p>
<p>mediaRecorder功能就是来录像的。其中MediaRecorder类中，包含了BpMediaRecorder代理对象引用。MediaRecorderClient本地对象驻留在mediaPlayService中。它的接口比较多，这里就列出我们今天关注的几个接口。其它接口查看源码吧<br>详细介绍可以参考源码：frameworks/av/include/media/IMediaRecorder.h<br>| 接口类型 |     接口说明|<br>| :——– |: ——–|<br>| virtual status_t setCamera(const sp&amp; camera,const sp&amp; proxy) = 0;        |   这个接口也是非常需要我们关注的，这里获取到了启动录像操作的本地对象(BnCameraRecordingProxy），并通过匿名binder通信方式，第二个参数就是本地对象.然后在startRecording时将帧监听对象注册到camera本地对象中了|<br>| virtual status_t setPreviewSurface(const sp&amp; surface) = 0;            |   将preview预览surface对象设置给medaiRecorder，因为mediaRecorder也有一个camera本地client,所以这个surface对象最终还是会设置到cameraService用于显示。而录像的帧会在CameraService本地创建一个bufferQueue，具体下面会详细说明|<br>| virtual status_t setListener(const sp&amp; listener) = 0;        |   这里一看就是设置监听对象，监听对象是jni中的JNIMediaRecorderListener对象，该对象可以回调MediaRecorder.java类中的postEventFromNative方法，将时间送到java层。其实MediaRecorder实现了BnMediaRecorderClient接口，即实现notify接口，那么这里其实将本地对象传到MediaRecorder本地的客户端对象中（本地对象拿到的就是代理对象了），参考代码片段1|<br>| virtual status_t start() = 0;        |   启动录像功能，函数追究下去和Camera关系不大了，这里就不细说了|  </p>
<h5 id="4-3-3-1、代码片段1"><a href="#4-3-3-1、代码片段1" class="headerlink" title="4.3.3.1、代码片段1"></a>4.3.3.1、代码片段1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源码路径：frameworks/base/media/jni/android_media_MediaRecorder.cpp</span><br><span class="line"><span class="comment">// create new listener and give it to MediaRecorder</span></span><br><span class="line">sp&lt;JNIMediaRecorderListener&gt; listener = <span class="keyword">new</span> JNIMediaRecorderListener(env, thiz, weak_this);</span><br><span class="line">mr-&gt;setListener(listener);</span><br></pre></td></tr></table></figure>

<p>mediaRecorder jni接口回调java方法，通知上层native事件。</p>
<h5 id="4-3-3-2、代码片段2"><a href="#4-3-3-2、代码片段2" class="headerlink" title="4.3.3.2、代码片段2"></a>4.3.3.2、代码片段2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaRecorder.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_setCamera</span><span class="params">(JNIEnv* env, jobject thiz, jobject camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// we should not pass a null camera to get_native_camera() call.</span></span><br><span class="line"><span class="comment">//这里检查camera是不是空的，显然不是空的。</span></span><br><span class="line">    <span class="comment">//这个地方需要好好研究一下，其中camera是java层的camera对象(即camera.java)</span></span><br><span class="line">    <span class="comment">//这里由java对象获取到camera应用端本地对象。</span></span><br><span class="line">    sp&lt;Camera&gt; c = get_native_camera(env, camera, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// get_native_camera will throw an exception in this case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取mediaRecorder本地对象</span></span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    <span class="comment">//下面要特别注意，这里为什么传入的不是Camera对象而是c-&gt;remote()，当时琢磨</span></span><br><span class="line">    <span class="comment">//着，camera.cpp也没实现什么代理类的接口啊，不过后来在cameraBase类中发现</span></span><br><span class="line">    <span class="comment">//重载了remote()方法，该方法返回ICamera代理对象，呵呵。这样的话就会在</span></span><br><span class="line">    <span class="comment">//mediaRecorder中创建一个新的ICamera代理对象。并在mediaPlayerService中</span></span><br><span class="line">    <span class="comment">//创建了一个本地的Camera对象。</span></span><br><span class="line">    <span class="comment">//c-&gt;getRecordingProxy():获取camera本地对象实现的Recording本地对象。这里</span></span><br><span class="line">    <span class="comment">//调用setCamera设置到mediaRecorder本地对象中了(见代码片段３)</span></span><br><span class="line">   process_media_recorder_call(env, mr-&gt;setCamera(c-&gt;remote(), c-&gt;getRecordingProxy()),</span><br><span class="line">            <span class="string">&quot;java/lang/RuntimeException&quot;</span>, <span class="string">&quot;setCamera failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//camera端</span></span><br><span class="line"><span class="function">sp&lt;ICameraRecordingProxy&gt; <span class="title">Camera::getRecordingProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;getProxy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecordingProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看下面RecordingProxy实现了BnCameraRecordingProxy接口，</span></span><br><span class="line"><span class="comment">//是个本地对象，水落石出了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordingProxy</span> :</span> <span class="keyword">public</span> BnCameraRecordingProxy</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        RecordingProxy(<span class="keyword">const</span> sp&lt;Camera&gt;&amp; camera);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ICameraRecordingProxy interface</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">startRecording</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stopRecording</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">releaseRecordingFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;IMemory&gt;&amp; mem)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里的是mCamera已经不再是之前preview启动时对应的那个本地Camera对象</span></span><br><span class="line">    <span class="comment">//这是mediaRecorder重新创建的camera本地对象。</span></span><br><span class="line">        sp&lt;Camera&gt;         mCamera;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-3-3、代码片段3-setCamera本地实现"><a href="#4-3-3-3、代码片段3-setCamera本地实现" class="headerlink" title="4.3.3.3、代码片段3-setCamera本地实现"></a>4.3.3.3、代码片段3-setCamera本地实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaRecorderClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaRecorderClient::setCamera</span><span class="params">(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;setCamera&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecorder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;recorder is not initialized&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRecorder-&gt;setCamera(camera, proxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数中可以看到创建了一个StagefrightRecorder对象，后续的其它操作</span></span><br><span class="line"><span class="comment">//都是通过mRecorder对象实现的</span></span><br><span class="line">MediaRecorderClient::MediaRecorderClient(<span class="keyword">const</span> sp&lt;MediaPlayerService&gt;&amp; service, <span class="keyword">pid_t</span> pid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;Client constructor&quot;</span>);</span><br><span class="line">    mPid = pid;</span><br><span class="line">    mRecorder = <span class="keyword">new</span> StagefrightRecorder;</span><br><span class="line">    mMediaPlayerService = service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StagefrightRecorder::setCamera实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StagefrightRecorder</span> :</span> <span class="keyword">public</span> MediaRecorderBase &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">StagefrightRecorder::setCamera</span><span class="params">(<span class="keyword">const</span> sp&lt;ICamera&gt; &amp;camera,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt; &amp;proxy)</span> </span>&#123;</span><br><span class="line"><span class="comment">//省去一些错误检查代码</span></span><br><span class="line">    mCamera = camera;</span><br><span class="line">    mCameraProxy = proxy;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终ICamera,ICameraRecordingProxy代理对象都存放到StagefrightRecorder对应的成员变量中，看来猪脚就在这个类中。</p>
<h5 id="4-3-3-4、代码片段4"><a href="#4-3-3-4、代码片段4" class="headerlink" title="4.3.3.4、代码片段4"></a>4.3.3.4、代码片段4</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraSource::isCameraAvailable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> cameraId, <span class="keyword">const</span> String16&amp; clientName, <span class="keyword">uid_t</span> clientUid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="number">0</span>) &#123;</span><br><span class="line">        mCamera = Camera::connect(cameraId, clientName, clientUid);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraFlags &amp;= ~FLAGS_HOT_CAMERA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We get the proxy from Camera, not ICamera. We need to get the proxy</span></span><br><span class="line">        <span class="comment">// to the remote Camera owned by the application. Here mCamera is a</span></span><br><span class="line">        <span class="comment">// local Camera object created by us. We cannot use the proxy from</span></span><br><span class="line">        <span class="comment">// mCamera here.</span></span><br><span class="line">        <span class="comment">//根据ICamera代理对象重新创建Camera本地对象</span></span><br><span class="line">        mCamera = Camera::create(camera);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraRecordingProxy = proxy;</span><br><span class="line">        <span class="comment">//目前还不清楚是什么标记，权且理解成支持热插拔标记</span></span><br><span class="line">        mCameraFlags |= FLAGS_HOT_CAMERA;</span><br><span class="line">        <span class="comment">//代理对象绑定死亡通知对象</span></span><br><span class="line">        mDeathNotifier = <span class="keyword">new</span> DeathNotifier();</span><br><span class="line">        <span class="comment">// isBinderAlive needs linkToDeath to work.</span></span><br><span class="line">        mCameraRecordingProxy-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier);</span><br><span class="line">    &#125;</span><br><span class="line">    mCamera-&gt;lock();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　由上面的类图之间的关系的，就知道mediaRecorder间接包含了cameaSource对象，这里为了简单直接要害代码。</p>
<p>☯ 1.在创建CameraSource对象时，会去检查一下Camera对象是否可用，可用的话就会根据传进来的代理对象重新创建Camera本地对象（注意这个时候Camera代理对象在mediaRecorder中）<br>☯ 2.然后保存RecordingProxy代理对象到mCameraRecordingProxy成员中，然后绑定死亡通知对象到RecordingProxy代理对象。</p>
<h5 id="4-3-3-5、代码片段5"><a href="#4-3-3-5、代码片段5" class="headerlink" title="4.3.3.5、代码片段5"></a>4.3.3.5、代码片段5</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraSource::startCameraRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;startCameraRecording&quot;</span>);</span><br><span class="line">    <span class="comment">// Reset the identity to the current thread because media server owns the</span></span><br><span class="line">    <span class="comment">// camera and recording is started by the applications. The applications</span></span><br><span class="line">    <span class="comment">// will connect to the camera in ICameraRecordingProxy::startRecording.</span></span><br><span class="line">    <span class="keyword">int64_t</span> token = IPCThreadState::self()-&gt;clearCallingIdentity();</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNumInputBuffers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = mCamera-&gt;sendCommand(</span><br><span class="line">            CAMERA_CMD_SET_VIDEO_BUFFER_COUNT, mNumInputBuffers, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = OK;</span><br><span class="line">    <span class="keyword">if</span> (mCameraFlags &amp; FLAGS_HOT_CAMERA) &#123;<span class="comment">//前面已经置位FLAGS_HOT_CAMERA，成立</span></span><br><span class="line">        mCamera-&gt;unlock();</span><br><span class="line">        mCamera.clear();</span><br><span class="line">        <span class="comment">//通过recording代理对象，直接启动camera本地端的recording</span></span><br><span class="line">        <span class="keyword">if</span> ((err = mCameraRecordingProxy-&gt;startRecording(</span><br><span class="line">                <span class="keyword">new</span> ProxyListener(<span class="keyword">this</span>))) != OK) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    IPCThreadState::self()-&gt;restoreCallingIdentity(token);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码需要我们注意的是在启动startRecording()时，创建的监听对象new ProxyListener(this),该监听对象会传到Camera本地对象中。当帧可用时，用来通知mediaRecorder有帧可以使用了，赶紧编码吧。</p>
<h5 id="4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象"><a href="#4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象" class="headerlink" title="4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象"></a>4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/include/media/stagefright/CameraSource.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyListener</span>:</span> <span class="keyword">public</span> BnCameraRecordingProxyListener &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ProxyListener(<span class="keyword">const</span> sp&lt;CameraSource&gt;&amp; source);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dataCallbackTimestamp</span><span class="params">(<span class="keyword">int64_t</span> timestampUs, <span class="keyword">int32_t</span> msgType,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> sp&lt;IMemory&gt; &amp;data)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        sp&lt;CameraSource&gt; mSource;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//frameworks/av/camera/Camera.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> Camera::RecordingProxy::startRecording(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;RecordingProxy::startRecording&quot;</span>);</span><br><span class="line">    mCamera-&gt;setRecordingProxyListener(listener);</span><br><span class="line">    mCamera-&gt;reconnect();</span><br><span class="line">    <span class="keyword">return</span> mCamera-&gt;startRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册帧监听对象就是在启动Recording时注册，主要有下面几步：</p>
<p>☯ 1.使用setRecordingProxyListener接口，将监听对象设置给mRecordingProxyListener 成员。<br>☯ 2.重新和cameraService握手(preview停止时就会断开链接，在切换瞬间就断开了)<br>☯ 3.使用ICamera代理对象启动录像。</p>
<h5 id="4-4、阶段小结"><a href="#4-4、阶段小结" class="headerlink" title="4.4、阶段小结"></a>4.4、阶段小结</h5><p>到这里Camera如何使用medaiRecorder录像的基本流程已经清楚了，这里我画了一个流程图，大概包含下面9个流程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/02-13-medaiRecorder-java-native.png" alt="Alt text"></p>
<p>☯ 过程1：上层点击了录像功能，或者录像preview模式下，会创建一个mediaRecorDer Java层对象。<br>☯ 过程2:java层mediaRecorder对象调用native_jni native_setup方法，创建一个native的mediaRecorder对象。创建的过程中连接mediaPlayerService,并通过匿名binder通信方式获取到一个mediaRecorderClient代理对象，并保存到mediaRecorder对象的成员变量mMediaRecorder中。<br>☯ 过程3:ava层的Camera对象传给mediaRecorder native层时，可以通过本地方法获取到Camera本地对象和ICamera代理对象。这里是获取ICamera代理对象和RecordingProxy本地对象<br>☯ 过程4:将ICamera代理对象和RecordingProxy本地对象传给在MedaiService本地端的MediaRecorderClient对象，这时ICamera是重新创建的ICamer代理对象，以及获取到RecordingProxy代理对象。<br>☯ 过程5：根据过程４获取到的新的ICamera代理对象和RecordingProxy代理对象，创建新的本地Camera对象Camera2，以及注册录像帧监听对象到Camera2中。<br>☯ 过程6：启动StartRecording<br>☯ 过程7:当录像帧可用时，通知驻留在MedaiRecorderClient中的Camera2本地对象收帧，于此同时Camera2又是通过注册的帧监听对象告知MediaClientClient对象。MediaClientClient对象拿到帧后进行录像编码。<br>☯ 过程8,过程９：通过回调函数，将一些消息发送给应用端。</p>
<h5 id="4-5、Camera-video创建BufferQueue"><a href="#4-5、Camera-video创建BufferQueue" class="headerlink" title="4.5、Camera video创建BufferQueue."></a>4.5、Camera video创建BufferQueue.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">StreamingProcessor::updateRecordingStream</span><span class="params">(<span class="keyword">const</span> Parameters &amp;params)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">m</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    sp&lt;CameraDeviceBase&gt; device = mDevice.promote();</span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line">    <span class="keyword">bool</span> newConsumer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecordingConsumer == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;%s: Camera %d: Creating recording consumer with %zu + 1 &quot;</span></span><br><span class="line">                <span class="string">&quot;consumer-side buffers&quot;</span>, __FUNCTION__, mId, mRecordingHeapCount);</span><br><span class="line">        <span class="comment">// Create CPU buffer queue endpoint. We need one more buffer here so that we can</span></span><br><span class="line">        <span class="comment">// always acquire and free a buffer when the heap is full; otherwise the consumer</span></span><br><span class="line">        <span class="comment">// will have buffers in flight we&#x27;ll never clear out.</span></span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">        <span class="comment">//创建bufferQueue，同时获取到生产者和消费者对象。</span></span><br><span class="line">        BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">        <span class="comment">//注意下面设置buffer的用处是GRALLOC_USAGE_HW_VIDEO_ENCODER，这个会在</span></span><br><span class="line">        <span class="comment">//mediaRecorder中使用到。</span></span><br><span class="line">        mRecordingConsumer = <span class="keyword">new</span> BufferItemConsumer(consumer,</span><br><span class="line">                GRALLOC_USAGE_HW_VIDEO_ENCODER,</span><br><span class="line">                mRecordingHeapCount + <span class="number">1</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setFrameAvailableListener(<span class="keyword">this</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setName(String8(<span class="string">&quot;Camera2-RecordingConsumer&quot;</span>));</span><br><span class="line">        mRecordingWindow = <span class="keyword">new</span> Surface(producer);</span><br><span class="line">        newConsumer = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Allocate memory later, since we don&#x27;t know buffer size until receipt</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更新部分代码，就不贴出来了－－－－</span></span><br><span class="line"><span class="comment">//注意下面video 录像buffer的像素格式是CAMERA2_HAL_PIXEL_FORMAT_OPAQUE</span></span><br><span class="line">    <span class="keyword">if</span> (mRecordingStreamId == NO_STREAM) &#123;</span><br><span class="line">        mRecordingFrameCount = <span class="number">0</span>;</span><br><span class="line">        res = device-&gt;createStream(mRecordingWindow,</span><br><span class="line">                params.videoWidth, params.videoHeight,</span><br><span class="line">                CAMERA2_HAL_PIXEL_FORMAT_OPAQUE, &amp;mRecordingStreamId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要处理下面几件事情。</p>
<p>☯ 1.由于录像不需要显示，这里创建CameraService BufferQueue本地对象，这个时候获取到的生产者和消费者都是本地的，只有BufferQueue保存的有IGraphicBufferAlloc代理对象mAllocator，专门用来分配buffer。<br>☯ 2.由于StremingProcess.cpp中实现了FrameAvailableListener监听接口方法onFrameAvailable()。这里会通过setFrameAvailableListener方法注册到BufferQueue中。<br>☯ 3.根据生产者对象创建surface对象，并传给Camera3Device申请录像buffer.<br>☯ 4.如果参数有偏差或者之前已经创建过video Stream.这里会删除或者更新videoStream.如果压根没有创建VideoStream,直接创建VideoStream并根据参数更新流信息。</p>
<h5 id="4-6、何时录像帧可用"><a href="#4-6、何时录像帧可用" class="headerlink" title="4.6、何时录像帧可用"></a>4.6、何时录像帧可用</h5><h5 id="4-6-1、onFrameAvailable"><a href="#4-6-1、onFrameAvailable" class="headerlink" title="4.6.1、onFrameAvailable()"></a>4.6.1、onFrameAvailable()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamingProcessor::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/*item*/</span>)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">true</span>;</span><br><span class="line">        mRecordingFrameAvailableSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当video buffer进行enqueue操作后,该函数会被调用。函数中可用发现，激活了StreamingProcessor主线程。</p>
<h5 id="4-6-2、StreamingProcessor线程loop"><a href="#4-6-2、StreamingProcessor线程loop" class="headerlink" title="4.6.2、StreamingProcessor线程loop"></a>4.6.2、StreamingProcessor线程loop</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StreamingProcessor::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        <span class="comment">//之前是在这里挂起的,现在有帧可用就会从这里唤醒。</span></span><br><span class="line">            res = mRecordingFrameAvailableSignal.waitRelative(</span><br><span class="line">                mMutex, kWaitDuration);</span><br><span class="line">            <span class="keyword">if</span> (res == TIMED_OUT) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res = processRecordingFrame();<span class="comment">//进一步处理。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (res == OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里发现，原来StreamingProcessor主线程只为录像服务，previewStream只是使用了它的几个方法而已。</p>
<h5 id="4-6-3、帧可用消息发送给Camera本地对象"><a href="#4-6-3、帧可用消息发送给Camera本地对象" class="headerlink" title="4.6.3、帧可用消息发送给Camera本地对象"></a>4.6.3、帧可用消息发送给Camera本地对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api1\client2\StreamingProcessor.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">StreamingProcessor::processRecordingFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Heap&gt; recordingHeap;</span><br><span class="line">    <span class="keyword">size_t</span> heapIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line"></span><br><span class="line">    BufferItemConsumer::BufferItem imgBuffer;</span><br><span class="line">    <span class="comment">//取出buffer消费，就是拿给mediaRecorder编码</span></span><br><span class="line">    res = mRecordingConsumer-&gt;acquireBuffer(&amp;imgBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line">    <span class="comment">// Call outside locked parameters to allow re-entrancy from notification</span></span><br><span class="line">    Camera2Client::<span class="function">SharedCameraCallbacks::Lock <span class="title">l</span><span class="params">(client-&gt;mSharedCameraCallbacks)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//调用Callback通知Camea本地对象。</span></span><br><span class="line">        l.mRemoteCallback-&gt;dataCallbackTimestamp(timestamp,</span><br><span class="line">                CAMERA_MSG_VIDEO_FRAME,</span><br><span class="line">                recordingHeap-&gt;mBuffers[heapIdx]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;%s: Camera %d: Remote callback gone&quot;</span>, __FUNCTION__, mId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure>
<p>之前我们已经知道Camera运行时存在类型为ICameraClient的两个对象,其中一个代理对象保存在CameraService中，本地对象保存的Camera本地对象中。这里代理对象通知本地对象取帧了。注意这里消息发送的是“CAMERA_MSG_VIDEO_FRAME”。</p>
<h5 id="4-6-4、Camera本地对象转发消息给mediaRecorder"><a href="#4-6-4、Camera本地对象转发消息给mediaRecorder" class="headerlink" title="4.6.4、Camera本地对象转发消息给mediaRecorder."></a>4.6.4、Camera本地对象转发消息给mediaRecorder.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/Camera.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera::dataCallbackTimestamp</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> msgType, <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; dataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If recording proxy listener is registered, forward the frame and return.</span></span><br><span class="line">    <span class="comment">// The other listener (mListener) is ignored because the receiver needs to</span></span><br><span class="line">    <span class="comment">// call releaseRecordingFrame.</span></span><br><span class="line">    sp&lt;ICameraRecordingProxyListener&gt; proxylistener;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//这里mRecordingProxyListener就是mediaRecorder注册过来的监听代理对象</span></span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        proxylistener = mRecordingProxyListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxylistener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//这里就把buffer送到了mediaRecorder中进行编码</span></span><br><span class="line">        proxylistener-&gt;dataCallbackTimestamp(timestamp, msgType, dataPtr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//---------省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里Camera本地对象就会调用mediaRecorder注册来的帧监听对象。前面我们已经做了那么长的铺垫，我想应该可以理解了。好了,mediaRecorder有饭吃了。</p>
<h5 id="4-7、总结"><a href="#4-7、总结" class="headerlink" title="4.7、总结"></a>4.7、总结</h5><p>1.一开始我自以为preview和Video使用同一个camera本地对象，看了代码发现，原来是不同的对象。<br>2.预览的BufferQueue是在CameraService中创建的，和surfaceFlinger没有关系，只是保留了IGraphicBufferAlloc代理对象mAllocator，用于分配buffer.<br>3.之匿名binder没有理解透彻，以为只有传递本地对象才能使用writeStrongBinder()接口保存binder对象，同时在使用端使用readStrongBinder()就可以获取到代理对象了。其实也可以传递代理对象，只不过代码会走另外一套逻辑，在kernel中重新创建一个binder_ref索引对象返回给另一端。如下mediaRecorder设置camera时就是传递的ICamera代理对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libmedia/IMediaRecorder.cpp]</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">setCamera</span><span class="params">(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;setCamera(%p,%p)&quot;</span>, camera.get(), proxy.get());</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor());</span><br><span class="line">        <span class="comment">//camera-&gt;asBinder()是ICamera代理对象</span></span><br><span class="line">        data.writeStrongBinder(camera-&gt;asBinder());</span><br><span class="line">        data.writeStrongBinder(proxy-&gt;asBinder());</span><br><span class="line">        remote()-&gt;transact(SET_CAMERA, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/camera/">Android Camera官方文档</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/eternity9255">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/stonedemo/category/1080451.html">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shell812/article/category/5905525">Android Camera 系统架构源码分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbw1992322/article/details/75259311">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanbixing123/article/details/52294305/">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ecb1be82e6a8">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1baad2a5281d">mm-camera层frame数据流源码分析 - 简书</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/category/6282972">@@Android Camera fw学习 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721">@@Android Camera API2分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775897/article/category/7112759">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhihuiguming/article/details/51382267">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/details/73709808">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/details/52076879">android camera动态库加载过程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190109/">https://zhoujinjian.com/posts/20190109/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Camera/">Camera</a><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190208/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Video System（1）：Video System(视频系统)框架分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190101/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Camera System（1）：Camera 系统 框架、Open()过程分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20190101/" title="Android Camera System（1）：Camera 系统 框架、Open()过程分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-01</div><div class="title">Android Camera System（1）：Camera 系统 框架、Open()过程分析</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Camera-System-startPreview%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">（一）、Camera System startPreview流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81Camera2-startPreview%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82-Java-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、Camera2 startPreview的应用层(Java)流程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81Camera2-startPreview%E7%9A%84Native%E5%B1%82%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">1.2、Camera2 startPreview的Native层流程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3%E3%80%81Camera2-startPreview%E7%9A%84HAL%E5%B1%82%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">1.3、Camera2 startPreview的HAL层流程分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Camera-System-takePicture%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">（二）、Camera System takePicture流程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Camera-System-takepicture-ZSL-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E6%9C%AC%E5%B0%8F%E8%8A%82%E5%9F%BA%E4%BA%8E-Android-5-1-API11%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0%E3%80%81%E6%B3%A8%E5%86%8C%E5%B8%A7%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">3.0、注册帧监听对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-1%E3%80%81captureSequence%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%86%8C%E5%B8%A7%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">3.0.1、captureSequence线程注册帧监听对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-1-1%E3%80%81%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">3.0.1.1、注册时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-1-2%E3%80%81%E6%8D%95%E8%8E%B7%E6%97%B6%E6%9C%BA"><span class="toc-number">3.4.</span> <span class="toc-text">3.0.1.2、捕获时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-2%E3%80%81ZslProcess3%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%86%8C%E5%B8%A7%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">3.0.2、ZslProcess3线程注册帧监听对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-2-1%E3%80%81%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA"><span class="toc-number">3.6.</span> <span class="toc-text">3.0.2.1、注册时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-0-2-2%E3%80%81%E6%8D%95%E8%8E%B7%E6%97%B6%E6%9C%BA"><span class="toc-number">3.7.</span> <span class="toc-text">3.0.2.2、捕获时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81%E6%9F%A5%E6%89%BEZSL%E6%8B%8D%E7%85%A7%E6%9C%80%E5%90%88%E9%80%82%E7%9A%84buffer"><span class="toc-number">3.8.</span> <span class="toc-text">3.1、查找ZSL拍照最合适的buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81%E8%AE%BE%E7%BD%AEzsl-input-buffer%E5%92%8C-jpeg-out-buffer"><span class="toc-number">3.9.</span> <span class="toc-text">3.2、设置zsl input buffer和 jpeg out buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E3%80%81%E5%BD%92%E8%BF%98jpeg-Buffer%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.10.</span> <span class="toc-text">3.3、归还jpeg Buffer干了什么.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4%E3%80%81%E4%BF%9D%E5%AD%98ZSLBuffer"><span class="toc-number">3.11.</span> <span class="toc-text">3.4、保存ZSLBuffer.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5%E3%80%81%E8%8E%B7%E5%8F%96%E6%8B%8D%E7%85%A7jpeg-Buffer"><span class="toc-number">3.12.</span> <span class="toc-text">3.5、获取拍照jpeg Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6%E3%80%81%E6%8B%8D%E7%85%A7%E5%B8%A7%E5%8F%AF%E7%94%A8%E5%9B%9E%E8%B0%83"><span class="toc-number">3.13.</span> <span class="toc-text">3.6、拍照帧可用回调</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7%E3%80%81jpeg-buffer%E5%9B%9E%E8%B0%83%E5%88%B0app"><span class="toc-number">3.14.</span> <span class="toc-text">3.7、jpeg buffer回调到app</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Camera-System-Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">（四）、Camera System Recorder流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81%E8%AE%A4%E8%AF%86video-mediaRecorder-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、认识video(mediaRecorder)状态机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E3%80%81Camera-app%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E5%BD%95%E5%83%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、Camera app如何启动录像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E3%80%81%E4%B8%8EMediaPlayerService%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">4.3.</span> <span class="toc-text">4.3、与MediaPlayerService相关的类接口之间的关系简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E3%80%81mediaRecorder%E4%BD%95%E6%97%B6%E4%B8%8EMediaPlayerService%E5%8F%91%E9%80%81%E5%85%B3%E7%B3%BB"><span class="toc-number">4.4.</span> <span class="toc-text">4.3.1、mediaRecorder何时与MediaPlayerService发送关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2%E3%80%81mediaPlayerService%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">4.5.</span> <span class="toc-text">4.3.2、mediaPlayerService类和接口之间关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3%E3%80%81MediaRecorder%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">4.6.</span> <span class="toc-text">4.3.3、MediaRecorder类和接口之间关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B51"><span class="toc-number">4.7.</span> <span class="toc-text">4.3.3.1、代码片段1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B52"><span class="toc-number">4.8.</span> <span class="toc-text">4.3.3.2、代码片段2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-3%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B53-setCamera%E6%9C%AC%E5%9C%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.</span> <span class="toc-text">4.3.3.3、代码片段3-setCamera本地实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-4%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B54"><span class="toc-number">4.10.</span> <span class="toc-text">4.3.3.4、代码片段4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-5%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B55"><span class="toc-number">4.11.</span> <span class="toc-text">4.3.3.5、代码片段5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-6%E3%80%81%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B56-mediaRecorder%E6%B3%A8%E5%86%8C%E5%B8%A7%E5%8F%AF%E7%94%A8%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.12.</span> <span class="toc-text">4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E3%80%81%E9%98%B6%E6%AE%B5%E5%B0%8F%E7%BB%93"><span class="toc-number">4.13.</span> <span class="toc-text">4.4、阶段小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5%E3%80%81Camera-video%E5%88%9B%E5%BB%BABufferQueue"><span class="toc-number">4.14.</span> <span class="toc-text">4.5、Camera video创建BufferQueue.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6%E3%80%81%E4%BD%95%E6%97%B6%E5%BD%95%E5%83%8F%E5%B8%A7%E5%8F%AF%E7%94%A8"><span class="toc-number">4.15.</span> <span class="toc-text">4.6、何时录像帧可用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-1%E3%80%81onFrameAvailable"><span class="toc-number">4.16.</span> <span class="toc-text">4.6.1、onFrameAvailable()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-2%E3%80%81StreamingProcessor%E7%BA%BF%E7%A8%8Bloop"><span class="toc-number">4.17.</span> <span class="toc-text">4.6.2、StreamingProcessor线程loop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-3%E3%80%81%E5%B8%A7%E5%8F%AF%E7%94%A8%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%BB%99Camera%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.18.</span> <span class="toc-text">4.6.3、帧可用消息发送给Camera本地对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-4%E3%80%81Camera%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8F%91%E6%B6%88%E6%81%AF%E7%BB%99mediaRecorder"><span class="toc-number">4.19.</span> <span class="toc-text">4.6.4、Camera本地对象转发消息给mediaRecorder.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.20.</span> <span class="toc-text">4.7、总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">（五）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>