<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Video System（4）：Android Multimedia - OpenMax实现分析 | zhoujinjian</title><meta name="keywords" content="Android,Video,Multimedia"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Video System（4）：Android Multimedia - OpenMax实现分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190211/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg">
<meta property="article:published_time" content="2019-02-11T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.968Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Video">
<meta property="article:tag" content="Multimedia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190211/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Video System（4）：Android Multimedia - OpenMax实现分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-11T01:25:00.000Z" title="发表于 2019-02-11 09:25:00">2019-02-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.968Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Multimedia/">Multimedia</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/categories/Android%E6%8A%80%E6%9C%AF%E7%82%B9/page/2/">【特别感谢 -  Copy Windrunnerlihuan（OpenMax分析）】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/60132620">【特别感谢 -  Android MediaCodec ACodec】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/54926526">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p>
<p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<hr>
<p>☯ \hardware\qcom\media\msm8996\libstagefrighthw</p>
<ul>
<li>QComOMXPlugin.cpp</li>
<li>QComOMXMetadata.h</li>
<li>QComOMXPlugin.h</li>
</ul>
<p>☯  \hardware\qcom\media\msm8996\mm-video-v4l2\vidc</p>
<p>☯ \hardware\qcom\media\msm8996\mm-core</p>
<hr>
<h4 id="（一）、OpenMax简介"><a href="#（一）、OpenMax简介" class="headerlink" title="（一）、OpenMax简介"></a>（一）、OpenMax简介</h4><p>  android中的 NuPlayer就是用OpenMax来做(codec)编解码的，本节就主要科普一下OpenMax和它在Android系统中扮演的角色。</p>
<h5 id="1-1、-OpenMax系统的结构"><a href="#1-1、-OpenMax系统的结构" class="headerlink" title="1.1、 OpenMax系统的结构"></a>1.1、 OpenMax系统的结构</h5><h6 id="1-1-1、OpenMax总体层次结构"><a href="#1-1-1、OpenMax总体层次结构" class="headerlink" title="1.1.1、OpenMax总体层次结构"></a>1.1.1、OpenMax总体层次结构</h6><p> OpenMax是一个多媒体应用程序的框架标准，由NVIDIA公司和Khronos在2006年推出。</p>
<p> OpenMax是无授权费的，跨平台的应用程序接口API，通过使媒体加速组件能够在开发、集成和编程环节中实现跨多操作系统和处理器硬件平台，提供全面的流媒体编解码器和应用程序便携化。</p>
<p>OpenMax的官方网站如下所示：<br>       <a target="_blank" rel="noopener" href="http://www.khronos.org/openmax/">http://www.khronos.org/openmax/</a><br>OpenMax实际上分成三个层次，自上而下分别是，OpenMax DL（开发层），OpenMax IL（集成层）和OpenMax AL（应用层）。三个层次的内容分别如下所示：</p>
<blockquote>
<p>第一层：OpenMax DL（Development Layer，开发层）<br>        OpenMax DL定义了一个API，它是音频、视频和图像功能的集合。供应商能够在一个新的处理器上实现并优化，然后编解码供应商使用它来编写更广泛的编解码器功能。它包括音频信号的处理功能，如FFT和filter，图像原始处理，如颜色空间转换、视频原始处理，以实现例如MPEG-4、H.264、MP3、AAC和JPEG等编解码器的优化。</p>
<p>第二层：OpenMax IL（Integration Layer，集成层）<br>       OpenMax IL作为音频、视频和图像编解码器能与多媒体编解码器交互，并以统一的行为支持组件（例如，资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是透明的底层接口应用于嵌入式、移动设备。它提供了应用程序和媒体框架，透明的。编解码器供应商必须写私有的或者封闭的接口，集成进移动设备。IL的主要目的是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。</p>
<p>第三层：OpenMax AL（Appliction Layer，应用层）<br>       OpenMax AL API在应用程序和多媒体中间件之间提供了一个标准化接口，多媒体中间件提供服务以实现被期待的API功能。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-01-openmaxsystem.png" alt="Alt text | center"></p>
<pre><code>OpenMax API将会与处理器一同提供，以**使库和编解码器开发者能够高速有效地利用新器件的完整加速潜能，无须担心其底层的硬件结构。**该标准是针对嵌入式设备和移动设备的多媒体软件架构。在架构底层上为多媒体的编解码和数据处理定义了一套统一的编程接口，对多媒体数据的处理功能进行系统级抽象，为用户屏蔽了底层的细节。因此，**多媒体应用程序和多媒体框架通过OpenMax IL可以以一种统一的方式来使用编解码和其他多媒体数据处理功能，具有了跨越软硬件平台的移植性。**</code></pre>
<p>注：在实际的应用中，OpenMax的三个层次中使用较多的是OpenMax IL集成层，由于操作系统到硬件的差异和多媒体应用的差异，OpenMax的DL和AL层使用相对较少。</p>
<h6 id="1-1-2、OpenMax-IL简介"><a href="#1-1-2、OpenMax-IL简介" class="headerlink" title="1.1.2、OpenMax IL简介"></a>1.1.2、OpenMax IL简介</h6><p>OpenMax IL 处在中间层的位置，OpenMAX IL 作为音频，视频和图像编解码器 能与多媒体编解码器交互，并以统一的行为支持组件（例如资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是 的底层接口应用于嵌入式或 / 和移动设备。它提供了应用程序和媒体框架， 透明的。本质上不存在这种标准化的接口，编解码器供 应商必须写私有的或者封闭的接口，集成进移动设备。 IL 的主要目的 是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。<br>       OpenMax IL 的目的就是为硬件平台的图形及音视频提供一个抽象层，可以为上层的应用提供一个可跨平台的支撑。这一点对于跨平台的媒体应用来说十分重要。本人也接触过几家高清解码芯片，这些芯片底层的音视频接口虽然功能上大致相同，但是接口设计及用法上各有不同，而且相差很多。你要想让自己开发的媒体应用完美的运行在不同的硬件厂商平台上，就得适应不同芯片的底层解码接口。这个对于应用开发来说十分繁琐。所以就需要类似于OpenMax IL 这种接口规范。应用假如涉及到音视频相关功能时，只需调用这些标准的接口，而不需要关心接口下方硬件相关的实现。假如换了硬件平台时，只需要把接口层与硬件适配好了就行了。上层应用不需要频繁改动。<br>       你可以把OpenMax IL 看作是中间件中的porting层接口，但是现在中间件大部分都是自家定义自己的。</p>
<p>OpenMax 想做的就是定义一个这样的行业标准，这样媒体应用、硬件厂商都遵循这种标准。硬件厂商将OpenMax 与处理器一并提供，上层的多媒体框架想要用到硬件音视频加速功能时，只需遵循openmax的接口就可以扩平台运行。<br>       可喜的，现在越来越多的多媒体框架及多媒体应用正在遵循openmax标准，包括各种知名的媒体开源软件。越来越多的芯片厂商也在遵循openmax的标准。对于现在的音视频编解码来说，分辨率越来越高，需要芯片提供硬件加速功能是个大的趋势。我相信 接口的标准化是一定要走的。如下图所示， openmax IL在多媒体框架中的应用：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-02-openmaxuse.png" alt="Alt text | center"></p>
<p><strong>OpenMax IL目前已经成为了事实上的多媒体框架标准。</strong>嵌入式处理器或者多媒体编解码模块的硬件生产者，通常提供标准的OpenMax IL层的软件接口，这样软件的开发者就可以基于这个层次的标准化接口进行多媒体程序的开发。</p>
<p> OpenMax IL的接口层次结构适中，既不是硬件编解码的接口，也不是应用程序层的接口，因此比较容易实现标准化。OpenMax IL的层次结构如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-03-openmaxIL.png" alt="Alt text | center"></p>
<p>图中的虚线中的内容是OpenMax IL层的内容，其主要实现了OpenMax IL中的各个组件（Component）。<strong>对下层，OpenMax IL可以调用OpenMax DL层的接口，也可以直接调用各种Codec实现。对上层，OpenMax IL可以给OpenMax AL 层等框架层（Middleware）调用，也可以给应用程序直接调用。</strong></p>
<h6 id="1-1-3、OpenMax-IL结构"><a href="#1-1-3、OpenMax-IL结构" class="headerlink" title="1.1.3、OpenMax IL结构"></a>1.1.3、OpenMax IL结构</h6><p>OpenMax IL主要内容如下所示。</p>
<p>☯ 客户端（Client）：OpenMax IL的调用者<br>☯ 组件（Component）：OpenMax IL的单元，每一个组件实现一种功能<br>☯ 端口（Port）：组件的输入输出接口<br>☯ 隧道化（Tunneled）：让两个组件直接连接的方式<br>       OpenMax IL的基本运作过程如图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-04-openmaxilbase.png" alt="Alt text | center"></p>
<p>OpenMAL IL的客户端，通过调用四个OpenMAL IL组件，实现了一个功能。四个组件分别是Source组件、Host组件、Accelerator组件和Sink组件。Source组件只有一个输出端口；而Host组件有一个输入端口和一个输出端口；Accelerator组件具有一个输入端口，调用了硬件的编解码器，加速主要体现在这个环节上。Accelerator组件和Sink组件通过私有通讯方式在内部进行连接，没有经过明确的组件端口。<br>       OpenMAL IL在使用的时候，其数据流也有不同的处理方式：既可以经由客户端，也可以不经由客户端。图中Source组件到Host组件的数据流就是经过客户端的；而Host组件到Accelerator组件的数据流就没有经过客户端，使用了隧道化的方式；Accelerator组件和Sink组件甚至可以使用私有的通讯方式。</p>
<p>   OpenMax Core是辅助各个组件运行的部分，它通常需要完成各个组件的初始化等工作，在真正运行过程中，重点是各个OpenMax IL的组件，OpenMax Core不是重点，也不是标准。</p>
<p> OpenMAL IL的组件是OpenMax IL实现的核心内容，一个组件以输入、输出端口为接口，端口可以被连接到另一个组件上。外部对组件可以发送命令，还进行设置/获取参数、配置等内容。组件的端口可以包含缓冲区（Buffer）的队列。</p>
<p>组件的处理的核心内容是：通过输入端口消耗Buffer，通过输出端口填充Buffer，由此多组件相联接可以构成流式的处理。OpenMAL IL中一个组件的结构如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-05-openilinternal.jpg" alt="Alt text | center"></p>
<pre><code>   组件的功能和其定义的端口类型密切相关，通常情况下：只有一个输出端口的，为Source组件；只有一个输入端口的，为Sink组件；有多个输入端口，一个输出端口的为Mux组件；有一个输入端口，多个输出端口的为DeMux组件；输入输出端口各一个组件的为中间处理环节，这是最常见的组件。</code></pre>
<p>  端口具体支持的数据也有不同的类型。例如，对于一个输入、输出端口各一个组件，其输入端口使用MP3格式的数据，输出端口使用PCM格式的数据，那么这个组件就是一个MP3解码组件。</p>
<p>  隧道化（Tunneled）是一个关于组件连接方式的概念。通过隧道化可以将不同的组件的一个输入端口和一个输出端口连接到一起，在这种情况下，两个组件的处理过程合并，共同处理。尤其对于单输入和单输出的组件，两个组件将作为类似一个使用。</p>
<h5 id="1-2、Android中的OpenMax"><a href="#1-2、Android中的OpenMax" class="headerlink" title="1.2、Android中的OpenMax"></a>1.2、Android中的OpenMax</h5><h6 id="1-2-1、OpenMax在Android中的使用情况"><a href="#1-2-1、OpenMax在Android中的使用情况" class="headerlink" title="1.2.1、OpenMax在Android中的使用情况"></a>1.2.1、OpenMax在Android中的使用情况</h6><p>  在Android中，OpenMax IL层，<strong>通常可以用于多媒体引擎的插件</strong>，Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为插件，主要用于<strong>编解码（Codec）</strong>处理。<br>  在Android的框架层，也定义了由Android封装的OpenMax接口，和标准的接口概念基本相同，但是使用C++类型的接口，并且使用了Android的Binder IPC机制。Android封装OpenMax的接口被StageFright使用，OpenCore没有使用这个接口，而是使用其他形式对OpenMax IL层接口进行封装。Android OpenMax的基本层次结构如图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-06-openmaxinandroid.jpg" alt="Alt text | center"></p>
<pre><code>   Android系统的一些部分对OpenMax IL层进行使用，基本使用的是标准OpenMax IL层的接口，只是进行了简单的封装。标准的OpenMax IL实现很容易以插件的形式加入到Android系统中。
   Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为多媒体编解码的插件，只是没有直接使用OpenMax IL层提供的纯C接口，而是对其进行了一定的封装(C++封装)。
   在Android2.x版本之后，Android的框架层也对OpenMax IL层的接口进行了封装定义，甚至使用Android中的Binder IPC机制。Stagefright使用了这个层次的接口，OpenCore没有使用。
   注：OpenCore使用OpenMax IL层作为编解码插件在前，Android框架层封装OpenMax接口在后面的版本中才引入。</code></pre>
<h6 id="1-2-2、Android-OpenMax实现的内容"><a href="#1-2-2、Android-OpenMax实现的内容" class="headerlink" title="1.2.2、Android OpenMax实现的内容"></a>1.2.2、Android OpenMax实现的内容</h6><p>   android中的 AwesomePlayer就是用openmax来做(Codec)编解码,其实在openmax接口设计中，他不光能用来当编解码。通过他的组件可以组成一个完整的播放器，包括sourc、demux、decode、output。但是为什么android只用他来做code呢？应该有如下方面：</p>
<p>☯    1.在整个播放器中，解码器不得不说是最重要的一部分，而且也是最耗资源的一块。如果全靠软解，直接通过cpu来运算，特别是高清视频。别的事你就可以啥都不干了。所以解码器是最需要硬件提供加速的部分。现在的高清解码芯片都是主芯片+DSP结构，解码的工作都是通过DSP来做，不会在过多的占用主芯片。所有将芯片中DSP硬件编解码的能力通过openmax标准接口呈现出来，提供上层播放器来用。我认为这块是openmax最重要的意义。<br>☯    2.source 主要是和协议打交道，demux 分解容器部分，大多数的容器格式的分解是不需要通过硬件来支持。只是ts流这种格式最可能用到硬件的支持。因为ts格式比较特殊，单包的大小太小了，只有188字节。所以也是为什么现在常见的解码芯片都会提供硬件ts demux 的支持。<br>☯   3.音视频输出部分video\audio output 这块和操作系统关系十分紧密。可以看看著名开源播放器vlc。vlc 在mac、linux、Windows都有，功能上差别也不大。所以说他是跨平台的，他跨平台跨在哪？主要的工作量还是在音视频解码完之后的输出模块。因为各个系统的图像渲染和音频输出实现方法不同，所以vlc需要针对每个平台实现不同的output。这部分内容放在openmax来显然不合适。<br>       Android中使用的主要是OpenMax的编解码功能。虽然OpenMax也可以生成输入、输出、文件解析-构建等组件，但是在各个系统（不仅是Android）中使用的最多的还是编解码组件。媒体的输入、输出环节和系统的关系很大，引入OpenMax标准比较麻烦；文件解析-构建环节一般不需要使用硬件加速。编解码组件也是最能体现硬件加速的环节，因此最常使用。</p>
<h5 id="1-3、初窥适配层接口"><a href="#1-3、初窥适配层接口" class="headerlink" title="1.3、初窥适配层接口"></a>1.3、初窥适配层接口</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节：</p>
<p>☯    编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>☯   OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br> <strong>Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配）</strong>，它作为Android本地层的接口，可以被Android的多媒体引擎调用。上一篇文章末尾，初始化解码器核心调用的两个方法就是适配层的接口。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-07-openmaxsult.jpg" alt="Alt text | center"></p>
<p>☯    1.上面已经说过了，android系统中只用openmax来做Codec，所以android向上抽象了一层OMXCodec，提供给上层播放器用。播放器中音视频解码器mVideosource、mAudiosource都是OMXCodec的实例。<br>☯    2.OMXCodec通过IOMX 依赖binder机制 获得 OMX服务，OMX服务 才是openmax 在android中 实现。<br>☯    3.OMX把软编解码和硬件编解码统一看作插件的形式管理起来。</p>
<h4 id="（二）、Android中OpenMax的实现-preview"><a href="#（二）、Android中OpenMax的实现-preview" class="headerlink" title="（二）、Android中OpenMax的实现(preview)"></a>（二）、Android中OpenMax的实现(preview)</h4><h5 id="2-1、OpenMax的接口与实现"><a href="#2-1、OpenMax的接口与实现" class="headerlink" title="2.1、OpenMax的接口与实现"></a>2.1、OpenMax的接口与实现</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节。</p>
<p>编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br>       Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配），它作为Android本地层的接口，可以被Android的多媒体引擎调用。</p>
<p>OpenMax IL层接口<br>       OpenMax IL层的接口定义由若干个头文件组成，这也是实现它需要实现的内容，位于frameworks/native/include/media/openmax下，它们的基本描述如下所示：</p>
<blockquote>
<p>OMX_Types.h：OpenMax Il的数据类型定义<br>OMX_Core.h：OpenMax IL核心的API<br>OMX_Component.h：OpenMax IL 组件相关的 API<br>OMX_Audio.h：音频相关的常量和数据结构<br>OMX_IVCommon.h：图像和视频公共的常量和数据结构<br>OMX_Image.h：图像相关的常量和数据结构<br>OMX_Video.h：视频相关的常量和数据结构<br>OMX_Other.h：其他数据结构（包括A/V 同步）<br>OMX_Index.h：OpenMax IL定义的数据结构索引<br>OMX_ContentPipe.h：内容的管道定义</p>
</blockquote>
<p>   <strong>提示：OpenMax标准只有头文件，没有标准的库，设置没有定义函数接口。对于实现者，需要实现的主要是包含函数指针的结构体。</strong></p>
<p>其中，OMX_Component.h中定义的OMX_COMPONENTTYPE结构体是OpenMax IL层的核心内容，表示一个组件，其内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/include/media/openmax/OMX_Component.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_COMPONENTTYPE</span>    </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    OMX_U32 nSize;                          <span class="comment">/* 这个结构体的大小 */</span>    </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本号 */</span>    </span><br><span class="line">    OMX_PTR pComponentPrivate;          <span class="comment">/* 这个组件的私有数据指针. */</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 调用者（IL client）设置的指针，用于保存它的私有数据，传回给所有的回调函数 */</span>    </span><br><span class="line">    OMX_PTR pApplicationPrivate;    </span><br><span class="line">    <span class="comment">/* 以下的函数指针返回OMX_core.h中的对应内容 */</span>    </span><br><span class="line">    OMX_ERRORTYPE (*GetComponentVersion)(<span class="comment">/* 获得组件的版本*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STRING pComponentName,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,    </span><br><span class="line">        OMX_OUT OMX_UUIDTYPE* pComponentUUID);    </span><br><span class="line">    OMX_ERRORTYPE (*SendCommand)(<span class="comment">/* 发送命令 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_COMMANDTYPE Cmd,    </span><br><span class="line">        OMX_IN  OMX_U32 nParam1,    </span><br><span class="line">        OMX_IN  OMX_PTR pCmdData);    </span><br><span class="line">    OMX_ERRORTYPE (*GetParameter)(<span class="comment">/* 获得参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nParamIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetParameter)(<span class="comment">/* 设置参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetConfig)(<span class="comment">/* 获得配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetConfig)(<span class="comment">/* 设置配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetExtensionIndex)(<span class="comment">/* 转换成OMX结构的索引 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_STRING cParameterName,    </span><br><span class="line">        OMX_OUT OMX_INDEXTYPE* pIndexType);    </span><br><span class="line">    OMX_ERRORTYPE (*GetState)(<span class="comment">/* 获得组件当前的状态 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STATETYPE* pState);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentTunnelRequest)(<span class="comment">/* 用于连接到另一个组件*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nPort,    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hTunneledComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nTunneledPort,    </span><br><span class="line">        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);    </span><br><span class="line">    OMX_ERRORTYPE (*UseBuffer)(<span class="comment">/* 为某个端口使用Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes,    </span><br><span class="line">        OMX_IN OMX_U8* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*AllocateBuffer)(<span class="comment">/* 在某个端口分配Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes);    </span><br><span class="line">    OMX_ERRORTYPE (*FreeBuffer)(<span class="comment">/*将某个端口Buffer释放*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*EmptyThisBuffer)(<span class="comment">/* 让组件消耗这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*FillThisBuffer)(<span class="comment">/* 让组件填充这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*SetCallbacks)(<span class="comment">/* 设置回调函数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,    </span><br><span class="line">        OMX_IN  OMX_PTR pAppData);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentDeInit)(<span class="comment">/* 反初始化组件 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent);    </span><br><span class="line">    OMX_ERRORTYPE (*UseEGLImage)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN <span class="keyword">void</span>* eglImage);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentRoleEnum)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_U8 *cRole,    </span><br><span class="line">        OMX_IN OMX_U32 nIndex);    </span><br><span class="line">&#125; OMX_COMPONENTTYPE;</span><br></pre></td></tr></table></figure>

<p>☯    1）EmptyThisBuffer和FillThisBuffer是驱动组件运行的基本的机制，前者表示让组件消耗缓冲区，表示对应组件输入的内容；后者表示让组件填充缓冲区，表示对应组件输出的内容。<br>☯    2）UseBuffer，AllocateBuffer，FreeBuffer为和端口相关的缓冲区管理函数，对于组件的端口有些可以自己分配缓冲区，有些可以使用外部的缓冲区，因此有不同的接口对其进行操作。<br>☯    3）SendCommand表示向组件发送控制类的命令。GetParameter，SetParameter，GetConfig，SetConfig几个接口用于辅助的参数和配置的设置和获取。<br>☯     4）ComponentTunnelRequest用于组件之间的隧道化连接，其中需要制定两个组件及其相连的端口。<br>☯     5）ComponentDeInit用于组件的反初始化。</p>
<p>OMX_COMPONENTTYPE结构体实现后，其中的各个函数指针就是调用者可以使用的内容。各个函数指针和OMX_core.h中定义的内容相对应。</p>
<p>提示：OpenMax函数的参数中，经常包含OMX_IN和OMX_OUT等宏，它们的实际内容为空，只是为了标记参数的方向是输入还是输出。</p>
<p>OMX_Component.h中端口类型的定义为OMX_PORTDOMAINTYPE枚举类型，内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_PORTDOMAINTYPE &#123;   </span><br><span class="line">    OMX_PortDomainAudio,        <span class="comment">/* 音频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainVideo,        <span class="comment">/* 视频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainImage,        <span class="comment">/* 图像类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainOther,        <span class="comment">/* 其他类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainKhronosExtensions = <span class="number">0x6F000000</span>,   <span class="comment">//为Khronos标准预留宽展</span></span><br><span class="line">    OMX_PortDomainVendorStartUnused = <span class="number">0x7F000000</span>    <span class="comment">//为厂商预留扩展</span></span><br><span class="line">    OMX_PortDomainMax = <span class="number">0x7ffffff</span>  </span><br><span class="line">&#125; OMX_PORTDOMAINTY</span><br></pre></td></tr></table></figure>
<p>音频类型，视频类型，图像类型，其他类型是OpenMax IL层此所定义的四种端口的类型。</p>
<p>端口具体内容的定义使用OMX_PARAM_PORTDEFINITIONTYPE类（也在OMX_Component.h中定义）来表示，其内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_PARAM_PORTDEFINITIONTYPE</span> &#123;</span>   </span><br><span class="line">    OMX_U32 nSize;                      <span class="comment">/* 结构体大小 */</span>   </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本*/</span>   </span><br><span class="line">    OMX_U32 nPortIndex;             <span class="comment">/* 端口号 */</span>   </span><br><span class="line">    OMX_DIRTYPE eDir;                   <span class="comment">/* 端口的方向 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountActual;         <span class="comment">/* 为这个端口实际分配的Buffer的数目 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountMin;            <span class="comment">/* 这个端口最小Buffer的数目*/</span>   </span><br><span class="line">    OMX_U32 nBufferSize;                <span class="comment">/* 缓冲区的字节数 */</span>   </span><br><span class="line">    OMX_BOOL bEnabled;                  <span class="comment">/* 是否使能 */</span>   </span><br><span class="line">    OMX_BOOL bPopulated;                <span class="comment">/* 是否在填充 */</span>   </span><br><span class="line">    OMX_PORTDOMAINTYPE eDomain;         <span class="comment">/* 端口的类型 */</span>   </span><br><span class="line">    <span class="keyword">union</span> &#123;                         <span class="comment">/* 端口实际的内容，由类型确定具体结构 */</span>   </span><br><span class="line">        OMX_AUDIO_PORTDEFINITIONTYPE audio;   </span><br><span class="line">        OMX_VIDEO_PORTDEFINITIONTYPE video;   </span><br><span class="line">        OMX_IMAGE_PORTDEFINITIONTYPE image;   </span><br><span class="line">        OMX_OTHER_PORTDEFINITIONTYPE other;   </span><br><span class="line">    &#125; format;   </span><br><span class="line">    OMX_BOOL bBuffersContiguous;   </span><br><span class="line">    OMX_U32 nBufferAlignment;   </span><br><span class="line">&#125; OMX_PARAM_PORTDEFINITIONTYPE;</span><br></pre></td></tr></table></figure>
<p>对于一个端口，其重点的内容如下:</p>
<p>☯    端口的方向（OMX_DIRTYPE）：包含OMX_DirInput（输入）和OMX_DirOutput（输出）两种<br>☯    端口分配的缓冲区数目和最小缓冲区数目<br>☯    端口的类型（OMX_PORTDOMAINTYPE）：可以是四种类型<br>☯    端口格式的数据结构：使用format联合体来表示，具体由四种不同类型来表示，与端口的类型相对应<br>☯    OMX_AUDIO_PORTDEFINITIONTYPE，OMX_VIDEO_PORTDEFINITIONTYPE，OMX_IMAGE_PORTDEFINITIONTYPE和OMX_OTHER_PORTDEFINITIONTYPE等几个具体的格式类型，分别在OMX_Audio.h，OMX_Video.h，OMX_Image.h和OMX_Other.h这四个头文件中定义。<br>       OMX_Core.h中定义的枚举类型OMX_STATETYPE命令表示OpenMax的状态机，内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_STATETYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_StateInvalid,                   <span class="comment">/* 组件监测到内部的数据结构被破坏 */</span>   </span><br><span class="line">    OMX_StateLoaded,                    <span class="comment">/* 组件被加载但是没有完成初始化 */</span>   </span><br><span class="line">    OMX_StateIdle,                      <span class="comment">/* 组件初始化完成，准备开始 */</span>   </span><br><span class="line">    OMX_StateExecuting,             <span class="comment">/* 组件接受了开始命令，正在树立数据 */</span>   </span><br><span class="line">    OMX_StatePause,                     <span class="comment">/* 组件接受暂停命令*/</span>   </span><br><span class="line">    OMX_StateWaitForResources,      <span class="comment">/* 组件正在等待资源 */</span>   </span><br><span class="line">    OMX_StateKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_StateVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_StateMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_STATETYPE;</span><br></pre></td></tr></table></figure>

<p>OpenMax组件的状态机可以由外部的命令改变，也可以由内部发生的情况改变。OpenMax IL组件的状态机的迁移关系如图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-08-OMXstate.png" alt="Alt text | center"></p>
<p> OMX_Core.h中定义的枚举类型OMX_COMMANDTYPE表示对组件的命令类型，内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_COMMANDTYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_CommandStateSet,                <span class="comment">/* 改变状态机器 */</span>   </span><br><span class="line">    OMX_CommandFlush,                   <span class="comment">/* 刷新数据队列 */</span>   </span><br><span class="line">    OMX_CommandPortDisable,             <span class="comment">/* 禁止端口 */</span>   </span><br><span class="line">    OMX_CommandPortEnable,              <span class="comment">/* 使能端口 */</span>   </span><br><span class="line">    OMX_CommandMarkBuffer,              <span class="comment">/* 标记组件或Buffer用于观察 */</span>   </span><br><span class="line">    OMX_CommandKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_CommandVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_CommandMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_COMMANDTYPE;</span><br></pre></td></tr></table></figure>

<p>OMX_COMMANDTYPE类型在SendCommand调用中作为参数被使用，其中OMX_CommandStateSet就是改变状态机的命令。</p>
<h6 id="2-1-2、OpenMax-IL实现的内容"><a href="#2-1-2、OpenMax-IL实现的内容" class="headerlink" title="2.1.2、OpenMax IL实现的内容"></a>2.1.2、OpenMax IL实现的内容</h6><p>  对于OpenMax IL层的实现，一般的方式并不调用OpenMax DL层。具体实现的内容就是各个不同的组件。<br>       OpenMax IL组件的实现包含以下两个步骤：</p>
<p>☯    组件的初始化函数：硬件和OpenMax数据结构的初始化，一般分成函数指针初始化、私有数据结构的初始化、端口的初始化等几个步骤，使用OMX_Component.h其中的pComponentPrivate成员保留本组件的私有数据为上下文，最后获得填充完成OMX_COMPONENTTYPE类型的结构体。<br>☯    OMX_COMPONENTTYPE类型结构体的各个指针：实现其中的各个函数指针，需要使用私有数据的时候，从其中的pComponentPrivate得到指针，转化成实际的数据结构使用。</p>
<p>端口的定义是OpenMax IL组件对外部的接口。OpenMax IL常用的组件大都是输入和输出端口各一个。对于最常用的编解码（Codec）组件，通常需要在每个组件的实现过程中，调用硬件的编解码接口来实现。在组件的内部处理中，可以建立线程来处理。OpenMax的组件的端口有默认参数，但也可以在运行时设置，因此一个端口也可以支持不同的编码格式。音频编码组件的输出和音频编码组件的输入通常是原始数据格式（PCM格式），视频编码组件的输出和视频编码组件的输入通常是原始数据格式（YUV格式）。<br>       提示：在一种特定的硬件实现中，编解码部分具有相似性，因此通常可以构建一个OpenMax组件的”基类”或者公共函数，来完成公共性的操作。</p>
<h5 id="2-2、Android中OpenMax的适配层"><a href="#2-2、Android中OpenMax的适配层" class="headerlink" title="2.2、Android中OpenMax的适配层"></a>2.2、Android中OpenMax的适配层</h5><p>  Android中的OpenMax适配层的接口在frameworks/av/include/media/IOMX.h文件定义，其内容如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOMX</span> :</span> <span class="keyword">public</span> IInterface &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    DECLARE_META_INTERFACE(OMX);    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *buffer_id;    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *node_id;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">livesLocally</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ComponentInfo</span> &#123;</span><span class="comment">// 组件的信息    </span></span><br><span class="line">        String8 mName;    </span><br><span class="line">        List&lt;String8&gt; mRoles;    </span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">listNodes</span><span class="params">(List&lt;ComponentInfo&gt; *<span class="built_in">list</span>)</span> </span>= <span class="number">0</span>;  <span class="comment">// 节点列表    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">allocateNode</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer,  <span class="comment">// 分配节点    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id *node)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">freeNode</span><span class="params">(node_id node)</span> </span>= <span class="number">0</span>; <span class="comment">// 找到节点    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">sendCommand</span><span class="params">(<span class="comment">// 发送命令    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getParameter</span><span class="params">(<span class="comment">// 获得参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">setParameter</span><span class="params">(<span class="comment">// 设置参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getConfig</span><span class="params">(<span class="comment">// 获得配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">setConfig</span><span class="params">(<span class="comment">// 设置配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">useBuffer</span><span class="params">(<span class="comment">// 使用缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">allocateBuffer</span><span class="params">(<span class="comment">// 分配缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">size_t</span> size,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer, <span class="keyword">void</span> **buffer_data)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">allocateBufferWithBackup</span><span class="params">(<span class="comment">// 分配带后备缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">freeBuffer</span><span class="params">(<span class="comment">// 释放缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, buffer_id buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">fillBuffer</span><span class="params">(node_id node, buffer_id buffer)</span> </span>= <span class="number">0</span>; <span class="comment">// 填充缓冲区    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">emptyBuffer</span><span class="params">(<span class="comment">// 消耗缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id buffer,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 range_offset, OMX_U32 range_length,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 flags, OMX_TICKS timestamp)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getExtensionIndex</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parameter_name,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_INDEXTYPE *index)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IOMXRenderer&gt; <span class="title">createRenderer</span><span class="params">(<span class="comment">// 创建渲染器（从ISurface）    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;ISurface&gt; &amp;surface,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_COLOR_FORMATTYPE colorFormat,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> encodedWidth, <span class="keyword">size_t</span> encodedHeight,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> displayWidth, <span class="keyword">size_t</span> displayHeight)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    ......   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> IOMX表示的是OpenMax的一个组件，根据Android的Binder IPC机制，BnOMX继承IOMX，实现者需要继承实现BnOMX。IOMX类中，有标准的OpenMax的GetParameter，SetParameter，GetConfig，SetConfig，SendCommand，UseBuffer，AllocateBuffer，FreeBuffer，FillThisBuffer和EmptyThisBuffer等接口。<br>       在IOMX.h文件中，另有表示观察器类的IOMXObserver，这个类表示OpenMax的观察者，其中只包含一个onMessage()函数，其参数为omx_message接口体，其中包含Event事件类型、FillThisBuffer完成和EmptyThisBuffer完成几种类型。<br>       提示：Android中OpenMax的适配层是OpenMAX IL层至上的封装层，在Android系统中被StageFright调用，也可以被其他部分调用。</p>
<h4 id="2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><a href="#2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现" class="headerlink" title="2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现"></a>2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</h4><h5 id="2-3-1、TI-OpenMax-IL实现的结构和机制"><a href="#2-3-1、TI-OpenMax-IL实现的结构和机制" class="headerlink" title="2.3.1、TI OpenMax IL实现的结构和机制"></a>2.3.1、TI OpenMax IL实现的结构和机制</h5><p> Android的开源代码中，已经包含了TI的OpenMax IL层的实现代码，其路径如hardware/ti/omap3/omx下。其中包含的主要目录如下所示：</p>
<p>☯    system：OpenMax核心和公共部分<br>☯    audio：音频处理部分的OpenMax IL组件<br>☯    video：视频处理部分OpenMax IL组件<br>☯    image：图像处理部分OpenMax IL组件<br>       TI OpenMax IL实现的结构如图所示:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-09-tiopenmaxil.png" alt="Alt text | center"></p>
<p> 在TI OpenMax IL实现中，最上面的内容是OpenMax的管理者用于管理和初始化，中间层是各个编解码单元的OpenMax IL标准组件，下层是LCML层，供各个OpenMax IL标准组件所调用。<br>       （1）TI OpenMax IL实现的公共部分在system/src/openmax_il/目录中，主要的内容如下所示。</p>
<p>☯ omx_core/src：OpenMax IL的核心，生成动态库libOMX_Core.so<br>☯ lcml/：LCML的工具库，生成动态库libLCML.so<br>       （2）I OpenMax IL的视频（Video）相关的组件在video/src/openmax_il/目录中，主要的内容如下所示。</p>
<p>☯ prepost_processor：Video数据的前处理和后处理，生成动态库libOMX.TI.VPP.so<br>☯ video_decode：Video解码器，生成动态库libOMX.TI.Video.Decoder.so<br>☯ video_encode：Video编码器，生成动态库libOMX.TI.Video.encoder.so<br>       （3）TI OpenMax IL的音频（Audio）相关的组件在audio/src/openmax_il/目录中，主要的内容如下所示。</p>
<p>☯ g711_dec：G711解码器，生成动态库libOMX.TI.G711.decode.so<br>☯ g711_enc：G711编码器，生成动态库libOMX.TI.G711.encode.so<br>☯ g722_dec：G722解码器，生成动态库libOMX.TI.G722.decode.so<br>☯ g722_enc：G722编码器，生成动态库libOMX.TI.G722.encode.so<br>☯ g726_dec：G726解码器，生成动态库libOMX.TI.G726.decode.so<br>☯ g726_enc：G726编码器，生成动态库libOMX.TI.G726.encode.so<br>☯ g729_dec：G729解码器，生成动态库libOMX.TI.G729.decode.so<br>☯ g729_enc：G720编码器，生成动态库libOMX.TI.G729.encode.so<br>☯ nbamr_dec：AMR窄带解码器，生成动态库libOMX.TI.AMR.decode.so<br>☯ nbamr_enc：AMR窄带编码器，生成动态库libOMX.TI.AMR.encode.so<br>☯ wbamr_dec：AMR宽带解码器，生成动态库libOMX.TI.WBAMR.decode.so<br>☯ wbamr_enc：AMR宽带编码器，生成动态库libOMX.TI.WBAMR.encode.so<br>☯ mp3_dec：MP3解码器，生成动态库libOMX.TI.MP3.decode.so<br>☯ aac_dec：AAC解码器，生成动态库libOMX.TI.AAC.decode.so<br>☯ aac_enc：AAC编码器，生成动态库libOMX.TI.AAC.encode.so<br>☯ wma_dec：WMA解码器，生成动态库libOMX.TI.WMA.decode.so<br>       （4）TI OpenMax IL的图像（Image）相关的组件在image/src/openmax_il/目录中，主要的内容如下所示。</p>
<p>☯ jpeg_enc：JPEG编码器，生成动态库libOMX.TI.JPEG.Encoder.so<br>☯ jpeg_dec：JPEG解码器，生成动态库libOMX.TI.JPEG.decoder.so</p>
<h5 id="2-3-2、TI-OpenMax-IL的核心和公共内容"><a href="#2-3-2、TI-OpenMax-IL的核心和公共内容" class="headerlink" title="2.3.2、TI OpenMax IL的核心和公共内容"></a>2.3.2、TI OpenMax IL的核心和公共内容</h5><p> LCML的全称是”Linux Common Multimedia Layer“，是TI的Linux公共多媒体层。在OpenMax IL的实现中，这个内容在system/src/openmax_il/lcml/目录中，主要文件是子目录src中的LCML_DspCodec.c文件。通过调用DSPBridge的内容， 让ARM和DSP进行通信，然DSP进行编解码方面的处理。DSP的运行还需要固件的支持。</p>
<p> TI OpenMax IL的核心实现在system/src/openmax_il/omx_core/目录中，生成TI OpenMax IL的核心库libOMX_Core.so。</p>
<p>其中子目录src中的OMX_Core.c为主要文件，其中定义了编解码器的名称等，其片断如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tComponentName[MAXCOMP][<span class="number">2</span>] = &#123;    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.JPEG.decoder&quot;</span>, <span class="string">&quot;image_decoder.jpeg&quot;</span>&#125;,<span class="comment">/* 图像和视频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.JPEG.Encoder&quot;</span>, <span class="string">&quot;image_encoder.jpeg&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.Decoder&quot;</span>, <span class="string">&quot;video_decoder.avc&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.Decoder&quot;</span>, <span class="string">&quot;video_decoder.mpeg4&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.Decoder&quot;</span>, <span class="string">&quot;video_decoder.wmv&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.encoder&quot;</span>, <span class="string">&quot;video_encoder.mpeg4&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.encoder&quot;</span>, <span class="string">&quot;video_encoder.h263&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.Video.encoder&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span>&#125;,    </span><br><span class="line">     <span class="comment">/* ......省略 ，语音相关组件*/</span>    </span><br><span class="line">#ifdef BUILD_WITH_TI_AUDIO <span class="comment">/* 音频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.MP3.decode&quot;</span>, <span class="string">&quot;audio_decoder.mp3&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.AAC.encode&quot;</span>, <span class="string">&quot;audio_encoder.aac&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.AAC.decode&quot;</span>, <span class="string">&quot;audio_decoder.aac&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.WMA.decode&quot;</span>, <span class="string">&quot;audio_decoder.wma&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.WBAMR.decode&quot;</span>, <span class="string">&quot;audio_decoder.amrwb&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.AMR.decode&quot;</span>, <span class="string">&quot;audio_decoder.amrnb&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.AMR.encode&quot;</span>, <span class="string">&quot;audio_encoder.amrnb&quot;</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">&quot;OMX.TI.WBAMR.encode&quot;</span>, <span class="string">&quot;audio_encoder.amrwb&quot;</span>&#125;,    </span><br><span class="line">#endif    </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  tComponentName数组的各个项中，第一个表示<strong>编解码库内容</strong>，第二个表示<strong>库所实现的功能</strong>。<br>       其中，TIOMX_GetHandle()函数用于获得各个组件的句柄，其实现的主要片断如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">TIOMX_GetHandle</span><span class="params">( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName,    </span></span></span><br><span class="line"><span class="function"><span class="params">    OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> prefix[] = <span class="string">&quot;lib&quot;</span>;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> postfix[] = <span class="string">&quot;.so&quot;</span>;    </span><br><span class="line">    OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*);    </span><br><span class="line">    OMX_ERRORTYPE err = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *componentType;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pErr = dlerror();    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; COUNTOF(pModules); i++) &#123;       <span class="comment">// 循环查找    </span></span><br><span class="line">        <span class="keyword">if</span>(pModules[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> refIndex = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (refIndex=<span class="number">0</span>; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123;    </span><br><span class="line">    <span class="comment">// 循环查找组件列表    </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(componentTable[refIndex].name, cComponentName) == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123;    </span><br><span class="line">            <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(prefix) + MAXNAMESIZE+ <span class="keyword">sizeof</span>(postfix)];    </span><br><span class="line">                <span class="built_in">strcpy</span>(buf, prefix);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, cComponentName);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, postfix);    </span><br><span class="line">                pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                <span class="comment">// 动态取出初始化的符号    </span></span><br><span class="line">                pComponentInit = dlsym(pModules[i], <span class="string">&quot;OMX_ComponentInit&quot;</span>);    </span><br><span class="line">                pErr = dlerror();    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                *pHandle = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OMX_COMPONENTTYPE));    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                pComponents[i] = *pHandle;    </span><br><span class="line">                componentType = (OMX_COMPONENTTYPE*) *pHandle;    </span><br><span class="line">                componentType-&gt;nSize = <span class="keyword">sizeof</span>(OMX_COMPONENTTYPE);    </span><br><span class="line">                err = (*pComponentInit)(*pHandle);   <span class="comment">// 执行初始化工作    </span></span><br><span class="line">                <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    err = OMX_ErrorComponentNotFound;    </span><br><span class="line">    <span class="keyword">goto</span> UNLOCK_MUTEX;    </span><br><span class="line">    <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">     <span class="keyword">return</span> (err);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在TIOMX_GetHandle()函数中，根据tComponentName数组中动态库的名称，动态打开各个编解码实现的动态库，取出其中的<strong>OMX_ComponentInit</strong>符号来执行各个组件的初始化。</p>
<h5 id="2-3-3、一个TI-OpenMax-IL组件的实现"><a href="#2-3-3、一个TI-OpenMax-IL组件的实现" class="headerlink" title="2.3.3、一个TI OpenMax IL组件的实现"></a>2.3.3、一个TI OpenMax IL组件的实现</h5><p>  TI OpenMax IL中各个组件都是通过调用LCML来实现的，实现的方式基本类似。主要都是实现了名称为OMX_ComponentInit的初始化函数，实现OMX_COMPONENTTYPE类型的结构体中的各个成员。各个组件其目录结构和文件结构也类似。</p>
<p>以MP3解码器的实现为例，在audio/src/openmax_il/mp3_dec/src目录中，主要包含以下文件：</p>
<p>☯ OMX_Mp3Decoder.c：MP3解码器组件实现<br>☯ OMX_Mp3Dec_CompThread.c：MP3解码器组件的线程循环<br>☯ OMX_Mp3Dec_Utils.c：MP3解码器的相关工具，调用LCML实现真正的MP3解码的功能<br>       OMX_Mp3Decoder.c中的OMX_ComponentInit()函数负责组件的初始化，返回的内容再从参数中得到，这个函数的主要片断如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">OMX_ComponentInit</span> <span class="params">(OMX_HANDLETYPE hComp)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    OMX_ERRORTYPE eError = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp;    </span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = <span class="literal">NULL</span>, *pPortDef_op = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_AUDIODEC_PORT_TYPE *pCompPort = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_BUFFERLIST *pTemp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">  </span><br><span class="line">    MP3D_OMX_CONF_CHECK_CMD(pHandle,<span class="number">1</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">/* ......省略，初始化OMX_COMPONENTTYPE类型的指针pHandle */</span>    </span><br><span class="line">    OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE);    </span><br><span class="line">    pComponentPrivate = pHandle-&gt;pComponentPrivate; <span class="comment">/* 私有指针互相指向 */</span>    </span><br><span class="line">    pComponentPrivate-&gt;pHandlepHandle = pHandle;    </span><br><span class="line">    <span class="comment">/* ......略，初始化似有数据指针pComponentPrivate */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_ip-&gt;nSize                   = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_ip-&gt;nPortIndex             = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortDef_ip-&gt;eDir                    = OMX_DirInput;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountActual    = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountMin        = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferSize             = MP3D_INPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferAlignment       = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_ip-&gt;bEnabled                 = OMX_TRUE;    </span><br><span class="line">    pPortDef_ip-&gt;bPopulated               = OMX_FALSE;    </span><br><span class="line">    pPortDef_ip-&gt;eDomain                   = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.cMIMEType = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.pNativeRender           = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* 设置输出端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_op-&gt;nSize                 = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_op-&gt;nPortIndex           = MP3D_OUTPUT_PORT;    </span><br><span class="line">    pPortDef_op-&gt;eDir                  = OMX_DirOutput;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountMin     = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountActual  = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferSize          = MP3D_OUTPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_op-&gt;nBufferAlignment    = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_op-&gt;bEnabled              = OMX_TRUE;    </span><br><span class="line">    pPortDef_op-&gt;bPopulated            = OMX_FALSE;    </span><br><span class="line">    pPortDef_op-&gt;eDomain               = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.eEncoding      = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.cMIMEType      = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.pNativeRender = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* ......省略，分配端口 */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">    pPortFormat-&gt;nPortIndex         = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortFormat-&gt;nIndex             = OMX_IndexParamAudioMp3;    </span><br><span class="line">    pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    <span class="comment">/* 设置输出端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">        pPortFormat-&gt;nPortIndex         = MP3D_OUTPUT_PORT;    </span><br><span class="line">        pPortFormat-&gt;nIndex             = OMX_IndexParamAudioPcm;    </span><br><span class="line">        pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    eError = Mp3Dec_StartCompThread(pHandle);   <span class="comment">// 启动MP3解码线程    </span></span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    <span class="keyword">return</span> eError;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个组件是OpenMax的标准实现方式，对外的接口的内容只有一个初始化函数。完成OMX_COMPONENTTYPE类型的初始化。输入端口的编号为MP3D_INPUT_PORT（==0），类型为OMX_PortDomainAudio，格式为OMX_AUDIO_CodingMP3。输出端口的编号是MP3D_OUTPUT_PORT（==1），类型为OMX_PortDomainAudio，格式为OMXAUDIO CodingPCM。</p>
<p>  OMX_Mp3Dec_CompThread.c中定义了MP3DEC_ComponentThread()函数，用于创建MP3解码的线程的执行函数。<br>  OMX_Mp3Dec_Utils.c中的Mp3Dec_StartCompThread()函数，调用了POSIX的线程库建立MP3解码的线程，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), <span class="literal">NULL</span>,    </span><br><span class="line">    MP3DEC_ComponentThread, pComponentPrivate);</span><br></pre></td></tr></table></figure>

<p> Mp3Dec_StartCompThread()函数就是在组件初始化函数OMX_ComponentInit()最后调用的内容。MP3线程的开始并不表示解码过程开始，线程需要等待通过pipe机制获得命令和数据（cmdPipe和dataPipe），在适当的时候开始工作。这个pipe在MP3解码组件的SendCommand等实现写操作，在线程中读取其内容。</p>
<h5 id="2-4、Qualcomm-高通-OpenMax-IL的硬件实现"><a href="#2-4、Qualcomm-高通-OpenMax-IL的硬件实现" class="headerlink" title="2.4、Qualcomm(高通) OpenMax IL的硬件实现"></a>2.4、Qualcomm(高通) OpenMax IL的硬件实现</h5><h6 id="2-4-1、qcom-OpenMax-IL实现的结构和机制"><a href="#2-4-1、qcom-OpenMax-IL实现的结构和机制" class="headerlink" title="2.4.1、qcom OpenMax IL实现的结构和机制"></a>2.4.1、qcom OpenMax IL实现的结构和机制</h6><p>（1）在AOSP中依然有对高通平台的OpenMax IL层实现代码，位于hardware/qcom/media/mm-core下。这一部分是OpenMax核心和公共部分，主要编译为libOmxCore.so。</p>
<p>（2）e.g. 继续在hardware/qcom/media下，选取mm-video-v4l2目录。即Video4linux2（简称V4L2),是linux中关于视频设备的内核驱动。再次进入vidc，（DivxDrmDecrypt为DRM数字版权相关）主要目录如下：</p>
<p>☯ vdec：视频解码处理，编译成libOmxVdec.so/libOmxVdecHevc.so<br>☯ venc：视频编码处理，编译成libOmxVenc.so<br>qcom OpenMax IL的核心和公共内容<br>       类似于前面介绍的TI，高通平台在OpenMax IL实现也是大同小异，位于hardware/qcom/media/mm-core，生成libOmxCore.so库。<br>       其中qc_omx_core为主要文件，位于hardware/qcom/media/mm-core/omxcore/src/common/下面。和TI的差不多，OMX_GetHandle()函数用户获取各个组件的句柄，其实现的主要片断如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编解码器组件集合数组</span></span><br><span class="line"><span class="keyword">extern</span> omx_core_cb_type core[];</span><br><span class="line"></span><br><span class="line"> OMX_API OMX_ERRORTYPE OMX_APIENTRY</span><br><span class="line">OMX_GetHandle(OMX_OUT OMX_HANDLETYPE*     handle,</span><br><span class="line">              OMX_IN OMX_STRING    componentName,</span><br><span class="line">              OMX_IN OMX_PTR             appData,</span><br><span class="line">              OMX_IN OMX_CALLBACKTYPE* callBacks)</span><br><span class="line">&#123;</span><br><span class="line">  OMX_ERRORTYPE  eRet = OMX_ErrorNone;</span><br><span class="line">  <span class="keyword">int</span> cmp_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> hnd_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  DEBUG_PRINT(<span class="string">&quot;OMXCORE API :  Get Handle %p %s %p\n&quot;</span>, handle,</span><br><span class="line">                                                     componentName,</span><br><span class="line">                                                     appData);</span><br><span class="line">  pthread_mutex_lock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">if</span>(handle)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sd</span>;</span></span><br><span class="line">    <span class="comment">//组件句柄</span></span><br><span class="line">    *handle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获取根据组件名获取相应index</span></span><br><span class="line">    cmp_index = get_cmp_index(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmp_index &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       DEBUG_PRINT(<span class="string">&quot;getting fn pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// dynamically load the so 动态加载组件的so库</span></span><br><span class="line">      core[cmp_index].fn_ptr =</span><br><span class="line">        omx_core_load_cmp_library(core[cmp_index].so_lib_name,</span><br><span class="line">                                  &amp;core[cmp_index].so_lib_handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(core[cmp_index].fn_ptr)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Construct the component requested</span></span><br><span class="line">        <span class="comment">// Function returns the opaque handle</span></span><br><span class="line">        <span class="comment">//根据获取的组件句柄初始化它</span></span><br><span class="line">        <span class="keyword">void</span>* pThis = (*(core[cmp_index].fn_ptr))();</span><br><span class="line">        <span class="keyword">if</span>(pThis)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//包装一层，忽略</span></span><br><span class="line">          <span class="keyword">void</span> *hComp = <span class="literal">NULL</span>;</span><br><span class="line">          hComp = qc_omx_create_component_wrapper((OMX_PTR)pThis);</span><br><span class="line">          <span class="keyword">if</span>((eRet = qc_omx_component_init(hComp, core[cmp_index].name)) !=</span><br><span class="line">                           OMX_ErrorNone)</span><br><span class="line">          &#123;</span><br><span class="line">              DEBUG_PRINT(<span class="string">&quot;Component not created succesfully\n&quot;</span>);</span><br><span class="line">              pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">              <span class="keyword">return</span> eRet;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置回调</span></span><br><span class="line">          qc_omx_component_set_callbacks(hComp,callBacks,appData);</span><br><span class="line">          hnd_index = get_comp_handle_index(componentName);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span>(hnd_index &gt;= <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//保存这个组件句柄</span></span><br><span class="line">            core[cmp_index].inst[hnd_index]= *handle = (OMX_HANDLETYPE) hComp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">          <span class="comment">/*-------下面全是错误处理，忽略------*/</span></span><br><span class="line">            DEBUG_PRINT(<span class="string">&quot;OMX_GetHandle:NO free slot available to store Component Handle\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">          &#125;</span><br><span class="line">          DEBUG_PRINT(<span class="string">&quot;Component %p Successfully created\n&quot;</span>,*handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">          DEBUG_PRINT(<span class="string">&quot;Component Creation failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        eRet = OMX_ErrorNotImplemented;</span><br><span class="line">        DEBUG_PRINT(<span class="string">&quot;library couldnt return create instance fn\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      eRet = OMX_ErrorNotImplemented;</span><br><span class="line">      DEBUG_PRINT(<span class="string">&quot;ERROR: Already another instance active  ;rejecting \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    eRet =  OMX_ErrorBadParameter;</span><br><span class="line">    DEBUG_PRINT(<span class="string">&quot;\n OMX_GetHandle: NULL handle \n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>  这里的有个数组：extern omx_core_cb_type core[]，是从别的文件中声明过来的全局变量，其中包含了各种编解码器的名称和一些属性的结构体。结构体定义位于hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.h：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">omx_core_cb_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>*                         name;<span class="comment">// Component name 组件名</span></span><br><span class="line">  create_qc_omx_component     fn_ptr;<span class="comment">// create instance fn ptr 创建实例函数指针</span></span><br><span class="line">  <span class="keyword">void</span>*                         inst[OMX_COMP_MAX_INST];<span class="comment">// Instance handle 实例句柄</span></span><br><span class="line">  <span class="keyword">void</span>*                so_lib_handle;<span class="comment">// So Library handle so库句柄</span></span><br><span class="line">  <span class="keyword">char</span>*                  so_lib_name;<span class="comment">// so directory so名</span></span><br><span class="line">  <span class="keyword">char</span>* roles[OMX_CORE_MAX_CMP_ROLES];<span class="comment">// roles played 组件扮演的角色</span></span><br><span class="line">&#125;omx_core_cb_type;</span><br></pre></td></tr></table></figure>
<p>  但是给omx_core_cb_type core[]这个结构体数组复制的地方要根据不同型号进行选取，我们进入hardware/qcom/media/mm-core/src下面，会看到有许多型号，7627A、7630、8084、8226、8610、8660等等。比如这个8974的，位于hardware/qcom/media/mm-core/src/8974/qc_registry_table_android.c中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">omx_core_cb_type core[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//avc/h264解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;OMX.qcom.video.decoder.avc&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">&quot;libOmxVdec.so&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;video_decoder.avc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//mpeg4解码器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;OMX.qcom.video.decoder.mpeg4&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">&quot;libOmxVdec.so&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;video_decoder.mpeg4&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//wmv解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;OMX.qcom.video.decoder.wmv&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">&quot;libOmxVdec.so&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;video_decoder.vc1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//hevc/h265编码器</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;OMX.qcom.video.encoder.hevc&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">&quot;libOmxVencHevc.so&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;video_encoder.hevc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...太多了，省略...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面就是对编解码器相关信息的注册。</p>
<p>在OMX_GetHandle()函数中，根据omx_core_cb_type core[]数组中动态库的名称，动态打开各个编解码实现的动态库,然后进行初始化。</p>
<h6 id="2-4-1、一个qcom-OpenMax-IL组件的实现"><a href="#2-4-1、一个qcom-OpenMax-IL组件的实现" class="headerlink" title="2.4.1、一个qcom OpenMax IL组件的实现"></a>2.4.1、一个qcom OpenMax IL组件的实现</h6><p> 高通平台对于编解码组件的处理都比较集中，不像TI那么分散和细致。一个组件实现都要包含Qc_omx_component.h头文件，位于很多地方，如hardware/qcom/media/mm-core/inc，要实现里面相关纯虚函数。当一个组件被创建后要初始化，就要实现component_init(OMX_IN OMX_STRING componentName)方法。</p>
<p>举个例子，依然以Video4linux2平台，进入hardware/qcom/media/mm-video-v4l2/vidc/vdec/src查看视频解码相关组件。比如我们看看解码组件omx_vdec_hevc.cpp，查看component_init方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENUS_HEVC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;/dev/video/venus_dec&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;/dev/video/q6_dec&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ======================================================================</span></span><br><span class="line"><span class="comment">   FUNCTION</span></span><br><span class="line"><span class="comment">   omx_vdec::ComponentInit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   DESCRIPTION</span></span><br><span class="line"><span class="comment">   Initialize the component.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PARAMETERS</span></span><br><span class="line"><span class="comment">   ctxt -- Context information related to the self.</span></span><br><span class="line"><span class="comment">   id   -- Event identifier. This could be any of the following:</span></span><br><span class="line"><span class="comment">   1. Command completion event</span></span><br><span class="line"><span class="comment">   2. Buffer done callback event</span></span><br><span class="line"><span class="comment">   3. Frame done callback event</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   RETURN VALUE</span></span><br><span class="line"><span class="comment">   None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">omx_vdec::component_init</span><span class="params">(OMX_STRING role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE eRet = OMX_ErrorNone;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">bufreq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">control</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   alignment = <span class="number">0</span>,buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> r,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> codec_ambiguous = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//打开设备文件&quot;/dev/video/venus_dec&quot;或&quot;/dev/video/q6_dec&quot;</span></span><br><span class="line">    OMX_STRING device_name = (OMX_STRING)DEVICE_NAME;</span><br><span class="line">    ......</span><br><span class="line">    drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是一个打开成功后，为什么要再次打开？？excuse me ？</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开设备文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">&quot;Omx_vdec::Comp Init Returning failure, errno %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;<span class="comment">//帧率分子</span></span><br><span class="line">    drv_ctx.frame_rate.fps_denominator = <span class="number">1</span>;<span class="comment">//帧率分母</span></span><br><span class="line">    <span class="comment">//创建一个异步线程，执行async_message_thread函数，对输入端进行设置</span></span><br><span class="line">    ret = pthread_create(&amp;async_thread_id,<span class="number">0</span>,async_message_thread,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建线程失败，则关闭设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(drv_ctx.video_driver_fd);</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">&quot;Failed to create async_message_thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the role information which provides the decoder kind</span></span><br><span class="line">    <span class="comment">//将组建角色名字copy进设备驱动上下文结构体的kind属性</span></span><br><span class="line">    strlcpy(drv_ctx.kind,role,<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//如果是mpeg4解码组件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">&quot;OMX.qcom.video.decoder.mpeg4&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.mpeg4&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.timestamp_adjust = <span class="literal">true</span>;</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG4;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_MPEG4;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG4*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG4;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是mpeg2解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">&quot;OMX.qcom.video.decoder.mpeg2&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.mpeg2&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_MPEG2;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG2;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG2*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG2;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是h263解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.h263&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.h263&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW(<span class="string">&quot;H263 Decoder selected&quot;</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H263;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingH263;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_H263;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H263;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是divx311...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.divx311&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.divx&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW (<span class="string">&quot;DIVX 311 Decoder selected&quot;</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX_311;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;createDivxDrmContext Failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx4...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.divx4&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.divx&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">&quot;DIVX 4 Decoder selected&quot;</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_4;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;createDivxDrmContext Failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.divx&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.divx&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">&quot;DIVX 5/6 Decoder selected&quot;</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_6;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;createDivxDrmContext Failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是avc/h264...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.avc&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.avc&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H264;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_H264;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingAVC;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H264;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是hevc/h265...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.hevc&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.hevc&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_HEVC;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_HEVC;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingHevc;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_HEVC;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果是vc1...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.vc1&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.vc1&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_G;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">    <span class="comment">//如果是wmv...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.wmv&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.vc1&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1_RCV;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_L;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">    <span class="comment">//如果是vp8...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">&quot;OMX.qcom.video.decoder.vp8&quot;</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">&quot;video_decoder.vp8&quot;</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        output_capability=V4L2_PIX_FMT_VP8;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingVPX;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VP8;</span><br><span class="line">        arbitrary_bytes = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果是不认识的解码组件，则报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">&quot;ERROR:Unknown Component&quot;</span>);</span><br><span class="line">        eRet = OMX_ErrorInvalidComponentName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果错误</span></span><br><span class="line">    <span class="keyword">if</span> (eRet == OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="comment">//设置视频输出编码格式为YUV的一种</span></span><br><span class="line">        drv_ctx.output_format = VDEC_YUV_FORMAT_NV12;</span><br><span class="line">        <span class="comment">//设置颜色编码</span></span><br><span class="line">        OMX_COLOR_FORMATTYPE dest_color_format = (OMX_COLOR_FORMATTYPE)</span><br><span class="line">            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;</span><br><span class="line">        <span class="keyword">if</span> (!client_buffers.set_color_format(dest_color_format)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;Setting color format failed&quot;</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//订阅事件</span></span><br><span class="line">        capture_capability= V4L2_PIX_FMT_NV12;</span><br><span class="line">        ret = subscribe_to_events(drv_ctx.video_driver_fd);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;Subscribe Event Failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">        <span class="comment">//设置查询能力标志位</span></span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_QUERYCAP, &amp;cap);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;Failed to query capabilities&quot;</span>);</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">&quot;Capabilities: driver_name = %s, card = %s, bus_info = %s,&quot;</span></span><br><span class="line">                    <span class="string">&quot; version = %d, capabilities = %x&quot;</span>, cap.driver, cap.card,</span><br><span class="line">                    cap.bus_info, cap.version, cap.capabilities);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">&quot;fmt: description: %s, fmt: %x, flags = %x&quot;</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">&quot;fmt: description: %s, fmt: %x, flags = %x&quot;</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        update_resolution(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = output_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;Failed to set format on output port&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;Set Format was successful&quot;</span>);</span><br><span class="line">        <span class="comment">//如果有歧义的解码组件</span></span><br><span class="line">        <span class="keyword">if</span> (codec_ambiguous) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_capability == V4L2_PIX_FMT_DIVX) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">divx_ctrl</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_4) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_5) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                divx_ctrl.id = V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT;</span><br><span class="line">                ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;divx_ctrl);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">&quot;Failed to set divx version&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">&quot;Codec should not be ambiguous&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解码相关参数设置</span></span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = capture_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;Failed to set format on capture port&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;Set Format was successful&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE;</span><br><span class="line">            control.value = <span class="number">1</span>;</span><br><span class="line">            DEBUG_PRINT_LOW(<span class="string">&quot;Omx_vdec:: calling to open secure device %d&quot;</span>, ret);</span><br><span class="line">            ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&amp;control);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">&quot;Omx_vdec:: Unable to open secure device %d&quot;</span>, ret);</span><br><span class="line">                close(drv_ctx.video_driver_fd);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Get the Buffer requirements for input and output ports*/</span></span><br><span class="line">        <span class="comment">//获得输入和输出的缓冲条件</span></span><br><span class="line">        drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;</span><br><span class="line">        drv_ctx.op_buf.buffer_type = VDEC_BUFFER_TYPE_OUTPUT;</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_1M;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_1M;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_4K;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_4K;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_ctx.interlace = VDEC_InterlaceFrameProgressive;</span><br><span class="line">        drv_ctx.extradata = <span class="number">0</span>;</span><br><span class="line">        drv_ctx.picture_order = VDEC_ORDER_DISPLAY;</span><br><span class="line">        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER;</span><br><span class="line">        control.value = V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;control);</span><br><span class="line">        drv_ctx.idr_only_decoding = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_state = OMX_StateLoaded;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEFAULT_EXTRADATA</span></span><br><span class="line">        <span class="keyword">if</span> (eRet == OMX_ErrorNone &amp;&amp; !secure_mode)</span><br><span class="line">            enable_extradata(DEFAULT_EXTRADATA, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        eRet=get_buffer_req(&amp;drv_ctx.ip_buf);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;Input Buffer Size =%d&quot;</span>,drv_ctx.ip_buf.buffer_size);</span><br><span class="line">        get_buffer_req(&amp;drv_ctx.op_buf);</span><br><span class="line">        <span class="comment">//如果解码器格式是h264或者hevc/h265</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||</span><br><span class="line">                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) &#123;</span><br><span class="line">            h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;</span><br><span class="line">            h264_scratch.pBuffer = (OMX_U8 *)<span class="built_in">malloc</span> (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">            h264_scratch.nFilledLen = <span class="number">0</span>;</span><br><span class="line">            h264_scratch.nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h264_scratch.pBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">&quot;h264_scratch.pBuffer Allocation failed &quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果解码器格式是h264</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_frame_parser.mutils = <span class="keyword">new</span> H264_Utils();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">&quot;parser utils Allocation failed &quot;</span>);</span><br><span class="line">                    eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m_frame_parser.mutils-&gt;initialize_frame_checking_environment();</span><br><span class="line">                    m_frame_parser.mutils-&gt;allocate_rbsp_buffer (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建一个h264流的解析器</span></span><br><span class="line">            h264_parser = <span class="keyword">new</span> h264_stream_parser();</span><br><span class="line">            <span class="keyword">if</span> (!h264_parser) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">&quot;ERROR: H264 parser allocation failed!&quot;</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开一个管道，读写端保存进fds数组</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>] == <span class="number">0</span> || fds[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pipe (temp1)) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">&quot;pipe creation failed&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//close (fds[0]);</span></span><br><span class="line">                <span class="comment">//close (fds[1]);</span></span><br><span class="line">                fds[<span class="number">0</span>] = temp1 [<span class="number">0</span>];</span><br><span class="line">                fds[<span class="number">1</span>] = temp1 [<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输入/读</span></span><br><span class="line">            m_pipe_in = fds[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//输出/写</span></span><br><span class="line">            m_pipe_out = fds[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//创建一个工作线程，调用omx开始处理解码，并进行i/o操作</span></span><br><span class="line">            r = pthread_create(&amp;msg_thread_id,<span class="number">0</span>,message_thread,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">&quot;component_init(): message_thread creation failed&quot;</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有错误，然后收尾</span></span><br><span class="line">    <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">&quot;Component Init Failed&quot;</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;Calling VDEC_IOCTL_STOP_NEXT_MSG&quot;</span>);</span><br><span class="line">        (<span class="keyword">void</span>)ioctl(drv_ctx.video_driver_fd, VDEC_IOCTL_STOP_NEXT_MSG,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;Calling close() on Video Driver&quot;</span>);</span><br><span class="line">        close (drv_ctx.video_driver_fd);</span><br><span class="line">        drv_ctx.video_driver_fd = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">&quot;omx_vdec::component_init() success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(&amp;h264_mv_buff,0,sizeof(struct h264_mv_buffer));</span></span><br><span class="line">    <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个是解码组件的初始化实现。我们能够看出和TI的差距挺大的。步骤大概如下（maybe wrong）：</p>
<p>☯ 打开media相关设备文件<br>☯ 创建一个异步线程，执行async_message_thread函数，对输入端进行设置<br>☯ 根据解码器role名配置相关属性<br>☯ 对视频解码相关基本配置进行设置<br>☯ 创建一个管道，然后再开一个个工作线程，调用omx开始处理解码，并进行i/o操作</p>
<h4 id="（三）、Android中OpenMax的实现"><a href="#（三）、Android中OpenMax的实现" class="headerlink" title="（三）、Android中OpenMax的实现"></a>（三）、Android中OpenMax的实现</h4><h5 id="3-1、android-MediaCodec-ACodec"><a href="#3-1、android-MediaCodec-ACodec" class="headerlink" title="3.1、android MediaCodec ACodec"></a>3.1、android MediaCodec ACodec</h5><h5 id="3-1-1、MediaCodec"><a href="#3-1-1、MediaCodec" class="headerlink" title="3.1.1、MediaCodec"></a>3.1.1、MediaCodec</h5><p>MediaCodec类可用于访问Android底层的媒体编解码器，例如，编码/解码组件。它是Android为多媒体支持提供的底层接口的一部分（通常与MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, 以及AudioTrack一起使用）。<br>从广义上讲，一个编解码器通过处理输入数据来产生输出数据。它通过异步方式处理数据，并且使用了一组输入输出buffers。在简单层面，请求（或接收）到一个空的输入buffer，向里面填满数据并将它传递给编解码器处理。这个编解码器将使用完这些数据并向所有空的输出buffer中的一个填充这些数据。最终，请求（或接受）到一个填充了数据的buffer,可以使用其中的数据内容，并且在使用完后将其释放回编解码器。</p>
<p>1、    Data Types<br>编解码器处理三种类型的数据：压缩数据，原始音频数据，原始视频数据。上述三种数据都可以通过ByteBuffers进行处理，但需要为原始视频数据提供一个Surface来提高编解码性能。<br>    压缩缓存（Compressed Buffers）：输入缓冲区(解码器)和输出缓冲区(编码器)包含压缩数据格式的类型。<br>    原始音频缓存（Raw Audio Buffers）：原始音频缓冲区包含整个PCM音频帧数据。<br>    原始视频缓存（Raw Video Buffers）：ByteBuffer模式视频缓冲区根据他们的颜色格式布局。视频编解码器可能支持三种类型的色彩格式：1)、native raw video format：被COLOR_FormatSurface标记，其可与输入或输出Surface一起使用；2)、flexible YUV buffers（如COLOR_FormatYUV420Flexible），可以与输入/输出Surface一起使用, ByteBuffer模式下可以通过调用getInput/OutputImage(int)方法进行使用；3)、通常只在ByteBuffer模式下被支持。由供应商指定，可以使用 getInput/OutputImage(int)方法。</p>
<p>2、States<br>在编解码器的生命周期内有三种理论状态：停止态-Stopped、执行态-Executing、释放态-Released。停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。执行状态（Executing）在概念上会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-10-MediaCodec-states.png" alt="Alt text | center"></p>
<p>使用工厂方法之一创建一个编解码器的时候，是处于Uninitialized状态。首先，需要通过configure(…)方法配置它，以此进入Configured 状态。然后，通过调用start()方法转入Executing 状态。在这个状态下可以通过上述buffer队列操作过程数据。<br>调用start()方法后立即进入Flushed状态，此时编解码器拥有所有的缓存。一旦第一个输入缓存被移出队列，编解码器就转入运行子状态，这种状态占据了编解码器的大部分生命周期。当将一个带有end-of-stream marker标记的输入缓存入队列时，编解码器将转入流结束子状态。可在Executing状态的任何时候通过调用flush()。<br>调用stop()方法返回编解码器的Uninitialized 状态，因此这个编解码器需要再次configured 。当使用完编解码器后，必须调用release()方法释放其资源。</p>
<p>3、Data Processing<br>每一个编解码器包含一组输入和输出缓存，这些缓存在API调用中通过buffer-ID进行引用。当成功调用start()方法后客户端将不会拥有输入或输出buffers。在同步模式下，通过调用dequeueInput/OutputBuffer(…) 方法从编解码器获得一个输入或输出buffer；在异步模式下，可以通过MediaCodec.Callback.onInput/OutputBufferAvailable(…)的回调方法自动地获得可用的buffers。<br>在获得一个输入buffe后，填充数据，利用queueInputBuffer/queueSecureInputBuffer方法将其提交给编解码器，不要提交多个具有相同时间戳的输入bufers（除非它是也被同样标记的codec-specific data，因为codec-specific data缓冲的时间戳无意义）。<br>a.    Asynchronous Processing using Buffers<br>    从Android 5.0开始，首选的方法是调用configure之前通过设置回调异步地处理数据。异步模式稍微改变了状态转换方式，因为必须在调用flush()方法后再调用start()方法才能使编解码器的状态转换为Running子状态并开始接收输入buffers。同样，初始调用start方法将编解码器的状态直接变化为Running 子状态并通过回调方法开始传递可用的输入buufers。<br>b.    Synchronous Processing using Buffers<br>从Android 5.0开始，即使在同步模式下使用编解码器，也应该通过getInput/OutputBuffer(int) 和/或 getInput/OutputImage(int) 方法检索输入和输出buffers。</p>
<h5 id="3-1-2、ACodec"><a href="#3-1-2、ACodec" class="headerlink" title="3.1.2、ACodec"></a>3.1.2、ACodec</h5><p>1、ACodec消息机制：<br>    ACodec有一个BaseState和派生出来的其他State，如 UninitializedState, LoadedToIdleState, ExecutingState等。当有消息过来时，如果派生类有重写的方法，则会调到重写的方法，如果没有，则会调到BaseState的<br>    ACodec继承自AHierarchicalStateMachine类，该类用于将收到的消息传递给哪个state。<br>    ACodec收到的消息分两种，一种是MediaCodec传过来的，对应onMessageReceived方法；另一种是OMX Component传过来的，对应onOMXMessage方法。而onOMXMessage里面又分了4种情况来调用不同的方法。（EVENT、EMPTY_BUFFER_DONE、FILL_BUFFER_DONE和FRAME_RENDERED）</p>
<p>2、MediaCodec与ACodec的通知：<br>    OMX的组件解码之后，ACodec::BaseState:: onOMXFillBufferDone (…)会被回调，去取得解码后的数据。然后会在onOMXFillBufferDone中调用notify通知MediaCodec，发给MediaCodec的消息形如notify-&gt;setInt32(“what”, CodecBase::kWhatDrainThisBuffer);<br>    MediaCodec收到ACodec发的消息之后会updateBuffers(kPortIndexOutput, msg) 进行更新，同时调用onOutputBufferAvailable()中通知NuPlayer::Decoder有可用的output buffer。</p>
<p>3、ACodec有三种端口模式状态，其会根据当前处于哪个状态来决定buffer如何处理：<br>    KEEP_BUFFERS：当ACodec处于BaseState或者收到OnInputBufferFilled消息但是buffer里面没有填充有效的数据时，ACodec握有的buffer不会送到OMX 组件；<br>    RESUBMIT_BUFFERS：当ACodec处于ExecutingState或者处于OutputPortSettingChangedState但是当前是input口的buffer时，ACodec将握有的buffer送给OMX 组件；<br>    FREE_BUFFERS：当ACodec处于OutputPortSettingChangedState并且当前是output口的buffer时，ACodec将握有的buffer free。</p>
<p>4、stagefright类的调用关系：<br>    OMXNodeInstance负责创建并维护不同的实例，这些实例以node作为唯一标识。这样播放器中每个ACodec在OMX服务端都对应有了自己的OMXNodeInstance实例。<br>    OMXMaster用来维护底层软硬件解码库，根据OMXNodeInstance中想要的解码器来创建解码实体组件。<br>    OMXPluginBase负责加载组件库，创建组件实例，由OMXMaster管理。Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。（Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent）<br>    OMXClient是客户端用来与OMX IL进行通信的。<br>    内部结构CallbackDispatcher作用是用来接收回调函数的消息<br>    OMXNodeInstance + CallbackDispatcher = 合作完成不同实例的消息处理任务</p>
<p>5、ACodec同OMXNodeInstance的消息传递：<br>    ACodec将CodecObserver observer对象通过omx-&gt;allocateNode()传递到OMXNodeInstance。<br>    OMXNodeInstance将kCallbacks(OnEvent,OnEmptyBufferDone,OnFillBufferDone)传递给OMX Component<br>    当OMX Component有消息notify上来时，OMXNodeInstance最先收到，然后调用OMX.cpp。将消息在OMX.cpp里面将OMX Component thread转换到CallbackDispatcher线程中处理。CallbackDispatcher又将消息反调到OMXNodeInstance. 最后调用CodecObserver 的onMessage()回到ACodec中</p>
<p>6、    ACodec与OMX组件的关系<br>    ACodec ，CodecObserver和OMXNodeInstance是一一对应的，简单的可以理解它们3个构成了OpenMAX IL的一个Component，每一个node就是一个codec在OMX服务端的标识。当然还有CallbackDispatcher，用于处理codec过来的消息，通过它的post/loop/dispatch来发起接收，从OMX.cpp发送消息，最终通过OMXNodeInstance::onMessage -&gt; CodecObserver::onMessage -&gt; ACodec::onMessage一路往上，当然消息的来源是因为我们有向codec注册OMXNodeInstance::kCallbacks。<br>    而在OMXPluginBase创建组件实例的时候，需要传递一个callback给组件，这个callback用于接收组件的消息，它的实现是在OMXNodeInstance.cpp中。而kcallbacks是OMXNodeInstance的静态成员变量，它内部的三个函数指针分别指向了OMXNodeInstance的三个静态方法，也即是这三个方法与组件进行着消息传递</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-11-OMX-allocateNode.png" alt="Alt text | center"></p>
<p>    对于NuPlayer来说，它并不直接接触解码组件，而是通过创建ACodec来和组件交互。ACode内部有一个id，这个id对应于一个OMXNodeInstance。OMX对象中会对产生的每一个OMXNodeInstance分配一个唯一的node_id。每一个OMXNodeInstance内部又保存着组件实例的指针【OMX_HANDLETYPE mHandle;】，通过这个指针就可以和组件进行交互。交互的流程为：ACodec → OMX → OMXNodeInstance → COMPONENT。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-12-NuPlayer-libstagefrighthw.png" alt="Alt text | center"></p>
<p>8、组件的管理<br>    对组件的管理可以总结为：通过OMXMaster加载libstagefrighthw.so库文件，创建OMXPluginBase【即创建继承此类的组件对象】，通过这个类来管理组件。<br>    Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent。OMXPluginBase扮演者组件的管理者。它负责加载组件库，创建组件实例。而OMXMaster则管理着OMXPluginBase，Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。<br>    对于厂商来说，如果要实现自己的组件管理模块，需要通过继承实现OMXPluginBase，并将之编译为libstagefrighthw.so。在OMXMaster中会加载这个库文件，然后调用其createOMXPlugin方法获得一个OMXPluginBase指针，然后将其加入OMXPluginBase列表以及与组件名相关的map 【mPluginByComponentName】中，后续都会通过OMXPluginBase来管理组件。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/VS-04-13-OMXMaster-addPlugin.png" alt="Alt text | center"></p>
<h5 id="3-2、音视频解码数据处理"><a href="#3-2、音视频解码数据处理" class="headerlink" title="3.2、音视频解码数据处理"></a>3.2、音视频解码数据处理</h5><p>数据处理请参考： <a target="_blank" rel="noopener" href="http://charlesvincent.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">音视频解码数据处理</a></p>
<h5 id="3-3、高通实现（参考高通文档）"><a href="#3-3、高通实现（参考高通文档）" class="headerlink" title="3.3、高通实现（参考高通文档）"></a>3.3、高通实现（参考高通文档）</h5><p><a target="_blank" rel="noopener" href="https://createpoint.qti.qualcomm.com/">OpenMAX Integration Layer Video Encoder for Linux Android（高通文档）</a><br><a target="_blank" rel="noopener" href="https://createpoint.qti.qualcomm.com/">OpenMAX Integration Layer Video Decoder for Linux Android（高通文档）</a></p>
<h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/2016/12/15/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%94-OpenMax%E7%AE%80%E4%BB%8B/">Android多媒体开发(五)—-OpenMax简介</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/">Android多媒体开发(六)—-Android中OpenMax的实现(preview)</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/">Android多媒体开发(七)—-Android中OpenMax的实现</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/54926526">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/60132620">android MediaCodec ACodec - CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190211/">https://zhoujinjian.com/posts/20190211/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Video/">Video</a><a class="post-meta__tags" href="/tags/Multimedia/">Multimedia</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190212/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.26.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190210/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.24.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20190208/" title="Android Video System（1）：Video System(视频系统)框架分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-08</div><div class="title">Android Video System（1）：Video System(视频系统)框架分析</div></div></a></div><div><a href="/posts/20190209/" title="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-09</div><div class="title">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</div></div></a></div><div><a href="/posts/20190210/" title="Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-10</div><div class="title">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</div></div></a></div><div><a href="/posts/20190212/" title="Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-12</div><div class="title">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</div></div></a></div><div><a href="/posts/20190213/" title="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-13</div><div class="title">Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</div></div></a></div><div><a href="/posts/20190214/" title="Android Video System（7）：Android Multimedia Codecs - AAC编解码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.29.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-14</div><div class="title">Android Video System（7）：Android Multimedia Codecs - AAC编解码分析</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81OpenMax%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">（一）、OpenMax简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81-OpenMax%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、 OpenMax系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-1%E3%80%81OpenMax%E6%80%BB%E4%BD%93%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1、OpenMax总体层次结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-2%E3%80%81OpenMax-IL%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2、OpenMax IL简介</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1-3%E3%80%81OpenMax-IL%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3、OpenMax IL结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81Android%E4%B8%AD%E7%9A%84OpenMax"><span class="toc-number">1.2.</span> <span class="toc-text">1.2、Android中的OpenMax</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-1%E3%80%81OpenMax%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1、OpenMax在Android中的使用情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-2%E3%80%81Android-OpenMax%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2、Android OpenMax实现的内容</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3%E3%80%81%E5%88%9D%E7%AA%A5%E9%80%82%E9%85%8D%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">1.3、初窥适配层接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android中OpenMax的实现(preview)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81OpenMax%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、OpenMax的接口与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-2%E3%80%81OpenMax-IL%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.2、OpenMax IL实现的内容</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E3%80%81Android%E4%B8%ADOpenMax%E7%9A%84%E9%80%82%E9%85%8D%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、Android中OpenMax的适配层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81TI-Texas-Instruments-%E5%BE%B7%E5%B7%9E%E4%BB%AA%E5%99%A8-OpenMax-IL%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1%E3%80%81TI-OpenMax-IL%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">2.3.1、TI OpenMax IL实现的结构和机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2%E3%80%81TI-OpenMax-IL%E7%9A%84%E6%A0%B8%E5%BF%83%E5%92%8C%E5%85%AC%E5%85%B1%E5%86%85%E5%AE%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2.3.2、TI OpenMax IL的核心和公共内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3%E3%80%81%E4%B8%80%E4%B8%AATI-OpenMax-IL%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">2.3.3、一个TI OpenMax IL组件的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4%E3%80%81Qualcomm-%E9%AB%98%E9%80%9A-OpenMax-IL%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">2.4、Qualcomm(高通) OpenMax IL的硬件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-1%E3%80%81qcom-OpenMax-IL%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">2.4.1、qcom OpenMax IL实现的结构和机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-1%E3%80%81%E4%B8%80%E4%B8%AAqcom-OpenMax-IL%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.4.1、一个qcom OpenMax IL组件的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">（三）、Android中OpenMax的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81android-MediaCodec-ACodec"><span class="toc-number">4.1.</span> <span class="toc-text">3.1、android MediaCodec ACodec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1%E3%80%81MediaCodec"><span class="toc-number">4.2.</span> <span class="toc-text">3.1.1、MediaCodec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2%E3%80%81ACodec"><span class="toc-number">4.3.</span> <span class="toc-text">3.1.2、ACodec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">3.2、音视频解码数据处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E3%80%81%E9%AB%98%E9%80%9A%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8F%82%E8%80%83%E9%AB%98%E9%80%9A%E6%96%87%E6%A1%A3%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">3.3、高通实现（参考高通文档）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">（四）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>