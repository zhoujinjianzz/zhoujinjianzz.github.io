<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android L Display System源码分析（4）：Android Graphics 系统分析（Android 5.0.2 &amp;&amp; Kernel 3.0.86） | zhoujinjian</title><meta name="keywords" content="Android,Linux,Graphics"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读 Android  &amp;&amp; Linux 平台源码、各位前辈总结的资料、加上自己的思考分析总结出来的，其中难免有理不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用。图文内容、源码整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（ ©Android @Linux 版权所有），谢谢(๑乛◡乛๑) 、（ ͡° ͜ʖ ͡°）、（ಡωಡ）！！！。（&#x3D;&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android L Display System源码分析（4）：Android Graphics 系统分析（Android 5.0.2 &amp;&amp; Kernel 3.0.86）">
<meta property="og:url" content="https://zhoujinjian.com/posts/20191101/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读 Android  &amp;&amp; Linux 平台源码、各位前辈总结的资料、加上自己的思考分析总结出来的，其中难免有理不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用。图文内容、源码整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（ ©Android @Linux 版权所有），谢谢(๑乛◡乛๑) 、（ ͡° ͜ʖ ͡°）、（ಡωಡ）！！！。（&#x3D;&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00004.jpg">
<meta property="article:published_time" content="2019-11-01T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.948Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00004.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20191101/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00004.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android L Display System源码分析（4）：Android Graphics 系统分析（Android 5.0.2 &amp;&amp; Kernel 3.0.86）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-01T01:25:00.000Z" title="发表于 2019-11-01 09:25:00">2019-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.948Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Display/">Display</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读 Android  &amp;&amp; Linux 平台源码、各位前辈总结的资料、加上自己的思考分析总结出来的，其中难免有理不对的地方，欢迎大家批评指正。<strong>文章为个人学习、研究、欣赏之用。图文内容、源码整理自互联网，如有侵权，请联系删除（◕‿◕）</strong>，转载请注明出处（ ©Android @Linux 版权所有），谢谢(๑乛◡乛๑) 、（ ͡° ͜ʖ ͡°）、（ಡωಡ）！！！。<br>（==<strong>文章基于 Kernel-3.0.86</strong>==）&amp;&amp;（==<strong>文章基于 Android 5.0.2</strong>==）<br><a target="_blank" rel="noopener" href="https://item.taobao.com/item.htm?spm=0.0.0.0.3GsGdQ&id=20131438062">【开发板 - 友善之臂 FriendlyARM Cortex-A9 Tiny4412 ADK Exynos4412 （ Android 5.0.2）HD702高清电容屏 扩展套餐】</a><br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1jJHm74q">【开发板 Android 5.0.2 &amp;&amp; Kernel 3.0.86 源码链接： https://pan.baidu.com/s/1jJHm74q 密码：yfih】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，特别感谢！！！</p>
<p><a target="_blank" rel="noopener" href="http://charlesvincent.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android 7.1.2 (Android N) Android Graphics 系统 分析】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/12192401">【Android图形显示之硬件抽象层Gralloc】</a></p>
<hr>
<p>==源码（部分）==：</p>
<p><strong>/frameworks/native/services/surfaceflinger/</strong></p>
<ul>
<li>tests/Transaction_test.cpp    </li>
<li>tests/vsync/vsync.cpp</li>
</ul>
<p><strong>/frameworks/native/include/gui/</strong></p>
<ul>
<li>BitTube.h</li>
<li>BufferSlot.h</li>
<li>BufferQueueCore.h</li>
<li>BufferQueueProducer.h</li>
</ul>
<p><strong>frameworks/base/core/java/android/app/</strong></p>
<ul>
<li>Activity.java</li>
<li>ActivityThread.java</li>
<li>Instrumentation.java</li>
</ul>
<p><strong>frameworks/base/core/jni/</strong></p>
<ul>
<li>android_view_DisplayEventReceiver.cpp    </li>
<li>android_view_SurfaceControl.cpp</li>
<li>android_view_Surface.cpp</li>
<li>android_view_SurfaceSession.cpp</li>
</ul>
<p><strong>frameworks/native/include/gui/</strong></p>
<ul>
<li>SurfaceComposerClient.h</li>
<li>IDisplayEventConnection.h</li>
<li>SurfaceComposerClient.h</li>
</ul>
<p><strong>frameworks/native/services/surfaceflinger/</strong></p>
<ul>
<li>SurfaceFlinger.cpp</li>
<li>Client.cpp</li>
<li>main_surfaceflinger.cpp</li>
<li>DisplayDevice.cpp</li>
<li>DispSync.cpp</li>
<li>EventControlThread.cpp</li>
<li>EventThread.cpp</li>
<li>Layer.cpp</li>
<li>MonitoredProducer.cpp</li>
</ul>
<p><strong>frameworks/base/core/java/android/view/</strong></p>
<ul>
<li>WindowManagerImpl.java</li>
<li>ViewManager.java</li>
<li>WindowManagerGlobal.java</li>
<li>ViewRootImpl.java</li>
<li>Choreographer.java</li>
<li>IWindowSession.aidl</li>
<li>DisplayEventReceiver.java</li>
<li>SurfaceControl.java</li>
<li>Surface.java</li>
<li>SurfaceSession.java</li>
</ul>
<p><strong>frameworks/native/include/ui</strong></p>
<ul>
<li>GraphicBuffer.h</li>
<li>GraphicBufferAllocator.h</li>
</ul>
<p><strong>frameworks/base/services/core/java/com/android/server/wm/</strong></p>
<ul>
<li>WindowManagerService.java</li>
<li>Session.java</li>
<li>WindowState.java</li>
<li>WindowStateAnimator.java</li>
<li>WindowSurfaceController.java</li>
</ul>
<hr>
<h4 id="（一）、Android-Graphics-系统框架"><a href="#（一）、Android-Graphics-系统框架" class="headerlink" title="（一）、Android Graphics 系统框架"></a>（一）、Android Graphics 系统框架</h4><p>Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。<br>● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）<br>● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。<br>● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。<br>● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.android.graphics.arc.png" alt="enter image description here"></p>
<p><strong>App</strong><br>基于Android系统的GUI框架开发完整的Apk应用。</p>
<p><strong>Android Graphics Stack Client(SurfaceFlinger  Client)</strong><br>Android在客户端的绘图堆栈通常包括：<br>OpenGL ES：使用GPU进行3D和2D的绘图的API<br>EGL：衔接GLES和系统的Native Window系统的适配层<br>Vulkan：Vulkan为Khronos Group推出的下一代跨平台图形开发接口，用于替代历史悠久的OpenGL。Android从7.0(Nougat)开始加入了对其的支持。Vulkan与OpenGL相比，接口更底层，从而使开发者能更直接地控制GPU。由于更好的并行支持，及更小的开销，性能上也有一定的提升。</p>
<p><strong>Android Graphics Stack Server（SurfaceFlinger  Server）</strong><br>SurfaceFlinger是Android用于管理Display和负责Window Composite（窗口混合），把应用的显示窗口输出到Display的系统服务。</p>
<p><strong>Android Drivers（HAL）</strong><br>Android的驱动层，通过Android本身的HAL（硬件抽象层）机制，运行于User Space，跟渲染相关的包括：</p>
<p>Hwcomposer：如果硬件支持，SurfaceFlinger可以请求hwcomposer去做窗口混合而不需要自己来做，这样的效率也会更高，减少对GPU资源的占用<br>Gralloc：用来管理Graphics Buffer的分配和管理系统的framebuffer<br>OpenGL ES/EGL</p>
<p><strong>Linux Kernel and Drivers</strong><br>除了标准的Linux内核和驱动（例如fb是framebuffer驱动），硬件厂商自己的驱动外，Android自己的一些Patches：</p>
<p>Ashmem：异步共享内存，用于在进程间共享一块内存区域，并允许系统在资源紧张时回收不加锁的内存块<br>ION：内存管理器 ION是google在Android4.0 为了解决内存碎片管理而引入的通用内存管理器,在面向程序员编程方面，它和ashmem很相似。但ION比ashmem更强大<br>Binder：高效的进程间通信机制<br>Vsync：Android 4.1引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作<br><strong>Hardware</strong><br>Display（显示器）、CPU、GPU、VPU（Video Process Unit）、和内存等等</p>
<h4 id="（二）、Android-Graphics-测试程序（C-）"><a href="#（二）、Android-Graphics-测试程序（C-）" class="headerlink" title="（二）、Android Graphics 测试程序（C++）"></a>（二）、Android Graphics 测试程序（C++）</h4><p>为了便于观察对原生测试程序显示图像大小做了如下修改：</p>
<blockquote>
<p>android-5.0.2\vendor\friendly-arm\tiny4412\SurfaceFlingerTestsRed\SurfaceFlingerTestsRed.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlingerTestsRed.JPG" alt="enter image description here"></p>
<p>我们先看一下主要步骤：<br>1、 创建SurfaceComposerClient</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br></pre></td></tr></table></figure>

<p>2、 客户端SurfaceComposerClient请求SurfaceFlinger创建Surface<br>注：App端对应SurfaceControl&lt;—&gt;SurfaceFlinger对应Layer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8(<span class="string">&quot;resize&quot;</span>),</span><br><span class="line">        <span class="number">800</span> / <span class="number">3</span>, <span class="number">1280</span>, PIXEL_FORMAT_RGB_565, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<p>3、处理事务，将SurfaceControl（App）的变化更新到Layer（SurfaceFlinger）图层</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface();</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">surfaceControl-&gt;setLayer(<span class="number">100000</span>);</span><br><span class="line">surfaceControl-&gt;setSize(<span class="number">800</span> / <span class="number">3</span>, <span class="number">1280</span>);</span><br><span class="line">surfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line">surface-&gt;lock(&amp;outBuffer, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">android_memset16((<span class="keyword">uint16_t</span>*)outBuffer.bits, <span class="number">0xF800</span>, bpr*outBuffer.height);</span><br><span class="line">surface-&gt;unlockAndPost();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来开始Android Graphics系统神秘探索之谜。</p>
<h4 id="（三）、Android-Graphics-禁用hwc和GPU"><a href="#（三）、Android-Graphics-禁用hwc和GPU" class="headerlink" title="（三）、Android Graphics 禁用hwc和GPU"></a>（三）、Android Graphics 禁用hwc和GPU</h4><h5 id="3-1、Disable-HWUI-GPU-HWC"><a href="#3-1、Disable-HWUI-GPU-HWC" class="headerlink" title="3.1、Disable_HWUI_GPU_HWC"></a>3.1、Disable_HWUI_GPU_HWC</h5><p>注：基于Android 5.0.2 Tiny4412源码，由于代码段较长，已放到GitHub<br><a target="_blank" rel="noopener" href="https://github.com/weidongshan/SYS_0003_Patch_Disable_HWC_GPU_tiny4412/blob/master/android-5.0.2_no_hwc_no_gpu.patch">Disable_HWUI_GPU_HWC.patch</a></p>
<h5 id="3-2、Vsync测试程序"><a href="#3-2、Vsync测试程序" class="headerlink" title="3.2、Vsync测试程序"></a>3.2、Vsync测试程序</h5><p>Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作。</p>
<p>查看frameworks/native/services/surfaceflinger/tests/下还有vsync测试程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/looper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/DisplayEventReceiver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Looper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver* q = (DisplayEventReceiver*)data;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">nsecs_t</span> oldTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n = q-&gt;getEvents(buffer, <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;event vsync: count=%d\t&quot;</span>, buffer[i].vsync.count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldTimeStamp) &#123;</span><br><span class="line">                <span class="keyword">float</span> t = <span class="keyword">float</span>(buffer[i].header.timestamp - oldTimeStamp) / s2ns(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%f ms (%f Hz)\n&quot;</span>, t*<span class="number">1000</span>, <span class="number">1.0</span>/t);</span><br><span class="line">            &#125;</span><br><span class="line">            oldTimeStamp = buffer[i].header.timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;error reading events (%s)\n&quot;</span>, strerror(-n));&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver myDisplayEvent;</span><br><span class="line">    sp&lt;Looper&gt; loop = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    loop-&gt;addFd(myDisplayEvent.getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT, receiver,</span><br><span class="line">            &amp;myDisplayEvent);</span><br><span class="line">    myDisplayEvent.setVsyncRate(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;about to poll...\n&quot;);</span></span><br><span class="line">        <span class="keyword">int32_t</span> ret = loop-&gt;pollOnce(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">                <span class="comment">//(&quot;ALOOPER_POLL_WAKE\n&quot;);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="comment">//(&quot;ALOOPER_POLL_CALLBACK\n&quot;);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ALOOPER_POLL_TIMEOUT\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ALOOPER_POLL_TIMEOUT\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ugh? poll returned %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行看看：可以看到vsync信号每隔16 ms一次，关于vsync知识稍后再分析。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event vsync: count=<span class="number">2631</span> <span class="number">16.168612</span> ms (<span class="number">61.848231</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2632</span> <span class="number">16.168613</span> ms (<span class="number">61.848224</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2633</span> <span class="number">16.168312</span> ms (<span class="number">61.849378</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2634</span> <span class="number">16.168682</span> ms (<span class="number">61.847961</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2635</span> <span class="number">16.168596</span> ms (<span class="number">61.848288</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2636</span> <span class="number">16.168867</span> ms (<span class="number">61.847255</span> Hz)</span><br></pre></td></tr></table></figure>

<h4 id="（四）、Android-SurfaceFlinger-内部机制"><a href="#（四）、Android-SurfaceFlinger-内部机制" class="headerlink" title="（四）、Android SurfaceFlinger 内部机制"></a>（四）、Android SurfaceFlinger 内部机制</h4><h5 id="4-1、APP与SurfaceFlinger的数据结构"><a href="#4-1、APP与SurfaceFlinger的数据结构" class="headerlink" title="4.1、APP与SurfaceFlinger的数据结构"></a>4.1、APP与SurfaceFlinger的数据结构</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.SurfaceFlinger.png" alt="enter image description here"></p>
<h6 id="4-1-1、BufferQueue介绍"><a href="#4-1-1、BufferQueue介绍" class="headerlink" title="4.1.1、BufferQueue介绍"></a>4.1.1、BufferQueue介绍</h6><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。<br>从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger.BufferQueue.png" alt="enter image description here"></p>
<p>先来看一下图中几个状态代表的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure>
<p><strong>FREE :</strong><br>FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue“拥有”。 它转换到DEQUEUED<br>当调用dequeueBuffer时。</p>
<p><strong>DEQUEUED：</strong><br>DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer“拥有”。 它可以转换到QUEUED（通过<br>queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p>
<p><strong>QUEUED：</strong><br>QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续<br>  修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue“拥有”。 它<br>  可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p>
<p><strong>ACQUIRED：</strong><br>ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到<br>获得栅栏fence信号。 BufferSlot由Consumer“拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个<br>分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p>
<p><strong>SHARED：</strong><br> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合，<br>除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p>
<p><strong>简单描述一下状态转换过程：</strong></p>
<p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p>
<p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。 </p>
<p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p>
<p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p>
<h6 id="4-1-2、生产者Producer"><a href="#4-1-2、生产者Producer" class="headerlink" title="4.1.2、生产者Producer"></a>4.1.2、生产者Producer</h6><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger.IGraphicsBufferProducer.png" alt="enter image description here"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、requestBuffer</strong><br>requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; requestBuffer requests a new buffer for the given index. The server (i.e.</span><br><span class="line">&#x2F;&#x2F; the IGraphicBufferProducer implementation) assigns the newly created</span><br><span class="line">&#x2F;&#x2F; buffer to the given slot index, and the client is expected to mirror the</span><br><span class="line">&#x2F;&#x2F; slot-&gt;buffer mapping so that it&#39;s not necessary to transfer a</span><br><span class="line">&#x2F;&#x2F; GraphicBuffer for every dequeue operation.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span><br><span class="line">virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>2、dequeueBuffer</strong><br>dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; dequeueBuffer requests a new buffer slot for the client to use. Ownership</span><br><span class="line">&#x2F;&#x2F; of the slot is transfered to the client, meaning that the server will not</span><br><span class="line">&#x2F;&#x2F; use the contents of the buffer associated with that slot.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w,</span><br><span class="line">        uint32_t h, PixelFormat format, uint32_t usage) &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp <GraphicBuffer>（即必须调用requestBuffer）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; detachBuffer attempts to remove all ownership of the buffer in the given</span><br><span class="line">&#x2F;&#x2F; slot from the buffer queue. If this call succeeds, the slot will be</span><br><span class="line">&#x2F;&#x2F; freed, and there will be no way to obtain the buffer from this interface.</span><br><span class="line">&#x2F;&#x2F; The freed slot will remain unallocated until either it is selected to</span><br><span class="line">&#x2F;&#x2F; hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span><br><span class="line">&#x2F;&#x2F; to the slot. The buffer must have already been dequeued, and the caller</span><br><span class="line">&#x2F;&#x2F; must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span><br><span class="line">&#x2F;&#x2F; requestBuffer).</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">virtual status_t detachBuffer(int slot) &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; attachBuffer attempts to transfer ownership of a buffer to the buffer</span><br><span class="line">&#x2F;&#x2F; queue. If this call succeeds, it will be as if this buffer was dequeued</span><br><span class="line">&#x2F;&#x2F; from the returned slot number. As such, this call will fail if attaching</span><br><span class="line">&#x2F;&#x2F; this buffer would cause too many buffers to be simultaneously dequeued.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">virtual status_t attachBuffer(int* outSlot,</span><br><span class="line">        const sp&lt;GraphicBuffer&gt;&amp; buffer) &#x3D; 0;</span><br></pre></td></tr></table></figure>

<h6 id="4-1-3、消费者Consumer"><a href="#4-1-3、消费者Consumer" class="headerlink" title="4.1.3、消费者Consumer"></a>4.1.3、消费者Consumer</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger.IGraphicsBufferConsumer.png" alt="enter image description here"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、acquireBuffer</strong><br>acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; acquireBuffer attempts to acquire ownership of the next pending buffer in</span><br><span class="line">&#x2F;&#x2F; the BufferQueue.  If no buffer is pending then it returns</span><br><span class="line">&#x2F;&#x2F; NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span><br><span class="line">&#x2F;&#x2F; information about the buffer is returned in BufferItem.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen,</span><br><span class="line">        uint64_t maxFrameNumber &#x3D; 0) &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>2、releaseBuffer</strong><br>releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; releaseBuffer releases a buffer slot from the consumer back to the</span><br><span class="line">&#x2F;&#x2F; BufferQueue.  This may be done while the buffer&#39;s contents are still</span><br><span class="line">&#x2F;&#x2F; being accessed.  The fence will signal when the buffer is no longer</span><br><span class="line">&#x2F;&#x2F; in use. frameNumber is used to indentify the exact buffer returned.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">virtual status_t releaseBuffer(int buf, uint64_t frameNumber,</span><br><span class="line">        EGLDisplay display, EGLSyncKHR fence,</span><br><span class="line">        const sp&lt;Fence&gt;&amp; releaseFence) &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-2、App（Java层）请求创建Surface过程"><a href="#4-2、App（Java层）请求创建Surface过程" class="headerlink" title="4.2、App（Java层）请求创建Surface过程"></a>4.2、App（Java层）请求创建Surface过程</h4><p>Activity创建过程以后再详细分析。直接从addToDisplay()分析。</p>
<h5 id="4-2-1、Session-addToDisplay-向WMS服务注册一个窗口对象；"><a href="#4-2-1、Session-addToDisplay-向WMS服务注册一个窗口对象；" class="headerlink" title="4.2.1、Session.addToDisplay()向WMS服务注册一个窗口对象；"></a>4.2.1、Session.addToDisplay()向WMS服务注册一个窗口对象；</h5><p>[Session.java]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        int viewVisibility, int displayId, Rect outContentInsets,</span><br><span class="line">        InputChannel outInputChannel) &#123;</span><br><span class="line">    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outInputChannel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。<br>在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。<br>[WindowState.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(TAG, <span class="string">&quot;Attaching &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; token=&quot;</span> + mToken</span><br><span class="line">        + <span class="string">&quot;, list=&quot;</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Session.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">&quot;First window added to &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;, creating SurfaceSession&quot;</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="string">&quot;  NEW SURFACE SESSION &quot;</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-2、SurfaceSession建立过程"><a href="#4-2-2、SurfaceSession建立过程" class="headerlink" title="4.2.2、SurfaceSession建立过程"></a>4.2.2、SurfaceSession建立过程</h5><p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p>
<p>客户端请求<br>[SurfaceSession.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。<br>[android_view_SurfaceSession.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。<br>是否似曾相识，就是前面最开始SurfaceFlinger_Test程序第一步：new SurfaceComposerClient的过程。<br>[SurfaceComposerClient.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。</p>
<p>服务端处理<br>在SurfaceFlinger服务端为应用程序创建交互的Client对象<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line"><span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(new Client(<span class="keyword">this</span>)</span>)</span>;</span><br><span class="line">status_t err = client-&gt;initCheck();</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    bclient = client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程"><a href="#4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程" class="headerlink" title="4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程"></a>4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.Ask.SurfaceFlinger.Create.Client.png" alt="enter image description here"></p>
<p>继续详细分析AppApp（C++层）请求创建SurfaceFlinger客户端(client)的过程</p>
<p>SurfaceComposerClient第一次强引用时，会执行onFirstRef()<br>[SurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步：获取”SurfaceFlinger”服务<br>ComposerService::getComposerService()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">ComposerService::getComposerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">&quot;ComposerService reconnected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ComposerService::getInstance()会调用connectLocked()获取”SurfaceFlinger”服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以前面instance.mComposerService其实返回的是”SurfaceFlinger”服务。<br>第二步：createConnection()<br>接下来就会调用”SurfaceFlinger”服务的createConnection()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    <span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(<span class="keyword">new</span> Client(<span class="keyword">this</span>))</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-4、APP申请创建Surface过程-Java层"><a href="#4-2-4、APP申请创建Surface过程-Java层" class="headerlink" title="4.2.4、APP申请创建Surface过程(Java层)"></a>4.2.4、APP申请创建Surface过程(Java层)</h5><p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowSurfaceController.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowStateAnimator.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>);</span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowSurfaceController.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowSurfaceController</span><span class="params">(SurfaceSession s,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags, WindowStateAnimator animator)</span> </span>&#123;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">    mSurfaceW = w;</span><br><span class="line">    mSurfaceH = h;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (animator.mWin.isChildWindow() &amp;&amp;</span><br><span class="line">            animator.mWin.mSubLayer &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            animator.mWin.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">                s, name, w, h, format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-4-1、APP申请创建Surface过程-C-层"><a href="#4-2-4-1、APP申请创建Surface过程-C-层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(C++层)"></a>4.2.4.1、APP申请创建Surface过程(C++层)</h6><p>SurfaceControl创建过程<br>[-&gt;SurfaceControl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_SurfaceControl.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">    jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line"><span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj))</span></span>;</span><br><span class="line">sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">        String8(name.c_str()), w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.Ask.SurfaceFlinger.CreateSurface.png" alt="enter image description here"></p>
<p>[-&gt;SurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">    PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;SurfaceComposerClient::createSurface error %s&quot;</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。<br>[ISurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Client.cpp]<br>MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">Client::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">status_t</span> <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer:<br>  [-&gt;ISurfaceComposerClient.h]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = <span class="number">0x00000000</span>,</span><br><span class="line">eFXSurfaceDim       = <span class="number">0x00020000</span>,</span><br><span class="line">eFXSurfaceMask      = <span class="number">0x000F0000</span></span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createNormalLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span></span>&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;createNormalLayer() failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.Ask.SurfaceFlinger.Create.Layer.png" alt="enter image description here"></p>
<p>第一次强引用Layer对象时，onFirstRef()函数被回调<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"><span class="comment">//创建BufferQueue对象</span></span><br><span class="line">BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">&quot;disabling triple buffering&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mFlinger-&gt;getDefaultDisplayDevice())</span></span>;</span><br><span class="line">updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的</p>
<h6 id="4-2-4-2、BufferQueue构造过程"><a href="#4-2-4-2、BufferQueue构造过程" class="headerlink" title="4.2.4.2、BufferQueue构造过程"></a>4.2.4.2、BufferQueue构造过程</h6><p>[-&gt;BufferQueue.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore(allocator))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">*outProducer = producer;</span><br><span class="line">*outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueCore.cpp]<br>所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueCore::BufferQueueCore(<span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :</span><br><span class="line">mAllocator(allocator),</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (allocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">composer</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    mAllocator = composer-&gt;createGraphicBufferAlloc();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;createGraphicBufferAlloc failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">        s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.App.SurfaceFlinger.BufferSlot.png" alt="enter image description here"></p>
<p>[-&gt;ISurfaceComposer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">virtual</span> sp&lt;IGraphicBufferAlloc&gt; <span class="title">createGraphicBufferAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferAlloc&gt; <span class="title">SurfaceFlinger::createGraphicBufferAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">sp&lt;GraphicBufferAlloc&gt; <span class="title">gba</span><span class="params">(<span class="keyword">new</span> GraphicBufferAlloc())</span></span>;</span><br><span class="line"><span class="keyword">return</span> gba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5、GraphicBufferAlloc构造过程"><a href="#4-2-5、GraphicBufferAlloc构造过程" class="headerlink" title="4.2.5、GraphicBufferAlloc构造过程"></a>4.2.5、<strong>GraphicBufferAlloc构造过程</strong></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\libs\gui\BufferQueueProducer.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;android::Fence&gt; *outFence, <span class="keyword">bool</span> async,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, <span class="keyword">uint32_t</span> format, <span class="keyword">uint32_t</span> usage)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line">        mConsumerName = mCore-&gt;mConsumerName;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: async=%s w=%u h=%u format=%#x, usage=%#x&quot;</span>,</span><br><span class="line">            async ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, width, height, format, usage);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> error;</span><br><span class="line">        BQ_LOGV(<span class="string">&quot;dequeueBuffer: allocating a new buffer for slot %d&quot;</span>, *outSlot);</span><br><span class="line">        <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">graphicBuffer</span><span class="params">(mCore-&gt;mAllocator-&gt;createGraphicBuffer(</span></span></span><br><span class="line"><span class="function"><span class="params">                    width, height, format, usage, &amp;error))</span></span>;</span><br><span class="line">     ......</span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: returning slot=%d/%&quot;</span> PRIu64 <span class="string">&quot; buf=%p flags=%#x&quot;</span>,</span><br><span class="line">            *outSlot,</span><br><span class="line">            mSlots[*outSlot].mFrameNumber,</span><br><span class="line">            mSlots[*outSlot].mGraphicBuffer-&gt;handle, returnFlags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;GraphicBufferAlloc.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">GraphicBufferAlloc::createGraphicBuffer</span><span class="params">(<span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> requestorName, <span class="keyword">status_t</span>* error)</span> </span>&#123;</span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">graphicBuffer</span><span class="params">(<span class="keyword">new</span> GraphicBuffer(</span></span></span><br><span class="line"><span class="function"><span class="params">        width, height, format, usage, <span class="built_in">std</span>::move(requestorName)))</span></span>;</span><br><span class="line"><span class="keyword">status_t</span> err = graphicBuffer-&gt;initCheck();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> graphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6、Gralloc模块打开过程-amp-amp-图形缓冲区创建过程"><a href="#4-2-6、Gralloc模块打开过程-amp-amp-图形缓冲区创建过程" class="headerlink" title="4.2.6、Gralloc模块打开过程 &amp;&amp; 图形缓冲区创建过程"></a>4.2.6、<strong>Gralloc模块打开过程 &amp;&amp; 图形缓冲区创建过程</strong></h5><p>[-&gt;GraphicBuffer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">    PixelFormat inFormat, <span class="keyword">uint32_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">: BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">  mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">width  =</span><br><span class="line">height =</span><br><span class="line">stride =</span><br><span class="line">format =</span><br><span class="line">usage  = <span class="number">0</span>;</span><br><span class="line">handle = <span class="literal">NULL</span>;</span><br><span class="line">mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,</span><br><span class="line">        <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">\android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\libs\ui\GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBuffer::initSize</span><span class="params">(<span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> reqUsage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    <span class="keyword">status_t</span> err = allocator.alloc(w, h, format, reqUsage, &amp;handle, &amp;stride);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width  = w;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height = h;</span><br><span class="line">        <span class="keyword">this</span>-&gt;format = format;</span><br><span class="line">        <span class="keyword">this</span>-&gt;usage  = reqUsage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\include\ui\GraphicBufferAllocator.h</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> GraphicBufferAllocator&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getInstance(); &#125;</span><br><span class="line"></span><br><span class="line">\android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\libs\ui\GraphicBufferAllocator.cpp</span><br><span class="line">GraphicBufferAllocator::GraphicBufferAllocator()</span><br><span class="line">    : mAllocDev(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;FATAL: can&#x27;t find the %s module&quot;</span>, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">        gralloc_open(<span class="keyword">module</span>, &amp;mAllocDev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="4-2-7、Android图形显示之硬件抽象层Gralloc"><a href="#4-2-7、Android图形显示之硬件抽象层Gralloc" class="headerlink" title="4.2.7、Android图形显示之硬件抽象层Gralloc"></a>4.2.7、Android图形显示之硬件抽象层Gralloc</h5><p>FrameBuffer驱动程序分析文中介绍了Linux系统下的显示驱动框架，每个显示屏被抽象为一个帧缓冲区，注册到FrameBuffer模块中，并在/dev/graphics目录下创建对应的fbX设备。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。用户空间的应用程序在使用帧缓冲区之间，首先要加载Gralloc模块，并且获得一个gralloc设备和一个fb设备。有了gralloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过gralloc设备来释放它，并且将它从地址空间中解除映射。</p>
<p>Gralloc模块实现源码位于：hardware/libhardware/modules/gralloc</p>
<p>├── Android.mk<br>├── framebuffer.cpp<br>├── gralloc.cpp<br>├── gralloc_priv.h<br>├── gr.h<br>└── mapper.cpp<br>Gralloc模块ID定义为：</p>
<blockquote>
<p> GRALLOC_HARDWARE_MODULE_ID “gralloc”</p>
</blockquote>
<p>同时定义了以HAL_MODULE_INFO_SYM为符号的类型为private_module_t的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\modules\gralloc\gralloc.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span></span><br><span class="line">        open: gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">    base: &#123;</span><br><span class="line">        common: &#123;</span><br><span class="line">            tag: HARDWARE_MODULE_TAG,</span><br><span class="line">            version_major: <span class="number">1</span>,</span><br><span class="line">            version_minor: <span class="number">0</span>,</span><br><span class="line">            id: GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">            name: <span class="string">&quot;Graphics Memory Allocator Module&quot;</span>,</span><br><span class="line">            author: <span class="string">&quot;The Android Open Source Project&quot;</span>,</span><br><span class="line">            methods: &amp;gralloc_module_methods</span><br><span class="line">        &#125;,</span><br><span class="line">        registerBuffer: gralloc_register_buffer,</span><br><span class="line">        unregisterBuffer: gralloc_unregister_buffer,</span><br><span class="line">        lock: gralloc_lock,</span><br><span class="line">        unlock: gralloc_unlock,</span><br><span class="line">    &#125;,</span><br><span class="line">    framebuffer: <span class="number">0</span>,</span><br><span class="line">    flags: <span class="number">0</span>,</span><br><span class="line">    numBuffers: <span class="number">0</span>,</span><br><span class="line">    bufferMask: <span class="number">0</span>,</span><br><span class="line">    lock: PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">    currentBuffer: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-7-1、数据结构定义"><a href="#4-2-7-1、数据结构定义" class="headerlink" title="4.2.7.1、数据结构定义"></a>4.2.7.1、数据结构定义</h6><p>在分析Gralloc模块之前，首先介绍Gralloc模块定义的一些数据结构。private_module_t用于描述Gralloc模块下的系统帧缓冲区信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/hardware/libhardware/include/hardware/fb.h</span><br><span class="line">/hardware/libhardware/modules/gralloc/gralloc_priv.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">gralloc_module_t</span> base;</span><br><span class="line">    <span class="keyword">private_handle_t</span>* framebuffer; <span class="comment">//指向系统帧缓冲区的句柄</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags; <span class="comment">//用来标志系统帧缓冲区是否支持双缓冲</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numBuffers;<span class="comment">//表示系统帧缓冲区包含有多少个图形缓冲区</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufferMask; <span class="comment">//记录系统帧缓冲区中的图形缓冲区的使用情况</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock; <span class="comment">//一个互斥锁，用来保护结构体private_module_t的并行访问</span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> currentBuffer; <span class="comment">//用来描述当前正在被渲染的图形缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> pmem_master;</span><br><span class="line">    <span class="keyword">void</span>* pmem_master_base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">info</span>;</span> <span class="comment">//保存设备显示屏的动态属性信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span> <span class="comment">////保存设备显示屏的固定属性信息</span></span><br><span class="line">    <span class="keyword">float</span> xdpi; <span class="comment">//描述设备显示屏在宽度</span></span><br><span class="line">    <span class="keyword">float</span> ydpi; <span class="comment">//描述设备显示屏在高度</span></span><br><span class="line">    <span class="keyword">float</span> fps; <span class="comment">//用来描述显示屏的刷新频率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>framebuffer_device_t用来描述系统帧缓冲区设备的信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/hardware/libhardware/include/hardware/fb.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">framebuffer_device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  flags;<span class="comment">//用来记录系统帧缓冲区的标志</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  width;<span class="comment">//用来描述设备显示屏的宽度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  height;<span class="comment">//用来描述设备显示屏的高度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       stride;<span class="comment">//用来描述设备显示屏的一行有多少个像素点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       format;<span class="comment">//用来描述系统帧缓冲区的像素格式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     xdpi;<span class="comment">//用来描述设备显示屏在宽度上的密度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     ydpi;<span class="comment">//用来描述设备显示屏在高度上的密度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     fps;<span class="comment">//用来描述设备显示屏的刷新频率</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       minSwapInterval;<span class="comment">//用来描述帧缓冲区交换前后两个图形缓冲区的最小时间间隔</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       maxSwapInterval;<span class="comment">//用来描述帧缓冲区交换前后两个图形缓冲区的最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> reserved[<span class="number">8</span>];<span class="comment">//保留</span></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(struct <span class="keyword">framebuffer_device_t</span>* window,<span class="keyword">int</span> interval);</span><br><span class="line">    <span class="comment">//用来设置帧缓冲区的更新区域</span></span><br><span class="line">    <span class="keyword">int</span> (*setUpdateRect)(struct <span class="keyword">framebuffer_device_t</span>* window,<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line">    <span class="comment">//用来将图形缓冲区buffer的内容渲染到帧缓冲区中去</span></span><br><span class="line">    <span class="keyword">int</span> (*post)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer);</span><br><span class="line">    <span class="comment">//用来通知fb设备，图形缓冲区的组合工作已经完成</span></span><br><span class="line">    <span class="keyword">int</span> (*compositionComplete)(struct <span class="keyword">framebuffer_device_t</span>* dev);</span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line">    <span class="keyword">int</span> (*enableScreen)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">int</span> enable);</span><br><span class="line">    <span class="comment">//保留</span></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">6</span>];</span><br><span class="line">&#125; <span class="keyword">framebuffer_device_t</span>;</span><br></pre></td></tr></table></figure>

<p>gralloc_module_t用于描述gralloc模块信息<br>alloc_device_t用于描述gralloc设备的信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">\android<span class="number">-5.0</span><span class="number">.2</span>\hardware\libhardware\include\hardware\gralloc.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gralloc_module_t</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> <span class="title">common</span>;</span></span><br><span class="line">　　<span class="comment">//映射一块图形缓冲区到一个进程的地址空间去</span></span><br><span class="line">　　<span class="keyword">int</span> (*registerBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">　　<span class="comment">//取消映射一块图形缓冲区到一个进程的地址空间去</span></span><br><span class="line">　　<span class="keyword">int</span> (*unregisterBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">　　<span class="comment">//锁定一个指定的图形缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> (*lock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,<span class="keyword">void</span>** vaddr);</span><br><span class="line">    <span class="comment">//解锁一个指定的图形缓冲区</span></span><br><span class="line">　　<span class="keyword">int</span> (*unlock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    <span class="keyword">int</span> (*perform)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">int</span> operation, ... );</span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">7</span>];</span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alloc_device_t用于描述gralloc设备的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="comment">//用于分配一块图形缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> (*alloc)(struct <span class="keyword">alloc_device_t</span>* dev,<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,<span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);</span><br><span class="line">    <span class="comment">//用于释放指定的图形缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(struct <span class="keyword">alloc_device_t</span>* dev,<span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">alloc_device_t</span> *dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">7</span>];</span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="4-2-7-2、Fb设备打开过程"><a href="#4-2-7-2、Fb设备打开过程" class="headerlink" title="4.2.7.2、Fb设备打开过程"></a>4.2.7.2、Fb设备打开过程</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span><br><span class="line"><span class="comment">// Load and prepare the FB HAL, which uses the gralloc module.  Sets mFbDev.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HWComposer::loadFbHalModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;%s module not found&quot;</span>, GRALLOC_HARDWARE_MODULE_ID);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> framebuffer_open(<span class="keyword">module</span>, &amp;mFbDev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于我们禁用了HWComposer，所以看看framebuffer_open</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\include\hardware\fb.h</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">framebuffer_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">framebuffer_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>,GRALLOC_HARDWARE_FB0, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>module指向的是一个用来描述Gralloc模块的hw_module_t结构体，前面提到，它的成员变量methods所指向的一个hw_module_methods_t结构体的成员函数open指向了Gralloc模块中的函数gralloc_device_open</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\modules\gralloc\gralloc.cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gralloc_device_open函数即可以打开fb设备，也可以用于打开gpu设备，这里根据设备名来区分打开的设备，对应fb设备，则调用fb_device_open函数来完成设备打开操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\modules\gralloc\framebuffer.cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="comment">//判断打开的是fb设备</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;</span><br><span class="line">        <span class="keyword">alloc_device_t</span>* gralloc_device;</span><br><span class="line">        <span class="comment">//打开gpu设备</span></span><br><span class="line">        status = gralloc_open(<span class="keyword">module</span>, &amp;gralloc_device);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        <span class="comment">//创建一个fb_context_t对象，用来描述fb设备上下文</span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        <span class="comment">//初始化fb_context_t对象</span></span><br><span class="line">        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">        <span class="comment">//注册fb设备的操作函数</span></span><br><span class="line">        dev-&gt;device.common.close = fb_close; </span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;</span><br><span class="line">        dev-&gt;device.post            = fb_post;</span><br><span class="line">        dev-&gt;device.setUpdateRect = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)<span class="keyword">module</span>;</span><br><span class="line">        <span class="comment">//将fb映射到当前进程地址空间</span></span><br><span class="line">        status = mapFrameBuffer(m);</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">int</span> format = (m-&gt;info.bits_per_pixel == <span class="number">32</span>)</span><br><span class="line">                         ? HAL_PIXEL_FORMAT_RGBX_8888</span><br><span class="line">                         : HAL_PIXEL_FORMAT_RGB_565;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = format;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line">            *device = &amp;dev-&gt;device.common;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFrameBuffer</span><span class="params">(struct <span class="keyword">private_module_t</span>* <span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = mapFrameBufferLocked(<span class="keyword">module</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-2-8、GraphicBuffer图形缓冲区创建过程"><a href="#4-2-8、GraphicBuffer图形缓冲区创建过程" class="headerlink" title="4.2.8、GraphicBuffer图形缓冲区创建过程"></a>4.2.8、GraphicBuffer图形缓冲区创建过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">frameworks\native\libs\ui\GraphicBufferAllocator.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBufferAllocator::alloc</span><span class="params">(<span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int32_t</span>* stride)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// make sure to not allocate a N x 0 or 0 x N buffer, since this is</span></span><br><span class="line">    <span class="comment">// allowed from an API stand-point allocate a 1x1 buffer instead.</span></span><br><span class="line">    <span class="keyword">if</span> (!w || !h)</span><br><span class="line">        w = h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have a h/w allocator and h/w buffer is requested</span></span><br><span class="line">    <span class="keyword">status_t</span> err; </span><br><span class="line">    </span><br><span class="line">    err = mAllocDev-&gt;alloc(mAllocDev, w, h, format, usage, handle, stride);</span><br><span class="line"></span><br><span class="line">    ALOGW_IF(err, <span class="string">&quot;alloc(%u, %u, %d, %08x, ...) failed %d (%s)&quot;</span>,</span><br><span class="line">            w, h, format, usage, err, strerror(-err));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        Mutex::Autolock _l(sLock);</span><br><span class="line">        KeyedVector&lt;buffer_handle_t, alloc_rec_t&gt;&amp; list(sAllocList);</span><br><span class="line">        <span class="keyword">int</span> bpp = bytesPerPixel(format);</span><br><span class="line">        <span class="keyword">if</span> (bpp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// probably a HAL custom format. in any case, we don&#x27;t know</span></span><br><span class="line">            <span class="comment">// what its pixel size is.</span></span><br><span class="line">            bpp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">alloc_rec_t</span> rec;</span><br><span class="line">        rec.w = w;</span><br><span class="line">        rec.h = h;</span><br><span class="line">        rec.s = *stride;</span><br><span class="line">        rec.format = format;</span><br><span class="line">        rec.usage = usage;</span><br><span class="line">        rec.size = h * stride[<span class="number">0</span>] * bpp;</span><br><span class="line">        <span class="built_in">list</span>.add(*handle, rec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hardware\libhardware\modules\gralloc\gralloc.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,<span class="comment">//gpu设备描述符</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> w, <span class="comment">//图像宽度</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> h, <span class="comment">//图像高度</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> format, <span class="comment">//图形格式</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> usage, <span class="comment">//图形缓冲区的使用类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="comment">//即将被分配的图形缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>* pStride)</span><span class="comment">//分配的图形缓冲区一行包含有多少个像素点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHandle || !pStride)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">size_t</span> size, stride;</span><br><span class="line">    <span class="keyword">int</span> align = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> bpp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBX_8888:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_BGRA_8888:</span><br><span class="line">        <span class="comment">//一个像素需要使用32位来表示，即4个字节</span></span><br><span class="line">            bpp = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_888:</span><br><span class="line">        <span class="comment">//一个像素需要使用24位来描述，即3个字节</span></span><br><span class="line">            bpp = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGB_565:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_5551:</span><br><span class="line">        <span class="keyword">case</span> HAL_PIXEL_FORMAT_RGBA_4444:</span><br><span class="line">        <span class="comment">//一个像需要使用16位来描述，即2个字节</span></span><br><span class="line">            bpp = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//w表示要分配的图形缓冲区所保存的图像的宽度，w*bpp就可以得到保存一行像素所需要使用的字节数，并且对齐到4个字节边界</span></span><br><span class="line">    <span class="keyword">size_t</span> bpr = (w*bpp + (align<span class="number">-1</span>)) &amp; ~(align<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//h表示要分配的图形缓冲区所保存的图像的高度，bpr* h就可以得到保存整个图像所需要使用的字节数</span></span><br><span class="line">    size = bpr * h;</span><br><span class="line">    <span class="comment">//要分配的图形缓冲区一行包含有多少个像素点</span></span><br><span class="line">    stride = bpr / bpp;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//要分配的图形缓冲区一行包含有多少个像素点</span></span><br><span class="line">    <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_HW_FB) &#123;</span><br><span class="line">        <span class="comment">//系统帧缓冲区中分配图形缓冲区</span></span><br><span class="line">        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从内存中分配图形缓冲区</span></span><br><span class="line">        err = gralloc_alloc_buffer(dev, size, usage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    *pStride = stride;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-2-8-1、系统帧缓冲区分配Buffer"><a href="#4-2-8-1、系统帧缓冲区分配Buffer" class="headerlink" title="4.2.8.1、系统帧缓冲区分配Buffer"></a>4.2.8.1、系统帧缓冲区分配Buffer</h6><p>gralloc_alloc_framebuffer函数用于从FrameBuffer中分配图形缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">android<span class="number">-5.0</span><span class="number">.2</span>\hardware\libhardware\modules\gralloc\gralloc.cpp</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);</span><br><span class="line">    pthread_mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">为了保证分配过程中线程安全，这里使用了<span class="keyword">private_module_t</span>中的lock来同步多线程。</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_alloc_framebuffer_locked</span><span class="params">(<span class="keyword">alloc_device_t</span>* dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> size, <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据alloc_device_t查找到系统帧缓冲区描述体</span></span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">    <span class="comment">/** *从系统帧缓冲区分配图形缓冲区之前，首先要对系统帧缓冲区进行过初始化。mapFrameBufferLocked函数用于系统帧缓冲区的初始化，在系统帧缓冲区初始化时，用private_ha*ndle_t来描述整个系统帧缓冲区信息，并保持到private_module_t的成员framebuffer中，如果该成员变量framebuffer为空，说明系统帧缓冲区还为被初始化。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;framebuffer == <span class="literal">NULL</span>) &#123;<span class="comment">//系统帧缓冲区还未初始化</span></span><br><span class="line">        <span class="comment">//初始化系统帧缓冲区，映射到当前进程的虚拟地址空间来</span></span><br><span class="line">        <span class="keyword">int</span> err = mapFrameBufferLocked(m);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到系统帧缓冲区的使用情况</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bufferMask = m-&gt;bufferMask;</span><br><span class="line">    <span class="comment">//系统帧缓冲区可以划分为多少个图形缓冲区来使用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> numBuffers = m-&gt;numBuffers;</span><br><span class="line">    <span class="comment">//设备显示屏一屏内容所占用的内存的大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">    <span class="comment">//如果系统帧缓冲区只有一个图形缓冲区大小，即变量numBuffers的值等于1，那么这个图形缓冲区就始终用作系统主图形缓冲区来使用</span></span><br><span class="line">    <span class="keyword">if</span> (numBuffers == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//不能够在系统帧缓冲区中分配图形缓冲区，从内存中来分配图形缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> newUsage = (usage &amp; ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;</span><br><span class="line">        <span class="keyword">return</span> gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//系统帧缓冲区中的图形缓冲区全部都分配出去了</span></span><br><span class="line">    <span class="keyword">if</span> (bufferMask &gt;= ((<span class="number">1L</span>U&lt;&lt;numBuffers)<span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向系统帧缓冲区的基地址</span></span><br><span class="line">    <span class="keyword">intptr_t</span> vaddr = <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    <span class="comment">//创建一个private_handle_t结构体hnd来描述这个即将要分配出去的图形缓冲区</span></span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(dup(m-&gt;framebuffer-&gt;fd), size,<span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER);</span><br><span class="line">    <span class="comment">//从bufferMask中查找空闲的图形缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span> ; i&lt;numBuffers ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bufferMask &amp; (<span class="number">1L</span>U&lt;&lt;i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;bufferMask |= (<span class="number">1L</span>U&lt;&lt;i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次从系统帧缓冲区中分配出去的图形缓冲区的大小都是刚好等于显示屏一屏内容大小的</span></span><br><span class="line">        vaddr += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配出去的图形缓冲区的开始地址保存在创建的private_handle_t结构体hnd的成员变量base中</span></span><br><span class="line">    hnd-&gt;base = vaddr;</span><br><span class="line">    <span class="comment">//分配出去的图形缓冲区的起始地址相对于系统帧缓冲区的基地址的偏移量</span></span><br><span class="line">    hnd-&gt;offset = vaddr - <span class="keyword">intptr_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    *pHandle = hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-2-8-2、内存中分配Buffer"><a href="#4-2-8-2、内存中分配Buffer" class="headerlink" title="4.2.8.2、内存中分配Buffer"></a>4.2.8.2、内存中分配Buffer</h6><p>该函数首先创建一块名为”gralloc-buffer”的匿名共享内存，并根据匿名共享内存的信息来构造一个private_handle_t对象，该对象用来描述分配的图形缓冲区，然后将创建的匿名共享内存映射到当前进程的虚拟地址空间。在系统帧缓冲区分配图形buffer时并没有执行地址空间映射，而这里却需要执行映射过程，为什么呢？这是因为在执行mapFrameBufferLocked函数初始化系统帧缓冲区时，已经将系统的整个帧缓冲区映射到当前进程地址空间中了，在系统帧缓冲区中分配buffer就不在需要重复映射了，而在内存中分配buffer就不一样，内存中分配的buffer是一块匿名共享内存，该匿名共享内存并没有映射到当前进程地址空间，因此这里就需要完成这一映射过程，从而为以后应用程序进程直接访问这块buffer做好准备工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapBuffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">private_handle_t</span>* hnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">    <span class="keyword">return</span> gralloc_map(<span class="keyword">module</span>, hnd, &amp;vaddr);</span><br><span class="line">&#125;</span><br><span class="line">gralloc_map将参数hnd所描述的一个图形缓冲区映射到当前进程的地址空间来。</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_map</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,<span class="keyword">buffer_handle_t</span> handle,<span class="keyword">void</span>** vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;</span><br><span class="line">    <span class="comment">//如果当前buffer不是从系统帧缓冲区中分配的</span></span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER)) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = hnd-&gt;size;</span><br><span class="line">        <span class="keyword">void</span>* mappedAddress = mmap(<span class="number">0</span>, size,PROT_READ|PROT_WRITE, MAP_SHARED, hnd-&gt;fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mappedAddress == MAP_FAILED) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Could not mmap %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> -errno;</span><br><span class="line">        &#125;</span><br><span class="line">        hnd-&gt;base = <span class="keyword">intptr_t</span>(mappedAddress) + hnd-&gt;offset;</span><br><span class="line">    &#125;</span><br><span class="line">    *vaddr = (<span class="keyword">void</span>*)hnd-&gt;base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化系统帧缓冲区的时候，已经将系统帧缓冲区映射到进程地址空间了，因此如果发现要注册的图形缓冲区是在系统帧缓冲区分配的，那么就不需要再执行映射图形缓冲区的操作了。</p>
<h5 id="4-2-9、生产者Producer构造过程"><a href="#4-2-9、生产者Producer构造过程" class="headerlink" title="4.2.9、生产者Producer构造过程"></a>4.2.9、生产者Producer构造过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br></pre></td></tr></table></figure>
<p>实例化BufferQueueProducer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueProducer::BufferQueueProducer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName(),</span><br><span class="line">    mStickyTransform(<span class="number">0</span>),</span><br><span class="line">    mLastQueueBufferFence(Fence::NO_FENCE),</span><br><span class="line">    mCallbackMutex(),</span><br><span class="line">    mNextCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCurrentCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCallbackCondition(),</span><br><span class="line">    mDequeueTimeout(<span class="number">-1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-10、消费者Consumer构造过程"><a href="#4-2-10、消费者Consumer构造过程" class="headerlink" title="4.2.10、消费者Consumer构造过程"></a>4.2.10、消费者Consumer构造过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br></pre></td></tr></table></figure>
<p>实例化BufferQueueConsumer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueConsumer::BufferQueueConsumer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="SurfaceFlinger设置监听"><a href="#SurfaceFlinger设置监听" class="headerlink" title="SurfaceFlinger设置监听"></a>SurfaceFlinger设置监听</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.Ask.SurfaceFlinger.ConsumeLisener.onFrameAvailable.png" alt="enter image description here"></p>
<h5 id="4-2-11、应用程序本地窗口Surface创建过程"><a href="#4-2-11、应用程序本地窗口Surface创建过程" class="headerlink" title="4.2.11、应用程序本地窗口Surface创建过程"></a>4.2.11、应用程序本地窗口Surface创建过程</h5><p>从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？</p>
<p>为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。<br>[-&gt;SurfaceControl.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::getSurface</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mutex::Autolock _l(mLock);</span><br><span class="line"><span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn&#x27;t matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">: mGraphicBufferProducer(bufferProducer),</span><br><span class="line">  mCrop(Rect::EMPTY_RECT),</span><br><span class="line">  mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">  mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">  mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">  mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">  mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">  mNextFrameNumber(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">ANativeWindow::query            = hook_query;</span><br><span class="line">ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mReqWidth = <span class="number">0</span>;</span><br><span class="line">mReqHeight = <span class="number">0</span>;</span><br><span class="line">mReqFormat = <span class="number">0</span>;</span><br><span class="line">mReqUsage = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。</p>
<h4 id="4-3、APP申请-lock-Buffer的过程"><a href="#4-3、APP申请-lock-Buffer的过程" class="headerlink" title="4.3、APP申请(lock)Buffer的过程"></a>4.3、APP申请(lock)Buffer的过程</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.SurfaceFlinger.lock.unlockpost.png" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ......</span><br><span class="line">    &#125; ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看Surface的lockCanvas方法：<br>[-&gt;Surface.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mCanvas 变量直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    checkNotReleasedLocked();</span><br><span class="line">    ......</span><br><span class="line">    mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取java层的Surface保存的long型句柄</span></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取java层dirty Rect的位置大小信息</span></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">    dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">    dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">    dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">    dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line"> <span class="comment">//调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?</span><br><span class="line">                                     kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">SkBitmap bitmap;</span><br><span class="line"><span class="comment">//创建一个SkBitmap </span></span><br><span class="line"><span class="comment">//图形缓冲区每一行像素大小</span></span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">bitmap.setInfo(info, bpr);</span><br><span class="line"><span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    bitmap.setPixels(outBuffer.bits);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">    bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">    nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">            dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</span><br><span class="line">lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line"><span class="keyword">return</span> (jlong) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑主要如下：<br>       1）获取java层dirty 的Rect大小和位置信息；<br>       2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer；<br>       3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象；<br>       4）将剪裁位置大小信息赋给java层Canvas对象。</p>
<h5 id="4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程"><a href="#4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程" class="headerlink" title="4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程"></a>4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</h5><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。<br>[-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;dequeueBuffer failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backBufferSlot</span><span class="params">(getSlotFromBufferLocked(backBuffer.get()))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">copyback</span><span class="params">(oldDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can&#x27;t copy-back anything, modify the user&#x27;s dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有：<br>       1）调用connect函数完成一些初始化；<br>       2）调用dequeueBuffer函数，申请图形缓冲区；<br>       3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。<br>       [-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt;&amp; <span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p>
<h4 id="4-4、APP提交-unlockAndPost-Buffer的过程"><a href="#4-4、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="4.4、APP提交(unlockAndPost)Buffer的过程"></a>4.4、APP提交(unlockAndPost)Buffer的过程</h4><p>Surface绘制完毕后，unlockCanvasAndPost操作。<br>[-&gt;android_view_Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   这里也比较简单，核心也是分两步：<br>       1）解锁图形缓冲区，和前面的lockAsync成对出现；<br>       2）queueBuffer去归还图形缓冲区；<br>        所以我们还是重点分析第二步，查看queueBuffer的实现：<br>       [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。<br>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>       1）从传入的QueueBufferInput ，解析填充一些变量；<br>       2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断；<br>       3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem；<br>       4）将BufferItem塞进mCore的mQueue队列，依照指定规则；<br>       5）然后通知SurfaceFlinger去消费。<br>Folw：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App.WMS.SurfaceFlinger.All.Flow.png" alt="enter image description here"></p>
<h4 id="（五）、通知SF消费合成"><a href="#（五）、通知SF消费合成" class="headerlink" title="（五）、通知SF消费合成"></a>（五）、通知SF消费合成</h4><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。<br>listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现：<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">&#123; <span class="comment">// Autolock scope</span></span><br><span class="line">    ......</span><br><span class="line">    mQueueItems.push_back(item);</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">    mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">    mQueueItemCondition.broadcast();</span><br><span class="line">&#125;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用MessageQueue的invalidate函数：<br>[MessageQueue.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.vsync.surfaceflinger.png" alt="enter image description here"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.sf_use_vsync.png" alt="enter image description here"></p>
<p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX;</span><br><span class="line">        ATRACE_INT(<span class="string">&quot;FrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">        <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">            signalLayerUpdate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">        refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">        refreshNeeded |= mRepaintEverything;</span><br><span class="line">        <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">            <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">            <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">            <span class="comment">// repaint</span></span><br><span class="line">            signalRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.handle_vsync.png" alt="enter image description here"></p>
<p>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">    mHadClientComposition = mHadClientComposition ||</span><br><span class="line">            mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    layer-&gt;releasePendingBuffer();</span><br><span class="line">&#125;</span><br><span class="line">mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要看下下面几个函数。<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br></pre></td></tr></table></figure>

<h5 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h5><p>我们先来看第一个函数preComposition()<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。<br>记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; lbc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">// add this layer to the current state list</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(IInterface::asBinder(gbc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach this layer to the client</span></span><br><span class="line">client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。<br>回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。</p>
<h4 id="1-1、每个Layer的onFrameAvailable函数"><a href="#1-1、每个Layer的onFrameAvailable函数" class="headerlink" title="1.1、每个Layer的onFrameAvailable函数"></a>1.1、每个Layer的onFrameAvailable函数</h4><p>onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Layer::onPreComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged || mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。<br>在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。<br>SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数<br>最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理<br>handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。</p>
<h4 id="1-2、绘制流程"><a href="#1-2、绘制流程" class="headerlink" title="1.2、绘制流程"></a>1.2、绘制流程</h4><p>用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。</p>
<h5 id="二、handleTransaction-handPageFlip更新Layer对象"><a href="#二、handleTransaction-handPageFlip更新Layer对象" class="headerlink" title="二、handleTransaction handPageFlip更新Layer对象"></a>二、handleTransaction handPageFlip更新Layer对象</h5><p>在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。</p>
<h4 id="2-1、handleTransaction函数"><a href="#2-1、handleTransaction函数" class="headerlink" title="2.1、handleTransaction函数"></a>2.1、handleTransaction函数</h4><p>handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数<br>handleTransactionLocked。<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransaction</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">Mutex::Autolock _l(mStateLock);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInTransaction = now;</span><br><span class="line"></span><br><span class="line">transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">handleTransactionLocked(transactionFlags);</span><br><span class="line"></span><br><span class="line">mLastTransactionTime = systemTime() - now;</span><br><span class="line">mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">invalidateHwcGeometry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。<br>handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。</p>
<h4 id="2-2、Layer的doTransaction函数"><a href="#2-2、Layer的doTransaction函数" class="headerlink" title="2.2、Layer的doTransaction函数"></a>2.2、Layer的doTransaction函数</h4><p>下面是Layer的doTransaction函数代码<br>[Layer.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">pushPendingState();<span class="comment">//上次绘制的State对象  </span></span><br><span class="line">Layer::State c = getCurrentState();<span class="comment">//当前使用的State对象 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                         (c.requested.h != s.requested.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">    <span class="comment">// the size changed, we need to ask our client to request a new buffer</span></span><br><span class="line">    <span class="comment">//如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸</span></span><br><span class="line">    <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">    <span class="comment">// a buffer, it&#x27;ll get the new size.</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">            c.requested.w, c.requested.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">        (c.requested.h != c.active.h);</span><br><span class="line"><span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resizePending &amp;&amp; mSidebandStream == NULL) &#123;</span><br><span class="line">    <span class="comment">//如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小  </span></span><br><span class="line">        flags |= eDontUpdateGeometryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有eDontUpdateGeometryState标志，更新active的值为request  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">    <span class="keyword">if</span> (mFreezePositionUpdates) &#123;</span><br><span class="line">        <span class="keyword">float</span> tx = c.active.transform.tx();</span><br><span class="line">        <span class="keyword">float</span> ty = c.active.transform.ty();</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">        c.active.transform.set(tx, ty);</span><br><span class="line">        editCurrentState.active = c.active;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editCurrentState.active = editCurrentState.requested;</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前state的active和以前的State的active不等，设置更新标志  </span></span><br><span class="line"><span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前state的sequence和以前state的sequence不等，设置更新标志</span></span><br><span class="line"><span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t type = c.active.transform.getType();</span><br><span class="line">    mNeedsFiltering = (!c.active.transform.preserveRects() ||</span><br><span class="line">            (type &gt;= Transform::SCALE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layer is hidden, signal and clear out all local sync points so</span></span><br><span class="line"><span class="comment">// that transactions for layers depending on this layer&#x27;s frames becoming</span></span><br><span class="line"><span class="comment">// visible are not blocked</span></span><br><span class="line"><span class="keyword">if</span> (c.flags &amp; layer_state_t::eLayerHidden) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; point : mLocalSyncPoints) &#123;</span><br><span class="line">        point-&gt;setFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mLocalSyncPoints.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">commitTransaction(c);</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。<br>Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。<br>State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。<br>State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。<br>layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。<br>sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。<br>doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::commitTransaction</span><span class="params">(<span class="keyword">const</span> State&amp; stateToCommit)</span> </span>&#123;</span><br><span class="line">mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3、handleTransactionLocked函数"><a href="#2-3、handleTransactionLocked函数" class="headerlink" title="2.3、handleTransactionLocked函数"></a>2.3、handleTransactionLocked函数</h5><p>下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析</p>
<p>2.3.1 处理Layer的事务<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">currentLayers</span><span class="params">(mCurrentState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify all layers of available frames</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    currentLayers[i]-&gt;notifyAvailableFrames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">            mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象<br>这里用两个变量的目的是和Layer中使用两个变量是一样的。<br>上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true</p>
<h5 id="2-3-2、处理显示设备的变化"><a href="#2-3-2、处理显示设备的变化" class="headerlink" title="2.3.2、处理显示设备的变化"></a>2.3.2、处理显示设备的变化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="comment">// here we take advantage of Vector&#x27;s copy-on-write semantics to</span></span><br><span class="line">    <span class="comment">// improve performance by skipping the transaction entirely when</span></span><br><span class="line">    <span class="comment">// know that the lists are identical</span></span><br><span class="line">    const KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    const KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">              <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the displays that were removed</span></span><br><span class="line">        <span class="comment">// (ie: in drawing state but not in current state)</span></span><br><span class="line">        <span class="comment">// also handle displays that changed</span></span><br><span class="line">        <span class="comment">// (ie: displays that are in both lists)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;dc ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (!draw[i].isMainDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Call makeCurrent() on the primary display so we can</span></span><br><span class="line">                    <span class="comment">// be sure that nothing associated with this display</span></span><br><span class="line">                    <span class="comment">// is current.</span></span><br><span class="line">                    <span class="function"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">defaultDisplay</span><span class="params">(getDefaultDisplayDevice())</span></span>;</span><br><span class="line">                    defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">                    <span class="function">sp&lt;DisplayDevice&gt; <span class="title">hw</span><span class="params">(getDisplayDevice(draw.keyAt(i)))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    <span class="keyword">if</span> (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(draw[i].type, <span class="literal">false</span>);</span><br><span class="line">                    mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;trying to remove the main display&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// this display is in both lists. see if something changed.</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="function"><span class="keyword">const</span> wp&lt;IBinder&gt;&amp; <span class="title">display</span><span class="params">(curr.keyAt(j))</span></span>;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    <span class="function">sp&lt;DisplayDevice&gt; <span class="title">hw</span><span class="params">(getDisplayDevice(display))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--; i--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt; <span class="title">disp</span><span class="params">(getDisplayDevice(display))</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation)</span><br><span class="line">                            || (state.viewport != draw[i].viewport)</span><br><span class="line">                            || (state.frame != draw[i].frame))</span><br><span class="line">                    &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation,</span><br><span class="line">                                state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find displays that were added</span></span><br><span class="line">        <span class="comment">// (ie: in current state but not in drawing state)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;cc ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer,</span><br><span class="line">                        <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int32_t</span> hwcDisplayId = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Virtual displays without a surface are dormant:</span></span><br><span class="line">                    <span class="comment">// they have external state (layer stack, projection,</span></span><br><span class="line">                    <span class="comment">// etc.) but no internal state (i.e. a DisplayDevice).</span></span><br><span class="line">                    <span class="keyword">if</span> (state.surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">                        DisplayUtils* displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                        <span class="keyword">int</span> status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">&quot;Unable to query width (%d)&quot;</span>, status);</span><br><span class="line">                        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">                        status = state.surface-&gt;query(</span><br><span class="line">                            NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                            <span class="string">&quot;Unable to query height (%d)&quot;</span>, status);</span><br><span class="line">                        <span class="keyword">if</span> (MAX_VIRTUAL_DISPLAY_DIMENSION == <span class="number">0</span> ||</span><br><span class="line">                            (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp;</span><br><span class="line">                             height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> usage = <span class="number">0</span>;</span><br><span class="line">                            status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage);</span><br><span class="line">                            ALOGW_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">&quot;Unable to query usage (%d)&quot;</span>, status);</span><br><span class="line">                            <span class="keyword">if</span> ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                  displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface,</span><br><span class="line">                                dispSurface, producer, bqProducer, bqConsumer,</span><br><span class="line">                                state.displayName, state.isSecure, state.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface!=<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="string">&quot;adding a supported display, but rendering &quot;</span></span><br><span class="line">                            <span class="string">&quot;surface is provided (%p), ignoring it&quot;</span>,</span><br><span class="line">                            state.surface.get());</span><br><span class="line">                    hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                    <span class="comment">// for supported (by hwc) displays we provide our</span></span><br><span class="line">                    <span class="comment">// own rendering surface</span></span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(*mHwc, state.type,</span><br><span class="line">                            bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">const</span> wp&lt;IBinder&gt;&amp; <span class="title">display</span><span class="params">(curr.keyAt(i))</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">NULL</span> &amp;&amp; producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                            state.type, hwcDisplayId,</span><br><span class="line">                            mHwc-&gt;getFormat(hwcDisplayId), state.isSecure,</span><br><span class="line">                            display, dispSurface, producer,</span><br><span class="line">                            mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">                    hw-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    hw-&gt;setProjection(state.orientation,</span><br><span class="line">                            state.viewport, state.frame);</span><br><span class="line">                    hw-&gt;setDisplayName(state.displayName);</span><br><span class="line">                    <span class="comment">// When a new display device is added update the active</span></span><br><span class="line">                    <span class="comment">// config by querying HWC otherwise the default config</span></span><br><span class="line">                    <span class="comment">// (config 0) will be used.</span></span><br><span class="line">                    <span class="keyword">if</span> (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp;</span><br><span class="line">                            hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">                        <span class="keyword">int</span> activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId);</span><br><span class="line">                        <span class="keyword">if</span> (activeConfig &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            hw-&gt;setActiveConfig(activeConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.add(display, hw);</span><br><span class="line">                    <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hwcDisplayId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId,</span><br><span class="line">                                    hw-&gt;getWidth(), hw-&gt;getHeight(),</span><br><span class="line">                                    hw-&gt;getFormat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是处理显示设备的变化，分成3种情况：<br>1.显示设备减少了，需要把显示设备对应的DisplayDevice移除<br>2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性<br>3.显示设备增加了，创建新的DisplayDevice加入系统中。</p>
<h5 id="2-3-3、设置TransfromHit"><a href="#2-3-3、设置TransfromHit" class="headerlink" title="2.3.3、设置TransfromHit"></a>2.3.3、设置TransfromHit</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we rely on the fact that layers are sorted by</span></span><br><span class="line">        <span class="comment">// layerStack first (so we don&#x27;t have to traverse the list</span></span><br><span class="line">        <span class="comment">// of displays for every layer).</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> layerStack = layer-&gt;getDrawingState().layerStack;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || currentlayerStack != layerStack) &#123;</span><br><span class="line">            currentlayerStack = layerStack;</span><br><span class="line">            <span class="comment">// figure out if this layerstack is mirrored</span></span><br><span class="line">            <span class="comment">// (more than one display) if so, pick the default display,</span></span><br><span class="line">            <span class="comment">// if not, pick the only display it&#x27;s on.</span></span><br><span class="line">            disp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (hw-&gt;getLayerStack() == currentlayerStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        disp = hw;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disp = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> TEMPORARY FIX ONLY. Real fix should cause layers to</span></span><br><span class="line">            <span class="comment">// redraw after transform hint changes. See bug 8508397.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// could be null when this layer is using a layerStack</span></span><br><span class="line">            <span class="comment">// that is not visible on any display. Also can occur at</span></span><br><span class="line">            <span class="comment">// screen off/on times.</span></span><br><span class="line">            disp = getDefaultDisplayDevice();</span><br><span class="line">        &#125;</span><br><span class="line">        layer-&gt;updateTransformHint(disp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。</p>
<h5 id="2-3-4、处理Layer增加情况"><a href="#2-3-4、处理Layer增加情况" class="headerlink" title="2.3.4、处理Layer增加情况"></a>2.3.4、处理Layer增加情况</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform our own transaction if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">    <span class="comment">// layers have been added</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some layers might have been removed, so</span></span><br><span class="line"><span class="comment">// we need to update the regions they&#x27;re exposing.</span></span><br><span class="line"><span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">            <span class="comment">//       compute the actual visible region</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">s</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">            Region visibleReg = s.active.transform.transform(</span><br><span class="line">                    Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">            invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。</p>
<h5 id="2-3-5、设置mDrawingState"><a href="#2-3-5、设置mDrawingState" class="headerlink" title="2.3.5、设置mDrawingState"></a>2.3.5、设置mDrawingState</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitTransaction();</span><br><span class="line">updateCursorAsync();</span><br></pre></td></tr></table></figure>

<p>调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。</p>
<h5 id="2-3-6-小结"><a href="#2-3-6-小结" class="headerlink" title="2.3.6 小结"></a>2.3.6 小结</h5><p>handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。</p>
<h4 id="2-4、handlePageFlip函数"><a href="#2-4、handlePageFlip函数" class="headerlink" title="2.4、handlePageFlip函数"></a>2.4、handlePageFlip函数</h4><p>handlePageFlip函数代码如下：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Region dirtyRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line"><span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line"><span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line"><span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line"><span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line"><span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line"><span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line"><span class="comment">// Display is now waiting on Layer 1&#x27;s frame, which is behind layer 0&#x27;s</span></span><br><span class="line"><span class="comment">// second frame. But layer 0&#x27;s second frame could be waiting on display.</span></span><br><span class="line">Vector&lt;Layer*&gt; layersWithQueuedFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layers.size(); i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">        frameQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">            layersWithQueuedFrames.push_back(layer.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;useEmptyDamage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123;</span><br><span class="line">    Layer* layer = layersWithQueuedFrames[i];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions))</span></span>;</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">s</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">    invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line"><span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line"><span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line"><span class="keyword">return</span> !layersWithQueuedFrames.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。<br>我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1.<br>继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。<br>下面我们看看latchBuffer函数</p>
<p>LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。<br>如果不需要推迟处理，把mQueuedFrames的值减1.<br>最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。</p>
<h5 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h5><p>这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。</p>
<h5 id="三、rebuildLayerStacks函数"><a href="#三、rebuildLayerStacks函数" class="headerlink" title="三、rebuildLayerStacks函数"></a>三、rebuildLayerStacks函数</h5><p>前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">updateExtendedMode();</span><br><span class="line"><span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line"><span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">    invalidateHwcGeometry();</span><br><span class="line">    <span class="comment">//计算每个显示设备上可见的Layer  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        Region opaqueRegion;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">        Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Transform&amp; <span class="title">tr</span><span class="params">(hw-&gt;getTransform())</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(hw-&gt;getBounds())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">//计算每个layer的可见区域，确定设备需要重新绘制的区域  </span></span><br><span class="line">            computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers,</span><br><span class="line">                    hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只需要和显示设备的LayerStack相同的layer  </span></span><br><span class="line">                    <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line"><span class="function"><span class="params">                            layer-&gt;visibleNonTransparentRegion))</span></span>;</span><br><span class="line">                    drawRegion.andSelf(bounds);</span><br><span class="line">                    <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果Layer的显示区域和显示设备的窗口有交集  </span></span><br><span class="line">                        <span class="comment">//把Layer加入列表中 </span></span><br><span class="line">                        layersSortedByZ.add(layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置显示设备的可见Layer列表  </span></span><br><span class="line">        hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">        hw-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">        hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。<br>computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。<br>而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。<br>其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。</p>
<h5 id="四、setUpHWComposer函数"><a href="#四、setUpHWComposer函数" class="headerlink" title="四、setUpHWComposer函数"></a>四、setUpHWComposer函数</h5><p>setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setUpHWComposer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到系统HWComposer对象  </span></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">hwc</span><span class="params">(getHwComposer())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">        mHwWorkListDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">                <span class="comment">//根据Layer数量在HWComposer中创建hwc_layer_list_t列表  </span></span><br><span class="line">                <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                        layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                        <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;</span><br><span class="line">                            cur-&gt;setSkip(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> freezeSurfacePresent = <span class="literal">false</span>;</span><br><span class="line">            isfreezeSurfacePresent(freezeSurfacePresent, hw, id);</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                 * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                <span class="comment">//将Layer的mActiveBuffer设置到HWComposer中 </span></span><br><span class="line">                layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                setOrientationEventControl(freezeSurfacePresent,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If possible, attempt to use the cursor overlay on each display.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isPotentialCursor()) &#123;</span><br><span class="line">                    cur-&gt;setIsCursorLayerHint();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;HWComposer::prepare failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        hw-&gt;prepareFrame(hwc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。<br>setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组<br>创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。<br>HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。</p>
<h5 id="五、合成所有层的图像-（doComposition-函数）"><a href="#五、合成所有层的图像-（doComposition-函数）" class="headerlink" title="五、合成所有层的图像 （doComposition()函数）"></a>五、合成所有层的图像 （doComposition()函数）</h5><p>doComposition函数是合成所有层的图像，代码如下：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen&#x27;s coordinate space</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">dirtyRegion</span><span class="params">(hw-&gt;getDirtyRegion(repaintEverything))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        hw-&gt;dirtyRegion.clear();</span><br><span class="line">        hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">        hw-&gt;swapRegion.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inform the h/w that we&#x27;re done compositing</span></span><br><span class="line">    hw-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br><span class="line">postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Region&amp; inDirtyRegion)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line"><span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line"><span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line"><span class="comment">// 2) There is work to be done (the dirty region isn&#x27;t empty)</span></span><br><span class="line"><span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGV(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the invalid region</span></span><br><span class="line"><span class="comment">//swapRegion设置为需要更新的区域  </span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();<span class="comment">//获得显示设备支持的更新方式标志  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">    <span class="comment">// we can redraw only what&#x27;s dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">    <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">    <span class="comment">// rectangle in that case</span></span><br><span class="line">    dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;<span class="comment">//支持部分更新  </span></span><br><span class="line">        <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">        <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">        <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">        <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">        <span class="comment">//将更新区域调整为整个窗口大小  </span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">        hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合成  </span></span><br><span class="line"><span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"><span class="comment">//没有硬件composer的情况，输出图像 </span></span><br><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。<br>真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。<br>合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.draw_whith_openGL_queuebuffer.png" alt="enter image description here"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\services\surfaceflinger\DisplayHardware\FramebufferSurface.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overrides ConsumerBase::onFrameAvailable(), does not call base class impl.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FramebufferSurface::onFrameAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    <span class="keyword">status_t</span> err = nextBuffer(buf, acquireFence);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error latching nnext FramebufferSurface buffer: %s (%d)&quot;</span>,</span><br><span class="line">                strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    err = mHwc.fbPost(mDisplayType, acquireFence, buf);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error posting framebuffer: %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android<span class="number">-5.0</span><span class="number">.2</span>\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer.cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HWComposer::fbPost</span><span class="params">(<span class="keyword">int32_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setFramebufferTarget(id, acquireFence, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acquireFence-&gt;waitForever(<span class="string">&quot;HWComposer::fbPost&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mFbDev-&gt;post(mFbDev, buffer-&gt;handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>zjj.display.sys ioctl <strong>FBIOPAN_DISPLAY</strong> fb_post() framebuffer.cpp</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">zjj.display.sys ioctl FBIOPAN_DISPLAY fb_post() framebuffer.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fb_post</span><span class="params">(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">private_handle_t</span>::validate(buffer) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fb_context_t</span>* ctx = (<span class="keyword">fb_context_t</span>*)dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_handle_t</span> <span class="keyword">const</span>*&gt;(buffer);</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base;</span><br><span class="line">        m-&gt;info.activate = FB_ACTIVATE_VBL;</span><br><span class="line">        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;FBIOPUT_VSCREENINFO failed&quot;</span>);</span><br><span class="line">            m-&gt;base.unlock(&amp;m-&gt;base, buffer); </span><br><span class="line">            <span class="keyword">return</span> -errno;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">       <span class="keyword">if</span> (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPAN_DISPLAY, &amp;m-&gt;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">           ALOGE(<span class="string">&quot;FBIOPAN_DISPLAY failed&quot;</span>);</span><br><span class="line">           m-&gt;base.unlock(&amp;m-&gt;base, buffer); </span><br><span class="line">           <span class="keyword">return</span> -errno;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>     </span></span><br><span class="line"></span><br><span class="line">        m-&gt;currentBuffer = buffer;</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LCD驱动前面已经分析过了，我们直接看看s3cfb_pan_display()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">\linux<span class="number">-3.0</span><span class="number">.86</span>\drivers\video\samsung\s3cfb_ops.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s3cfb_pan_display</span><span class="params">(struct fb_var_screeninfo *var, struct fb_info *fb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3cfb_window</span> *<span class="title">win</span> = <span class="title">fb</span>-&gt;<span class="title">par</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3cfb_global</span> *<span class="title">fbdev</span> = <span class="title">get_fimd_global</span>(<span class="title">win</span>-&gt;<span class="title">id</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c_platform_fb</span> *<span class="title">pdata</span> = <span class="title">to_fb_plat</span>(<span class="title">fbdev</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;id == pdata-&gt;default_win)</span><br><span class="line">        spin_lock(&amp;fbdev-&gt;slock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EXYNOS_DEV_PD</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(fbdev-&gt;system_state == POWER_OFF) || fbdev-&gt;regs == <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(fbdev-&gt;dev, <span class="string">&quot;%s::system_state is POWER_OFF, fb%d, win%d\n&quot;</span>, __func__, fb-&gt;node, win-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;id == pdata-&gt;default_win)</span><br><span class="line">            spin_unlock(&amp;fbdev-&gt;slock);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var-&gt;yoffset + var-&gt;yres &gt; var-&gt;yres_virtual) &#123;</span><br><span class="line">        dev_err(fbdev-&gt;dev, <span class="string">&quot;invalid yoffset value\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;id == pdata-&gt;default_win)</span><br><span class="line">            spin_unlock(&amp;fbdev-&gt;slock);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CPU_EXYNOS4210)</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(var-&gt;xoffset + var-&gt;xres &gt; var-&gt;xres_virtual)) &#123;</span><br><span class="line">        dev_err(fbdev-&gt;dev, <span class="string">&quot;invalid xoffset value\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (win-&gt;id == pdata-&gt;default_win)</span><br><span class="line">            spin_unlock(&amp;fbdev-&gt;slock);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    fb-&gt;var.xoffset = var-&gt;xoffset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    fb-&gt;var.yoffset = var-&gt;yoffset;</span><br><span class="line"></span><br><span class="line">    dev_dbg(fbdev-&gt;dev, <span class="string">&quot;[fb%d] win%d: yoffset for pan display: %d\n&quot;</span>,</span><br><span class="line">        fb-&gt;node, win-&gt;id, var-&gt;yoffset);</span><br><span class="line"></span><br><span class="line">    s3cfb_set_buffer_address(fbdev, win-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win-&gt;id == pdata-&gt;default_win)</span><br><span class="line">        spin_unlock(&amp;fbdev-&gt;slock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s3cfb_set_buffer_address</span><span class="params">(struct s3cfb_global *ctrl, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> *<span class="title">fix</span> = &amp;<span class="title">ctrl</span>-&gt;<span class="title">fb</span>[<span class="title">id</span>]-&gt;<span class="title">fix</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> *<span class="title">var</span> = &amp;<span class="title">ctrl</span>-&gt;<span class="title">fb</span>[<span class="title">id</span>]-&gt;<span class="title">var</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c_platform_fb</span> *<span class="title">pdata</span> = <span class="title">to_fb_plat</span>(<span class="title">ctrl</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">    <span class="keyword">dma_addr_t</span> start_addr = <span class="number">0</span>, end_addr = <span class="number">0</span>;</span><br><span class="line">    u32 shw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fix-&gt;smem_start) &#123;</span><br><span class="line">        start_addr = fix-&gt;smem_start + ((var-&gt;xres_virtual *</span><br><span class="line">                var-&gt;yoffset + var-&gt;xoffset) *</span><br><span class="line">                (var-&gt;bits_per_pixel / <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        end_addr = start_addr + fix-&gt;line_length * var-&gt;yres;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pdata-&gt;hw_ver == <span class="number">0x62</span>) || (pdata-&gt;hw_ver == <span class="number">0x70</span>)) &#123;</span><br><span class="line">        shw = readl(ctrl-&gt;regs + S3C_WINSHMAP);</span><br><span class="line">        shw |= S3C_WINSHMAP_PROTECT(id);</span><br><span class="line">        writel(shw, ctrl-&gt;regs + S3C_WINSHMAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writel(start_addr, ctrl-&gt;regs + S3C_VIDADDR_START0(id));</span><br><span class="line">    writel(end_addr, ctrl-&gt;regs + S3C_VIDADDR_END0(id));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pdata-&gt;hw_ver == <span class="number">0x62</span>) || (pdata-&gt;hw_ver == <span class="number">0x70</span>)) &#123;</span><br><span class="line">        shw = readl(ctrl-&gt;regs + S3C_WINSHMAP);</span><br><span class="line">        shw &amp;= ~(S3C_WINSHMAP_PROTECT(id));</span><br><span class="line">        writel(shw, ctrl-&gt;regs + S3C_WINSHMAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_dbg(ctrl-&gt;dev, <span class="string">&quot;[win%d] start_addr: 0x%08x, end_addr: 0x%08x\n&quot;</span>,</span><br><span class="line">        id, start_addr, end_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，spin_lock首先把framebuffer锁住，然后更新framebuffer的S3C_VIDADDR_START0 和 S3C_VIDADDR_END0，释放锁spin_unlock就将具体的画面数据刷新到LCD屏幕上了。</p>
<h5 id="六、postFramebuffer-函数"><a href="#六、postFramebuffer-函数" class="headerlink" title="六、postFramebuffer()函数"></a>六、postFramebuffer()函数</h5><p>上一节的doComposition函数最后调用了postFramebuffer函数，代码如下：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFramebuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">hwc</span><span class="params">(getHwComposer())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">        <span class="comment">// EGL spec says:</span></span><br><span class="line">        <span class="comment">//   &quot;surface must be bound to the calling thread&#x27;s current context,</span></span><br><span class="line">        <span class="comment">//    for the current rendering API.&quot;</span></span><br><span class="line">        getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">    &#125;</span><br><span class="line">    hwc.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the default display current because the VirtualDisplayDevice code cannot</span></span><br><span class="line"><span class="comment">// deal with dequeueBuffer() being called outside of the composition loop; however</span></span><br><span class="line"><span class="comment">// the code below can call glFlush() which is allowed (and does in some case) call</span></span><br><span class="line"><span class="comment">// dequeueBuffer().</span></span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">    hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">    <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;=<span class="number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line"><span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">    logFrameStats();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。</p>
<h4 id="（六）、Android-SurfaceFlinger-VSync工作原理"><a href="#（六）、Android-SurfaceFlinger-VSync工作原理" class="headerlink" title="（六）、Android SurfaceFlinger - VSync工作原理"></a>（六）、Android SurfaceFlinger - VSync工作原理</h4><h5 id="一、VSYNC-总体概念"><a href="#一、VSYNC-总体概念" class="headerlink" title="一、VSYNC 总体概念"></a>一、VSYNC 总体概念</h5><h5 id="6-1-1、VSYNC-概念"><a href="#6-1-1、VSYNC-概念" class="headerlink" title="6.1.1、VSYNC 概念"></a>6.1.1、VSYNC 概念</h5><p>VSYNC（Vertical Synchronization）是一个相当古老的概念，对于游戏玩家，它有一个更加大名鼎鼎的中文名字—-垂直同步。<br>“垂直同步(vsync)”指的是显卡的输出帧数和屏幕的垂直刷新率相同，这完全是一个CRT显示器上的概念。其实无论是VSYNC还是垂直同步这个名字，因为LCD根本就没有垂直扫描的这种东西，因此这个名字本身已经没有意义。但是基于历史的原因，这个名称在图形图像领域被沿袭下来。<br>在当下，垂直同步的含义我们可以理解为，使得显卡生成帧的速度和屏幕刷新的速度的保持一致。举例来说，如果屏幕的刷新率为60Hz，那么生成帧的速度就应该被固定在1/60 s。</p>
<h5 id="6-1-2、Android-VSYNC-—-黄油计划"><a href="#6-1-2、Android-VSYNC-—-黄油计划" class="headerlink" title="6.1.2、Android VSYNC — 黄油计划"></a>6.1.2、Android VSYNC — 黄油计划</h5><p>谷歌为解决Android系统流畅性问题。在4.1版本引入了一个重大的改进—Project Butter黄油计划。<br>Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。<br>VSYNC最重要的作用是防止出现画面撕裂（screentearing）。所谓画面撕裂，就是指一个画面上出现了两帧画面的内容，如下图。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.view-teaning.png" alt="enter image description here"></p>
<p>为什么会出现这种情况呢？这种情况一般是因为显卡输出帧的速度高于显示器的刷新速度，导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题。这也就是我们所说的画面撕裂。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.Draw-whithout-vsync.png" alt="enter image description here"></p>
<p>这个图中有三个元素，Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等。VSync用于指导双缓冲区的交换。<br>以时间的顺序来看下将会发生的异常：<br>Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成<br>Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧<br>Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理<br>Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。这种情况被Android开发组命名为“Jank”。<br>Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。<br>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。原因大家应该都看到了，就是CPU没有及时地开始着手处理第2帧的渲染工作，以致“延误军机”。</p>
<p>其实总结上面的这个情况之所以发生，首先的原因就在于第二帧没有及时的绘制（当然即使第二帧及时绘制，也依然可能出现Jank，这就是同时引入三重缓冲的作用。我们将在三重缓冲一节中再讲解这种情况）。那么如何使得第二帧即使被绘制呢？<br>这就是我们在Graphic系统中引入VSYNC的原因，考虑下面这张图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.Draw-whit-vsync.png" alt="enter image description here"></p>
<p>如上图所示，一旦VSync出现后，立刻就开始执行下一帧的绘制工作。这样就可以大大降低Jank出现的概率。另外，VSYNC引入后，要求绘制也只能在收到VSYNC消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现—-CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况—-引入VSYNC后，绘制的速度就和屏幕刷新的速度保持一致了。</p>
<h5 id="二、VSync信号产生"><a href="#二、VSync信号产生" class="headerlink" title="二、VSync信号产生"></a>二、VSync信号产生</h5><p>那么VSYNC信号是如何生成的呢？<br>Android系统中VSYNC信号分为两种，一种是硬件生成的信号，一种是软件模拟的信号。<br>硬件信号是由HardwareComposer提供的，HWC封装了相关的HAL层，如果硬件厂商提供的HAL层实现能定时产生VSYNC中断，则直接使用硬件的VSYNC中断，否则HardwareComposer内部会通过VSyncThread来模拟产生VSYNC中断（其实现很简单，就是sleep固定时间，然后唤醒）。</p>
<p>SurfaceFlinger的启动过程中inti()会创建一个HWComposer对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">&quot;debug.sf.no_hw_vsync&quot;</span>, value, <span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don&#x27;t need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don&#x27;t have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">&quot;debug.sf.no_hw_vsync&quot;</span>, value, <span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don&#x27;t need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don&#x27;t have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们来看下上面这段代码。<br>首先mDebugForceFakeVSync是为了调制，可以通过这个变量设置强制使用软件VSYNC模拟。<br>然后针对不同的屏幕，初始化了他们的mLastHwVSync和mVSyncCounts值。<br>如果硬件支持，那么就把needVSyncThread设置为false，表示不需要软件模拟。<br>接着通过eventControl来暂时的关闭了VSYNC信号，这一点将在下面讲解eventControl时一并讲解。<br>最后，如果需要软件模拟Vsync信号的话，那么我们将通过一个单独的VSyncThread线程来做这个工作(fake VSYNC是这个线程唯一的作用)。我们来看下这个线程。</p>
<p><strong>软件模拟</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period = mRefreshPeriod;  </span><br><span class="line">    <span class="comment">//当前的时间  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime(CLOCK_MONOTONIC);  </span><br><span class="line">    <span class="comment">//下一次VSYNC到来的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> next_vsync = mNextFakeVSync;  </span><br><span class="line">    <span class="comment">//为了等待下个时间到来应该休眠的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> sleep = next_vsync - now;  </span><br><span class="line">    <span class="comment">//错过了VSYNC的时间  </span></span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// we missed, find where the next vsync should be  </span></span><br><span class="line">        <span class="comment">//重新计算下应该休息的时间  </span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));  </span><br><span class="line">        <span class="comment">//更新下次VSYNC的时间  </span></span><br><span class="line">        next_vsync = now + sleep;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//更新下下次VSYNC的时间  </span></span><br><span class="line">    mNextFakeVSync = next_vsync + period;  </span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">spec</span>;</span>  </span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;  </span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="comment">//纳秒精度级的休眠  </span></span><br><span class="line">        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//休眠之后，到了该发生VSYNC的时间了  </span></span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个函数其实很简单，无非就是一个简单的时间计算，计算过程我已经写在了程序注释里面。总之到了应该发生VSYNC信号的时候，就调用了mHwc.mEventHandler.onVSyncReceived(0, next_vsync)函数来通知VSYNC的到来。</p>
<p>我们注意到mEventHandler实际上是在HWC创建时被传入的，我们来看下HWC创建时的代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mHwc &#x3D; new HWComposer(this,  </span><br><span class="line">        *static_cast&lt;HWComposer::EventHandler *&gt;(this));  </span><br><span class="line">        </span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,  </span><br><span class="line">                   private IBinder::DeathRecipient,  </span><br><span class="line">                   private HWComposer::EventHandler  </span><br></pre></td></tr></table></figure>

<p>可以看到这个mEventHandler实际上就是SurfaceFlinger。也就是说，VSYNC信号到来时，SurfaceFlinger的onVSyncReceived函数处理了这个消息。<br>这里我们暂时先不展开SurfaceFlinger内的逻辑处理，等我们下面分析完硬件实现后，一并进行分析</p>
<p><strong>硬件实现</strong><br>上面我们讲了软件如何模拟一个VSYNC信号并通知SurfaceFlinger,那么硬件又是如何实现这一点的呢？<br>我们再一次回到HWC的创建过程中来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mHwc) &#123;  </span><br><span class="line">       ALOGE(<span class="string">&quot;Lee Using %s version %u.%u&quot;</span>, HWC_HARDWARE_COMPOSER,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);  </span><br><span class="line">       <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;  </span><br><span class="line">           mCBContext-&gt;hwc = <span class="keyword">this</span>;  </span><br><span class="line">           mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;  </span><br><span class="line">           mCBContext-&gt;procs.vsync = &amp;hook_vsync;  </span><br><span class="line">           <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;  </span><br><span class="line">           <span class="keyword">else</span>  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;  </span><br><span class="line">           <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));  </span><br><span class="line">           mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);  </span><br><span class="line">       &#125;  </span><br></pre></td></tr></table></figure>

<p>来看下上面这段实现。<br>当HWC有vsync信号生成时，硬件模块会通过procs.vsync来通知软件部分，因此也就是调用了hook_vsync函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HWComposer::hook_vsync</span><span class="params">(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int64_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));  </span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HWComposer::vsync</span><span class="params">(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//只有真实的硬件设备才会产生VSYNC  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;  </span><br><span class="line">        &#123;  </span><br><span class="line">            mLastHwVSync[disp] = timestamp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们发现最后殊途同归，硬件信号最终也通过onVSyncReceived函数通知到了SurfaceFlinger了。下面我们来分析下SurfaceFlinger的处理过程。</p>
<h5 id="三、Surfaceflinger对VSYNC消息的处理"><a href="#三、Surfaceflinger对VSYNC消息的处理" class="headerlink" title="三、Surfaceflinger对VSYNC消息的处理"></a>三、Surfaceflinger对VSYNC消息的处理</h5><p>先来直接看下Surfaceflinger的onVSyncReceived函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onVSyncReceived</span><span class="params">(<span class="keyword">int32_t</span> type, <span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPrimaryDispSync是什么？addResyncSample有什么作用？<br>要回答这三个问题，我们首先还是得回到SurfaceFlinger的init函数中来。</p>
<h5 id="6-3-1、Surfaceflinger-init"><a href="#6-3-1、Surfaceflinger-init" class="headerlink" title="6.3.1、Surfaceflinger.init()"></a>6.3.1、Surfaceflinger.init()</h5><p>先看一下总体flow：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.Vsync-surfaceflinger.init.png" alt="enter image description here"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  &quot;SurfaceFlinger&#39;s main thread ready to run. &quot;</span><br><span class="line">            &quot;Initializing graphics H&#x2F;W...&quot;);</span><br><span class="line"></span><br><span class="line">    &#123; </span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; start the EventThread</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc, *this);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread &#x3D; new EventThread(sfVsyncSrc, *this);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread &#x3D; new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2个EventThread对象分别是mEventThread，给app用，mSFEventThread，给surfaceflinger自己用。<br>下面给出这4个Thread关系图。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger.init.DispSyncThread.png" alt="enter image description here"></p>
<p>这两个DispSyncSource就是KK引入的重大变化。Android 4.4(KitKat)引入了VSync的虚拟化，即把硬件的VSync信号先同步到一个本地VSync模型中，再从中一分为二，引出两条VSync时间与之有固定偏移的线程。示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger-App-Vsync-offset.png" alt="enter image description here"></p>
<p>Google这样修改的目的又是什么呢？<br>=在当前三重缓冲区的架构下，即对于一帧内容，先等App UI画完了，SurfaceFlinger再出场对其进行合并渲染后放入framebuffer，最后整到屏幕上。而现有的VSync模型是让大家一起开始干活。<br>这个架构其实会产生一个问题，因为App和SurfaceFlinger被同时唤醒，导致他们二者总是一起工作，必然导致VSync来临的时刻，这二者之间产生了CPU资源的抢占。因此，谷歌给这两个工作都加上一个小小的延迟，让这两个工作并不是同时被唤醒，这样大家就可以错开使用资源的高峰期，提高工作的效率。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SurfaceFlinger-Vsync-app-sf.png" alt="enter image description here"></p>
<p>这两个延迟，其实就分别对应上面代码中的vsyncSrc（绘制延迟）和sfVsyncSrc（合成延迟）。<br>在创建了两个DispSyncSource变量后，我们使用它们来初始化了两个EventThread。下面我们来详细看下EventThread的创建流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(<span class="keyword">const</span> sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mFlinger(flinger),</span><br><span class="line">      mUseSoftwareVSync(<span class="literal">false</span>),</span><br><span class="line">      mVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mDebugVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mVsyncHintSent(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].vsync.count =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">se</span>;</span></span><br><span class="line">    se.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr = <span class="keyword">this</span>;</span><br><span class="line">    se.sigev_notify_function = vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    run(<span class="string">&quot;EventThread&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventThread的构造函数很简单。重点是它的onFirstRef函数启动了一个EventThread线程，于是下面的代码才是重点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数本身并不复杂，其中调用了一个waitForEvent的函数。这个函数相当之长，为了防止代码展开太多，我们这里暂时不再详细分析这个函数。我们目前只需要知道这个函数的最重要的作用是等待Event的到来，并且查找对event感兴趣的监听者，而在没有event到来时，线程处于休眠状态，等待event的唤醒（我们将下一篇VSYNC的接收和处理中展开分析这个函数）。<br>这样，EventThread线程就运行起来，处在等待被event唤醒的状态下。<br><strong>MessageQueue和EventThread建立连接</strong><br>简单说明完EventThread之后，我们再次回到SurfaceFlinger的init过程中来。回到init()函数代码中来：<br>将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接，这样SurfaceFlinger才能真正接收到来自HWC的VSYNC信号。<br>我们来看下这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    mEventThread = eventThread;  </span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();  </span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();  </span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,  </span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里代码逻辑其实很简单，就是创建了一个到EventThread的连接，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。<br><strong>向Eventhread注册一个事件的监听者——createEventConnection</strong><br>在SurfaceFlinger的init函数中，我们调用了mEventQueue.setEventThread(mSFEventThread)函数，我们在前面一章中已经提到过，这个函数将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接。我们来看下这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThread::Connection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">EventThread::Connection::Connection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;  </span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;  </span><br><span class="line">    mDisplayEventConnections.add(connection);  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会导致一个Connection类的创建，而这个connection类会被保存在EventThread下的一个容器内。<br>通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p>
<h5 id="6-3-2、VSync信号的处理"><a href="#6-3-2、VSync信号的处理" class="headerlink" title="6.3.2、VSync信号的处理"></a>6.3.2、VSync信号的处理</h5><p>我们在前面一章也提到了无论是软件方式还是硬件方式，SurfaceFlinger收到VSync信号后，处理函数都是onVSyncReceived函数：</p>
<p><strong>VSync消息处理——addResyncSample</strong><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.SF-Vsync-addResyncSample.png" alt="enter image description here"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">    mResyncSamples[idx] = timestamp;  </span><br><span class="line">  </span><br><span class="line">    ......</span><br><span class="line">    updateModelLocked();  </span><br><span class="line">    .......</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>粗略浏览下这个函数，发现前半部分其实在做一些简单的计数统计，重点实现显然是updateModelLocked函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void DispSync::updateModelLocked() &#123;  </span><br><span class="line">    if (mNumResyncSamples &gt;&#x3D; MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;  </span><br><span class="line">        nsecs_t durationSum &#x3D; 0;  </span><br><span class="line">        for (size_t i &#x3D; 1; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx &#x3D; (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            size_t prev &#x3D; (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            durationSum +&#x3D; mResyncSamples[idx] - mResyncSamples[prev];  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        mPeriod &#x3D; durationSum &#x2F; (mNumResyncSamples - 1);  </span><br><span class="line">  </span><br><span class="line">        double sampleAvgX &#x3D; 0;  </span><br><span class="line">        double sampleAvgY &#x3D; 0;  </span><br><span class="line">        double scale &#x3D; 2.0 * M_PI &#x2F; double(mPeriod);  </span><br><span class="line">        for (size_t i &#x3D; 0; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx &#x3D; (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            nsecs_t sample &#x3D; mResyncSamples[idx];  </span><br><span class="line">            double samplePhase &#x3D; double(sample % mPeriod) * scale;  </span><br><span class="line">            sampleAvgX +&#x3D; cos(samplePhase);  </span><br><span class="line">            sampleAvgY +&#x3D; sin(samplePhase);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        sampleAvgX &#x2F;&#x3D; double(mNumResyncSamples);  </span><br><span class="line">        sampleAvgY &#x2F;&#x3D; double(mNumResyncSamples);  </span><br><span class="line">  </span><br><span class="line">        mPhase &#x3D; nsecs_t(atan2(sampleAvgY, sampleAvgX) &#x2F; scale);  </span><br><span class="line">        ...... </span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>不得不说，前面大段的数学计算让人有些困惑，我们暂且跳过，先分析下主线流程，也就是mThread-&gt;updateModel(mPeriod, mPhase)这个调用：</p>
<p><strong>DispSyncThread.updateModel的用途</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(<span class="keyword">nsecs_t</span> period, <span class="keyword">nsecs_t</span> phase)</span> </span>&#123;  </span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">    mPeriod = period;  </span><br><span class="line">    mPhase = phase;  </span><br><span class="line">    mCond.signal();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>updateModel是DispSyncThread类的函数，这个函数本身代码很短，其实它的主要作用是mCond.signal发送一个信号给等待中的线程。那么究竟是谁在等待这个条件呢？<br>其实等待这个条件的正是DispSyncThread的循环函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">status_t</span> err;  </span><br><span class="line">      <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">      <span class="keyword">nsecs_t</span> nextEventTime = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">          Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">          <span class="keyword">nsecs_t</span> targetTime = <span class="number">0</span>;  </span><br><span class="line">          &#123; <span class="comment">// Scope for lock  </span></span><br><span class="line">              <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">              ......</span><br><span class="line">              <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;  </span><br><span class="line">                  err = mCond.wait(mMutex);  </span><br><span class="line">                  ...... </span><br><span class="line">              &#125;  </span><br><span class="line">              nextEventTime = computeNextEventTimeLocked(now);  </span><br><span class="line">              targetTime = nextEventTime;  </span><br><span class="line">              ...... </span><br><span class="line">              &#125;  </span><br><span class="line">              now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">              ......</span><br><span class="line">              callbackInvocations = gatherCallbackInvocationsLocked(now);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              fireCallbackInvocations(callbackInvocations);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<p>大量的时间相关的计算和状态的转变我们不再深入研究，我们来看下这个线程被通知唤醒之后做的两个主要的函数的处理，gatherCallbackInvocationsLocked()和fireCallbackInvocations()。</p>
<p>gatherCallbackInvocationsLocked()的代码其实很简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> now)</span> </span>&#123;  </span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">    <span class="keyword">nsecs_t</span> ref = now - mPeriod;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">nsecs_t</span> t = computeListenerNextEventTimeLocked(mEventListeners[i],  </span><br><span class="line">                ref);  </span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;  </span><br><span class="line">            CallbackInvocation ci;  </span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;  </span><br><span class="line">            ci.mEventTime = t;  </span><br><span class="line">            callbackInvocations.push(ci);  </span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>其实就是从mEventListeners取出之前注册的事件监听者，放入callbackInvocations中，等待后面的调用。至于监听者从何处而来？在waitforevent时通过enableVSyncLocked注册的。</p>
<p>继续看下fireCallbackInvocations()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;  </span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;`  </span><br></pre></td></tr></table></figure>

<p>我们目前只分析主线的走向,接下来调用了DispSyncSource的onDispSyncEvent在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span> </span>&#123;  </span><br><span class="line">        sp&lt;VSyncSource::Callback&gt; callback;  </span><br><span class="line">        &#123;  </span><br><span class="line">            callback = mCallback;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            callback-&gt;onVSyncEvent(when);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onVSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    Mutex::Autolock _l(mLock);  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们看到这里mCondition.broadcas发出了命令，那么EventThread中waitforEvent的等待就会被唤醒。而一旦唤醒，我们就回到了EventThread的loop中，我们来看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool EventThread::threadLoop() &#123;  </span><br><span class="line">    DisplayEventReceiver::Event event;  </span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;  </span><br><span class="line">    signalConnections &#x3D; waitForEvent(&amp;event);  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; dispatch events to listeners...  </span><br><span class="line">    const size_t count &#x3D; signalConnections.size();  </span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;count ; i++) &#123;  </span><br><span class="line">        const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);  </span><br><span class="line">        &#x2F;&#x2F; now see if we still need to report this event  </span><br><span class="line">        status_t err &#x3D; conn-&gt;postEvent(event);  </span><br><span class="line">        ......</span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里主要就是通过conn-&gt;postEvent来分发事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(  </span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">DisplayEventReceiver::sendEvents</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,  </span></span></span><br><span class="line"><span class="function"><span class="params">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/zjj.display.sys.App-SurfaceFlinger-Vsync-postEvent.png" alt="enter image description here"></p>
<p>其实看到这里的BitTube我们就明白了，在本文开始时候我们提到：</p>
<p>通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p>
<p>所以我们这里可以来看看MessageQueue::cb_eventReceiver函数了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;  </span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> n;  </span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];  </span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;  </span><br><span class="line">                mHandler-&gt;dispatchInvalidate();  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们看到收到消息之后MessageQueue对消息进行了分发，我们目前走的是dispatchInvalidate()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;  </span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;  </span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:  </span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> REFRESH:  </span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:  </span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> </span>&#123;  </span><br><span class="line">    ATRACE_CALL();  </span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        handleMessageInvalidate();  </span><br><span class="line">        signalRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:  </span><br><span class="line">        handleMessageRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>到了这里，就进入了SurfaceFlinger的处理流程，我们看到对于INVALIDATE的消息，实际上系统在处理过程中实际还是会发送一个Refresh消息。</p>
<h5 id="6-4、App向Eventhread注册一个事件的监听者—createEventConnection"><a href="#6-4、App向Eventhread注册一个事件的监听者—createEventConnection" class="headerlink" title="6.4、App向Eventhread注册一个事件的监听者—createEventConnection()"></a>6.4、App向Eventhread注册一个事件的监听者—createEventConnection()</h5><p>在ViewRootImpl的构造函数中会实例化Choreographer对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">                . . . . . </span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在mChoreographer 的构造函数中实例化FrameDisplayEventReceiver对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Choreographer(Looper looper) &#123;</span><br><span class="line">               . . . . . .</span><br><span class="line">               mDisplayEventReceiver &#x3D; USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在FrameDisplayEventReceiver的父类构造函数中会调用到，android_view_DisplayEventReceiver.cpp中的nativeInit方法,在nativeInit方法中有如下过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    . . . . . .</span><br></pre></td></tr></table></figure>

<p>创建NativeDisplayEventReceiver类 类型指针<br>在NativeDisplayEventReceiver的构造函数中会调用DisplayEventReceiver类的无参构造函数实例化成员mReceiver；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中获取Surfaceflinger服务的代理对象，然后通过Binder IPC创建BpDisplayEventConnection对象<br>该函数经由BnSurfaceComposer.onTransact函数辗转调用到SurfaceFlinger.createDisplayEventConnection函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了熟悉的面孔mEventThread，该对象是一个EventThread对象，该对象在SurfaceFlinger.init函数里面创建，但是创建运行以后，貌似还没有进行任何的动作，这里调用createEventConnection函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThread::Connection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后mEventConnection-&gt;getDataChannel()方法再次通过Binder IPC创建 BitTube对象mDataChannel ，在Binder IPC创建mDataChannel 过程中会从服务端EventThread::Connection::Connection中（在EventThread类中定义）接收一个socketpair创建的FIFO文件描述符；</p>
<p>EventThread::Connection::Connection创建描述符的代码：<br>Connection构造函数调用BitTube的无参构造函数，在BitTube的构造函数中调用init函数；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitTube::init</span><span class="params">(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// sine we don&#x27;t use the &quot;return channel&quot;, we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd = sockets[<span class="number">0</span>];</span><br><span class="line">        mSendFd = sockets[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd = -errno;</span><br><span class="line">        ALOGE(<span class="string">&quot;BitTube: pipe creation failed (%s)&quot;</span>, strerror(-mReceiveFd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到NativeDisplayEventReceiver类的父类DisplayEventDispatcher中的initialize()方法，<br>  将BpDisplayEventConnection对象获取到的mDataChannel （BitTube类型）中的文件描述符添加到UI主线程Looper的epoll中，<br>  当文件描述符中被写入数据时，该epoll_wait会被唤醒；<br>  直接看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeDisplayEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要代码是mMessageQueue-&gt;getLooper()-&gt;addFd()这一行，其中的参数mReceiver.getFd()返回的是在创建NativeDisplayEventReceiver时从SurfaceFlinger服务端接收回来的socket接收端描述符，前面分析到<br>mMessageQueue是与当前应用线程关联的java层的MessageQueue对应的native层的MessageQueue对象，下面看一下Looper.addFd这个函数，上面调用时传进来的this指针对应的是一个NativeDisplayEventReceiver对象，该类继承了LooperCallback：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, Looper_callbackFunc callback, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addFd(fd, ident, events, callback ? <span class="keyword">new</span> SimpleLooperCallback(callback) : <span class="literal">NULL</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> epollEvents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">        eventItem.events = epollEvents;</span><br><span class="line">        eventItem.data.fd = fd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将上面传进来的NativeDisplayEventReceiver对象封装成一个SimpleLooperCallback对象，调用下面的addFd函数的时候主要步骤如下：<br>（1）创建一个struct epoll_event结构体对象，将对应的内存全部用清0，并作对应的初始化；<br>（2）查询通过addFd方法已经添加到epoll中监听的文件描述符；<br>（3）查询不到的话，则调用epoll_ctl方法设置EPOLL_CTL_ADD属性将对应的文件描述符添加到epoll监听的描述符中；<br>（4）根据前面addFd传入的参数EVENT_INPUT，说明当前应用线程的native层的Looper对象中的epoll机制已经开始监听来自于SurfaceFlinger服务端socket端的写入事件。 </p>
<h5 id="6-5、App请求Vsync信号"><a href="#6-5、App请求Vsync信号" class="headerlink" title="6.5、App请求Vsync信号"></a>6.5、App请求Vsync信号</h5><p>前面讲解ViewRootImpl.setView()的时候，因涉及到Vsync信号知识，requestLayout()没有具体讲解，现在继续。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[-&gt;Choreographer.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。</p>
<h5 id="6-5-1、Vsync请求过程"><a href="#6-5-1、Vsync请求过程" class="headerlink" title="6.5.1、Vsync请求过程"></a>6.5.1、Vsync请求过程</h5><p>我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>[-&gt;DisplayEventReceiver.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_DisplayEventReceiver.cpp    ]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">        reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">status_t status = receiver-&gt;scheduleVsync();</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">    String8 message;</span><br><span class="line">    message.appendFormat(<span class="string">&quot;Failed to schedule next vertical sync pulse.  status=%d&quot;</span>, status);</span><br><span class="line">    jniThrowRuntimeException(env, message.string());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VSync请求过程又转交给了DisplayEventReceiver：<br>[-&gt;DisplayEventReceiver.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line"><span class="keyword">if</span> (mEventConnection != NULL) &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mEventConnection也是前面创建native层对象NativeDisplayEventReceiver时创建的，实际对象是一个BpDisplayEventConnection对象，也就是一个Binder客户端，对应的Binder服务端BnDisplayEventConnection是一个EventThread::Connection对象，对应的BpDisplayEventConnection.requestNextVsync函数和BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)函数没有进行特别的处理，下面就调用到EventThread::Connection.requestNextVsync函数，从BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)开始已经从用户进程将需要垂直同步信号的请求发送到了SurfaceFlinger进程，下面的函数调用开始进入SF进程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::requestNextVsync() &#123;</span><br><span class="line">    mEventThread-&gt;requestNextVsync(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>辗转调用到EventThread.requestNextVsync函数，注意里面传了参数this，也就是当前的EventThread::Connection对象，需要明确的是，这里的mEventThread对象是创建EventThread::Connection对象的时候保存的，对应的是SurfaceFlinger对象的里面的mEventThread成员，该对象是一个在SurfaceFlinger.init里面创建并启动的线程对象，可见设计的时候就专门用这个SurfaceFlinger.mEventThread线程来接收来自应用进程的同步信号请求，每来一个应用进程同步信号请求，就通过SurfaceFlinger.mEventThread创建一个EventThread::Connection对象，并通过EventThread.registerDisplayEventConnection函数将创建的EventThread::Connection对象保存到EventThread.mDisplayEventConnections里面，上面有调用到了EventThread.requestNextVsync函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传进来的是一个前面创建的EventThread::Connection对象，里面判断到了EventThread::Connection.count成员变量，看一下EventThread::Connection构造函数中初始变量的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventThread::Connection::Connection(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到初始值是-1，这个值就是前面那个问题的关键，EventThread::Connection.count标示了这次应用进程的垂直同步信号的请求是一次性的，还是多次重复的，看一下注释里面对于这个变量的说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count &gt;= 1 : continuous event. count is the vsync rate</span></span><br><span class="line"><span class="comment">// count == 0 : one-shot event that has not fired</span></span><br><span class="line"><span class="comment">// count ==-1 : one-shot event that fired this round / disabled</span></span><br><span class="line"><span class="keyword">int32_t</span> count;</span><br></pre></td></tr></table></figure>

<p>很清楚的说明了，count = 0说明当前的垂直同步信号请求是一个一次性的请求，并且还没有被处理。上面EventThread::requestNextVsync里面将count设置成0，同时调用了mCondition.broadcast()唤醒所有正在等待mCondition的线程，这个会触发EventThread.waitForEvent函数从：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCondition.wait(mLock);</span><br></pre></td></tr></table></figure>

<p>中醒来，醒来之后经过一轮do…while循环就会返回，返回以后调用序列如下：<br>（1）EventThread::Connection.postEvent(event)<br>（2）DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)，mChannel参数就是前面创建DisplayEventReceiver是创建的BitTube对象<br>（3）BitTube::sendObjects(dataChannel, events, count)，static函数，通过dataChannel指向BitTube对象<br>最终调用到BitTube::sendObjects函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::sendObjects</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span> <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用到BitTube::write函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::write</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span>* vaddr, <span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> err, len;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">        <span class="comment">// cannot return less than size, since we&#x27;re using SOCK_SEQPACKET</span></span><br><span class="line">        err = len &lt; <span class="number">0</span> ? errno : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == EINTR);</span><br><span class="line">    <span class="keyword">return</span> err == <span class="number">0</span> ? len : -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用到了::send函数，::是作用域描述符，如果前面没有类名之类的，代表的就是全局的作用域，也就是调用全局函数send，这里很容易就能想到这是一个socket的写入函数，也就是将event事件数据写入到BitTube中互联的socket中，这样在另一端马上就能收到写入的数据，前面分析到这个BitTube的socket的两端连接着SurfaceFlinger进程和应用进程，也就是说通过调用BitTube::write函数，将最初由SurfaceFlinger捕获到的垂直信号事件经由BitTube中互联的socket从SurfaceFlinger进程发送到了应用进程中BitTube的socket接收端。<br>下面就要分析应用进程是如何接收并使用这个垂直同步信号事件的。</p>
<h5 id="6-5-2、应用进程接收VSync"><a href="#6-5-2、应用进程接收VSync" class="headerlink" title="6.5.2、应用进程接收VSync"></a>6.5.2、应用进程接收VSync</h5><h6 id="6-5-2-1、解析VSync事件"><a href="#6-5-2-1、解析VSync事件" class="headerlink" title="6.5.2.1、解析VSync事件"></a>6.5.2.1、解析VSync事件</h6><p>VSync同步信号事件已经发送到用户进程中的socket接收端，在前面NativeDisplayEventReceiver.initialize中分析到应用进程端的socket接收描述符已经被添加到Choreographer所在线程的native层的Looper机制中，在epoll中监听EPOLLIN事件，当socket收到数据后，epoll会马上返回，下面分步骤看一下Looper.pollInner()数：<br>（1）epoll_wait</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure>

<p>在监听到描述符对应的事件后，epoll_wait会马上返回，并将产生的具体事件类型写入到参数eventItems里面，最终返回的eventCount是监听到的事件的个数<br>（2）事件分析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">     <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">     <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">     <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;   <span class="comment">//判断是不是pipe读管道的事件   这里如果是EventThread,这里就是一个socket的描述符,而不是mWakeReadPipeFd</span></span><br><span class="line">         <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">             awoken(); <span class="comment">// 清空读管道中的数据</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;</span>, epollEvents);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//EventThread接收到同步信号走的这里</span></span><br><span class="line">         <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">         <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">             pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</span></span><br><span class="line">                     <span class="string">&quot;no longer registered.&quot;</span>, epollEvents, fd);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Looper目前了解到的主要监听的文件描述符种类有两种：<br>1）消息事件，epoll_wait监听pipe管道的接收端描述符mWakeReadPipeFd<br>2）与VSync信号，epoll_wait监听socket接收端描述符，并在addFd的过程中将相关的信息封装在一个Request结构中，并以fd为key存储到了mRequests中，具体可以回过头看3.1.2关于addFd的分析；<br>因此，上面走的是else的分支，辨别出当前的事件类型后，调用pushResponse：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::pushResponse</span><span class="params">(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;  <span class="comment">//复制不是引用，调用拷贝构造函数</span></span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将Request和events封装在一个Response对象里面，存储到了mResponses里面，也就是mResponses里面放的是“某某fd上接收到了类别为events的时间”记录，继续向下看Looper.pollInner函数<br>（3）事件分发处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke all response callbacks.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">        <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">        response.request.callback.clear();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的response.request是从pushResponse里面复制过来的，里面的request对应的Request对象是在addFd的时候创建的，ident成员就是POLL_CALLBACK，所以继续走到response.request.callback-&gt;handleEvent这个函数，回忆一下3.1.2里面的addFd函数，这里的callback实际上是一个SimpleLooperCallback（定义在Looper.cpp中）对象，看一下里面的handleEvent函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleLooperCallback::handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCallback(fd, events, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mCallback就是当时在addFd的时候传进来的callBack参数，实际上对应的就是NativeDisplayEventReceiver对象本身，因此最终就将垂直同步信号事件分发到了NativeDisplayEventReceiver.handleEvent函数中。</p>
<h5 id="6-5-3、VSync事件分发"><a href="#6-5-3、VSync事件分发" class="headerlink" title="6.5.3、VSync事件分发"></a>6.5.3、<strong>VSync事件分发</strong></h5><p>调用到NativeDisplayEventReceiver.handleEvent函数，该函数定义在android_view_DisplayEventReceiver.cpp中，直接列出该函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NativeDisplayEventReceiver::handleEvent</span><span class="params">(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Display event receiver pipe was closed or an error occurred.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Received spurious callback for unhandled poll event.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;receiver %p ~ Vsync pulse: timestamp=%&quot;</span> PRId64 <span class="string">&quot;, id=%d, count=%d&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>, vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断事件是不是正确的Looper::EVENT_INPUT事件，然后调用到NativeDisplayEventReceiver.processPendingEvents函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NativeDisplayEventReceiver::processPendingEvents</span><span class="params">(<span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That&#x27;s fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">&quot;receiver %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed to get events from display event receiver, status=%d&quot;</span>, <span class="keyword">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mReceiver也就是前面创建NativeDisplayEventReceiver对象是创建的成员变量对象DisplayEventReceiver，下面调用到DisplayEventReceiver.getEvents函数，应该是要从出现同步信号事件的socket中读取数据，上面Looper机制中epoll中监听到socket以后，返回到NativeDisplayEventReceiver.handleEvent里面，但是socket里面的数据还没有读取，下面的调用流程为：<br>（1）mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) —-&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event* events, size_t count)<br>（2）BitTube::recvObjects(dataChannel, events, count) —-&gt; BitTube::recvObjects(const sp&amp; tube, void* events, size_t count, size_t objSize)<br>看一下这个recvObjects函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::recvObjects</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;read(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在NativeDisplayEventReceiver中创建了一个缓冲区，并在recvObjects中将socket中的Event数据读到这个缓冲区中，这个Event.header.type一般都是DISPLAY_EVENT_VSYNC，因此在上面的processPendingEvents函数中会将Event数据保存在outCount所指向的内存中，并返回true。 接下来返回到NativeDisplayEventReceiver.handleEvent后会调用到dispatchVsync函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的处理很直接，直接调用mReceiverObjGlobal对象在gDisplayEventReceiverClassInfo.dispatchVsync中指定的函数，将后面的timestamp（时间戳） id（设备ID） count（经过的同步信号的数量，一般没有设置采样频率应该都是1），下面分别看一下mReceiverObjGlobal以及gDisplayEventReceiverClassInfo.dispatchVsync代表的是什么？<br>（1）mReceiverObjGlobal</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;receiver %p ~ Initializing input event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到mReceiverObjGlobal是创建NativeDisplayEventReceiver对象时传进来的第二个参数，该对象是在nativeInit函数中创建： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env, receiverObj, messageQueue); </span><br></pre></td></tr></table></figure>

<p>进一步的，receiverObj是调用nativeInit函数时传进来的第一个参数（第一个参数env是系统用于连接虚拟机时自动加上的），nativeInit函数又是在Choreographer中创建FrameDisplayEventReceiver对象时，在基类DisplayEventReceiver构造器中调用的，因此这里的mReceiverObjGlobal对应的就是Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver。<br>（2）gDisplayEventReceiverClassInfo.dispatchVsync<br>在JNI中有很多这样的类似的结构体对象，这些对象都是全局结构体对象，这里的gDisplayEventReceiverClassInfo就是这样的一个对象，里面描述了一些在整个文件内可能会调用到的java层的相关类以及成员函数的相关信息，看一下gDisplayEventReceiverClassInfo：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    jclass clazz; </span><br><span class="line">    jmethodID dispatchVsync;</span><br><span class="line">    jmethodID dispatchHotplug;</span><br><span class="line">&#125; gDisplayEventReceiverClassInfo;</span><br></pre></td></tr></table></figure>

<p>看一下里面的变量名称就能知道大致的含义，clazz成员代表的是某个java层的类的class信息，dispatchVsync和dispatchHotplug代表的是java层类的方法的方法信息，看一下该文件中注册JNI函数的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_view_DisplayEventReceiver</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = RegisterMethodsOrDie(env, <span class="string">&quot;android/view/DisplayEventReceiver&quot;</span>, gMethods, NELEM(gMethods)); </span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">&quot;android/view/DisplayEventReceiver&quot;</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz); </span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">&quot;dispatchVsync&quot;</span>, <span class="string">&quot;(JII)V&quot;</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">&quot;dispatchHotplug&quot;</span>, <span class="string">&quot;(JIZ)V&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegisterMethodsOrDie调用注册了java层调用native方法时链接到的函数的入口，下面clazz对应的就是java层的“android/view/DisplayEventReceiver.java”类，gDisplayEventReceiverClassInfo.dispatchVsync里面保存的就是clazz类信息中与dispatchVsync方法相关的信息，同样dispatchHotplug也是。<br>分析到这里，就知道应用进程native接收到同步信号事件后，会调用Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver的dispatchVsync方法。</p>
<h5 id="6-5-4、应用接收Vsync"><a href="#6-5-4、应用接收Vsync" class="headerlink" title="6.5.4、应用接收Vsync"></a>6.5.4、应用接收Vsync</h5><p>看一下FrameDisplayEventReceiver.dispatchVsync方法，也就是DisplayEventReceiver.dispatchVsync方法(Choreographer.java)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Called from native code.   </span><br><span class="line"> @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line"> private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">     onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line"> &#125;</span><br><span class="line"> 注释表明这个方法是从native代码调用的，该函数然后会调用FrameDisplayEventReceiver.onVsync方法：</span><br><span class="line">     @Override</span><br><span class="line">     public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">         &#x2F;&#x2F; Ignore vsync from secondary display.</span><br><span class="line">         &#x2F;&#x2F; This can be problematic because the call to scheduleVsync() is a one-shot.</span><br><span class="line">         &#x2F;&#x2F; We need to ensure that we will still receive the vsync from the primary</span><br><span class="line">         &#x2F;&#x2F; display which is the one we really care about.  Ideally we should schedule</span><br><span class="line">         &#x2F;&#x2F; vsync for a particular display.</span><br><span class="line">         &#x2F;&#x2F; At this time Surface Flinger won&#39;t send us vsyncs for secondary displays</span><br><span class="line">         &#x2F;&#x2F; but that could change in the future so let&#39;s log a message to help us remember</span><br><span class="line">         &#x2F;&#x2F; that we need to fix this.</span><br><span class="line">         &#x2F;&#x2F;注释：忽略来自非主显示器的Vsync信号，但是我们前面调用的scheduleVsync函数只能请求到一次Vsync信号，因此需要重新调用scheduleVsync函数</span><br><span class="line">         &#x2F;&#x2F;请求来自主显示设备的Vsync信号</span><br><span class="line">         if (builtInDisplayId !&#x3D; SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">             Log.d(TAG, &quot;Received vsync from secondary display, but we don&#39;t support &quot;</span><br><span class="line">                     + &quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span><br><span class="line">                     + &quot;vsync for a specific display to ensure it doesn&#39;t lose track &quot;</span><br><span class="line">                     + &quot;of its scheduled vsync.&quot;);</span><br><span class="line">             scheduleVsync();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Post the vsync event to the Handler.</span><br><span class="line">         &#x2F;&#x2F; The idea is to prevent incoming vsync events from completely starving</span><br><span class="line">         &#x2F;&#x2F; the message queue.  If there are no messages in the queue with timestamps</span><br><span class="line">         &#x2F;&#x2F; earlier than the frame time, then the vsync event will be processed immediately.</span><br><span class="line">         &#x2F;&#x2F; Otherwise, messages that predate the vsync event will be handled first.</span><br><span class="line">         long now &#x3D; System.nanoTime();</span><br><span class="line">         if (timestampNanos &gt; now) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f)</span><br><span class="line">                     + &quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span><br><span class="line">                     + &quot;timestamps using the correct timebase.&quot;);</span><br><span class="line">             timestampNanos &#x3D; now;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (mHavePendingVsync) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Already have a pending vsync event.  There should only be &quot;</span><br><span class="line">                     + &quot;one at a time.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             mHavePendingVsync &#x3D; true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mTimestampNanos &#x3D; timestampNanos;  &#x2F;&#x2F;同步信号时间戳</span><br><span class="line">         mFrame &#x3D; frame;                &#x2F;&#x2F;同步信号的个数，理解就是从调用scheduleVsync到onVsync接收到信号之间经历的同步信号的个数，一般都是1</span><br><span class="line">         Message msg &#x3D; Message.obtain(mHandler, this);</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">         mHandler.sendMessageAtTime(msg, timestampNanos &#x2F; TimeUtils.NANOS_PER_MS);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>貌似这里的处理只是往Choreographer对象中的mHandler对应的线程Looper中发送一个消息，消息的内容有两个特点：<br>（1）将this，也就是当前的FrameDisplayEventReceiver对象作为参数，后面会回调到FrameDisplayEventReceiver.run方法；<br>（2）为Message设置FLAG_ASYNCHRONOUS属性；<br>发送这个FLAG_ASYNCHRONOUS消息后，后面会回调到FrameDisplayEventReceiver.run方法，至于为什么，后面再写文章结合View.invalidate方法的过程分析，看一下FrameDisplayEventReceiver.run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mHavePendingVsync &#x3D; false;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Choreographer.doFrame方法，如果是重绘事件doFrame方法会最终调用到ViewRootImpl.performTraversals方法进入实际的绘制流程。经过上面的分析可以知道，调用一次Choreographer.scheduleVsyncLocked只会请求一次同步信号，也就是回调一次FrameDisplayEventReceiver.onVsync方法，在思考一个问题，一个应用进程需要多次请求Vsync同步信号会不会使用同样的一串对象？多个线程又是怎么样的？<br>答：一般绘制操作只能在主线程里面进行，因此一般来说只会在主线程里面去请求同步信号，可以认为不会存在同一个应用的多个线程请求SF的Vsync信号，Choreographer是一个线程内的单例模式，存储在了 ThreadLocal sThreadInstance对象里面，所以主线程多次请求使用的是同一个Choreographer对象，所以后面的一串对象应该都是可以复用的。</p>
<h4 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="http://charlesvincent.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android 7.1.2 (Android N) Android Graphics 系统 分析】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/12192401">【Android图形显示之硬件抽象层Gralloc】</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20191101/">https://zhoujinjian.com/posts/20191101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00004.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20191201/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00005.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android L Display System源码分析（5）：App 界面显示流程源码分析 之 Activity启动流程分析（Android 9.0 &amp;&amp; Kernel 3.18）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20191001/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00003.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android L Display System源码分析（3）：LCD驱动分析（Android 5.0.2 &amp;&amp; Kernel 3.0.86）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Android-Graphics-%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">（一）、Android Graphics 系统框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-Graphics-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%EF%BC%88C-%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android Graphics 测试程序（C++）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android-Graphics-%E7%A6%81%E7%94%A8hwc%E5%92%8CGPU"><span class="toc-number">3.</span> <span class="toc-text">（三）、Android Graphics 禁用hwc和GPU</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81Disable-HWUI-GPU-HWC"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、Disable_HWUI_GPU_HWC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81Vsync%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、Vsync测试程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Android-SurfaceFlinger-%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">（四）、Android SurfaceFlinger 内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81APP%E4%B8%8ESurfaceFlinger%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、APP与SurfaceFlinger的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-1%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1、BufferQueue介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-2%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2、生产者Producer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-3%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3、消费者Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E3%80%81App%EF%BC%88Java%E5%B1%82%EF%BC%89%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">4.2、App（Java层）请求创建Surface过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1%E3%80%81Session-addToDisplay-%E5%90%91WMS%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1%EF%BC%9B"><span class="toc-number">5.1.</span> <span class="toc-text">4.2.1、Session.addToDisplay()向WMS服务注册一个窗口对象；</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2%E3%80%81SurfaceSession%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">4.2.2、SurfaceSession建立过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3%E3%80%81App%EF%BC%88C-%E5%B1%82%EF%BC%89%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BASurfaceFlinger%E5%AE%A2%E6%88%B7%E7%AB%AF-client-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4%E3%80%81APP%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B-Java%E5%B1%82"><span class="toc-number">5.4.</span> <span class="toc-text">4.2.4、APP申请创建Surface过程(Java层)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-4-1%E3%80%81APP%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B-C-%E5%B1%82"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.2.4.1、APP申请创建Surface过程(C++层)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-4-2%E3%80%81BufferQueue%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">4.2.4.2、BufferQueue构造过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-5%E3%80%81GraphicBufferAlloc%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">4.2.5、GraphicBufferAlloc构造过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-6%E3%80%81Gralloc%E6%A8%A1%E5%9D%97%E6%89%93%E5%BC%80%E8%BF%87%E7%A8%8B-amp-amp-%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">4.2.6、Gralloc模块打开过程 &amp;&amp; 图形缓冲区创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-7%E3%80%81Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E4%B9%8B%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82Gralloc"><span class="toc-number">5.7.</span> <span class="toc-text">4.2.7、Android图形显示之硬件抽象层Gralloc</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-7-1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.7.1.</span> <span class="toc-text">4.2.7.1、数据结构定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-7-2%E3%80%81Fb%E8%AE%BE%E5%A4%87%E6%89%93%E5%BC%80%E8%BF%87%E7%A8%8B"><span class="toc-number">5.7.2.</span> <span class="toc-text">4.2.7.2、Fb设备打开过程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-8%E3%80%81GraphicBuffer%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.8.</span> <span class="toc-text">4.2.8、GraphicBuffer图形缓冲区创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-8-1%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8DBuffer"><span class="toc-number">5.8.1.</span> <span class="toc-text">4.2.8.1、系统帧缓冲区分配Buffer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-8-2%E3%80%81%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%86%E9%85%8DBuffer"><span class="toc-number">5.8.2.</span> <span class="toc-text">4.2.8.2、内存中分配Buffer</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-9%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.9.</span> <span class="toc-text">4.2.9、生产者Producer构造过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-10%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.10.</span> <span class="toc-text">4.2.10、消费者Consumer构造过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SurfaceFlinger%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC"><span class="toc-number">5.10.1.</span> <span class="toc-text">SurfaceFlinger设置监听</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-11%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E7%AA%97%E5%8F%A3Surface%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">5.11.</span> <span class="toc-text">4.2.11、应用程序本地窗口Surface创建过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E3%80%81APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">4.3、APP申请(lock)Buffer的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E3%80%81Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA-APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E3%80%81APP%E6%8F%90%E4%BA%A4-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">4.4、APP提交(unlockAndPost)Buffer的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E9%80%9A%E7%9F%A5SF%E6%B6%88%E8%B4%B9%E5%90%88%E6%88%90"><span class="toc-number">8.</span> <span class="toc-text">（五）、通知SF消费合成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81preComposition-%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">一、preComposition()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E6%AF%8F%E4%B8%AALayer%E7%9A%84onFrameAvailable%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">1.1、每个Layer的onFrameAvailable函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">1.2、绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81handleTransaction-handPageFlip%E6%9B%B4%E6%96%B0Layer%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.1.</span> <span class="toc-text">二、handleTransaction handPageFlip更新Layer对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81handleTransaction%E5%87%BD%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">2.1、handleTransaction函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81Layer%E7%9A%84doTransaction%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">2.2、Layer的doTransaction函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E3%80%81handleTransactionLocked%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">2.3、handleTransactionLocked函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2%E3%80%81%E5%A4%84%E7%90%86%E6%98%BE%E7%A4%BA%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">12.2.</span> <span class="toc-text">2.3.2、处理显示设备的变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3%E3%80%81%E8%AE%BE%E7%BD%AETransfromHit"><span class="toc-number">12.3.</span> <span class="toc-text">2.3.3、设置TransfromHit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4%E3%80%81%E5%A4%84%E7%90%86Layer%E5%A2%9E%E5%8A%A0%E6%83%85%E5%86%B5"><span class="toc-number">12.4.</span> <span class="toc-text">2.3.4、处理Layer增加情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5%E3%80%81%E8%AE%BE%E7%BD%AEmDrawingState"><span class="toc-number">12.5.</span> <span class="toc-text">2.3.5、设置mDrawingState</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">12.6.</span> <span class="toc-text">2.3.6 小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81handlePageFlip%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">2.4、handlePageFlip函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">13.1.</span> <span class="toc-text">2.5 小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81rebuildLayerStacks%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">三、rebuildLayerStacks函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81setUpHWComposer%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">四、setUpHWComposer函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%90%88%E6%88%90%E6%89%80%E6%9C%89%E5%B1%82%E7%9A%84%E5%9B%BE%E5%83%8F-%EF%BC%88doComposition-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">五、合成所有层的图像 （doComposition()函数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD%E3%80%81postFramebuffer-%E5%87%BD%E6%95%B0"><span class="toc-number">13.5.</span> <span class="toc-text">六、postFramebuffer()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Android-SurfaceFlinger-VSync%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">（六）、Android SurfaceFlinger - VSync工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81VSYNC-%E6%80%BB%E4%BD%93%E6%A6%82%E5%BF%B5"><span class="toc-number">14.1.</span> <span class="toc-text">一、VSYNC 总体概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1%E3%80%81VSYNC-%E6%A6%82%E5%BF%B5"><span class="toc-number">14.2.</span> <span class="toc-text">6.1.1、VSYNC 概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2%E3%80%81Android-VSYNC-%E2%80%94-%E9%BB%84%E6%B2%B9%E8%AE%A1%E5%88%92"><span class="toc-number">14.3.</span> <span class="toc-text">6.1.2、Android VSYNC — 黄油计划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81VSync%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F"><span class="toc-number">14.4.</span> <span class="toc-text">二、VSync信号产生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81Surfaceflinger%E5%AF%B9VSYNC%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">14.5.</span> <span class="toc-text">三、Surfaceflinger对VSYNC消息的处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1%E3%80%81Surfaceflinger-init"><span class="toc-number">14.6.</span> <span class="toc-text">6.3.1、Surfaceflinger.init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2%E3%80%81VSync%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">14.7.</span> <span class="toc-text">6.3.2、VSync信号的处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4%E3%80%81App%E5%90%91Eventhread%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E8%80%85%E2%80%94createEventConnection"><span class="toc-number">14.8.</span> <span class="toc-text">6.4、App向Eventhread注册一个事件的监听者—createEventConnection()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5%E3%80%81App%E8%AF%B7%E6%B1%82Vsync%E4%BF%A1%E5%8F%B7"><span class="toc-number">14.9.</span> <span class="toc-text">6.5、App请求Vsync信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-1%E3%80%81Vsync%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">14.10.</span> <span class="toc-text">6.5.1、Vsync请求过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-2%E3%80%81%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6VSync"><span class="toc-number">14.11.</span> <span class="toc-text">6.5.2、应用进程接收VSync</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#6-5-2-1%E3%80%81%E8%A7%A3%E6%9E%90VSync%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.11.1.</span> <span class="toc-text">6.5.2.1、解析VSync事件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-3%E3%80%81VSync%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="toc-number">14.12.</span> <span class="toc-text">6.5.3、VSync事件分发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-4%E3%80%81%E5%BA%94%E7%94%A8%E6%8E%A5%E6%94%B6Vsync"><span class="toc-number">14.13.</span> <span class="toc-text">6.5.4、应用接收Vsync</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">15.</span> <span class="toc-text">（七）、参考文档(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>