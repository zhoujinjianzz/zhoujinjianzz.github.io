<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 10 Camera源码分析6：Camera HAL3简介 &amp;&amp; Camera Provider分析 | zhoujinjian</title><meta name="keywords" content="Camera"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 10.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 10 Camera源码分析6：Camera HAL3简介 &amp;&amp; Camera Provider分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20220315/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 10.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.36.jpg">
<meta property="article:published_time" content="2022-03-14T19:15:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.932Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Camera">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.36.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20220315/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.36.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 10 Camera源码分析6：Camera HAL3简介 &amp;&amp; Camera Provider分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-14T19:15:00.000Z" title="发表于 2022-03-15 03:15:00">2022-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.932Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Camera/">Camera</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料 Android 10.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Kernel-4.19</strong>==）&amp;&amp;（==<strong>文章基于 Android 10.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.khadas.cn/edge-v">【开发板 Khadas Edge V】</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/khadas/linux/tree/khadas-edge-Qt">【开发板 Khadas Edge V Android 10.0 &amp;&amp; Linux（Kernel 4.19）源码链接】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，特别感谢！！！</p>
<p> <a target="_blank" rel="noopener" href="https://deepinout.com/android-camera/android-camera-hal3-intro.html">Android Camera HAL3简介</a> </p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/Vincentywj/article/details/86759599">Android P之Camera HAL3流程分析（0）</a> </p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775897/article/details/81240600">[Android O] Camera 服务启动流程简析</a> </p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41944449/article/details/99453461">Android Camera Provider启动流程</a> </p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/yiranfeng/category_9850785.html">【Android10.0 进程间通信系列】</a></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/a185531353/article/details/93223686">【Android P HIDL 之 CameraProvider】</a></p>
<hr>
<p>==源码（部分）==：</p>
<p><strong>F:\Khadas_Edge_Android_Q\system\hwservicemanager\</strong></p>
<p><strong>F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\</strong></p>
<p><strong>F:\Khadas_Edge_Android_Q\system\libhidl\</strong></p>
<p><strong>/Khadas_Edge_Android_Q/out/soong/.intermediates/hardware/interfaces/camera/provider/2.4/android.hardware.camera.provider@2.4_genc++/gen/android/hardware/camera/</strong></p>
<p>==源码（部分）==：</p>
<hr>
<p>始于谷歌的Treble开源项目，基于接口与实现的分离的设计原则，谷歌加入了Camera Provider这一抽象层，该层作为一个独立进程存在于整个系统中，并且通过HIDL这一自定义语言成功地将Camera Hal Module从Camera Service中解耦出来，承担起了对Camera HAL的封装工作，纵观整个Android系统，对于Camera Provider而言，对上是通过HIDL接口负责与Camera Service的跨进程通信，对下通过标准的HAL3接口下发针对Camera的实际操作，这俨然是一个中央枢纽般的调配中心的角色，而事实上正是如此，由此看来，对Camera Provider的梳理变得尤为重要，接下来就以我个人理解出发来简单介绍下Camera Provider。</p>
<p>Camera Provider通过提供标准的HIDL接口给Camera Service进行调用，保持与Service的正常通信，其中谷歌将HIDL接口的定义直接暴露给平台厂商进行自定义实现，其中为了极大地减轻并降低开发者的工作量和开发难度，谷歌很好地封装了其跨进程实现细节，同样地，Camera Provider通过标准的HAL3接口，向下控制着具体的Camera HAL Module，而这个接口依然交由平台厂商负责去实现，而进程内部则通过简单的函数调用，将HIDL接口与HAL3接口完美的衔接起来，由此构成了Provider整体架构。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/camera_provider_arc.png"></p>
<p>由图中可以看出Camera Provider进程由两部分组成，一是运行在系统中的主程序通过提供了标准的HIDL接口保持了与Camera Service的跨进程通讯，二是为了进一步扩展其功能，通过dlopen方式加载了一系列So库，而其中就包括了实现了Camera HAL3接口的So库，而HAL3接口主要定义了主要用于实现图像控制的功能，其实现主要交由平台厂商或者开发者来完成，所以Camera HAL3 So库的实现各式各样，在Rockchip平台上，这里的实现就是camera.rk30board.so。</p>
<p>在开始梳理Rockchip Camera HAL3 So库实现之前，不防先从上到下，以接口为主线简单梳理下Camera Provider的各个部分:</p>
<h2 id="（一）、Camera-HIDL-接口"><a href="#（一）、Camera-HIDL-接口" class="headerlink" title="（一）、Camera HIDL 接口"></a>（一）、Camera HIDL 接口</h2><p>首先需要明确一个概念，就是HIDL是一种自定义语言，其核心是接口的定义，而谷歌为了使开发者将注意力落在接口的定义上而不是机制的实现上，主动封装了HIDL机制的实现细节，开发者只需要通过*.hal文件定义接口，填充接口内部实际的实现即可，接下来来看下具体定义的几个主要接口：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/cmaera_hidl.png"></p>
<p>因为HIDL机制本身是跨进程通讯的，所以Camera Service本身通过HIDL接口获取的对象都会有Bn端和Bp端，分别代表了Binder两端，接下来为了方便理解，我们都省略掉Bn/Bp说法,直接用具体接口类代表，忽略跨进程两端的区别。</p>
<h4 id="（1）、ICameraProvider-hal"><a href="#（1）、ICameraProvider-hal" class="headerlink" title="（1）、ICameraProvider.hal"></a>（1）、ICameraProvider.hal</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\ICameraProvider.hal</span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ICameraProviderCallback;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice;</span><br><span class="line"></span><br><span class="line">interface ICameraProvider &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setCallback:</span></span><br><span class="line"><span class="comment">     * Provide a callback interface to the HAL provider to inform framework of</span></span><br><span class="line"><span class="comment">     * asynchronous camera events. The framework must call this function once</span></span><br><span class="line"><span class="comment">     * during camera service startup, before any other calls to the provider</span></span><br><span class="line"><span class="comment">     * (note that in case the camera service restarts, this method must be</span></span><br><span class="line"><span class="comment">     * invoked again during its startup).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setCallback(ICameraProviderCallback callback) generates (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getVendorTags:</span></span><br><span class="line"><span class="comment">     * Retrieve all vendor tags supported by devices discoverable through this</span></span><br><span class="line"><span class="comment">     * provider. The tags are grouped into sections.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getVendorTags() generates (Status status, vec&lt;VendorTagSection&gt; sections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraIdList:</span></span><br><span class="line"><span class="comment">     * Returns the list of internal camera device interfaces known to this</span></span><br><span class="line"><span class="comment">     * camera provider. These devices can then be accessed via the hardware</span></span><br><span class="line"><span class="comment">     * service manager.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCameraIdList()</span><br><span class="line">            generates (Status status, vec&lt;<span class="built_in">string</span>&gt; cameraDeviceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isSetTorchModeSupported:</span></span><br><span class="line"><span class="comment">     * Returns if the camera devices known to this camera provider support</span></span><br><span class="line"><span class="comment">     * setTorchMode API or not. If the provider does not support setTorchMode</span></span><br><span class="line"><span class="comment">     * API, calling to setTorchMode will return METHOD_NOT_SUPPORTED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isSetTorchModeSupported() generates (Status status, <span class="keyword">bool</span> support);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraDeviceInterface_VN_x:</span></span><br><span class="line"><span class="comment">     * Return a android.hardware.camera.device@N.x/ICameraDevice interface for</span></span><br><span class="line"><span class="comment">     * the requested device name. This does not power on the camera device, but</span></span><br><span class="line"><span class="comment">     * simply acquires the interface for querying the device static information,</span></span><br><span class="line"><span class="comment">     * or to additionally open the device for active use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A separate method is required for each major revision of the camera device</span></span><br><span class="line"><span class="comment">     * HAL interface, since they are not compatible with each other.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Valid device names for this provider can be obtained via either</span></span><br><span class="line"><span class="comment">     * getCameraIdList(), or via availability callbacks from</span></span><br><span class="line"><span class="comment">     * ICameraProviderCallback::cameraDeviceStatusChange().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCameraDeviceInterface_V1_x(<span class="built_in">string</span> cameraDeviceName) generates</span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">1.0</span>::ICameraDevice device);</span><br><span class="line">    getCameraDeviceInterface_V3_x(<span class="built_in">string</span> cameraDeviceName) generates</span><br><span class="line">            (Status status,</span><br><span class="line">             android.hardware.camera.device@<span class="number">3.2</span>::ICameraDevice device);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该文件中定义了ICameraProvider接口类，由CameraProvider继承并实现，在Camera Provider启动的时候被实例化，主要接口如下：</p>
<ul>
<li>getCameraDeviceInterface_V3_x: 该方法主要用于Camera Service获取ICameraDevice，通过该对象可以控制Camera 设备的诸如配置数据流、下发request等具体行为。</li>
<li>setCallback： 将Camera Service 实现的ICameraProviderCallback传入Camera Provider，一旦Provider有事件产生时便可以通过该对象通知Camera Service。</li>
</ul>
<h4 id="（2）、ICameraProviderCallback-hal"><a href="#（2）、ICameraProviderCallback-hal" class="headerlink" title="（2）、ICameraProviderCallback.hal"></a>（2）、ICameraProviderCallback.hal</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\ICameraProviderCallback.hal</span><br><span class="line">package android.hardware.camera.provider@<span class="number">2.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line">interface ICameraProviderCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cameraDeviceStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of a specific</span></span><br><span class="line"><span class="comment">     * camera device has changed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * On camera service startup, when ICameraProvider::setCallback is invoked,</span></span><br><span class="line"><span class="comment">     * the camera service must assume that all internal camera devices are in</span></span><br><span class="line"><span class="comment">     * the CAMERA_DEVICE_STATUS_PRESENT state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The provider must call this method to inform the camera service of any</span></span><br><span class="line"><span class="comment">     * initially NOT_PRESENT devices, and of any external camera devices that</span></span><br><span class="line"><span class="comment">     * are already present, as soon as the callbacks are available through</span></span><br><span class="line"><span class="comment">     * setCallback.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cameraDeviceStatusChange(<span class="built_in">string</span> cameraDeviceName,</span><br><span class="line">            CameraDeviceStatus newStatus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * torchModeStatusChange:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Callback to the camera service to indicate that the state of the torch</span></span><br><span class="line"><span class="comment">     * mode of the flash unit associated with a specific camera device has</span></span><br><span class="line"><span class="comment">     * changed. At provider registration time, the camera service must assume</span></span><br><span class="line"><span class="comment">     * the torch modes are in the TORCH_MODE_STATUS_AVAILABLE_OFF state if</span></span><br><span class="line"><span class="comment">     * android.flash.info.available is reported as true via the</span></span><br><span class="line"><span class="comment">     * ICameraDevice::getCameraCharacteristics call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    torchModeStatusChange(<span class="built_in">string</span> cameraDeviceName,</span><br><span class="line">            TorchModeStatus newStatus);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该文件中定义了ICameraProviderCallback回调接口类，该接口由Camera Service 中的CameraProviderManager::ProviderInfo继承并实现，在Camera Service 启动的时候被实例化，通过调用ICameraProvider::setCallback接口注册到Camera Provider中，其主要接口如下：</p>
<ul>
<li>cameraDeviceStatusChange： 将Camera 设备状态上传至Camera Service，状态由CameraDeviceStatus定义</li>
</ul>
<h4 id="（3）、ICameraDevice-hal"><a href="#（3）、ICameraDevice-hal" class="headerlink" title="（3）、ICameraDevice.hal"></a>（3）、ICameraDevice.hal</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ackage android.hardware.camera.device@<span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"><span class="keyword">import</span> ICameraDeviceSession;</span><br><span class="line"><span class="keyword">import</span> ICameraDeviceCallback;</span><br><span class="line"></span><br><span class="line">interface ICameraDevice &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get camera device resource cost information.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getResourceCost() generates (Status status, CameraResourceCost resourceCost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCameraCharacteristics:</span></span><br><span class="line"><span class="comment">     * Return the static camera information for this camera device. This</span></span><br><span class="line"><span class="comment">     * information may not change between consecutive calls.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCameraCharacteristics() generates</span><br><span class="line">            (Status status, CameraMetadata cameraCharacteristics);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setTorchMode:</span></span><br><span class="line"><span class="comment">     * Turn on or off the torch mode of the flash unit associated with this</span></span><br><span class="line"><span class="comment">     * camera device. If the operation is successful, HAL must notify the</span></span><br><span class="line"><span class="comment">     * framework torch state by invoking</span></span><br><span class="line"><span class="comment">     * ICameraProviderCallback::torchModeStatusChange() with the new state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setTorchMode(TorchMode mode) generates (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open:</span></span><br><span class="line"><span class="comment">     * Power on and initialize this camera device for active use, returning a</span></span><br><span class="line"><span class="comment">     * session handle for active operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    open(ICameraDeviceCallback callback) generates</span><br><span class="line">            (Status status, ICameraDeviceSession session);</span><br><span class="line">    dumpState(handle fd);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该文件中定义了ICameraDevice接口类，由CameraDevice::TrampolineDeviceInterface_3_2实现，其主要接口如下:</p>
<ul>
<li><p>open： 用于创建一个Camera设备，并且将Camera Service中继承ICameraDeviceCallback并实现了相应接口的Camera3Device作为参数传入Provider中，供Provider上传事件或者图像数据。</p>
</li>
<li><p>getCameraCharacteristics：用于获取Camera设备的属性。</p>
</li>
</ul>
<h4 id="（4）、ICameraDeviceCallback-hal"><a href="#（4）、ICameraDeviceCallback-hal" class="headerlink" title="（4）、ICameraDeviceCallback.hal"></a>（4）、ICameraDeviceCallback.hal</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package android.hardware.camera.device@<span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line">interface ICameraDeviceCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * processCaptureResult:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send results from one or more completed or partially completed captures</span></span><br><span class="line"><span class="comment">     * to the framework.</span></span><br><span class="line"><span class="comment">     * processCaptureResult() may be invoked multiple times by the HAL in</span></span><br><span class="line"><span class="comment">     * response to a single capture request. This allows, for example, the</span></span><br><span class="line"><span class="comment">     * metadata and low-resolution buffers to be returned in one call, and</span></span><br><span class="line"><span class="comment">     * post-processed JPEG buffers in a later call, once it is available. Each</span></span><br><span class="line"><span class="comment">     * call must include the frame number of the request it is returning</span></span><br><span class="line"><span class="comment">     * metadata or buffers for. Only one call to processCaptureResult</span></span><br><span class="line"><span class="comment">     * may be made at a time by the HAL although the calls may come from</span></span><br><span class="line"><span class="comment">     * different threads in the HAL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A component (buffer or metadata) of the complete result may only be</span></span><br><span class="line"><span class="comment">     * included in one process_capture_result call. A buffer for each stream,</span></span><br><span class="line"><span class="comment">     * and the result metadata, must be returned by the HAL for each request in</span></span><br><span class="line"><span class="comment">     * one of the processCaptureResult calls, even in case of errors producing</span></span><br><span class="line"><span class="comment">     * some of the output. A call to processCaptureResult() with neither</span></span><br><span class="line"><span class="comment">     * output buffers or result metadata is not allowed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The order of returning metadata and buffers for a single result does not</span></span><br><span class="line"><span class="comment">     * matter, but buffers for a given stream must be returned in FIFO order. So</span></span><br><span class="line"><span class="comment">     * the buffer for request 5 for stream A must always be returned before the</span></span><br><span class="line"><span class="comment">     * buffer for request 6 for stream A. This also applies to the result</span></span><br><span class="line"><span class="comment">     * metadata; the metadata for request 5 must be returned before the metadata</span></span><br><span class="line"><span class="comment">     * for request 6.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    processCaptureResult(vec&lt;CaptureResult&gt; results);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify:</span></span><br><span class="line"><span class="comment">     * Asynchronous notification callback from the HAL, fired for various</span></span><br><span class="line"><span class="comment">     * reasons. Only for information independent of frame capture, or that</span></span><br><span class="line"><span class="comment">     * require specific timing. Multiple messages may be sent in one call; a</span></span><br><span class="line"><span class="comment">     * message with a higher index must be considered to have occurred after a</span></span><br><span class="line"><span class="comment">     * message with a lower index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    notify(vec&lt;NotifyMsg&gt; msgs);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该文件中定义了ICameraDeviceCallback接口类，由Camera Service中的Camera3Device继承并实现，通过调用ICameraDevice::open方法注册到Provider中，其主要接口如下：</p>
<ul>
<li>processCaptureResult: 一旦有图像数据产生会通过调用该方法将数据以及meta data上传至Camera Service。</li>
<li>notify: 通过该方法上传事件至Camera Service中，比如shutter事件等。</li>
</ul>
<h4 id="（5）、ICameraDeviceSession-hal"><a href="#（5）、ICameraDeviceSession-hal" class="headerlink" title="（5）、ICameraDeviceSession.hal"></a>（5）、ICameraDeviceSession.hal</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\device\<span class="number">3.3</span>\ICameraDeviceSession.hal</span><br><span class="line">    </span><br><span class="line">package android.hardware.camera.device@<span class="number">3.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::Status;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">3.2</span>::ICameraDeviceSession;</span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.device@<span class="number">3.2</span>::StreamConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera device active session interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Obtained via ICameraDevice::open(), this interface contains the methods to</span></span><br><span class="line"><span class="comment"> * configure and request captures from an active camera device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraDeviceSession extends @<span class="number">3.2</span>::ICameraDeviceSession &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configureStreams_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Identical to @3.2::ICameraDeviceSession.configureStreams, except that:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - The output HalStreamConfiguration now contains an overrideDataspace</span></span><br><span class="line"><span class="comment">     *   field, to be used by the HAL to select a different dataspace for some</span></span><br><span class="line"><span class="comment">     *   use cases when dealing with the IMPLEMENTATION_DEFINED pixel format.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Clients may invoke either this method or</span></span><br><span class="line"><span class="comment">     * @3.2::ICameraDeviceSession.configureStreams() for stream configuration.</span></span><br><span class="line"><span class="comment">     * This method is recommended for clients to use since it provides more</span></span><br><span class="line"><span class="comment">     * flexibility.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    configureStreams_3_3(StreamConfiguration requestedConfiguration)</span><br><span class="line">            generates (Status status,</span><br><span class="line">                    @<span class="number">3.3</span>::HalStreamConfiguration halConfiguration);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\device\<span class="number">3.2</span>\ICameraDeviceSession.hal</span><br><span class="line">    </span><br><span class="line">package android.hardware.camera.device@<span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.camera.common@<span class="number">1.0</span>::types;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Camera device active session interface.</span></span><br><span class="line"><span class="comment"> * Obtained via ICameraDevice::open(), this interface contains the methods to</span></span><br><span class="line"><span class="comment"> * configure and request captures from an active camera device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface ICameraDeviceSession &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * constructDefaultRequestSettings:</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    constructDefaultRequestSettings(RequestTemplate type) generates</span><br><span class="line">            (Status status, CameraMetadata requestTemplate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configureStreams:</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the streamList. This method must be called at</span></span><br><span class="line"><span class="comment">     * least once before a request is submitted with processCaptureRequest().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    configureStreams(StreamConfiguration requestedConfiguration)</span><br><span class="line">            generates (Status status,</span><br><span class="line">                    HalStreamConfiguration halConfiguration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * processCaptureRequest:</span></span><br><span class="line"><span class="comment">     * Send a list of capture requests to the HAL. The HAL must not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next set of requests to</span></span><br><span class="line"><span class="comment">     * process. Only one call to processCaptureRequest() must be made at a time</span></span><br><span class="line"><span class="comment">     * by the framework, and the calls must all be from the same thread. The</span></span><br><span class="line"><span class="comment">     * next call to processCaptureRequest() must be made as soon as a new</span></span><br><span class="line"><span class="comment">     * request and its associated buffers are available. In a normal preview</span></span><br><span class="line"><span class="comment">     * scenario, this means the function is generally called again by the</span></span><br><span class="line"><span class="comment">     * framework almost instantly. If more than one request is provided by the</span></span><br><span class="line"><span class="comment">     * client, the HAL must process the requests in order of lowest index to</span></span><br><span class="line"><span class="comment">     * highest index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    processCaptureRequest(vec&lt;CaptureRequest&gt; requests,</span><br><span class="line">            vec&lt;BufferCache&gt; cachesToRemove)</span><br><span class="line">            generates (Status status, <span class="keyword">uint32_t</span> numRequestProcessed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureRequestMetadataQueue:</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with processCaptureRequest. If</span></span><br><span class="line"><span class="comment">     * client decides to use fast message queue to pass request metadata,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCaptureRequestMetadataQueue() generates (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getCaptureResultMetadataQueue:</span></span><br><span class="line"><span class="comment">     * Retrieves the queue used along with</span></span><br><span class="line"><span class="comment">     * ICameraDeviceCallback.processCaptureResult.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getCaptureResultMetadataQueue() generates (fmq_sync&lt;<span class="keyword">uint8_t</span>&gt; <span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flush:</span></span><br><span class="line"><span class="comment">     * Flush all currently in-process captures and all buffers in the pipeline</span></span><br><span class="line"><span class="comment">     * on the given device. Generally, this method is used to dump all state as</span></span><br><span class="line"><span class="comment">     * quickly as possible in order to prepare for a configure_streams() call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    flush() generates (Status status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close:</span></span><br><span class="line"><span class="comment">     * Shut down the camera device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该文件中定义了ICameraDeviceSession接口类，由CameraDeviceSession::TrampolineSessionInterface_3_3继承并实现，其主要接口如下：</p>
<ul>
<li>constructDefaultRequestSettings：用于创建默认的Request配置项。</li>
<li>configureStreams：用于配置数据流，其中包括了output buffer/Surface/图像格式大小等属性。</li>
<li>processCaptureRequest：下发request到Provider中，一个request对应着一次图像需求。</li>
<li>close: 关闭当前会话。</li>
</ul>
<h2 id="（二）、Camera-Provider-主程序"><a href="#（二）、Camera-Provider-主程序" class="headerlink" title="（二）、Camera Provider 主程序"></a>（二）、Camera Provider 主程序</h2><p>接下来进入到Provider内部去看看，整个进程是如何运转的，这个服务进程的启动很简单，主要动作是注册该 CameraProvider，以便 CameraServer 启动时能找到它。需要注意的是，此时 CameraProvider 还未实例化与初始化。以下图为例进行分析:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/android.hardware.camera.provider@2.4-service.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\2.4\default\android.hardware.camera.provider@2.4-service_64.rc</span><br><span class="line">service vendor.camera-provider-2-4 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.camera.provider@2.4-service</span><br><span class="line">    class hal</span><br><span class="line">    user cameraserver</span><br><span class="line">    group audio camera input drmrpc</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    capabilities SYS_NICE</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;camera-daemon&#x2F;tasks &#x2F;dev&#x2F;stune&#x2F;top-app&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p>在android启动的过程中，init进程调用该脚本启动 camera provider 服务。根据该目录下的 Android.bp 可以知道，其实就是运行该目录下 service.cpp 编译的可执行文件，service.cpp 内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\<span class="keyword">default</span>\service.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;CameraProvider@2.4 legacy service is starting.&quot;</span>);</span><br><span class="line">    <span class="comment">// The camera HAL may communicate to other vendor components via</span></span><br><span class="line">    <span class="comment">// /dev/vndbinder</span></span><br><span class="line">    android::ProcessState::initWithDriver(<span class="string">&quot;/dev/vndbinder&quot;</span>);</span><br><span class="line">    <span class="keyword">status_t</span> status;</span><br><span class="line">    <span class="keyword">if</span> (kLazyService) &#123;</span><br><span class="line">        status = defaultLazyPassthroughServiceImplementation&lt;ICameraProvider&gt;(<span class="string">&quot;legacy/0&quot;</span>,</span><br><span class="line">                                                                              <span class="comment">/*maxThreads*/</span> <span class="number">6</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = defaultPassthroughServiceImplementation&lt;ICameraProvider&gt;(<span class="string">&quot;legacy/0&quot;</span>,</span><br><span class="line">                                                                          <span class="comment">/*maxThreads*/</span> <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据以上代码可以得知：</p>
<ul>
<li>android::ProcessState::initWithDriver ：camera HAL 通过 /dev/vndbinder 驱动可与其他模块的HAL进行通信</li>
<li>defaultPassthroughServiceImplementation ：创建默认为直通模式（passthrough）的 CameraProvider 服务；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\include\hidl\LegacySupport.h</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>, <span class="title">typename</span> <span class="title">Func</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>)) <span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">    <span class="title">Func</span> <span class="title">registerServiceCb</span>, <span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span>&amp; name = <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">/* 获得CameraProvider实例化对象（不是Binder代理）,（此处的name为 “legacy/0”） */</span></span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line">    ......</span><br><span class="line">   <span class="comment">/* 将 CameraProvider 注册为一个服务，其他进程需要使用camera HAL层时，通过Binder</span></span><br><span class="line"><span class="comment">     * 得到 CameraProvider 代理类即可操作 camera HAL层，不需要每次都dlopen(HAL.so)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">status_t</span> status = registerServiceCb(service, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == OK) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Registration complete for %s/%s.&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Could not register service %s/%s (%d).&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str(), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>)) <span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span>&amp; name, <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line">    ......</span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(<span class="string">&quot;default&quot;</span>, maxThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（1）、获取-CameraProvider-实例对象"><a href="#（1）、获取-CameraProvider-实例对象" class="headerlink" title="（1）、获取 CameraProvider 实例对象"></a>（1）、获取 CameraProvider 实例对象</h4><p>从 LegacySupport.h 可以知道，defaultPassthroughServiceImplementation为模板类函数，将会通过 ==sp<ICameraProvider> service = ICameraProvider::getService(name, true /* getStub */)== 获取 CameraProvider 实例化对象，以上操作，将会进入 CameraProviderAll.cpp。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Khadas_Edge_Android_Q/out/soong/.intermediates/hardware/interfaces/camera/provider/<span class="number">2.4</span>/android.hardware.camera.provider@<span class="number">2.4</span>_genc++/gen/android/hardware/camera/provider/<span class="number">2.4</span>/CameraProviderAll.cpp</span><br><span class="line">    </span><br><span class="line">::<span class="function">android::sp&lt;ICameraProvider&gt; <span class="title">ICameraProvider::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::getServiceInternal&lt;BpHwCameraProvider&gt;(serviceName, <span class="literal">true</span>, getStub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\include\hidl\HidlTransportSupport.h</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BpType, <span class="keyword">typename</span> IType = <span class="keyword">typename</span> BpType::Pure,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same&lt;i_tag, <span class="keyword">typename</span> IType::_hidl_tag&gt;::value&gt;,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same&lt;bphw_tag, <span class="keyword">typename</span> BpType::_hidl_tag&gt;::value&gt;&gt;</span><br><span class="line">sp&lt;IType&gt; getServiceInternal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; instance, <span class="keyword">bool</span> retry, <span class="keyword">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line"></span><br><span class="line">    sp&lt;IBase&gt; base = getRawServiceInternal(IType::descriptor, instance, retry, getStub);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// getRawServiceInternal guarantees we get the proper class</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;IType&gt;(<span class="keyword">new</span> BpType(getOrCreateCachedBinder(base.get())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IType::castFrom(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，参数 BpHwCameraProvider::descriptor 为<a href="mailto:&#97;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#114;&#100;&#x77;&#97;&#114;&#x65;&#46;&#x63;&#x61;&#x6d;&#101;&#114;&#x61;&#46;&#x70;&#x72;&#x6f;&#118;&#x69;&#x64;&#101;&#x72;&#x40;&#x32;&#x2e;&#52;">&#97;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#114;&#100;&#x77;&#97;&#114;&#x65;&#46;&#x63;&#x61;&#x6d;&#101;&#114;&#x61;&#46;&#x70;&#x72;&#x6f;&#118;&#x69;&#x64;&#101;&#x72;&#x40;&#x32;&#x2e;&#52;</a>::ICameraProvider，instance 为 “legacy/0” ，retry 为 true，getStub 为 true。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\ServiceManagement.cpp</span><br><span class="line"><span class="function">sp&lt;::android::hidl::base::V1_0::IBase&gt; <span class="title">getRawServiceInternal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; instance,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             <span class="keyword">bool</span> retry, <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* getStub 为 true，直通模式，将返回CameraProvider实例对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="comment">/* 获取ServiceManager代理 */</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">/* 获取CameraProvider实例对象 */</span></span><br><span class="line">            sp&lt;IBase&gt; base = pm-&gt;get(descriptor, instance).withDefault(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                base = wrapPassthrough(base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassthroughServiceManager</span> :</span> IServiceManager1_1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openLibs</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fqName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span> <span class="comment">/* continue */</span> (<span class="keyword">void</span>* <span class="comment">/* handle */</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="comment">/* lib */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="comment">/* sym */</span>)&gt;&amp; eachLib)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></span><br><span class="line">        <span class="comment">/* fqName = android.hardware.camera.provider@2.4::ICameraProvider */</span></span><br><span class="line">        <span class="keyword">size_t</span> idx = fqName.find(<span class="string">&quot;::&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="built_in">std</span>::<span class="built_in">string</span>::npos ||</span><br><span class="line">                idx + <span class="built_in">strlen</span>(<span class="string">&quot;::&quot;</span>) + <span class="number">1</span> &gt;= fqName.size()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;Invalid interface name passthrough lookup: &quot;</span> &lt;&lt; fqName;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = fqName.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = fqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">&quot;::&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* prefix = android.hardware.camera.provider@2.4-impl */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">&quot;-impl&quot;</span>;</span><br><span class="line">        <span class="comment">/* sym = HIDL_FETCH_ICameraProvider */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">&quot;HIDL_FETCH_&quot;</span> + ifaceName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</span><br><span class="line">        <span class="keyword">void</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        dlerror(); <span class="comment">// clear</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> halLibPathVndkSp = android::base::StringPrintf(</span><br><span class="line">            HAL_LIBRARY_PATH_VNDK_SP_FOR_VERSION, details::getVndkVersionStr().c_str());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR,</span><br><span class="line">                                          halLibPathVndkSp, HAL_LIBRARY_PATH_SYSTEM&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path : paths) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">&quot;.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 经过上面的一些添加转换，最终</span></span><br><span class="line"><span class="comment">                 * fullPath = /vendor/lib/hw/android.hardware.camera.provider@2.4-impl.so</span></span><br><span class="line"><span class="comment">                 * */</span></span><br><span class="line">                <span class="keyword">if</span> (path == HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">/* Lambda表达式代入 */</span></span><br><span class="line">                <span class="keyword">if</span> (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Return&lt;sp&lt;IBase&gt;&gt; <span class="title">get</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; fqName,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> hidl_string&amp; name)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        sp&lt;IBase&gt; ret = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* [&amp;] 此处为Lambda表达式，简单理解为函数指针即可，先执行 openLibs() */</span></span><br><span class="line">        openLibs(fqName, [&amp;](<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;sym) &#123;</span><br><span class="line">            <span class="comment">/* handle ：dlopen() 的返回值</span></span><br><span class="line"><span class="comment">             * lib ：android.hardware.camera.provider@2.4-impl.so</span></span><br><span class="line"><span class="comment">             * sym ：HIDL_FETCH_ICameraProvider</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            IBase* (*generator)(<span class="keyword">const</span> <span class="keyword">char</span>* name);</span><br><span class="line">            <span class="comment">/* 返回 HIDL_FETCH_ICameraProvider() 函数对应的函数地址 */</span></span><br><span class="line">            *(<span class="keyword">void</span> **)(&amp;generator) = dlsym(handle, sym.c_str());</span><br><span class="line">            <span class="keyword">if</span>(!generator) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span>* error = dlerror();</span><br><span class="line">                ......</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 执行 HIDL_FETCH_ICameraProvider() 函数，该函数返回CameraProvider实例对象保存在ret，</span></span><br><span class="line"><span class="comment">             * 所以get()函数将返回 ret </span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            ret = (*generator)(name.c_str());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                dlclose(handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// this module doesn&#x27;t provide this instance name</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actual fqname might be a subclass.</span></span><br><span class="line">            <span class="comment">// This assumption is tested in vts_treble_vintf_test</span></span><br><span class="line">            <span class="keyword">using</span> ::android::hardware::details::getDescriptor;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> actualFqName = getDescriptor(ret.get());</span><br><span class="line">            CHECK(actualFqName.size() &gt; <span class="number">0</span>);</span><br><span class="line">            registerReference(actualFqName, name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 函数传递进来的fpName为 <a href="mailto:&#97;&#x6e;&#100;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#99;&#97;&#109;&#x65;&#114;&#97;&#46;&#x70;&#114;&#111;&#x76;&#x69;&#x64;&#101;&#x72;&#64;&#50;&#x2e;&#x34;">&#97;&#x6e;&#100;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#99;&#97;&#109;&#x65;&#114;&#97;&#46;&#x70;&#114;&#111;&#x76;&#x69;&#x64;&#101;&#x72;&#64;&#50;&#x2e;&#x34;</a>::ICameraProvider ，name为 legacy/0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\<span class="keyword">default</span>\CameraProvider_2_4.cpp</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">ICameraProvider* <span class="title">HIDL_FETCH_ICameraProvider</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IMPL&gt;</span><br><span class="line"><span class="function">CameraProvider&lt;IMPL&gt;* <span class="title">getProviderImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CameraProvider&lt;IMPL&gt; *provider = <span class="keyword">new</span> CameraProvider&lt;IMPL&gt;();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ICameraProvider* <span class="title">HIDL_FETCH_ICameraProvider</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> android::hardware::camera::provider::V2_4::implementation;</span><br><span class="line">    ICameraProvider* provider = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">/* 传递进来的 name 为 legacy/0，而 kLegacyProviderName 定义为 legacy/0 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, kLegacyProviderName) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 创建LegacyCameraProviderImpl_2_4对象，构造函数将会调用initialize() 函数 */</span></span><br><span class="line">        provider = getProviderImpl&lt;LegacyCameraProviderImpl_2_4&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, kExternalProviderName) == <span class="number">0</span>) &#123;</span><br><span class="line">        provider = getProviderImpl&lt;ExternalCameraProviderImpl_2_4&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;%s: unknown instance name: %s&quot;</span>, __FUNCTION__, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> provider;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\<span class="keyword">default</span>\LegacyCameraProviderImpl_2_4.cpp</span><br><span class="line">     </span><br><span class="line">     LegacyCameraProviderImpl_2_4::LegacyCameraProviderImpl_2_4() :</span><br><span class="line">        <span class="keyword">camera_module_callbacks_t</span>(&#123;sCameraDeviceStatusChange,</span><br><span class="line">                                   sTorchModeStatusChange&#125;) &#123;</span><br><span class="line">    mInitFailed = initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LegacyCameraProviderImpl_2_4::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    <span class="comment">/* 在通过 hw_get_module() 加载HAL层so：其实是通过获取各种android属性</span></span><br><span class="line"><span class="comment">     * （在设备端可以通过 getprop 命令查看当前设备支持的属性），</span></span><br><span class="line"><span class="comment">     * 得到HAL so的名称（*variant_keys[]），而后探测、加载该HAL so库，并通</span></span><br><span class="line"><span class="comment">     * 过 dlsym() 函数返回标识符为 HAL_MODULE_INFO_SYM_AS_STR 的HMI地址</span></span><br><span class="line"><span class="comment">     * （由于各个HAL层代码最终会通过 HAL_MODULE_INFO_SYM 修饰，编译器识别到</span></span><br><span class="line"><span class="comment">     * 该符号时将会将标示地址导出为HMI符号，从而在加载HAL so时可以获取）</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* rawModule 将指向 HAL 中的 camera_module_t 类型结构体，</span></span><br><span class="line"><span class="comment">     * 此时，CameraProvider 与 camera HAL 绑定成功，可以通过</span></span><br><span class="line"><span class="comment">     * CameraProvider操作camera HAL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 创建 CameraModule 对象 */</span></span><br><span class="line">    <span class="comment">/* CameraModule.cpp：android/hardware/interfaces/camera/common/1.0/default */</span>    </span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">   <span class="comment">/* mModule-&gt;init()主要完成以下操作：</span></span><br><span class="line"><span class="comment">     * 1. 当camera HAL的 module_api_version &gt;= CAMERA_MODULE_API_VERSION_2_4，将调用HAL-&gt;init()</span></span><br><span class="line"><span class="comment">     * 2. 通过 HAL getNumberOfCameras() 获取设置camera数量，并将该参数设置为 mCameraInfoMap 容器的大小</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    err = mModule-&gt;init();</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">&quot;Loaded \&quot;%s\&quot; camera module&quot;</span>, mModule-&gt;getModuleName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup vendor tags here so HAL can setup vendor keys in camera characteristics</span></span><br><span class="line">    VendorTagDescriptor::clearGlobalVendorTagDescriptor();</span><br><span class="line">    <span class="keyword">if</span> (!setUpVendorTags()) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;%s: Vendor tag setup failed, will not be available.&quot;</span>, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup callback now because we are going to try openLegacy next</span></span><br><span class="line">    err = mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras();</span><br><span class="line">    <span class="comment">/* 将获取camera信息并保存，其中将有HAL version 信息，应用</span></span><br><span class="line"><span class="comment">     * 层将会检查HAL层版本信息从而确认调用不同的API实现相机应用</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mNumberOfLegacyCameras; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">camera_info</span> <span class="title">info</span>;</span></span><br><span class="line">        <span class="keyword">auto</span> rc = mModule-&gt;getCameraInfo(i, &amp;info);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">char</span> cameraId[kMaxCameraIdLen];</span><br><span class="line">        <span class="built_in">snprintf</span>(cameraId, <span class="keyword">sizeof</span>(cameraId), <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cameraIdStr</span><span class="params">(cameraId)</span></span>;</span><br><span class="line">        mCameraStatusMap[cameraIdStr] = CAMERA_DEVICE_STATUS_PRESENT;</span><br><span class="line"></span><br><span class="line">        addDeviceNames(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mInitFailed</span></span><br><span class="line">&#125;</span><br><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\common\<span class="number">1.0</span>\<span class="keyword">default</span>\CameraModule.cpp</span><br><span class="line"> CameraModule::CameraModule(<span class="keyword">camera_module_t</span> *<span class="keyword">module</span>) : mNumberOfCameras(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;%s: camera hardware module must not be null&quot;</span>, __FUNCTION__);</span><br><span class="line">        assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mModule = <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CameraModule::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> res = OK;</span><br><span class="line">    <span class="keyword">if</span> (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp;</span><br><span class="line">            mModule-&gt;init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ATRACE_BEGIN(<span class="string">&quot;camera_module-&gt;init&quot;</span>);</span><br><span class="line">        res = mModule-&gt;init();</span><br><span class="line">        ATRACE_END();</span><br><span class="line">    &#125;</span><br><span class="line">    mNumberOfCameras = getNumberOfCameras();</span><br><span class="line">    mCameraInfoMap.setCapacity(mNumberOfCameras);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 01-18 08:50:15.868   264   264 I <a href="mailto:&#67;&#97;&#109;&#80;&#114;&#x76;&#100;&#x72;&#x40;&#x32;&#x2e;&#x34;&#x2d;&#108;&#101;&#x67;&#97;&#x63;&#121;">&#67;&#97;&#109;&#80;&#114;&#x76;&#100;&#x72;&#x40;&#x32;&#x2e;&#x34;&#x2d;&#108;&#101;&#x67;&#97;&#x63;&#121;</a>: Loaded “Rockchip Camera3HAL Module” camera module</p>
</blockquote>
<p>至此，已获得CameraProvider实例对象，最终返回赋值给 registerPassthroughServiceImplementation() 函数中的 service 。</p>
<h4 id="（2）、将-CameraProvider-注册为服务"><a href="#（2）、将-CameraProvider-注册为服务" class="headerlink" title="（2）、将 CameraProvider 注册为服务"></a>（2）、将 CameraProvider 注册为服务</h4><p>在得到CameraProvider实例对象之后，将通过 service-&gt;registerAsService(name) 进行服务注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/Khadas_Edge_Android_Q/out/soong/.intermediates/hardware/interfaces/camera/provider/<span class="number">2.4</span>/android.hardware.camera.provider@<span class="number">2.4</span>_genc++/gen/android/hardware/camera/provider/<span class="number">2.4</span>/CameraProviderAll.cpp</span><br><span class="line">    </span><br><span class="line">    ::<span class="function">android::<span class="keyword">status_t</span> <span class="title">ICameraProvider::registerAsService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::registerAsServiceInternal(<span class="keyword">this</span>, serviceName);</span><br><span class="line">&#125;</span><br><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\ServiceManagement.cpp</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">registerAsServiceInternal</span><span class="params">(<span class="keyword">const</span> sp&lt;IBase&gt;&amp; service, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    sp&lt;IServiceManager1_2&gt; sm = defaultServiceManager1_2();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> registered = <span class="literal">false</span>;</span><br><span class="line">    Return&lt;<span class="keyword">void</span>&gt; ret = service-&gt;interfaceChain([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; chain) &#123;</span><br><span class="line">        registered = sm-&gt;addWithChain(name.c_str(), service, chain).withDefault(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">        onRegistrationImpl(getDescriptor(service.get()), name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registered ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\ServiceManagement.cpp</span><br><span class="line">    <span class="function">Return&lt;<span class="keyword">bool</span>&gt; <span class="title">ServiceManager::addWithChain</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> hidl_vec&lt;hidl_string&gt;&amp; chain)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> callingContext = getBinderCallingContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addImpl(name, service, chain, callingContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceManager::addImpl</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> hidl_vec&lt;hidl_string&gt;&amp; interfaceChain,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> AccessControl::CallingContext&amp; callingContext)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; interfaceChain.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fqName = interfaceChain[i];</span><br><span class="line"></span><br><span class="line">        PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName];</span><br><span class="line">        HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ifaceMap.insertService(</span><br><span class="line">                <span class="built_in">std</span>::make_unique&lt;HidlService&gt;(fqName, name, service, callingContext.pid));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hidlService-&gt;setService(service, callingContext.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ifaceMap.sendPackageRegistrationNotification(fqName, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> linkRet = service-&gt;linkToDeath(<span class="keyword">this</span>, kServiceDiedCookie).withDefault(<span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排除一切问题后，把需要注册的服务，注册到mServiceMap中，最后建立一个linkToDeath，当服务挂掉时会接收到通知，做一些清理工作。注册好服务之后，camerservice就可以获取到。</p>
<h4 id="（3）、总结："><a href="#（3）、总结：" class="headerlink" title="（3）、总结："></a>（3）、总结：</h4><p>在系统初始化的时候，系统会去运行<a href="mailto:&#97;&#x6e;&#100;&#x72;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#46;&#99;&#x61;&#x6d;&#101;&#114;&#97;&#x2e;&#112;&#114;&#x6f;&#118;&#x69;&#100;&#x65;&#x72;&#64;&#x32;&#x2e;&#52;&#45;&#115;&#x65;&#x72;&#118;&#x69;&#99;&#x65;">&#97;&#x6e;&#100;&#x72;&#111;&#x69;&#x64;&#x2e;&#104;&#x61;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#46;&#99;&#x61;&#x6d;&#101;&#114;&#97;&#x2e;&#112;&#114;&#x6f;&#118;&#x69;&#100;&#x65;&#x72;&#64;&#x32;&#x2e;&#52;&#45;&#115;&#x65;&#x72;&#118;&#x69;&#99;&#x65;</a>程序启动Provider进程，并加入HW Service Manager中接受统一管理，在该过程中实例化了一个LegacyCameraProviderImpl_2_4对象，并在其构造函数中通过hw_get_module标准方法获取HAL的camera_module_t结构体,并将其存入CameraModule对象中，之后通过调用该camera_modult_t结构体的init方法初始化HAL Module，紧接着调用其get_number_of_camera方法获取当前HAL支持的Camera数量，最后通过调用其set_callbacks方法将LegcyCameraProviderImpl_2_4（LegcyCameraProviderImpl_2_4继承了camera_modult_callback_t）作为参数传入camera.rk30board.so中，接受来自camera.rk30board.so中的数据以及事件，当这一系列动作完成了之后，Camera Provider进程便一直便存在于系统中，监听着来自Camera Service的调用。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/Camera_Provider_Interface.png"></p>
<p>接下来以上图为例简单介绍下Provider中几个重要流程：</p>
<ul>
<li><p>Camera Service通过调用ICameraProvider的getCameraDeviceInterface_v3_x接口获取ICameraDevice，在此过程中，Provider会去实例化一个CameraDevice对象，并且将之前存有camera_modult_t结构体的CameraModule对象传入CameraDevice中，这样就可以在CameraDevice内部通过CameraModule访问到camera_module_t的相关资源，然后将CameraDevice内部类TrampolineSessionInterface_3_3（该类继承并实现了ICameraDevice接口）返回给Camera Service。</p>
</li>
<li><p>Camera Service通过之前获取的ICameraDevice，调用其open方法来打开Camera设备，接着在Provider中会去调用CameraDevice对象的open方法，在该方法内部会去调用camera_module_t结构体的open方法，从而获取到HAL部分的camera3_device_t结构体，紧接着Provider会实例化一个CameraDeviceSession对象，并且将刚才获取到的camera3_device_t结构体以参数的方式传入CameraDeviceSession中，在CameraDeviceSession的构造方法中又会调用CameraDeviceSession的initialize方法，在该方法内部又会去调用camera3_device_t结构体的ops内的initialize方法开始HAL部分的初始化工作，最后CameraDeviceSession对象被作为camera3_callback_ops的实现传入HAL，接收来自HAL的数据或者具体事件，当一切动作都完成后，Provider会将CameraDeviceSession::TrampolineDeviceInterface_3_2（该类继承并实现了ICameraDeviceSession接口）对象通过HIDL回调的方法返回给Camera Service中。</p>
</li>
<li><p>Camera Service通过调用ICameraDevcieSession的configureStreams_3_3接口进行数据流的配置，在Provider中，最终会通过调用之前获取的camera3_device_t结构体内ops的configure_streams方法下发到HAL中进行处理。</p>
</li>
<li><p>Camera Service通过调用ICameraDevcieSession的processCaptureRequest接口下发request请求到Provider中，在Provider中，最终依然会通过调用获取的camera3_device_t结构体内ops中的process_capture_request方法将此次请求下发到HAL中进行处理。</p>
</li>
</ul>
<p>从整个流程不难看出，这几个接口最终对应的是HAL3的接口，并且Provider并没有经过太多复杂的额外的处理。</p>
<h2 id="（三）、Camera-HAL3-接口"><a href="#（三）、Camera-HAL3-接口" class="headerlink" title="（三）、Camera HAL3 接口"></a>（三）、Camera HAL3 接口</h2><p>HAL硬件抽象层(Hardware Abstraction Layer)，是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层， 每一个平台厂商可以将不开源的代码封装在这一层，仅仅提供二进制文件。<br>该层定义了自己的一套通用标准接口，平台厂商务必按照以下规则定义自己的Module:</p>
<ul>
<li>每一个硬件模块都通过hw_module_t来描述，具有固定的名字HMI</li>
<li>每一个硬件模块都必须实现hw_module_t里面的open方法，用于打开硬件设备，并返回对应的操作接口集合</li>
<li>硬件的操作接口集合使用hw_device_t 来描述，并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li>
</ul>
<p>其中代表硬件模块的是hw_module_t，对应的设备是通过hw_device_t来描述，这两者的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\hardware.h</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** tag must be initialized to HARDWARE_MODULE_TAG */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The API version of the implemented module. The module owner is</span></span><br><span class="line"><span class="comment">     * responsible for updating the version when a module interface has</span></span><br><span class="line"><span class="comment">     * changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Identifier of module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Name of this module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Author/owner/implementor of the module */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Modules methods */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** module&#x27;s dso */</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/** padding to 128 bytes, reserved for future use */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** reference to the module this device belongs to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** padding reserved for future use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Close this device */</span></span><br><span class="line">    <span class="keyword">int</span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的定义可以看出，主要是通过hw_module_t 代表了模块，通过其open方法用来打开一个设备，而该设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外，并无其它方法，由此可见谷歌定义的HAL接口，并不能满足绝大部分HAL模块的需要，所以谷歌想出了一个比较好的解决方式，那便是将这两个基本结构嵌入到更大的结构体内部，同时在更大的结构内部定义了各自模块特有的方法，用于实现模块的功能，这样，一来对上保持了HAL的统一规范，二来也扩展了模块的功能。</p>
<p>基于上面的方式，谷歌便针对Camera 提出了HAL3接口，其中主要包括了用于代表一系列操作主体的结构体以及具体操作函数，接下来我们分别进行详细介绍：</p>
<h4 id="（1）、camera-module"><a href="#（1）、camera-module" class="headerlink" title="（1）、camera_module"></a>（1）、camera_module</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\camera_common.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common methods of the camera module.  This *must* be the first member of</span></span><br><span class="line"><span class="comment">     * camera_module as users of this structure will cast a hw_module_t to</span></span><br><span class="line"><span class="comment">     * camera_module pointer in contexts where it&#x27;s known the hw_module_t</span></span><br><span class="line"><span class="comment">     * references a camera_module.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras:</span></span><br><span class="line"><span class="comment">     * Returns the number of camera devices accessible through the camera</span></span><br><span class="line"><span class="comment">     * module.  The camera devices are numbered 0 through N-1, where N is the</span></span><br><span class="line"><span class="comment">     * value returned by this call. The name of the camera device for open() is</span></span><br><span class="line"><span class="comment">     * simply the number converted to a string. That is, &quot;0&quot; for camera ID 0,</span></span><br><span class="line"><span class="comment">     * &quot;1&quot; for camera ID 1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_camera_info:</span></span><br><span class="line"><span class="comment">     * Return the static camera information for a given camera device. This</span></span><br><span class="line"><span class="comment">     * information may not change for a camera device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_callbacks:</span></span><br><span class="line"><span class="comment">     * Provide callback function pointers to the HAL module to inform framework</span></span><br><span class="line"><span class="comment">     * of asynchronous camera module events. The framework will call this</span></span><br><span class="line"><span class="comment">     * function once after initial camera HAL module load, after the</span></span><br><span class="line"><span class="comment">     * get_number_of_cameras() method is called for the first time, and before</span></span><br><span class="line"><span class="comment">     * any other calls to the module.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open_legacy:</span></span><br><span class="line"><span class="comment">     * Open a specific legacy camera HAL device if multiple device HAL API</span></span><br><span class="line"><span class="comment">     * versions are supported by this camera HAL module. For example, if the</span></span><br><span class="line"><span class="comment">     * camera module supports both CAMERA_DEVICE_API_VERSION_1_0 and</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_2 device API for the same camera id,</span></span><br><span class="line"><span class="comment">     * framework can call this function to open the camera device as</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_1_0 device.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set_torch_mode:</span></span><br><span class="line"><span class="comment">     * Turn on or off the torch mode of the flash unit associated with a given</span></span><br><span class="line"><span class="comment">     * camera ID. If the operation is successful, HAL must notify the framework</span></span><br><span class="line"><span class="comment">     * torch state by invoking</span></span><br><span class="line"><span class="comment">     * camera_module_callbacks.torch_mode_status_change() with the new state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init:</span></span><br><span class="line"><span class="comment">     * This method is called by the camera service before any other methods</span></span><br><span class="line"><span class="comment">     * are invoked, right after the camera HAL library has been successfully</span></span><br><span class="line"><span class="comment">     * loaded. It may be left as NULL by the HAL module, if no initialization</span></span><br><span class="line"><span class="comment">     * in needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*init)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_physical_camera_info:</span></span><br><span class="line"><span class="comment">     * Return the static metadata for a physical camera as a part of a logical</span></span><br><span class="line"><span class="comment">     * camera device. This function is only called for those physical camera</span></span><br><span class="line"><span class="comment">     * ID(s) that are not exposed independently. In other words, camera_id will</span></span><br><span class="line"><span class="comment">     * be greater or equal to the return value of get_number_of_cameras().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,</span><br><span class="line">            <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is_stream_combination_supported:</span></span><br><span class="line"><span class="comment">     * Check for device support of specific camera stream combination.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify_device_state_change:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Notify the camera module that the state of the overall device has</span></span><br><span class="line"><span class="comment">     * changed in some way that the HAL may want to know about.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由定义不难发现，camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法，而camera3_device_t包含了hw_device_t，主要用来表示Camera设备，其中定义了camera3_device_ops操作方法集合，用来实现正常获取图像数据以及控制Camera的功能。</p>
<h4 id="（2）、camera3-stream-configuration"><a href="#（2）、camera3-stream-configuration" class="headerlink" title="（2）、camera3_stream_configuration"></a>（2）、camera3_stream_configuration</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\camera3.h</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_configuration</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The total number of streams requested by the framework.  This includes</span></span><br><span class="line"><span class="comment">     * both input and output streams. The number of streams will be at least 1,</span></span><br><span class="line"><span class="comment">     * and there will be at least one output-capable stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> num_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of camera stream pointers, defining the input/output</span></span><br><span class="line"><span class="comment">     * configuration for the camera HAL device.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At most one input-capable stream may be defined (INPUT or BIDIRECTIONAL)</span></span><br><span class="line"><span class="comment">     * in a single configuration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * At least one output-capable stream must be defined (OUTPUT or</span></span><br><span class="line"><span class="comment">     * BIDIRECTIONAL).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> **streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_3:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The operation mode of streams in this configuration, one of the value</span></span><br><span class="line"><span class="comment">     * defined in camera3_stream_configuration_mode_t.  The HAL can use this</span></span><br><span class="line"><span class="comment">     * mode as an indicator to set the stream property (e.g.,</span></span><br><span class="line"><span class="comment">     * camera3_stream-&gt;max_buffers) appropriately. For example, if the</span></span><br><span class="line"><span class="comment">     * configuration is</span></span><br><span class="line"><span class="comment">     * CAMERA3_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE, the HAL may</span></span><br><span class="line"><span class="comment">     * want to set aside more buffers for batch mode operation (see</span></span><br><span class="line"><span class="comment">     * android.control.availableHighSpeedVideoConfigurations for batch mode</span></span><br><span class="line"><span class="comment">     * definition).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> operation_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &gt;= CAMERA_DEVICE_API_VERSION_3_5:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The session metadata buffer contains the initial values of</span></span><br><span class="line"><span class="comment">     * ANDROID_REQUEST_AVAILABLE_SESSION_KEYS. This field is optional</span></span><br><span class="line"><span class="comment">     * and camera clients can choose to ignore it, in which case it will</span></span><br><span class="line"><span class="comment">     * be set to NULL. If parameters are present, then Hal should examine</span></span><br><span class="line"><span class="comment">     * the parameter values and configure its internal camera pipeline</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span> *session_parameters;</span><br><span class="line">&#125; <span class="keyword">camera3_stream_configuration_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该结构体主要用来代表配置的数据流列表，内部装有上层需要进行配置的数据流的指针，内部的定义简单介绍下：</p>
<ul>
<li>num_streams: 代表了来自上层的数据流的数量，其中包括了output以及input stream。</li>
<li>streams: 是streams的指针数组，包括了至少一条output stream以及至多一条input stream。</li>
<li>operation_mode: 当前数据流的操作模式，该模式在camera3_stream_configuration_mode_t中被定义，HAL通过这个参数可以针对streams做不同的设置。</li>
<li>session_parameters: 该参数可以作为缺省参数，直接设置为NULL即可，CAMERA_DEVICE_API_VERSION_3_5以上的版本才支持。</li>
</ul>
<h4 id="（3）、camera3-stream-t"><a href="#（3）、camera3-stream-t" class="headerlink" title="（3）、camera3_stream_t"></a>（3）、camera3_stream_t</h4><p>结构体camera3_stream_t的代码定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\camera3.h</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by framework before configure_streams()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of the stream, one of the camera3_stream_type_t values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stream_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The width in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The height in pixels of the buffers in this stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The pixel format for the buffers in this stream. Format is a value from</span></span><br><span class="line"><span class="comment">     * the HAL_PIXEL_FORMAT_* list in system/core/include/system/graphics.h, or</span></span><br><span class="line"><span class="comment">     * from device-specific headers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****</span></span><br><span class="line"><span class="comment">     * Set by HAL during configure_streams().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The gralloc usage flags for this stream, as needed by the HAL. The usage</span></span><br><span class="line"><span class="comment">     * flags are defined in gralloc.h (GRALLOC_USAGE_*), or in device-specific</span></span><br><span class="line"><span class="comment">     * headers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum number of buffers the HAL device may need to have dequeued at</span></span><br><span class="line"><span class="comment">     * the same time. The HAL device may not have more buffers in-flight from</span></span><br><span class="line"><span class="comment">     * this stream than this value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> max_buffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A handle to HAL-private information for the stream. Will not be inspected</span></span><br><span class="line"><span class="comment">     * by the framework code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A field that describes the contents of the buffer. The format and buffer</span></span><br><span class="line"><span class="comment">     * dimensions define the memory layout and structure of the stream buffers,</span></span><br><span class="line"><span class="comment">     * while dataSpace defines the meaning of the data within the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">android_dataspace_t</span> data_space;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rotation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The physical camera id this stream belongs to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* physical_camera_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_t</span>;</span><br></pre></td></tr></table></figure>

<p>该结构体主要用来代表具体的数据流实体，在整个的配置过程中，需要在上层进行填充，当下发到HAL中后，HAL会针对其中的各项属性进行配置，这里便简单介绍下其内部的各个元素的意义：</p>
<ul>
<li>stream_type: 表示数据流的类型，类型在camera3_stream_type_t中被定义。</li>
<li>width： 表示当前数据流中的buffer的宽度。</li>
<li>height: 表示当前数据流中buffer的高度。</li>
<li>format: 表示当前数据流中buffer的格式，该格式是在system/core/include/system/graphics.h中被定义。</li>
<li>usage： 表示当前数据流的gralloc用法，其用法定义在gralloc.h中。</li>
<li>max_buffers： 指定了当前数据流中可能支持的最大数据buffer数量。</li>
<li>data_space: 指定了当前数据流buffer中存储的图像数据的颜色空间。</li>
<li>rotation：指定了当前数据流的输出buffer的旋转角度，其角度的定义在camera3_stream_rotation_t中，该参数由Camera Service进行设置，必须在HAL中进行设置，该参数对于input stream并没有效果。</li>
<li>physical_camera_id： 指定了当前数据流从属的物理camera Id。</li>
</ul>
<h4 id="（4）、camera3-stream-buffer-t"><a href="#（4）、camera3-stream-buffer-t" class="headerlink" title="（4）、camera3_stream_buffer_t"></a>（4）、camera3_stream_buffer_t</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_stream_buffer</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The handle of the stream this buffer is associated with</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">camera3_stream_t</span> *stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The native handle to the buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">buffer_handle_t</span> *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Current state of the buffer, one of the camera3_buffer_status_t</span></span><br><span class="line"><span class="comment">     * values. The framework will not pass buffers to the HAL that are in an</span></span><br><span class="line"><span class="comment">     * error state. In case a buffer could not be filled by the HAL, it must</span></span><br><span class="line"><span class="comment">     * have its status set to CAMERA3_BUFFER_STATUS_ERROR when returned to the</span></span><br><span class="line"><span class="comment">     * framework with process_capture_result().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The acquire sync fence for this buffer. The HAL must wait on this fence</span></span><br><span class="line"><span class="comment">     * fd before attempting to read from or write to this buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">int</span> acquire_fence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The release sync fence for this buffer. The HAL must set this fence when</span></span><br><span class="line"><span class="comment">     * returning buffers to the framework, or write -1 to indicate that no</span></span><br><span class="line"><span class="comment">     * waiting is required for this buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> release_fence;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_stream_buffer_t</span>;</span><br></pre></td></tr></table></figure>

<p>该结构体主要用来代表具体的buffer对象，其中重要元素如下：</p>
<ul>
<li>stream: 代表了从属的数据流</li>
<li>buffer：buffer句柄</li>
</ul>
<h4 id="（5）、核心接口函数解析"><a href="#（5）、核心接口函数解析" class="headerlink" title="（5）、核心接口函数解析"></a>（5）、核心接口函数解析</h4><p>HAL3的核心接口都是在camera3_device_ops中被定义，代码定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\camera3.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize:</span></span><br><span class="line"><span class="comment">     * One-time initialization to pass framework callback function pointers to</span></span><br><span class="line"><span class="comment">     * the HAL. Will be called once after a successful open() call, before any</span></span><br><span class="line"><span class="comment">     * other functions are called on the camera3_device_ops structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*initialize)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_callback_ops_t</span> *callback_ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Stream management</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * configure_streams:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CAMERA_DEVICE_API_VERSION_3_0 only:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Reset the HAL camera device processing pipeline and set up new input and</span></span><br><span class="line"><span class="comment">     * output streams. This call replaces any existing stream configuration with</span></span><br><span class="line"><span class="comment">     * the streams defined in the stream_list. This method will be called at</span></span><br><span class="line"><span class="comment">     * least once after initialize() before a request is submitted with</span></span><br><span class="line"><span class="comment">     * process_capture_request().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*configure_streams)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_stream_configuration_t</span> *stream_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * register_stream_buffers:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*register_stream_buffers)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_set_t</span> *buffer_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Request creation and submission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * construct_default_request_settings:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Create capture settings for standard camera use cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The device must return a settings buffer that is configured to meet the</span></span><br><span class="line"><span class="comment">     * requested use case, which must be one of the CAMERA3_TEMPLATE_*</span></span><br><span class="line"><span class="comment">     * enums. All request control fields must be included.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* (*construct_default_request_settings)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">int</span> type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_request:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send a new capture request to the HAL. The HAL should not return from</span></span><br><span class="line"><span class="comment">     * this call until it is ready to accept the next request to process. Only</span></span><br><span class="line"><span class="comment">     * one call to process_capture_request() will be made at a time by the</span></span><br><span class="line"><span class="comment">     * framework, and the calls will all be from the same thread. The next call</span></span><br><span class="line"><span class="comment">     * to process_capture_request() will be made as soon as a new request and</span></span><br><span class="line"><span class="comment">     * its associated buffers are available. In a normal preview scenario, this</span></span><br><span class="line"><span class="comment">     * means the function will be called again by the framework almost</span></span><br><span class="line"><span class="comment">     * instantly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*process_capture_request)(<span class="keyword">const</span> struct camera3_device *,</span><br><span class="line">            <span class="keyword">camera3_capture_request_t</span> *request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">     * Miscellaneous methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get_metadata_vendor_tag_ops:</span></span><br><span class="line"><span class="comment">     * Get methods to query for vendor extension metadata tag information. The</span></span><br><span class="line"><span class="comment">     * HAL should fill in all the vendor tag operation methods, or leave ops</span></span><br><span class="line"><span class="comment">     * unchanged if no vendor tags are defined.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*get_metadata_vendor_tag_ops)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">vendor_tag_query_ops_t</span>* ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dump)(<span class="keyword">const</span> struct camera3_device *, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*flush)(<span class="keyword">const</span> struct camera3_device *);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*signal_stream_flush)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_streams,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_t</span>* <span class="keyword">const</span>* streams);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> (*is_reconfiguration_required)(<span class="keyword">const</span> struct camera3_device*,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* old_session_params,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera_metadata_t</span>* new_session_params);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span> *reserved[<span class="number">6</span>];</span><br><span class="line">&#125; <span class="keyword">camera3_device_ops_t</span>;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看见，该结构体定义了一系列的函数指针，用来指向平台厂商实际的实现方法，接下来就其中几个方法简单介绍下：</p>
<p><strong>a) initialize</strong><br>该方法必须在camera_module_t中的open方法之后，其它camera3_device_ops中方法之前被调用，主要用来将上层实现的回调方法注册到HAL中，并且根据需要在该方法中加入自定义的一些初始化操作，另外，谷歌针对该方法在性能方面也有严格的限制，该方法需要在5ms内返回，最长不能超过10ms。</p>
<p><strong>b) configure_streams</strong><br>该方法在完成initialize方法之后，在调用process_capture_request方法之前被调用，主要用于重设当前正在运行的Pipeline以及设置新的输入输出流，其中它会将stream_list中的新的数据流替换之前配置的数据流。在调用该方法之前必须确保没有新的request下发并且当前request的动作已经完成，否则会引起无法预测的错误。一旦HAL调用了该方法，则必须在内部配置好满足当前数据流配置的帧率，确保这个流程的运行的顺畅性。<br>其中包含了两个参数，分别是camera3_device以及stream_list(camera3_stream_configuration_t ),其中第二个参数是上层传入的数据流配置列表，该列表中必须包含至少一个output stream，同时至多包含一个input stream。<br>另外，谷歌针对该方法有着严格的性能要求，平台厂商在实现该方法的时候，需要在500ms内返回，最长不能超过1000ms。</p>
<p><strong>c) construct_default_request_settings</strong><br>该方法主要用于构建一系列默认的Camera Usecase的capture 设置项，通过camera_metadata_t来进行描述，其中返回值是一个camera_metadata_t指针，其指向的内存地址是由HAL来进行维护的，同样地，该方法需要在1ms内返回，最长不能超过5ms。</p>
<p><strong>d) process_capture_request</strong><br>该方法用于下发单次新的capture request到HAL中， 上层必须保证该方法的调用都是在一个线程中完成，而且该方法是异步的，同时其结果并不是通过返回值给到上层，而是通过HAL调用另一个接口process_capture_result()来将结果返回给上层的，在使用的过程中，通过in-flight机制，保证短时间内下发足够多的request，从而满足帧率要求。</p>
<p>该方法的性能依然受到谷歌的严格要求，规定其需要在一帧图像处理完的时长内返回，最长不超过4帧图像处理完成的时长，比如当前预览帧率是30帧，则该方法的操作耗时最长不能超过120ms，否则便会引起明显的帧抖动，从而影响用户体验。</p>
<p><strong>e) dump</strong><br>该方法用于打印当前Camera设备的状态，一般是由上层通过dumpsys工具输出debug dump信息或者主动抓取bugreport的时候被调用，该方法必须是非阻塞实现，同时需要保证在1ms内返回，最长不能超过10ms。</p>
<p><strong>f) flush</strong><br>当上层需要执行新的configure_streams的时候，需要调用该方法去尽可能快地清除掉当前已经在处理中的或者即将处理的任务，为配置数据流提供一个相对稳定的环境，其具体工作如下：</p>
<ul>
<li>所有的还在流转的request会尽可能快的返回</li>
<li>并未开始进行流转的request会直接返回，并携带错误信息</li>
<li>任何可以打断的硬件操作会立即被停止</li>
<li>任何无法进行打断的硬件操作会在当前状态下进行休眠</li>
</ul>
<p>flush会在所有的buffer都得以释放，所有request都成功返回后才真正返回，该方法需要在100ms内返回，最长不能超过1000ms。</p>
<p>上面的一系列方法是上层直接对下控制Camera Hal，而一旦Camera Hal产生了数据或者事件的时候，可以通过camera3_callback_ops中定义的回调方法将数据或者事件返回至上层，该结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\hardware\libhardware\include\hardware\camera3.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_callback_ops</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * process_capture_result:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Send results from a completed capture to the framework.</span></span><br><span class="line"><span class="comment">     * process_capture_result() may be invoked multiple times by the HAL in</span></span><br><span class="line"><span class="comment">     * response to a single capture request. This allows, for example, the</span></span><br><span class="line"><span class="comment">     * metadata and low-resolution buffers to be returned in one call, and</span></span><br><span class="line"><span class="comment">     * post-processed JPEG buffers in a later call, once it is available. Each</span></span><br><span class="line"><span class="comment">     * call must include the frame number of the request it is returning</span></span><br><span class="line"><span class="comment">     * metadata or buffers for.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*process_capture_result)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_capture_result_t</span> *result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notify:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Asynchronous notification callback from the HAL, fired for various</span></span><br><span class="line"><span class="comment">     * reasons. Only for information independent of frame capture, or that</span></span><br><span class="line"><span class="comment">     * require specific timing. The ownership of the message structure remains</span></span><br><span class="line"><span class="comment">     * with the HAL, and the msg only needs to be valid for the duration of this</span></span><br><span class="line"><span class="comment">     * call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*notify)(<span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_notify_msg_t</span> *msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">camera3_buffer_request_status_t</span> (*request_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffer_reqs,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_buffer_request_t</span> *buffer_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">uint32_t</span> *num_returned_buf_reqs,</span><br><span class="line">            <span class="comment">/*out*/</span><span class="keyword">camera3_stream_buffer_ret_t</span> *returned_buf_reqs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*return_stream_buffers)(</span><br><span class="line">            <span class="keyword">const</span> struct camera3_callback_ops *,</span><br><span class="line">            <span class="keyword">uint32_t</span> num_buffers,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span>* <span class="keyword">const</span>* buffers);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">camera3_callback_ops_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中常用的回调方法主要有两个：用于返回数据的process_capture_result以及用于返回事件的notify，接下来分别介绍下：</p>
<p><strong>1、process_capture_result</strong><br>该方法用于返回HAL部分产生的metadata和image buffers，它与request是多对一的关系，同一个request，可能会对应到多个result，比如可以通过调用一次该方法用于返回metadata以及低分辨率的图像数据，再调用一次该方法用于返回jpeg格式的拍照数据，而这两次调用时对应于同一个process_capture_request动作。</p>
<p>同一个Request的Metadata以及Image Buffers的先后顺序无关紧要，但是同一个数据流的不同Request之间的Result必须严格按照Request的下发先后顺序进行依次返回的，如若不然，会导致图像数据显示出现顺序错乱的情况。</p>
<p>该方法是非阻塞的，而且并且必须要在5ms内返回。</p>
<p><strong>2、notify</strong><br>该方法用于异步返回HAL事件到上层，必须非阻塞实现，而且要在5ms内返回。</p>
<p>谷歌为了将系统框架和平台厂商的自定义部分相分离，在Android上推出了Treble项目，该项目直接将平台厂商的实现部分放入vendor分区中进行管理，进而与system分区保持隔离，这样便可以在相互独立的空间中进行各自的迭代升级，而互不干扰，而在相机框架体系中，便将Camera HAL Module从Camera Service中解耦出来，放入独立进程Camera Provider中进行管理，而为了更好的进行跨进程访问，谷歌针对Provider提出了HIDL机制用于Camera Servic对于Camera Provier的访问，而HIDL接口的实现是在Camera Provider中实现，针对Camera HAL Module的控制又是通过谷歌制定的Camera HAL3接口来完成，所以由此看来，Provider的职责也比较简单，通过HIDL机制保持与Camera Service的通信，通过HAL3接口控制着Camera HAL Module。</p>
<h2 id="（四）、Camera-Service启动流程概览"><a href="#（四）、Camera-Service启动流程概览" class="headerlink" title="（四）、Camera Service启动流程概览"></a>（四）、Camera Service启动流程概览</h2><p>系统启动时，就会启动 CameraProvider 服务。它将 Camera HAL 从 cameraserver 进程中分离出来，作为一个独立进程 <a href="mailto:&#97;&#x6e;&#x64;&#114;&#x6f;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#97;&#x72;&#101;&#x2e;&#x63;&#x61;&#x6d;&#x65;&#x72;&#x61;&#46;&#112;&#114;&#x6f;&#118;&#x69;&#x64;&#101;&#114;&#x40;&#x32;&#x2e;&#x34;&#45;&#x73;&#x65;&#x72;&#x76;&#105;&#x63;&#101;">&#97;&#x6e;&#x64;&#114;&#x6f;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#97;&#x72;&#101;&#x2e;&#x63;&#x61;&#x6d;&#x65;&#x72;&#x61;&#46;&#112;&#114;&#x6f;&#118;&#x69;&#x64;&#101;&#114;&#x40;&#x32;&#x2e;&#x34;&#45;&#x73;&#x65;&#x72;&#x76;&#105;&#x63;&#101;</a> 来控制 HAL。<br>这两个进程之间通过 HIDL 机制进行通信。它的主要功能（如下图所示）是将 service 与 HAL 隔离，以方便 HAL 部分进行独立升级。这其实和 APP 与 Framework 之间的 Binder 机制类似，通过引入一个进程间通信机制而针对不同层级进行解耦（从 Local call 变成了 Remote call）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/Cameraserver_treble.png"></p>
<p>总体逻辑顺序：</p>
<ul>
<li><p>provider 进程启动，注册；</p>
</li>
<li><p>cameraserver 进程启动，注册，初始化；</p>
</li>
<li><p>cameraserver 获取远端 provider（此时实例化 CameraProvider 并初始化）。<br>上图中，实线箭头是调用关系。左边是 cameraserver 进程中的动作，右边则是 provider 进程中的动作，它们之间通过 ICameraProvider 联系在了一起，而这个东西与 HIDL 相关，我们可以不用关心它的实现方式。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android.10.Camera.06/cameraserver_hidl_cameraprovier.png"></p>
</li>
</ul>
<p>由图可见：</p>
<ul>
<li>cameraserver 一侧，Cameraservice 类依旧是主体。它通过 CameraProviderManager 来管理对 CameraProvider 的操作。此处初始化的最终目的是连接上 CameraProvider。</li>
<li>provider 一侧，最终主体是 CameraProvider。初始化最终目的是得到一个 mModule，通过它可以直接与 HAL 接口定义层进行交互。</li>
</ul>
<h4 id="（1）、CameraService-的启动与初始化"><a href="#（1）、CameraService-的启动与初始化" class="headerlink" title="（1）、CameraService 的启动与初始化"></a>（1）、CameraService 的启动与初始化</h4><p>一般来说应该是 Provider 服务先启动，然后 Cameraserver 再启动，并 ”连接“ 到 Provider。前面已经分析了 Provider 的启动，现在就来看看 Cameraserver 的启动流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\camera\cameraserver\cameraserver.rc</span><br><span class="line">    service cameraserver /system/bin/cameraserver</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">audio</span> <span class="title">camera</span> <span class="title">input</span> <span class="title">drmrpc</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">ioprio</span> <span class="title">rt</span> 4</span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">camera</span>-<span class="title">daemon</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">top</span>-<span class="title">app</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">rlimit</span> <span class="title">rtprio</span> 10 10</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">F</span>:</span>\Khadas_Edge_Android_Q\frameworks\av\camera\cameraserver\main_cameraserver.cpp</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">&quot;cameraserver&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NDEBUG 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CameraService.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/HidlTransportSupport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span>** argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set 5 threads for HIDL calls. Now cameraserver will serve HIDL calls in</span></span><br><span class="line">    <span class="comment">// addition to consuming them from the Camera HAL as well.</span></span><br><span class="line">    hardware::configureRpcThreadpool(<span class="number">5</span>, <span class="comment">/*willjoin*/</span> <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="comment">//defaultServiceManager的实现容易混淆，系统中有两个实现，在调用时需要注意方法所在的域，</span></span><br><span class="line">    <span class="comment">/* 获得 ServiceManager 的代理类 BpServiceManager, 注意不是 HwServiceManager 的代理类</span></span><br><span class="line"><span class="comment">     * ServiceManager 这个服务管理器是用来跟上层framework交互的，原理跟 HwServiceManager一样</span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ALOGI(<span class="string">&quot;ServiceManager: %p done instantiate&quot;</span>, sm.get());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//01-18 08:50:15.771   326   326 I cameraserver: ServiceManager: 0xe90231a0</span></span><br><span class="line"><span class="comment">//01-18 08:50:15.771   326   326 I CameraService: CameraService started (pid=326)</span></span><br><span class="line"><span class="comment">//01-18 08:50:15.772   326   326 I CameraService: CameraService process starting</span></span><br></pre></td></tr></table></figure>

<p>实例化只有简单的一行代码，但实例化的过程并不那么简单。这个 instantiate() 接口并不是定义在 CameraService 类中的，而是定义在 BinderService 类里（而 CameraService 继承了它）。在此处，它的作用是创建一个 CameraService（通过 new 的方式），并将其加入到 ServiceManager 中（注意，在这一过程中，CameraService 被强指针引用了）。</p>
<p>==<strong>CameraService::instantiate()的实现，将CameraService注册到ServiceManager</strong>==</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\CameraService.h</span><br><span class="line">    <span class="comment">//注册的SERVICE：&quot;media.camera&quot;</span></span><br><span class="line">    <span class="comment">// Implementation of BinderService&lt;T&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">getServiceName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;media.camera&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\frameworks\native\libs\binder\include\binder\BinderService.h</span><br><span class="line">    <span class="comment">/*BinderService 是 CameraService 的父类，模板类 SERVICE = CameraService*/</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> SERVICE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderService</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">status_t</span> <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> dumpFlags = IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 得到ServiceManager的代理类BpServiceManager*/</span></span><br><span class="line">        <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">        <span class="comment">/* SERVICE = CameraService， 注册CameraService 实例化对象*/</span></span><br><span class="line">        <span class="comment">/*new CameraService() 得到实例化对象，智能指针第一次引用回调用 onFirstRef() 函数, 后面分析*/</span></span><br><span class="line">        <span class="keyword">return</span> sm-&gt;addService(String16(SERVICE::getServiceName()), <span class="keyword">new</span> SERVICE(), allowIsolated,</span><br><span class="line">                              dumpFlags);<span class="comment">//注册的SERVICE：&quot;media.camera&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 静态类属性的， 所以可以直接调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span> </span>&#123; publish(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">status_t</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> NO_ERROR; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>由于首次被强指针引用时，就会调用 <code>onFirstRef()</code> 函数执行初始化之类的业务逻辑，所以现在就看看 CameraService 在此处实现了什么逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\CameraService.cpp</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CameraService::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;CameraService process starting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update battery life tracking if service is restarting</span></span><br><span class="line">    <span class="function">BatteryNotifier&amp; <span class="title">notifier</span><span class="params">(BatteryNotifier::getInstance())</span></span>;</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> res = INVALID_OPERATION;</span><br><span class="line"></span><br><span class="line">    res = enumerateProviders();</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        mInitialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUidPolicy = <span class="keyword">new</span> UidPolicy(<span class="keyword">this</span>);</span><br><span class="line">    mUidPolicy-&gt;registerSelf();</span><br><span class="line">    mSensorPrivacyPolicy = <span class="keyword">new</span> SensorPrivacyPolicy(<span class="keyword">this</span>);</span><br><span class="line">    mSensorPrivacyPolicy-&gt;registerSelf();</span><br><span class="line">    sp&lt;HidlCameraService&gt; hcs = HidlCameraService::getInstance(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (hcs-&gt;registerAsService() != android::OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;%s: Failed to register default android.frameworks.cameraservice.service@1.0&quot;</span>,</span><br><span class="line">              __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This needs to be last call in this function, so that it&#x27;s as close to</span></span><br><span class="line">    <span class="comment">// ServiceManager::addService() as possible.</span></span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">    ALOGI(<span class="string">&quot;CameraService pinged cameraservice proxy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraService::enumerateProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; deviceIds;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">l</span><span class="params">(mServiceLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == mCameraProviderManager.get()) &#123;</span><br><span class="line">            mCameraProviderManager = <span class="keyword">new</span> CameraProviderManager();</span><br><span class="line">            res = mCameraProviderManager-&gt;initialize(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;%s: Unable to initialize camera provider manager: %s (%d)&quot;</span>,</span><br><span class="line">                        __FUNCTION__, strerror(-res), res);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setup vendor tags before we call get_camera_info the first time</span></span><br><span class="line">        <span class="comment">// because HAL might need to setup static vendor keys in get_camera_info</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> maybe put this into CameraProviderManager::initialize()?</span></span><br><span class="line">        mCameraProviderManager-&gt;setUpVendorTags();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == mFlashlight.get()) &#123;</span><br><span class="line">            mFlashlight = <span class="keyword">new</span> CameraFlashlight(mCameraProviderManager, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Failed to enumerate flash units: %s (%d)&quot;</span>, strerror(-res), res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历mProviders</span></span><br><span class="line">        deviceIds = mCameraProviderManager-&gt;getCameraDeviceIds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; cameraId : deviceIds) &#123;</span><br><span class="line">        String8 id8 = String8(cameraId.c_str());</span><br><span class="line">        <span class="keyword">if</span> (getCameraState(id8) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            onDeviceStatusChanged(id8, CameraDeviceStatus::PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先将 <code>CameraProviderManager</code> 实例化，然后调用 <code>initialize()</code> 接口将其初始化，传入的参数是 <code>this</code> 指针，指向当前 CameraService 实例的地址。</li>
<li>mServiceProxy的赋值，上面是CameraProviderManager的初始化过程，CameraProviderManager就是管理camera Service与camera provider之间通信的工程管理类，两个参数，其中第二个参数就是远程代理类。这个参数已经是默认赋值了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\common\CameraProviderManager.h</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HardwareServiceInteractionProxy</span> :</span> <span class="keyword">public</span> ServiceInteractionProxy &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> sp&lt;hardware::camera::provider::V2_4::ICameraProvider&gt; <span class="title">getService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hardware::camera::provider::V2_4::ICameraProvider::getService(serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> hardware::hidl_vec&lt;hardware::hidl_string&gt; <span class="title">listServices</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//可以看到initialize函数proxy为默认值：sHardwareServiceInteractionProxy</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">initialize</span><span class="params">(wp&lt;StatusListener&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInteractionProxy *proxy = &amp;sHardwareServiceInteractionProxy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\common\CameraProviderManager.cpp</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">CameraProviderManager::initialize</span><span class="params">(wp&lt;CameraProviderManager::StatusListener&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInteractionProxy* proxy)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mInterfaceMutex)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mServiceProxy = proxy;</span><br><span class="line">    mDeviceState = <span class="keyword">static_cast</span>&lt;hardware::hidl_bitfield&lt;provider::V2_5::DeviceState&gt;&gt;(</span><br><span class="line">        provider::V2_5::DeviceState::NORMAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Registering will trigger notifications for all already-known providers</span></span><br><span class="line">    <span class="keyword">bool</span> success = mServiceProxy-&gt;registerForNotifications(</span><br><span class="line">        <span class="comment">/* instance name, empty means no filter */</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; instance : mServiceProxy-&gt;listServices()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;addProviderLocked(instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraProviderManager::addProviderLocked</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; providerInfo : mProviders) &#123;</span><br><span class="line">        <span class="comment">//检查已知的 Provider 中是否已有名为 `legacy/0` 的。</span></span><br><span class="line">        <span class="keyword">if</span> (providerInfo-&gt;mProviderName == newProvider) &#123;</span><br><span class="line">            ALOGW(<span class="string">&quot;%s: Camera provider HAL with name &#x27;%s&#x27; already registered&quot;</span>, __FUNCTION__,</span><br><span class="line">                    newProvider.c_str());</span><br><span class="line">            <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;provider::V2_4::ICameraProvider&gt; interface;</span><br><span class="line">    <span class="comment">//根据 legacy/0 从服务代理处获取 CameraProvider 接口</span></span><br><span class="line">    interface = mServiceProxy-&gt;getService(newProvider);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//通过 ProviderInfo 来保存当前 Provider 相关信息。</span></span><br><span class="line">    sp&lt;ProviderInfo&gt; providerInfo = <span class="keyword">new</span> ProviderInfo(newProvider, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = providerInfo-&gt;initialize(interface, mDeviceState);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//记录当前 Provider。</span></span><br><span class="line">    mProviders.push_back(providerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="（2）、CameraProviderManager-ProviderInfo-initialize"><a href="#（2）、CameraProviderManager-ProviderInfo-initialize" class="headerlink" title="（2）、CameraProviderManager::ProviderInfo::initialize"></a>（2）、CameraProviderManager::ProviderInfo::initialize</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::ProviderInfo::initialize(</span><br><span class="line">        sp&lt;provider::V2_4::ICameraProvider&gt;&amp; interface,</span><br><span class="line">        hardware::hidl_bitfield&lt;provider::V2_5::DeviceState&gt; currentDeviceState) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = parseProviderName(mProviderName, &amp;mType, &amp;mId);</span><br><span class="line">    ......</span><br><span class="line">    ALOGI(<span class="string">&quot;Connecting to new camera provider: %s, isRemote? %d&quot;</span>,</span><br><span class="line">            mProviderName.c_str(), interface-&gt;isRemote());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine minor version</span></span><br><span class="line">    <span class="keyword">auto</span> castResult = provider::V2_5::ICameraProvider::castFrom(interface);</span><br><span class="line">    <span class="keyword">if</span> (castResult.isOk()) &#123;</span><br><span class="line">        mMinorVersion = <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mMinorVersion = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cameraDeviceStatusChange callbacks may be called (and causing new devices added)</span></span><br><span class="line">    <span class="comment">// before setCallback returns</span></span><br><span class="line">    hardware::Return&lt;Status&gt; status = interface-&gt;setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    hardware::Return&lt;<span class="keyword">bool</span>&gt; linked = interface-&gt;linkToDeath(<span class="keyword">this</span>, <span class="comment">/*cookie*/</span> mId);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;%s: Setting device state for %s: 0x%&quot;</span> PRIx64,</span><br><span class="line">            __FUNCTION__, mProviderName.c_str(), mDeviceState);</span><br><span class="line">    notifyDeviceStateChange(currentDeviceState);</span><br><span class="line"></span><br><span class="line">    res = setUpVendorTags();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Get initial list of camera devices, if any</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; devices;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret = interface-&gt;getCameraIdList([&amp;status, <span class="keyword">this</span>, &amp;devices](</span><br><span class="line">            Status idStatus,</span><br><span class="line">            <span class="keyword">const</span> hardware::hidl_vec&lt;hardware::hidl_string&gt;&amp; cameraDeviceNames) &#123;</span><br><span class="line">        status = idStatus;</span><br><span class="line">        <span class="keyword">if</span> (status == Status::OK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; name : cameraDeviceNames) &#123;</span><br><span class="line">                <span class="keyword">uint16_t</span> major, minor;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> type, id;</span><br><span class="line">                <span class="keyword">status_t</span> res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">                <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;%s: Error parsing deviceName: %s: %d&quot;</span>, __FUNCTION__, name.c_str(), res);</span><br><span class="line">                    status = Status::INTERNAL_ERROR;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    devices.push_back(name);</span><br><span class="line">                    mProviderPublicCameraIds.push_back(id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mIsRemote = interface-&gt;isRemote();</span><br><span class="line"></span><br><span class="line">    sp&lt;StatusListener&gt; listener = mManager-&gt;getStatusListener();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; device : devices) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">        <span class="keyword">status_t</span> res = addDevice(device, common::V1_0::CameraDeviceStatus::PRESENT, &amp;id);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Log:Camera provider legacy/0 ready with 1 camera devices</span></span><br><span class="line">    ALOGI(<span class="string">&quot;Camera provider %s ready with %zu camera devices&quot;</span>,</span><br><span class="line">            mProviderName.c_str(), mDevices.size());</span><br><span class="line"></span><br><span class="line">    mInitialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）、CameraProviderManager-ProviderInfo-addDevice"><a href="#（3）、CameraProviderManager-ProviderInfo-addDevice" class="headerlink" title="（3）、CameraProviderManager::ProviderInfo::addDevice"></a>（3）、CameraProviderManager::ProviderInfo::addDevice</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> CameraProviderManager::ProviderInfo::addDevice(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        CameraDeviceStatus initialStatus, <span class="comment">/*out*/</span> <span class="built_in">std</span>::<span class="built_in">string</span>* parsedId) &#123;</span><br><span class="line">    <span class="comment">//CameraProviderManager: Enumerating new camera device: device@3.3/legacy/0</span></span><br><span class="line">    ALOGI(<span class="string">&quot;Enumerating new camera device: %s&quot;</span>, name.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> major, minor;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> type, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DeviceInfo&gt; deviceInfo;</span><br><span class="line">    <span class="keyword">switch</span> (major) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo1&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            deviceInfo = initializeDeviceInfo&lt;DeviceInfo3&gt;(name, mProviderTagid,</span><br><span class="line">                    id, minor);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: Device %s: Unknown HIDL device HAL major version %d:&quot;</span>, __FUNCTION__,</span><br><span class="line">                    name.c_str(), major);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deviceInfo == <span class="literal">nullptr</span>) <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    deviceInfo-&gt;mStatus = initialStatus;</span><br><span class="line">    <span class="keyword">bool</span> isAPI1Compatible = deviceInfo-&gt;isAPI1Compatible();</span><br><span class="line"></span><br><span class="line">    mDevices.push_back(<span class="built_in">std</span>::move(deviceInfo));</span><br><span class="line"></span><br><span class="line">    mUniqueCameraIds.insert(id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (parsedId != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *parsedId = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）、CameraProviderManager-ProviderInfo-initializeDeviceInfo"><a href="#（4）、CameraProviderManager-ProviderInfo-initializeDeviceInfo" class="headerlink" title="（4）、CameraProviderManager::ProviderInfo::initializeDeviceInfo"></a>（4）、CameraProviderManager::ProviderInfo::initializeDeviceInfo</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\common\CameraProviderManager.cpp</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DeviceInfoT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="built_in">unique_ptr</span>&lt;CameraProviderManager::ProviderInfo::DeviceInfo&gt;</span><br><span class="line">    CameraProviderManager::ProviderInfo::initializeDeviceInfo(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="keyword">metadata_vendor_id_t</span> tagId,</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">uint16_t</span> minorVersion) &#123;</span><br><span class="line">    Status status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cameraInterface =</span><br><span class="line">            startDeviceInterface&lt;<span class="keyword">typename</span> DeviceInfoT::InterfaceT&gt;(name);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    CameraResourceCost resourceCost;</span><br><span class="line">    cameraInterface-&gt;getResourceCost([&amp;status, &amp;resourceCost](</span><br><span class="line">        Status s, CameraResourceCost cost) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                resourceCost = cost;</span><br><span class="line">            &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; conflictName : resourceCost.conflictingDevices) &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> major, minor;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> type, id;</span><br><span class="line">        <span class="keyword">status_t</span> res = parseDeviceName(conflictName, &amp;major, &amp;minor, &amp;type, &amp;id);</span><br><span class="line">        ......</span><br><span class="line">        conflictName = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DeviceInfo&gt;(</span><br><span class="line">        <span class="keyword">new</span> DeviceInfoT(name, tagId, id, minorVersion, resourceCost, <span class="keyword">this</span>,</span><br><span class="line">                mProviderPublicCameraIds, cameraInterface));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\common\CameraProviderManager.cpp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">sp&lt;device::V3_2::ICameraDevice&gt;</span><br><span class="line">CameraProviderManager::ProviderInfo::startDeviceInterface</span><br><span class="line">        &lt;device::V3_2::ICameraDevice&gt;(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) &#123;</span><br><span class="line">    Status status;</span><br><span class="line">    sp&lt;device::V3_2::ICameraDevice&gt; cameraInterface;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface();</span><br><span class="line">    ......</span><br><span class="line">    ret = interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](</span><br><span class="line">        Status s, sp&lt;device::V3_2::ICameraDevice&gt; interface) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                cameraInterface = interface;</span><br><span class="line">            &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> cameraInterface;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getCameraDeviceInterface_V3_x</span></span><br><span class="line">F:\Khadas_Edge_Android_Q\hardware\interfaces\camera\provider\<span class="number">2.4</span>\<span class="keyword">default</span>\LegacyCameraProviderImpl_2_4.cpp</span><br><span class="line">    <span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">LegacyCameraProviderImpl_2_4::getCameraDeviceInterface_V3_x</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> hidl_string&amp; cameraDeviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ICameraProvider::getCameraDeviceInterface_V3_x_cb _hidl_cb)</span>  </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;LegacyCameraProviderImpl_2_4 getCameraDeviceInterface_V3_x&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cameraId, deviceVersion;</span><br><span class="line">    <span class="keyword">bool</span> match = matchDeviceName(cameraDeviceName, &amp;deviceVersion, &amp;cameraId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">deviceName</span><span class="params">(cameraDeviceName.c_str())</span></span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> index = mCameraDeviceNames.indexOf(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(cameraId, deviceName));</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCameraStatusMap.count(cameraId) == <span class="number">0</span> ||</span><br><span class="line">            mCameraStatusMap[cameraId] != CAMERA_DEVICE_STATUS_PRESENT) &#123;</span><br><span class="line">        _hidl_cb(Status::ILLEGAL_ARGUMENT, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> Void();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;android::hardware::camera::device::V3_2::implementation::CameraDevice&gt; deviceImpl;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// ICameraDevice 3.2 and 3.3</span></span><br><span class="line">    <span class="comment">// Since some Treble HAL revisions can map to the same legacy HAL version(s), we default</span></span><br><span class="line">    <span class="comment">// to the newest possible Treble HAL revision, but allow for override if needed via</span></span><br><span class="line">    <span class="comment">// system property.</span></span><br><span class="line">    <span class="keyword">switch</span> (mPreferredHal3MinorVersion) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123; <span class="comment">// Map legacy camera device v3 HAL to Treble camera device HAL v3.3</span></span><br><span class="line">            ALOGV(<span class="string">&quot;Constructing v3.3 camera device&quot;</span>);</span><br><span class="line">            deviceImpl = <span class="keyword">new</span> android::hardware::camera::device::V3_3::implementation::CameraDevice(</span><br><span class="line">                    mModule, cameraId, mCameraDeviceNames);</span><br><span class="line">           ..</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb (Status::OK, deviceImpl-&gt;getInterface());</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//01-18 08:50:15.089   258   258 I CamPrvdr@2.4-legacy: Loaded &quot;Rockchip Camera3HAL Module&quot; camera module</span></span><br><span class="line"><span class="comment">//01-18 08:50:15.091   258   258 V CamPrvdr@2.4-legacy: Preferred HAL 3 minor version is 3</span></span><br><span class="line"><span class="comment">//01-18 08:50:15.113   258   435 I CamPrvdr@2.4-legacy: LegacyCameraProviderImpl_2_4 getCameraDeviceInterface_V3_x</span></span><br><span class="line"><span class="comment">//01-18 08:50:15.113   258   435 V CamPrvdr@2.4-legacy: Constructing v3.3 camera device</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CameraProviderManager::ProviderInfo::DeviceInfo3::DeviceInfo3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">metadata_vendor_id_t</span> tagId, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id,</span><br><span class="line">        <span class="keyword">uint16_t</span> minorVersion,</span><br><span class="line">        <span class="keyword">const</span> CameraResourceCost&amp; resourceCost,</span><br><span class="line">        sp&lt;ProviderInfo&gt; parentProvider,</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; publicCameraIds,</span><br><span class="line">        sp&lt;InterfaceT&gt; interface) :</span><br><span class="line">        DeviceInfo(name, tagId, id, hardware::hidl_version&#123;<span class="number">3</span>, minorVersion&#125;,</span><br><span class="line">                   publicCameraIds, resourceCost, parentProvider) &#123;</span><br><span class="line">    <span class="comment">// Get camera characteristics and initialize flash unit availability</span></span><br><span class="line">    Status status;</span><br><span class="line">    hardware::Return&lt;<span class="keyword">void</span>&gt; ret;</span><br><span class="line">    ret = interface-&gt;getCameraCharacteristics([&amp;status, <span class="keyword">this</span>](Status s,</span><br><span class="line">                    device::V3_2::CameraMetadata metadata) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                <span class="keyword">if</span> (s == Status::OK) &#123;</span><br><span class="line">                    <span class="keyword">camera_metadata_t</span> *buffer =</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera_metadata_t</span>*&gt;(metadata.data());</span><br><span class="line">                    <span class="keyword">size_t</span> expectedSize = metadata.size();</span><br><span class="line">                    <span class="keyword">int</span> res = validate_camera_metadata_structure(buffer, &amp;expectedSize);</span><br><span class="line">                    <span class="keyword">if</span> (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) &#123;</span><br><span class="line">                        set_camera_metadata_vendor_id(buffer, mProviderTagid);</span><br><span class="line">                        mCameraCharacteristics = buffer;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ALOGE(<span class="string">&quot;%s: Malformed camera metadata received from HAL&quot;</span>, __FUNCTION__);</span><br><span class="line">                        status = Status::INTERNAL_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    ......</span><br><span class="line">    mIsPublicallyHiddenSecureCamera = isPublicallyHiddenSecureCamera();</span><br><span class="line">    <span class="keyword">status_t</span> res = fixupMonochromeTags();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">auto</span> stat = addDynamicDepthTags();</span><br><span class="line">    ......</span><br><span class="line">    res = deriveHeicTags();</span><br><span class="line">    ......</span><br><span class="line">    camera_metadata_entry flashAvailable =</span><br><span class="line">            mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE);</span><br><span class="line">    ......</span><br><span class="line">    queryPhysicalCameraIds();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsLogicalCamera) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; id : mPhysicalIds) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::find(mPublicCameraIds.begin(), mPublicCameraIds.end(), id) !=</span><br><span class="line">                    mPublicCameraIds.end()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">hardware::hidl_string <span class="title">hidlId</span><span class="params">(id)</span></span>;</span><br><span class="line">            ret = interface_3_5-&gt;getPhysicalCameraCharacteristics(hidlId,</span><br><span class="line">                    [&amp;status, &amp;id, <span class="keyword">this</span>](Status s, device::V3_2::CameraMetadata metadata) &#123;</span><br><span class="line">                status = s;</span><br><span class="line">                <span class="keyword">if</span> (s == Status::OK) &#123;</span><br><span class="line">                    <span class="keyword">camera_metadata_t</span> *buffer =</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">camera_metadata_t</span>*&gt;(metadata.data());</span><br><span class="line">                    <span class="keyword">size_t</span> expectedSize = metadata.size();</span><br><span class="line">                    <span class="keyword">int</span> res = validate_camera_metadata_structure(buffer, &amp;expectedSize);</span><br><span class="line">                    <span class="keyword">if</span> (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) &#123;</span><br><span class="line">                        set_camera_metadata_vendor_id(buffer, mProviderTagid);</span><br><span class="line">                        mPhysicalCameraCharacteristics[id] = buffer;</span><br><span class="line">                    &#125; .......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kEnableLazyHal) &#123;</span><br><span class="line">        <span class="comment">// Save HAL reference indefinitely</span></span><br><span class="line">        mSavedInterface = interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//sp&lt;InterfaceT&gt; interface) :</span></span><br><span class="line"><span class="comment">//        DeviceInfo(name, tagId, id, hardware::hidl_version&#123;3, minorVersion&#125;,</span></span><br><span class="line"><span class="comment">//                   publicCameraIds, resourceCost, parentProvider)</span></span><br></pre></td></tr></table></figure>

<h4 id="（5）、CameraService-与-CameraProvider衔接"><a href="#（5）、CameraService-与-CameraProvider衔接" class="headerlink" title="（5）、CameraService 与 CameraProvider衔接"></a>（5）、CameraService 与 CameraProvider衔接</h4><p>继续分析CameraProviderManager::addProviderLocked中的mServiceProxy-&gt;getService(newProvider)即为HardwareServiceInteractionProxy-&gt;getService(newProvider)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\frameworks\av\services\camera\libcameraservice\common\CameraProviderManager.h</span><br><span class="line"><span class="comment">// Standard use case - call into the normal generated static methods which invoke</span></span><br><span class="line"><span class="comment">// the real hardware service manager</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HardwareServiceInteractionProxy</span> :</span> <span class="keyword">public</span> ServiceInteractionProxy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">registerForNotifications</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> sp&lt;hidl::manager::V1_0::IServiceNotification&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">            &amp;notification)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hardware::camera::provider::V2_4::ICameraProvider::registerForNotifications(</span><br><span class="line">                serviceName, notification);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;hardware::camera::provider::V2_4::ICameraProvider&gt; <span class="title">getService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hardware::camera::provider::V2_4::ICameraProvider::getService(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> hardware::hidl_vec&lt;hardware::hidl_string&gt; <span class="title">listServices</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/Khadas_Edge_Android_Q/out/soong/.intermediates/hardware/interfaces/camera/provider/<span class="number">2.4</span>/android.hardware.camera.provider@<span class="number">2.4</span>_genc++/gen/android/hardware/camera/provider/CameraProviderAll.cpp</span><br><span class="line">    </span><br><span class="line">::<span class="function">android::sp&lt;ICameraProvider&gt; <span class="title">ICameraProvider::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::getServiceInternal&lt;BpHwCameraProvider&gt;(serviceName, <span class="literal">true</span>, getStub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\ServiceManagement.cpp</span><br><span class="line"><span class="function">sp&lt;::android::hidl::base::V1_0::IBase&gt; <span class="title">getRawServiceInternal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; instance,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             <span class="keyword">bool</span> retry, <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::manager::V1_0::IServiceManager;</span><br><span class="line">    sp&lt;Waiter&gt; waiter;</span><br><span class="line"></span><br><span class="line">    sp&lt;IServiceManager1_1&gt; sm;</span><br><span class="line">    Transport transport = Transport::EMPTY;</span><br><span class="line">    <span class="keyword">if</span> (kIsRecovery) &#123;</span><br><span class="line">        transport = Transport::PASSTHROUGH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sm = defaultServiceManager1_1();</span><br><span class="line">        ......</span><br><span class="line">        Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(descriptor, instance);</span><br><span class="line">        ......</span><br><span class="line">        transport = transportRet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; (vintfHwbinder || vintfLegacy); tries++) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//查询ICameraProvider这个hidl服务，得到IBase对象</span></span><br><span class="line">        Return&lt;sp&lt;IBase&gt;&gt; ret = sm-&gt;get(descriptor, instance);</span><br><span class="line">       ......</span><br><span class="line">        sp&lt;IBase&gt; base = ret;</span><br><span class="line">        <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Return&lt;<span class="keyword">bool</span>&gt; canCastRet =</span><br><span class="line">                details::canCastInterface(base.get(), descriptor.c_str(), <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (canCastRet.isOk() &amp;&amp; canCastRet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (waiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    waiter-&gt;done();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> base; <span class="comment">// still needs to be wrapped by Bp class.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!handleCastError(canCastRet, descriptor, instance)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sp&lt;IBase&gt; base = pm-&gt;get(descriptor, instance).withDefault(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                base = wrapPassthrough(base);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F:\Khadas_Edge_Android_Q\system\libhidl\transport\include\hidl\HidlTransportSupport.h</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BpType, <span class="keyword">typename</span> IType = <span class="keyword">typename</span> BpType::Pure,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same&lt;i_tag, <span class="keyword">typename</span> IType::_hidl_tag&gt;::value&gt;,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same&lt;bphw_tag, <span class="keyword">typename</span> BpType::_hidl_tag&gt;::value&gt;&gt;</span><br><span class="line">sp&lt;IType&gt; getServiceInternal(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; instance, <span class="keyword">bool</span> retry, <span class="keyword">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="comment">//这里通过sm-&gt;get(ICameraProvider::descriptor, serviceName)查询ICameraProvider这个hidl服务，得到IBase对象后，再通过ICameraProvider::castFrom转换为ICameraProvider对象。</span></span><br><span class="line">    sp&lt;IBase&gt; base = getRawServiceInternal(IType::descriptor, instance, retry, getStub);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (base-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// getRawServiceInternal guarantees we get the proper class</span></span><br><span class="line">        <span class="comment">/* 获取 CameraProvider 代理类对象(binder) */</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;IType&gt;(<span class="keyword">new</span> BpType(getOrCreateCachedBinder(base.get())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 转换为 BpHwCameraProvider 对象 */</span></span><br><span class="line">    <span class="keyword">return</span> IType::castFrom(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.779</span>   <span class="number">326</span>   <span class="number">326</span> I CameraProviderManager: Connecting to <span class="keyword">new</span> camera provider: external/<span class="number">0</span>, isRemote? <span class="number">1</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.779</span>   <span class="number">326</span>   <span class="number">326</span> V CameraProviderManager: initialize: Setting device state <span class="keyword">for</span> external/<span class="number">0</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.780</span>   <span class="number">326</span>   <span class="number">326</span> V CameraProviderManager: Request to start camera provider: external/<span class="number">0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.780</span>   <span class="number">326</span>   <span class="number">326</span> I CameraProviderManager: Camera provider external/<span class="number">0</span> ready with <span class="number">0</span> camera devices</span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.893</span>   <span class="number">326</span>   <span class="number">326</span> I CameraProviderManager: Connecting to <span class="keyword">new</span> camera provider: legacy/<span class="number">0</span>, isRemote? <span class="number">1</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.894</span>   <span class="number">326</span>   <span class="number">326</span> V CameraProviderManager: initialize: Setting device state <span class="keyword">for</span> legacy/<span class="number">0</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.894</span>   <span class="number">326</span>   <span class="number">326</span> V CameraProviderManager: Request to start camera provider: legacy/<span class="number">0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.896</span>   <span class="number">326</span>   <span class="number">326</span> I CameraProviderManager: Enumerating <span class="keyword">new</span> camera device: device@<span class="number">3.3</span>/legacy/<span class="number">0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.896</span>   <span class="number">326</span>   <span class="number">326</span> V CameraProviderManager: Request to start camera provider: legacy/<span class="number">0</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.905</span>   <span class="number">326</span>   <span class="number">326</span> E CameraProviderManager: DeviceInfo3: Converted ICameraDevice instance to <span class="literal">nullptr</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.905</span>   <span class="number">326</span>   <span class="number">326</span> I CameraProviderManager: Camera provider legacy/<span class="number">0</span> ready with <span class="number">1</span> camera devices</span><br><span class="line">01-18 08:50:15.905   326   422 W CameraProviderManager: addProviderLocked: Camera provider HAL with name &#x27;external/0&#x27; already registered</span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.906</span>   <span class="number">326</span>   <span class="number">326</span> I CameraService: onDeviceStatusChanged: Status changed <span class="keyword">for</span> cameraId=<span class="number">0</span>, newStatus=<span class="number">1</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.906</span>   <span class="number">326</span>   <span class="number">326</span> I CameraService: onDeviceStatusChanged: Unknown camera ID <span class="number">0</span>, a <span class="keyword">new</span> camera is added</span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.906</span>   <span class="number">326</span>   <span class="number">422</span> I CameraService: onDeviceStatusChanged: Status changed <span class="keyword">for</span> cameraId=<span class="number">0</span>, newStatus=<span class="number">1</span></span><br><span class="line"><span class="number">01</span><span class="number">-18</span> <span class="number">08</span>:<span class="number">50</span>:<span class="number">15.907</span>   <span class="number">326</span>   <span class="number">326</span> V CameraService: updateStatus: Status has changed <span class="keyword">for</span> camera ID <span class="number">0</span> from <span class="number">0</span> to <span class="number">0x1</span></span><br><span class="line">01-18 08:50:15.907   326   422 W CameraProviderManager: addProviderLocked: Camera provider HAL with name &#x27;legacy/0&#x27; already registered</span><br></pre></td></tr></table></figure>



<p>Binder 分为 Bp 以及 Bn，Bp 对应 client ， Bn 对应 server。</p>
<p>CameraProvider 服务，通过 ICameraProvider::getService 实例化 CameraProvider，然后通过toBinder函数转换为BnHwCameraProvider，注册到HwServiceManager中。</p>
<p>CameraService 服务，通过 ICameraProvider::getService 拿到 BpHwCameraProvider，然后通过binder通信调用到CameraProvider，进而调用Camera HAL。</p>
<p>上层 framework 通过 ServiceManager( /dev/binder ) 得到 CameraService 服务，而<br>CameraService 通过 HwServiceManager( /dev/hwbinder ) 得到 CameraProvider 服务，而 CameraProvider 与 Camera HAL 绑定。这样上层 framework 就能够访问 Camera HAL 层了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20220315/">https://zhoujinjian.com/posts/20220315/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Camera/">Camera</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.36.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20220401/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.37.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 10 Camera源码分析7：Rockchip_Camera_Hal3_User_Manual</div></div></a></div><div class="next-post pull-right"><a href="/posts/20220301/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.35.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 10 Camera源码分析5：rkisp_demo分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20220515/" title="Android 10 Camera源码分析10：Camera Android架构(基于Q)转载.md"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-15</div><div class="title">Android 10 Camera源码分析10：Camera Android架构(基于Q)转载.md</div></div></a></div><div><a href="/posts/20220101/" title="Android 10 Camera源码分析1：MIPI CSI2总结基于DPHY2.1(转载)"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.31.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-01</div><div class="title">Android 10 Camera源码分析1：MIPI CSI2总结基于DPHY2.1(转载)</div></div></a></div><div><a href="/posts/20220115/" title="Android 10 Camera源码分析2：V4L2简介"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.32.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-15</div><div class="title">Android 10 Camera源码分析2：V4L2简介</div></div></a></div><div><a href="/posts/20220201/" title="Android 10 Camera源码分析3：videobuf2 申请与map、入队与出队"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.33.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">Android 10 Camera源码分析3：videobuf2 申请与map、入队与出队</div></div></a></div><div><a href="/posts/20220215/" title="Android 10 Camera源码分析4：Rockchip ISP1 Driver 分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-15</div><div class="title">Android 10 Camera源码分析4：Rockchip ISP1 Driver 分析</div></div></a></div><div><a href="/posts/20220301/" title="Android 10 Camera源码分析5：rkisp_demo分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.35.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">Android 10 Camera源码分析5：rkisp_demo分析</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Camera-HIDL-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">（一）、Camera HIDL 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81ICameraProvider-hal"><span class="toc-number">1.0.1.</span> <span class="toc-text">（1）、ICameraProvider.hal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81ICameraProviderCallback-hal"><span class="toc-number">1.0.2.</span> <span class="toc-text">（2）、ICameraProviderCallback.hal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81ICameraDevice-hal"><span class="toc-number">1.0.3.</span> <span class="toc-text">（3）、ICameraDevice.hal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E3%80%81ICameraDeviceCallback-hal"><span class="toc-number">1.0.4.</span> <span class="toc-text">（4）、ICameraDeviceCallback.hal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E3%80%81ICameraDeviceSession-hal"><span class="toc-number">1.0.5.</span> <span class="toc-text">（5）、ICameraDeviceSession.hal</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Camera-Provider-%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">（二）、Camera Provider 主程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81%E8%8E%B7%E5%8F%96-CameraProvider-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.1.</span> <span class="toc-text">（1）、获取 CameraProvider 实例对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81%E5%B0%86-CameraProvider-%E6%B3%A8%E5%86%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.0.2.</span> <span class="toc-text">（2）、将 CameraProvider 注册为服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.0.3.</span> <span class="toc-text">（3）、总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Camera-HAL3-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">（三）、Camera HAL3 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81camera-module"><span class="toc-number">3.0.1.</span> <span class="toc-text">（1）、camera_module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81camera3-stream-configuration"><span class="toc-number">3.0.2.</span> <span class="toc-text">（2）、camera3_stream_configuration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81camera3-stream-t"><span class="toc-number">3.0.3.</span> <span class="toc-text">（3）、camera3_stream_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E3%80%81camera3-stream-buffer-t"><span class="toc-number">3.0.4.</span> <span class="toc-text">（4）、camera3_stream_buffer_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">3.0.5.</span> <span class="toc-text">（5）、核心接口函数解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Camera-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="toc-number">4.</span> <span class="toc-text">（四）、Camera Service启动流程概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81CameraService-%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.0.1.</span> <span class="toc-text">（1）、CameraService 的启动与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81CameraProviderManager-ProviderInfo-initialize"><span class="toc-number">4.0.2.</span> <span class="toc-text">（2）、CameraProviderManager::ProviderInfo::initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81CameraProviderManager-ProviderInfo-addDevice"><span class="toc-number">4.0.3.</span> <span class="toc-text">（3）、CameraProviderManager::ProviderInfo::addDevice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E3%80%81CameraProviderManager-ProviderInfo-initializeDeviceInfo"><span class="toc-number">4.0.4.</span> <span class="toc-text">（4）、CameraProviderManager::ProviderInfo::initializeDeviceInfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E3%80%81CameraService-%E4%B8%8E-CameraProvider%E8%A1%94%E6%8E%A5"><span class="toc-number">4.0.5.</span> <span class="toc-text">（5）、CameraService 与 CameraProvider衔接</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>