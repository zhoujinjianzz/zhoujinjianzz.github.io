<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android P Graphics System（五）：GraphicBuffer和Gralloc分析（转载） | zhoujinjian</title><meta name="keywords" content="Android,Graphics"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。（&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android P Graphics System（五）：GraphicBuffer和Gralloc分析（转载）">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190724/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。（&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.40.jpg">
<meta property="article:published_time" content="2019-07-24T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.964Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.40.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190724/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.40.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android P Graphics System（五）：GraphicBuffer和Gralloc分析（转载）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-07-24T01:25:00.000Z" title="发表于 2019-07-24 09:25:00">2019-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.964Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Graphics/">Graphics</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。<br>（==<strong>文章基于 Kernel-3.18</strong>==）&amp;&amp;（==<strong>文章基于 Android 9.0</strong>==）<br> <a target="_blank" rel="noopener" href="https://www.intrinsyc.com/snapdragon-embedded-development-kits/open-q-820-usom-development-kit/">【开发板 Intrinsyc Open-Q™ 820 µSOM Development Kit】</a><br><a target="_blank" rel="noopener" href="https://gitlab.com/zhoujinjianzz/apq8096_la.um.7.5.r1-03100-8x96.0_p_v5.0">【开发板 Android 9.0 &amp;&amp; Linux（Kernel 3.18）源码链接】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，特别感谢！！！</p>
<p><strong>注：本博文转载于【<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/f92447ae8445">夕月风</a>】</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd0b38832346">（1）【GraphicBuffer和Gralloc分析】</a></p>
<hr>
<p>==源码（部分）==：<br><strong>frameworks/native/libs/ui/</strong><br><strong>drivers/staging/android/ion/msm/</strong><br><strong>hardware/interfaces/graphics/mapper/2.0/</strong></p>
<hr>
<h4 id="一、GraphicBuffer定义"><a href="#一、GraphicBuffer定义" class="headerlink" title="一、GraphicBuffer定义"></a>一、GraphicBuffer定义</h4><p>BufferQueue中的Buffer对象，我们用的都是GraphicBuffer，那么GraphicBuffer是怎么来的呢？接下里我们具体来看这里的流程。<br>Surface是Andorid窗口的描述，是ANativeWindow的实现；同样GraphicBuffer是Android中图形Buffer的描述，是ANativeWindowBuffer的实现。而一个窗口，可以有几个Buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/include/ui/GraphicBuffer.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicBuffer</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer, RefBase&gt;,</span><br><span class="line">      <span class="keyword">public</span> Flattenable&lt;GraphicBuffer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Flattenable</span>&lt;GraphicBuffer&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br></pre></td></tr></table></figure>
<p>其中ANativeObjectBase是一个模板类，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/include/ui/ANativeObjectBase.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NATIVE_TYPE, <span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> REF,</span><br><span class="line">        <span class="keyword">typename</span> NATIVE_BASE = <span class="keyword">android_native_base_t</span>&gt;</span><br><span class="line">class ANativeObjectBase : <span class="keyword">public</span> NATIVE_TYPE, <span class="keyword">public</span> REF</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Disambiguate between the incStrong in REF and NATIVE_TYPE</span></span><br><span class="line">    <span class="keyword">void</span> incStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> &#123;</span><br><span class="line">        REF::incStrong(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        REF::decStrong(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样ANativeObjectBase继承ANativeWindowBuffer和RefBase，GraphicBuffer继承ANativeObjectBase和Flattenable。<br>这样做的目的：</p>
<ul>
<li>RefBase使GraphicBuffer支持引用计数控制</li>
<li>Flattenable使GraphicBuffer支持序列化。<br>其中的关键类 ANativeWindowBuffer，它是一个结构体，是对Native Buffer的一个描述，其定义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/nativebase/include/nativebase/nativebase.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindowBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="comment">// 构造函数，decStrong和incStrong的实现；得初始化common</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">android_native_base_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> stride;</span><br><span class="line">    <span class="keyword">int</span> format;</span><br><span class="line">    <span class="keyword">int</span> usage_deprecated;</span><br><span class="line">    <span class="keyword">uintptr_t</span> layerCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* handle;</span><br><span class="line">    <span class="keyword">uint64_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">8</span> - (<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>) / <span class="keyword">sizeof</span>(<span class="keyword">void</span>*))];</span><br><span class="line">&#125; ANativeWindowBuffer_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANativeWindowBuffer</span> <span class="title">ANativeWindowBuffer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Old typedef for backwards compatibility.</span></span><br><span class="line"><span class="keyword">typedef</span> ANativeWindowBuffer_t <span class="keyword">android_native_buffer_t</span>;</span><br></pre></td></tr></table></figure>
<p>ANativeWindowBuffer中，很多属性前面我们介绍Surface时，已经介绍过了。这里重点看看这个native_handle_t。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* system/core/libcutils/include/cutils/native_handle.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> version;        <span class="comment">/* sizeof(native_handle_t) */</span></span><br><span class="line">    <span class="keyword">int</span> numFds;         <span class="comment">/* number of file-descriptors at &amp;data[0] */</span></span><br><span class="line">    <span class="keyword">int</span> numInts;        <span class="comment">/* number of ints at &amp;data[numFds] */</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>];        <span class="comment">/* numFds + numInts ints */</span></span><br><span class="line">    ... ...</span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure>
<p>native_handle_t也就是具体Buffer的句柄，根据native_handle_t就能找到护体的Buffer。这里是用文件描述符进行描述的。</p>
<p>GraphicBuffer，很多属性都是继承于父类的，GraphicBuffer自己的属性比较少</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/include/ui/GraphicBuffer.h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> mOwner;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    GraphicBufferMapper&amp; mBufferMapper;</span><br><span class="line">    <span class="keyword">ssize_t</span> mInitCheck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numbers of fds/ints in native_handle_t to flatten</span></span><br><span class="line">    <span class="keyword">uint32_t</span> mTransportNumFds;</span><br><span class="line">    <span class="keyword">uint32_t</span> mTransportNumInts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> mId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stores the generation number of this buffer. If this number does not</span></span><br><span class="line">    <span class="comment">// match the BufferQueue&#x27;s internal generation number (set through</span></span><br><span class="line">    <span class="comment">// IGBP::setGenerationNumber), attempts to attach the buffer will fail.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> mGenerationNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mOwner<br>表示该GraphicBuffer持有的只是handle，还是持有具体的数据</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">     ownNone   = <span class="number">0</span>,</span><br><span class="line">     ownHandle = <span class="number">1</span>,</span><br><span class="line">     ownData   = <span class="number">2</span>,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>mOwner不一样，释放时，流程不一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GraphicBuffer::free_handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner == ownHandle) &#123;</span><br><span class="line">        mBufferMapper.freeBuffer(handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOwner == ownData) &#123;</span><br><span class="line">        GraphicBufferAllocator&amp; allocator(GraphicBufferAllocator::get());</span><br><span class="line">        allocator.<span class="built_in">free</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    handle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GraphicBufferMapper<br>GraphicBuffer实现Flattenable，可以将GraphicBuffer进行打包，在Binder中传递，但是传递只是Buffer的描述属性，并不真正去拷贝Buffer的内容。怎么实现的共享的，关键还是这里的handle。GraphicBufferMapper会根据handle去在不同的进程中进map，map到同一块物理内存。这里先埋个伏笔，后续我们会讲到。</li>
<li>mId<br>GraphicBuffer的ID，这个ID在不同进程中都是一样的</li>
<li>mGenerationNumber<br>可以理解问题这个buffer被用多少次了。如果这个值和BufferQueue中的mGenerationNumber不一直，那么是不能attach的。</li>
</ul>
<p>余下，GraphicBuffer的相关函数我们接下来具体来看～</p>
<h4 id="二、分配一块Buffer"><a href="#二、分配一块Buffer" class="headerlink" title="二、分配一块Buffer"></a>二、分配一块Buffer</h4><p>Producer dequeueBuffer的时候，并不是 每一次都会去分配一块Buffer。还记得什么时候回去分配Buffer吗？没错，设置了标识BUFFER_NEEDS_REALLOCATION时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: allocating a new buffer for slot %d&quot;</span>, *outSlot);</span><br><span class="line">    sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">            width, height, format, BQ_LAYER_COUNT, usage,</span><br><span class="line">            &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.size()&#125;);</span><br></pre></td></tr></table></figure>

<p>此时分配的Buffer，参数比较齐全，对应的构造函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/GraphicBuffer.cpp</span><br><span class="line"></span><br><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">        PixelFormat inFormat, <span class="keyword">uint32_t</span> inLayerCount, <span class="keyword">uint64_t</span> usage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">    : GraphicBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount,</span><br><span class="line">            usage, <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认构造函数中，主要是做变量是初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer()</span><br><span class="line">    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">      mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    width  =</span><br><span class="line">    height =</span><br><span class="line">    stride =</span><br><span class="line">    format =</span><br><span class="line">    usage_deprecated = <span class="number">0</span>;</span><br><span class="line">    usage  = <span class="number">0</span>;</span><br><span class="line">    layerCount = <span class="number">0</span>;</span><br><span class="line">    handle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mOwner默认是ownData。GraphicBufferMapper是一个单例类，mBufferMapper在每个进程中只有一个实际对象。inLayerCount为1，在BufferQueueProducer中是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> BQ_LAYER_COUNT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBuffer::initWithSize</span><span class="params">(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">        PixelFormat inFormat, <span class="keyword">uint32_t</span> inLayerCount, <span class="keyword">uint64_t</span> inUsage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    <span class="keyword">uint32_t</span> outStride = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,</span><br><span class="line">            inUsage, &amp;handle, &amp;outStride, mId,</span><br><span class="line">            <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        mBufferMapper.getTransportSize(handle, &amp;mTransportNumFds, &amp;mTransportNumInts);</span><br><span class="line"></span><br><span class="line">        width = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inWidth);</span><br><span class="line">        height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inHeight);</span><br><span class="line">        format = inFormat;</span><br><span class="line">        layerCount = inLayerCount;</span><br><span class="line">        usage = inUsage;</span><br><span class="line">        usage_deprecated = <span class="keyword">int</span>(usage);</span><br><span class="line">        stride = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(outStride);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>GraphicBufferAllocator<br>Buffer管理中，另外一个单例类，GraphicBufferAllocator把Buffer分配出来你，GraphicBufferMapper可以将其map到自己的进程。<br>需要主要的是，BufferQueueProducer是跑在SurfaceFlinger进程中的，也就是说，绝大部分的应用，使用的Buffer，都是SurfaceFlinger进程分配出来的，所以，如果SurfaceFlinger出现内存泄露，FD泄露等问题，很有可能都是应用没有释放，SurfaceFlinger不会主动释放，它只响应应用的请求。SurfaceFlinger是背锅侠！</li>
</ul>
<p>GraphicBufferAllocator定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/include/ui/GraphicBufferAllocator.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicBufferAllocator</span> :</span> <span class="keyword">public</span> Singleton&lt;GraphicBufferAllocator&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> GraphicBufferAllocator&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getInstance(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">allocate</span><span class="params">(<span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span> layerCount, <span class="keyword">uint64_t</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">uint32_t</span>* stride, <span class="keyword">uint64_t</span> graphicBufferId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">free</span><span class="params">(<span class="keyword">buffer_handle_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(String8&amp; res)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpToSystemLog</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_rec_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> width;</span><br><span class="line">        <span class="keyword">uint32_t</span> height;</span><br><span class="line">        <span class="keyword">uint32_t</span> stride;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> layerCount;</span><br><span class="line">        <span class="keyword">uint64_t</span> usage;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> requestorName;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Mutex sLock;</span><br><span class="line">    <span class="keyword">static</span> KeyedVector&lt;<span class="keyword">buffer_handle_t</span>, <span class="keyword">alloc_rec_t</span>&gt; sAllocList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;GraphicBufferAllocator&gt;;</span></span><br><span class="line">    GraphicBufferAllocator();</span><br><span class="line">    ~GraphicBufferAllocator();</span><br><span class="line"></span><br><span class="line">    GraphicBufferMapper&amp; mMapper;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> Gralloc2::Allocator&gt; mAllocator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>两个主要的方法，一个allocate用来分配Buffer，一个free用来释放Buffe。</li>
<li>sAllocList，申请的Buffer，都保存下来，放到sAllocList中，并不是保存具体的Buffer，而是Buffer的描述alloc_rec_t。</li>
<li>mAllocator，Gralloc登场，gralloc采用版本化管理，用的是Gralloc2。</li>
</ul>
<p>GraphicBufferAllocator的allocate函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBufferAllocator::allocate</span><span class="params">(<span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">        PixelFormat format, <span class="keyword">uint32_t</span> layerCount, <span class="keyword">uint64_t</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">uint32_t</span>* stride,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> <span class="comment">/*graphicBufferId*/</span>, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure to not allocate a N x 0 or 0 x N buffer, since this is</span></span><br><span class="line">    <span class="comment">// allowed from an API stand-point allocate a 1x1 buffer instead.</span></span><br><span class="line">    <span class="keyword">if</span> (!width || !height)</span><br><span class="line">        width = height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that layerCount is valid.</span></span><br><span class="line">    <span class="keyword">if</span> (layerCount &lt; <span class="number">1</span>)</span><br><span class="line">        layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Gralloc2::IMapper::BufferDescriptorInfo info = &#123;&#125;;</span><br><span class="line">    info.width = width;</span><br><span class="line">    info.height = height;</span><br><span class="line">    info.layerCount = layerCount;</span><br><span class="line">    info.format = <span class="keyword">static_cast</span>&lt;Gralloc2::PixelFormat&gt;(format);</span><br><span class="line">    info.usage = usage;</span><br><span class="line"></span><br><span class="line">    Gralloc2::Error error = mAllocator-&gt;allocate(info, stride, handle);</span><br><span class="line">    <span class="keyword">if</span> (error == Gralloc2::Error::NONE) &#123;</span><br><span class="line">        Mutex::Autolock _l(sLock);</span><br><span class="line">        KeyedVector&lt;buffer_handle_t, alloc_rec_t&gt;&amp; list(sAllocList);</span><br><span class="line">        <span class="keyword">uint32_t</span> bpp = bytesPerPixel(format);</span><br><span class="line">        <span class="keyword">alloc_rec_t</span> rec;</span><br><span class="line">        rec.width = width;</span><br><span class="line">        rec.height = height;</span><br><span class="line">        rec.stride = *stride;</span><br><span class="line">        rec.format = format;</span><br><span class="line">        rec.layerCount = layerCount;</span><br><span class="line">        rec.usage = usage;</span><br><span class="line">        rec.size = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(height * (*stride) * bpp);</span><br><span class="line">        rec.requestorName = <span class="built_in">std</span>::move(requestorName);</span><br><span class="line">        <span class="built_in">list</span>.add(*handle, rec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to allocate (%u x %u) layerCount %u format %d &quot;</span></span><br><span class="line">                <span class="string">&quot;usage %&quot;</span> PRIx64 <span class="string">&quot;: %d&quot;</span>,</span><br><span class="line">                width, height, layerCount, format, usage,</span><br><span class="line">                error);</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看allocate函数之前，我们先来看一下GraphicBuffer相关的类：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG5.GraphicBuffer-Class.png" alt="Alt text | center"><br>GraphicBuffer的左膀右臂，GraphicBufferAllocator和GraphicBufferMapper！从Android 8.0开始，Android 操作系统框架在架构方面的一项重大改变，提出了treble 项目。Vendor的实现和Androd的实现分开，Android和HAL，采用HwBinder进行通信，减少Android对HAL的直接依赖。这里的Allocator和Mapper，就是对HAL结合的包装；IAllocator，IMapper的HAL的接口。V2_1::IMapper是一个对Gralloc HAL的2.1版本。<br>回到allocate函数～<br>BufferDescriptorInfo，对Buffer的描述，在HAL层也通用。根据需要，生成BufferDescriptorInfo，再通过Gralloc2的Allocator进行allocate。allocate出来的Buffer 句柄，保存在sAllocList中。<br>Gralloc2 Allocator的allocate函数提供了很多形态，可以满足我们不同的要求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/include/ui/Gralloc2.h</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The returned buffers are already imported and must not be imported</span></span><br><span class="line"><span class="comment">     * again.  outBufferHandles must point to a space that can contain at</span></span><br><span class="line"><span class="comment">     * least &quot;count&quot; buffer_handle_t.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Error <span class="title">allocate</span><span class="params">(BufferDescriptor descriptor, <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandles)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Error <span class="title">allocate</span><span class="params">(BufferDescriptor descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandle)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allocate(descriptor, <span class="number">1</span>, outStride, outBufferHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Error <span class="title">allocate</span><span class="params">(<span class="keyword">const</span> IMapper::BufferDescriptorInfo&amp; descriptorInfo, <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandles)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BufferDescriptor descriptor;</span><br><span class="line">        Error error = mMapper.createDescriptor(descriptorInfo, &amp;descriptor);</span><br><span class="line">        <span class="keyword">if</span> (error == Error::NONE) &#123;</span><br><span class="line">            error = allocate(descriptor, count, outStride, outBufferHandles);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Error <span class="title">allocate</span><span class="params">(<span class="keyword">const</span> IMapper::BufferDescriptorInfo&amp; descriptorInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandle)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allocate(descriptorInfo, <span class="number">1</span>, outStride, outBufferHandle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们传的参数是BufferDescriptorInfo，首先要根据BufferDescriptorInfo，生成一个BufferDescriptor，这个是mapper的HAL层实现的，因为这个BufferDescriptor最后也是要给到HAL层，HAL层根据BufferDescriptor去生成相应描述的Buffer。<br>最后，allocate的通用实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/Gralloc2.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">Error <span class="title">Allocator::allocate</span><span class="params">(BufferDescriptor descriptor, <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandles)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Error error;</span><br><span class="line">    <span class="keyword">auto</span> ret = mAllocator-&gt;allocate(descriptor, count,</span><br><span class="line">            [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpStride,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpBuffers) &#123;</span><br><span class="line">                error = tmpError;</span><br><span class="line">                <span class="keyword">if</span> (tmpError != Error::NONE) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// import buffers</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    error = mMapper.importBuffer(tmpBuffers[i],</span><br><span class="line">                            &amp;outBufferHandles[i]);</span><br><span class="line">                    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                            mMapper.freeBuffer(outBufferHandles[j]);</span><br><span class="line">                            outBufferHandles[j] = <span class="literal">nullptr</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                *outStride = tmpStride;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the kernel driver sees BC_FREE_BUFFER and closes the fds now</span></span><br><span class="line">    hardware::IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret.isOk()) ? error : kTransactionError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>count，表示需要分配的Buffer个数，也就是说我们一次可以分配多个Buffer。</p>
<p>allocator分配完成后，再通过importBuffer函数，import到我们的handle中outBufferHandle。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/Gralloc2.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">Error <span class="title">Mapper::importBuffer</span><span class="params">(<span class="keyword">const</span> hardware::hidl_handle&amp; rawHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">buffer_handle_t</span>* outBufferHandle)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Error error;</span><br><span class="line">    <span class="keyword">auto</span> ret = mMapper-&gt;importBuffer(rawHandle,</span><br><span class="line">            [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpBuffer)</span><br><span class="line">            &#123;</span><br><span class="line">                error = tmpError;</span><br><span class="line">                <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                *outBufferHandle = <span class="keyword">static_cast</span>&lt;<span class="keyword">buffer_handle_t</span>&gt;(tmpBuffer);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret.isOk()) ? error : kTransactionError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gralloc1-0-接口介绍"><a href="#Gralloc1-0-接口介绍" class="headerlink" title="Gralloc1.0 接口介绍"></a>Gralloc1.0 接口介绍</h4><p>Graphic相关的HAL的接口都在定义在hardware/interfaces/graphics/。allocator和mapper也是分开的。</p>
<h4 id="IAllocator接口"><a href="#IAllocator接口" class="headerlink" title="IAllocator接口"></a>IAllocator接口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/IAllocator.hal</span><br><span class="line"></span><br><span class="line">package android.hardware.graphics.allocator@<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.graphics.mapper@<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">interface IAllocator &#123;</span><br><span class="line">    @entry</span><br><span class="line">    @<span class="built_in">exit</span></span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    dumpDebugInfo() generates (<span class="built_in">string</span> debugInfo);</span><br><span class="line"></span><br><span class="line">    @entry</span><br><span class="line">    @<span class="built_in">exit</span></span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    allocate(BufferDescriptor descriptor, <span class="keyword">uint32_t</span> count)</span><br><span class="line">        generates (Error error,</span><br><span class="line">                   <span class="keyword">uint32_t</span> stride,</span><br><span class="line">                   vec&lt;handle&gt; buffers);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IAllocator主要两个接口：</p>
<ul>
<li>allocate<br>根据Buffer Descriptor描述的属性，分配对应的Buffer；count，分配的个数；返回值，stride，Buffer 步长，何为步长？我们知道Buffer都有一个宽度，但是Buffer的内存中分配的时候，都是采用对齐后的大小。多少位对齐，每个硬件平台不一样。比如，我们在一个32对齐的平台上，需要申请一块60x60大小的Buffer。因为要做对齐，所以实际分配的大小为64x60。那么对于这块Buffer，stride就是64。这是因为我们读Buffer的时候，基本都是一行一行的读的，我们要读i行j列，也就是base + i*stride + j的位置。在有的场合下，高也会要求做对齐，那么60x60的Buffer，实际分配的大小是64x64的。buffers这是分配的Buffer的handle了。</li>
<li>dumpDebugInfo<br>dump函数，主要用来debug用</li>
</ul>
<p>所以，IAllocator的接口主要就一个allocate。<br>IAllocator又是怎么跟HAL模块连接上的呢？其实一个hidl的接口，在编译时会生成很多东西～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hidl_interface &#123;</span><br><span class="line">    name: <span class="string">&quot;android.hardware.graphics.allocator@2.0&quot;</span>,</span><br><span class="line">    root: <span class="string">&quot;android.hardware&quot;</span>,</span><br><span class="line">    vndk: &#123;</span><br><span class="line">        enabled: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">&quot;IAllocator.hal&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    interfaces: [</span><br><span class="line">        <span class="string">&quot;android.hardware.graphics.common@1.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;android.hardware.graphics.mapper@2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;android.hidl.base@1.0&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    gen_java: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IAllocator的目录如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out/soong/.intermediates/hardware/interfaces/graphics/allocator/<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">./android.hardware.graphics.allocator@<span class="number">2.0</span>_genc++_headers/gen/android/hardware/graphics/allocator/<span class="number">2.0</span>/IAllocator.h</span><br><span class="line">./android.hardware.graphics.allocator@<span class="number">2.0</span>_genc++/gen/android/hardware/graphics/allocator/<span class="number">2.0</span>/AllocatorAll.cpp</span><br></pre></td></tr></table></figure>
<p>Gralloc2的构造函数中，将首先建立和HAL层的HwBinder服务连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/Gralloc2.cpp</span><br><span class="line"></span><br><span class="line">Allocator::Allocator(<span class="keyword">const</span> Mapper&amp; mapper)</span><br><span class="line">    : mMapper(mapper)</span><br><span class="line">&#123;</span><br><span class="line">    mAllocator = IAllocator::getService();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;gralloc-alloc is missing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IAllocator的getService函数，是.hal文件中是没有定义的，但是编译的中间结果中会生成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* out/soong/.intermediates/hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/android.hardware.graphics.allocator@<span class="number">2.0</span>_genc++_headers/gen/android/hardware/graphics/allocator/<span class="number">2.0</span>/IAllocator.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ::<span class="function">android::sp&lt;IAllocator&gt; <span class="title">getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">&quot;default&quot;</span>, <span class="keyword">bool</span> getStub=<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里用的是缺省构造函数，这里其实和Binder是类似的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* out/soong/.intermediates/hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/android.hardware.graphics.allocator@<span class="number">2.0</span>_genc++/gen/android/hardware/graphics/allocator/<span class="number">2.0</span>/AllocatorAll.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">::<span class="function">android::sp&lt;IAllocator&gt; <span class="title">IAllocator::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::getServiceInternal&lt;BpHwAllocator&gt;(serviceName, <span class="literal">true</span>, getStub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">IAllocator::registerAsService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> </span>&#123;</span><br><span class="line">    ::android::hardware::details::onRegistration(<span class="string">&quot;android.hardware.graphics.allocator@2.0&quot;</span>, <span class="string">&quot;IAllocator&quot;</span>, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</span><br><span class="line">            = ::android::hardware::defaultServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IAllocator HAL服务是谁呢？默认的实现在这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>默认服务起来的时候，将通过defaultPassthroughServiceImplementation去注册IAllocator的HAL服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">&quot;android.hardware.graphics.allocator@2.0-service&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/graphics/allocator/2.0/IAllocator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> android::hardware::graphics::allocator::V2_0::IAllocator;</span><br><span class="line"><span class="keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;IAllocator&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defaultPassthroughServiceImplementation的实现在LegacySupport.h中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">* system/libhidl/transport/include/hidl/LegacySupport.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Could not get passthrough implementation for %s/%s.&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_FATAL_IF(service-&gt;isRemote(), <span class="string">&quot;Implementation of %s/%s is remote!&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == OK) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Registration complete for %s/%s.&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Could not register service %s/%s (%d).&quot;</span>,</span><br><span class="line">            Interface::descriptor, name.c_str(), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">std</span>:</span>:<span class="built_in">string</span> name,</span><br><span class="line">                                            <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(<span class="string">&quot;default&quot;</span>, maxThreads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IAllocator被注册为Passthrough的Service。registerAsService，看看前面的函数，这个service将会被add到IServiceManager中，这这样，get的时候，就能获取到了。<br>获取到service的时，将会调HIDL_FETCH_***的函数，我们这里就是HIDL_FETCH_IAllocator，中间过程都是在system/libhidl中实现的。这里就不细跟了。<br>HIDL_FETCH_IAllocator的函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">IAllocator* <span class="title">HIDL_FETCH_IAllocator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;failed to get gralloc module&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> major = (<span class="keyword">module</span>-&gt;module_api_version &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">switch</span> (major) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gralloc1Allocator(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gralloc0Allocator(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">&quot;unknown gralloc module major version %d&quot;</span>, major);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HIDL_FETCH时，将会加载对应的HAL实现了。gralloc这边的HAL实现GRALLOC_HARDWARE_MODULE_ID。major就是gralloc的API版本。Gralloc1Allocator是对1.0版本的适配，Gralloc0Allocator是对最初版本的适配。</p>
<h4 id="Gralloc1-Allocator-HAL层接口"><a href="#Gralloc1-Allocator-HAL层接口" class="headerlink" title="Gralloc1 Allocator HAL层接口"></a>Gralloc1 Allocator HAL层接口</h4><p>大多数Hardware的接口都定义在hardware/libhardware/include/hardware，Gralloc也不例外。<br>Gralloc1，HAL的描述为gralloc1_device_t</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* hardware/libhardware/include/hardware/gralloc1.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gralloc1_device</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Must be the first member of this struct, since a pointer to this struct</span></span><br><span class="line"><span class="comment">     * will be generated by casting from a hw_device_t* */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Devices支持的能力</span></span><br><span class="line">    <span class="keyword">void</span> (*getCapabilities)(struct gralloc1_device* device, <span class="keyword">uint32_t</span>* outCount,</span><br><span class="line">            <span class="keyword">int32_t</span>* <span class="comment">/*gralloc1_capability_t*/</span> outCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应功能的函数指针</span></span><br><span class="line">    <span class="keyword">gralloc1_function_pointer_t</span> (*getFunction)(struct gralloc1_device* device,</span><br><span class="line">            <span class="keyword">int32_t</span> <span class="comment">/*gralloc1_function_descriptor_t*/</span> descriptor);</span><br><span class="line">&#125; <span class="keyword">gralloc1_device_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Gralloc1和前面的的实现有比较大的差别，接口都通过函数指针实现，不再采用原来的方式。</p>
<p>下面是Gralloc0的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* hardware/libhardware/include/hardware/gralloc.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*alloc)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">alloc_device_t</span> *dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">7</span>];</span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br></pre></td></tr></table></figure>

<p>Gralloc0中，还是采用直接的函数调用。Gralloc1中，只是getCapabilities采用直接的函数调用。<br>Gralloc1时，走的Gralloc1Allocator，Gralloc0时，走的Gralloc0Allocator。我们主要来看一下Gralloc1Allocator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc1Allocator.cpp</span><br><span class="line"></span><br><span class="line">Gralloc1Allocator::Gralloc1Allocator(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>)</span><br><span class="line">    : mDevice(<span class="literal">nullptr</span>), mCapabilities(), mDispatch() &#123;</span><br><span class="line">    <span class="keyword">int</span> result = gralloc1_open(<span class="keyword">module</span>, &amp;mDevice);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;failed to open gralloc1 device: %s&quot;</span>,</span><br><span class="line">                         strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initCapabilities();</span><br><span class="line">    initDispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gralloc1_open，打开HAL层Gralloc1的具体实现。获取到gralloc1_device_t设备mDevice。</p>
<p>通过initCapabilities函数，将Gralloc1的能力都读出来，放到capabilities中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc1Allocator.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Allocator::initCapabilities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    mDevice-&gt;getCapabilities(mDevice, &amp;count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int32_t</span>&gt; <span class="title">capabilities</span><span class="params">(count)</span></span>;</span><br><span class="line">    mDevice-&gt;getCapabilities(mDevice, &amp;count, capabilities.data());</span><br><span class="line">    capabilities.resize(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> capability : capabilities) &#123;</span><br><span class="line">        <span class="keyword">if</span> (capability == GRALLOC1_CAPABILITY_LAYERED_BUFFERS) &#123;</span><br><span class="line">            mCapabilities.layeredBuffers = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mDevice的getCapabilities函数调了两次，这个在HAL实现中经常用到，第一次，主要是获取大小，第二次才去获取具体的值。</p>
<p>initDispatch初始化函数指针，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc1Allocator.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Allocator::initDispatch</span><span class="params">(<span class="keyword">gralloc1_function_descriptor_t</span> desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     T* outPfn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pfn = mDevice-&gt;getFunction(mDevice, desc);</span><br><span class="line">    <span class="keyword">if</span> (!pfn) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;failed to get gralloc1 function %d&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *outPfn = <span class="keyword">reinterpret_cast</span>&lt;T&gt;(pfn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Allocator::initDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_DUMP, &amp;mDispatch.dump);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_CREATE_DESCRIPTOR,</span><br><span class="line">                 &amp;mDispatch.createDescriptor);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_DESTROY_DESCRIPTOR,</span><br><span class="line">                 &amp;mDispatch.destroyDescriptor);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_SET_DIMENSIONS, &amp;mDispatch.setDimensions);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_SET_FORMAT, &amp;mDispatch.setFormat);</span><br><span class="line">    <span class="keyword">if</span> (mCapabilities.layeredBuffers) &#123;</span><br><span class="line">        initDispatch(GRALLOC1_FUNCTION_SET_LAYER_COUNT,</span><br><span class="line">                     &amp;mDispatch.setLayerCount);</span><br><span class="line">    &#125;</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_SET_CONSUMER_USAGE,</span><br><span class="line">                 &amp;mDispatch.setConsumerUsage);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_SET_PRODUCER_USAGE,</span><br><span class="line">                 &amp;mDispatch.setProducerUsage);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_GET_STRIDE, &amp;mDispatch.getStride);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_ALLOCATE, &amp;mDispatch.allocate);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_RELEASE, &amp;mDispatch.release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mDevice根据gralloc1_function_descriptor_t，去HAL的实现中去获取对应的函数指针，初始化到mDispatch中。以后我们直接调mDispatch中的函数就访问到HAL的实现。<br>Gralloc1的gralloc1_function_descriptor_t包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* hardware/libhardware/include/hardware/gralloc1.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    GRALLOC1_FUNCTION_INVALID = <span class="number">0</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_DUMP = <span class="number">1</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_CREATE_DESCRIPTOR = <span class="number">2</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_DESTROY_DESCRIPTOR = <span class="number">3</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_SET_CONSUMER_USAGE = <span class="number">4</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_SET_DIMENSIONS = <span class="number">5</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_SET_FORMAT = <span class="number">6</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_SET_PRODUCER_USAGE = <span class="number">7</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_BACKING_STORE = <span class="number">8</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_CONSUMER_USAGE = <span class="number">9</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_DIMENSIONS = <span class="number">10</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_FORMAT = <span class="number">11</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_PRODUCER_USAGE = <span class="number">12</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_STRIDE = <span class="number">13</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_ALLOCATE = <span class="number">14</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_RETAIN = <span class="number">15</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_RELEASE = <span class="number">16</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_NUM_FLEX_PLANES = <span class="number">17</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_LOCK = <span class="number">18</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_LOCK_FLEX = <span class="number">19</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_UNLOCK = <span class="number">20</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_SET_LAYER_COUNT = <span class="number">21</span>,</span><br><span class="line">    GRALLOC1_FUNCTION_GET_LAYER_COUNT = <span class="number">22</span>,</span><br><span class="line">    GRALLOC1_LAST_FUNCTION = <span class="number">22</span>,</span><br><span class="line">&#125; <span class="keyword">gralloc1_function_descriptor_t</span>;</span><br></pre></td></tr></table></figure>
<p>IAllocator需要实现的gralloc1_function_descriptor_t包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc1Allocator.h</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        GRALLOC1_PFN_DUMP dump;</span><br><span class="line">        GRALLOC1_PFN_CREATE_DESCRIPTOR createDescriptor;</span><br><span class="line">        GRALLOC1_PFN_DESTROY_DESCRIPTOR destroyDescriptor;</span><br><span class="line">        GRALLOC1_PFN_SET_DIMENSIONS setDimensions;</span><br><span class="line">        GRALLOC1_PFN_SET_FORMAT setFormat;</span><br><span class="line">        GRALLOC1_PFN_SET_LAYER_COUNT setLayerCount;</span><br><span class="line">        GRALLOC1_PFN_SET_CONSUMER_USAGE setConsumerUsage;</span><br><span class="line">        GRALLOC1_PFN_SET_PRODUCER_USAGE setProducerUsage;</span><br><span class="line">        GRALLOC1_PFN_GET_STRIDE getStride;</span><br><span class="line">        GRALLOC1_PFN_ALLOCATE allocate;</span><br><span class="line">        GRALLOC1_PFN_RELEASE release;</span><br><span class="line">    &#125; mDispatch;</span><br></pre></td></tr></table></figure>
<p>我们去实现Gralloc1的HAL时，allocator只去要实现getCapabilities和上面mDispatch中的gralloc1_function_descriptor_t就可以了。</p>
<h4 id="IMapper接口"><a href="#IMapper接口" class="headerlink" title="IMapper接口"></a>IMapper接口</h4><p>IMapper的接口有两个版本2.0和2.1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls hardware/interfaces/graphics/mapper</span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span>  <span class="number">2.1</span></span><br></pre></td></tr></table></figure>
<p>2.1是可选的，暂时不严格要求支持：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/Gralloc2.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mapper::preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    android::hardware::preloadPassthroughService&lt;hardware::graphics::mapper::V2_0::IMapper&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mapper::Mapper()</span><br><span class="line">&#123;</span><br><span class="line">    mMapper = IMapper::getService();</span><br><span class="line">    <span class="keyword">if</span> (mMapper == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;gralloc-mapper is missing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMapper-&gt;isRemote()) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;gralloc-mapper must be in passthrough mode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMapper 2.1 is optional</span></span><br><span class="line">    mMapperV2_1 = hardware::graphics::mapper::V2_1::IMapper::castFrom(mMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMapper也是PassThrough的模式。</p>
<h4 id="IMapper2-0的接口"><a href="#IMapper2-0的接口" class="headerlink" title="IMapper2.0的接口"></a>IMapper2.0的接口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/mapper/<span class="number">2.0</span>/IMapper.hal</span><br><span class="line"></span><br><span class="line">package android.hardware.graphics.mapper@<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.graphics.common@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">interface IMapper &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BufferDescriptorInfo</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> width; <span class="comment">// 宽，横向的像素点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> height; <span class="comment">//高，纵向的像素点数</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The number of image layers that must be in the allocated buffer.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> layerCount;</span><br><span class="line"></span><br><span class="line">        PixelFormat format; <span class="comment">//像素点的格式</span></span><br><span class="line"></span><br><span class="line">        bitfield&lt;BufferUsage&gt; usage; <span class="comment">//用处</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> &#123;</span></span><br><span class="line">        <span class="keyword">int32_t</span> left;</span><br><span class="line">        <span class="keyword">int32_t</span> top;</span><br><span class="line">        <span class="keyword">int32_t</span> width;</span><br><span class="line">        <span class="keyword">int32_t</span> height;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Buffer的描述，这个描述在分配Buffer时使用</span></span><br><span class="line"><span class="comment">     * 如果成功，返回值为NONE, 参数无效或冲突返回BAD_VALUE，没有资源返回NO_RESOURCES，参数不支持返回UNSUPPORTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @entry</span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    createDescriptor(BufferDescriptorInfo descriptorInfo)</span><br><span class="line">          generates (Error error,</span><br><span class="line">                     BufferDescriptor descriptor);</span><br><span class="line"></span><br><span class="line">    @entry</span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    importBuffer(handle rawHandle) generates (Error error, pointer buffer);</span><br><span class="line"></span><br><span class="line">    @<span class="built_in">exit</span></span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    freeBuffer(pointer buffer) generates (Error error);</span><br><span class="line"></span><br><span class="line">    @callflow(next=<span class="string">&quot;unlock&quot;</span>)</span><br><span class="line">    lock(pointer buffer,</span><br><span class="line">         bitfield&lt;BufferUsage&gt; cpuUsage,</span><br><span class="line">         Rect accessRegion,</span><br><span class="line">         handle acquireFence)</span><br><span class="line">        generates (Error error,</span><br><span class="line">                   pointer data);</span><br><span class="line"></span><br><span class="line">    @callflow(next=<span class="string">&quot;unlock&quot;</span>)</span><br><span class="line">    lockYCbCr(pointer buffer,</span><br><span class="line">              bitfield&lt;BufferUsage&gt; cpuUsage,</span><br><span class="line">              Rect accessRegion,</span><br><span class="line">              handle acquireFence)</span><br><span class="line">        generates (Error error,</span><br><span class="line">                   YCbCrLayout layout);</span><br><span class="line"></span><br><span class="line">    @callflow(next=<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    unlock(pointer buffer)</span><br><span class="line">        generates (Error error,</span><br><span class="line">                   handle releaseFence);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IMapper的接口比IAllocator多，具体一些信息我写在代码中。</p>
<ul>
<li>createDescriptor<br>创建一个BufferDescriptor，分配Buffer时，根据Descriptor分配。</li>
<li>importBuffer<br>Buffer被冲其他进程或HAL克隆出来时，这个Buffer是RAW状态的Buffer，raw handle是不能直接访问真正的Buffer的，我们需要把它imported到imported的handle中才能访问。创建imported handle时，需要验证raw handle的有效性，且raw handle需要能多少import创建多个imported handle。在passthrough HALs中，从HAL接收到的handle，可能已经被import到进程中，这个时候要能区分，将其当做raw handle处理，而不是返回BAD_BUFFER。</li>
<li>freeBuffer<br>释放Buffer handle，通过importBuffer返回的handle必现通过这个接口释放。importBuffer时申请的所有资源必须一起释放。比如 imported handle如果通过native_handle_create创建的，那么必须调用native_handle_close和native_handle_delete</li>
<li>lock<br>将Buffer锁住，用来做制定的处理。多线程可以同事lock，但是不能同时写。超出accessRegion区域的Buffer不能写，超出的区域不受保护。Buffer的地址是指针buffer，是从left-top开始的，即使accessRegion不是left-top描述。</li>
<li>lockYCbCr<br>这个lock很相似，只是返回值不一样，这里是YCbCrLayout。除非是Codec配置为flexible-YUV-compatible的颜色格式，要不必现是PixelFormat::YCbCr_*_888格式的。</li>
<li>unlock<br>表示CPU访问Buffer已经完成</li>
</ul>
<p>IMapper用到的数据类型定义在types.hal中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/mapper/<span class="number">2.0</span>/types.hal</span><br><span class="line"></span><br><span class="line">package android.hardware.graphics.mapper@<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Error : <span class="keyword">int32_t</span> &#123;</span><br><span class="line">    NONE            = <span class="number">0</span>, <span class="comment">/** no error */</span></span><br><span class="line">    BAD_DESCRIPTOR  = <span class="number">1</span>, <span class="comment">/** invalid BufferDescriptor */</span></span><br><span class="line">    BAD_BUFFER      = <span class="number">2</span>, <span class="comment">/** invalid buffer handle */</span></span><br><span class="line">    BAD_VALUE       = <span class="number">3</span>, <span class="comment">/** invalid width, height, etc. */</span></span><br><span class="line">    <span class="comment">/* 4 is reserved */</span></span><br><span class="line">    NO_RESOURCES    = <span class="number">5</span>, <span class="comment">/** temporary failure due to resource contention */</span></span><br><span class="line">    <span class="comment">/* 6 is reserved */</span></span><br><span class="line">    UNSUPPORTED     = <span class="number">7</span>, <span class="comment">/** permanent failure */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A buffer descriptor is an implementation-defined opaque data returned by</span></span><br><span class="line"><span class="comment"> * createDescriptor. It describes the properties of a buffer and is consumed</span></span><br><span class="line"><span class="comment"> * by the allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> vec&lt;<span class="keyword">uint32_t</span>&gt; BufferDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Structure for describing YCbCr formats for consumption by applications.</span></span><br><span class="line"><span class="comment"> * This is used with PixelFormat::YCBCR_*_888.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Buffer chroma subsampling is defined in the format.</span></span><br><span class="line"><span class="comment"> * e.g. PixelFormat::YCBCR_420_888 has subsampling 4:2:0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Buffers must have a 8 bit depth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * y, cb, and cr point to the first byte of their respective planes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Stride describes the distance in bytes from the first value of one row of</span></span><br><span class="line"><span class="comment"> * the image to the first value of the next row. It includes the width of the</span></span><br><span class="line"><span class="comment"> * image plus padding.</span></span><br><span class="line"><span class="comment"> * yStride is the stride of the luma plane.</span></span><br><span class="line"><span class="comment"> * cStride is the stride of the chroma planes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * chromaStep is the distance in bytes from one chroma pixel value to the</span></span><br><span class="line"><span class="comment"> * next. This is 2 bytes for semiplanar (because chroma values are interleaved</span></span><br><span class="line"><span class="comment"> * and each chroma value is one byte) and 1 for planar.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YCbCrLayout</span> &#123;</span></span><br><span class="line">    pointer y;</span><br><span class="line">    pointer cb;</span><br><span class="line">    pointer cr;</span><br><span class="line">    <span class="keyword">uint32_t</span> yStride;</span><br><span class="line">    <span class="keyword">uint32_t</span> cStride;</span><br><span class="line">    <span class="keyword">uint32_t</span> chromaStep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="IMapper2-1的接口"><a href="#IMapper2-1的接口" class="headerlink" title="IMapper2.1的接口"></a>IMapper2.1的接口</h4><p>IMapper2.1的接口继承IMapper2.0的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/mapper/<span class="number">2.1</span>/IMapper.hal</span><br><span class="line"></span><br><span class="line">package android.hardware.graphics.mapper@<span class="number">2.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.hardware.graphics.mapper@<span class="number">2.0</span>::Error;</span><br><span class="line"><span class="keyword">import</span> android.hardware.graphics.mapper@<span class="number">2.0</span>::IMapper;</span><br><span class="line"></span><br><span class="line">interface IMapper extends android.hardware.graphics.mapper@<span class="number">2.0</span>::IMapper &#123;</span><br><span class="line"></span><br><span class="line">    validateBufferSize(pointer buffer,</span><br><span class="line">                       BufferDescriptorInfo descriptorInfo,</span><br><span class="line">                       <span class="keyword">uint32_t</span> stride)</span><br><span class="line">            generates (Error error);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the transport size of a buffer. An imported buffer handle is a raw</span></span><br><span class="line"><span class="comment">     * buffer handle with the process-local runtime data appended. This</span></span><br><span class="line"><span class="comment">     * function, for example, allows a caller to omit the process-local</span></span><br><span class="line"><span class="comment">     * runtime data at the tail when serializing the imported buffer handle.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that a client might or might not omit the process-local runtime</span></span><br><span class="line"><span class="comment">     * data when sending an imported buffer handle. The mapper must support</span></span><br><span class="line"><span class="comment">     * both cases on the receiving end.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param buffer is the buffer to get the transport size from.</span></span><br><span class="line"><span class="comment">     * @return error is NONE upon success. Otherwise,</span></span><br><span class="line"><span class="comment">     *                  BAD_BUFFER when the buffer is invalid.</span></span><br><span class="line"><span class="comment">     * @return numFds is the number of file descriptors needed for transport.</span></span><br><span class="line"><span class="comment">     * @return numInts is the number of integers needed for transport.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getTransportSize(pointer buffer)</span><br><span class="line">            generates (Error error,</span><br><span class="line">                       <span class="keyword">uint32_t</span> numFds,</span><br><span class="line">                       <span class="keyword">uint32_t</span> numInts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>validateBufferSize<br>验证，Buffer能不能被制定的描述信息和步长的访问者访问。</li>
<li>getTransportSize<br>获取Buffer传输的大小。一个Imported handle是一个raw handle再加上进程本地运行的数据，所以我们可以获取到进程本地的数据。</li>
</ul>
<p>IMapper的HIDL_FETCH_IMapper函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/mapper/<span class="number">2.0</span>/<span class="keyword">default</span>/GrallocMapper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">IMapper* <span class="title">HIDL_FETCH_IMapper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;failed to get gralloc module&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> major = (<span class="keyword">module</span>-&gt;module_api_version &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">switch</span> (major) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gralloc1Mapper(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gralloc0Mapper(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">&quot;unknown gralloc module major version %d&quot;</span>, major);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IMapper的HAL模块ID为GRALLOC_HARDWARE_MODULE_ID，和IAllocator类似，这里也对应两个mapper。Gralloc1Mapper和Gralloc0Mapper<br>前面IAllocator的时候，有个main函数，这里为什么没有？那么，IMapper是怎么找到的呢？<br>夏雨荷已死，还记得Gralloc2中的preload吗？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/libs/ui/Gralloc2.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mapper::preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    android::hardware::preloadPassthroughService&lt;hardware::graphics::mapper::V2_0::IMapper&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gralloc1-Mapper-HAL层接口"><a href="#Gralloc1-Mapper-HAL层接口" class="headerlink" title="Gralloc1 Mapper HAL层接口"></a>Gralloc1 Mapper HAL层接口</h4><p>Mapper的接口也定义在gralloc1.h中，Gralloc1对应的Mapper为Gralloc1Mapper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* hardware/interfaces/graphics/allocator/<span class="number">2.0</span>/<span class="keyword">default</span>/Gralloc1On0Adapter.cpp</span><br><span class="line"></span><br><span class="line">Gralloc1Mapper::Gralloc1Mapper(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>)</span><br><span class="line">    : mDevice(<span class="literal">nullptr</span>), mDispatch() &#123;</span><br><span class="line">    <span class="keyword">int</span> result = gralloc1_open(<span class="keyword">module</span>, &amp;mDevice);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;failed to open gralloc1 device: %s&quot;</span>,</span><br><span class="line">                         strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initCapabilities();</span><br><span class="line">    initDispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper的initCapabilities函数，和allocator的initCapabilities函数类似，都是通过gralloc1_device_t的getCapabilities函数去获取。只是这里但是做了一个封装了mCapabilities。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Mapper::initCapabilities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCapabilities.highUsageBits = <span class="literal">true</span>;</span><br><span class="line">    mCapabilities.layeredBuffers = <span class="literal">false</span>;</span><br><span class="line">    mCapabilities.unregisterImplyDelete = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    mDevice-&gt;getCapabilities(mDevice, &amp;count, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int32_t</span>&gt; <span class="title">capabilities</span><span class="params">(count)</span></span>;</span><br><span class="line">    mDevice-&gt;getCapabilities(mDevice, &amp;count, capabilities.data());</span><br><span class="line">    capabilities.resize(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> capability : capabilities) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (capability) &#123;</span><br><span class="line">            <span class="keyword">case</span> GRALLOC1_CAPABILITY_LAYERED_BUFFERS:</span><br><span class="line">                mCapabilities.layeredBuffers = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE:</span><br><span class="line">                mCapabilities.unregisterImplyDelete = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是这里但是做了一个封装了mCapabilities。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> highUsageBits;</span><br><span class="line">    <span class="keyword">bool</span> layeredBuffers;</span><br><span class="line">    <span class="keyword">bool</span> unregisterImplyDelete;</span><br><span class="line">&#125; mCapabilities = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>Gralloc1，中Mapper 对应的gralloc1_function_descriptor_t如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Mapper::initDispatch</span><span class="params">(<span class="keyword">gralloc1_function_descriptor_t</span> desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  T* outPfn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pfn = mDevice-&gt;getFunction(mDevice, desc);</span><br><span class="line">    <span class="keyword">if</span> (!pfn) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;failed to get gralloc1 function %d&quot;</span>, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *outPfn = <span class="keyword">reinterpret_cast</span>&lt;T&gt;(pfn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gralloc1Mapper::initDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_RETAIN, &amp;mDispatch.retain);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_RELEASE, &amp;mDispatch.release);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_GET_NUM_FLEX_PLANES,</span><br><span class="line">                 &amp;mDispatch.getNumFlexPlanes);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_LOCK, &amp;mDispatch.lock);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_LOCK_FLEX, &amp;mDispatch.lockFlex);</span><br><span class="line">    initDispatch(GRALLOC1_FUNCTION_UNLOCK, &amp;mDispatch.unlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapper的HAL实现，只要实现上述的gralloc1_function_descriptor_t。</p>
<p>我们来看一下Gralloc1的相关类似关系～</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG5.gralloc1.png" alt="Alt text | center"></p>
<p>最终，Gralloc1都是在gralloc1_device_t中去实现的。当然，如果HAL没有实现对应地Gralloc1，而是Gralloc0。Android这边也是提供适配的。对应的代码在：<br>hardware/interfaces/graphics/allocator/2.0/default/gralloc1-adapter.cpp</p>
<p>下面，我们找一个具体平台的实现来看看，gralloc的HAL层是怎么实现的。</p>
<h4 id="三、Qcom高通平台Gralloc-HAL实现"><a href="#三、Qcom高通平台Gralloc-HAL实现" class="headerlink" title="三、Qcom高通平台Gralloc HAL实现"></a>三、Qcom高通平台Gralloc HAL实现</h4><p>我们这里拿到的代码是AOSP的，和vendor从Qcom那里拿到的估计有些区别。我们就看骁龙835吧～，msm8998的displayHAL相关的实现在hardware/qcom/display/msm8998。</p>
<h5 id="gralloc1整体架构"><a href="#gralloc1整体架构" class="headerlink" title="gralloc1整体架构"></a>gralloc1整体架构</h5><p>高通gralloc HAL的实现在libgralloc1中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* hardware/qcom/display/msm8998/libgralloc1/gr_device_impl.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span>.open = gralloc_device_open&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gralloc_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">  .common = &#123;</span><br><span class="line">    .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version = GRALLOC_MODULE_API_VERSION_1_0,</span><br><span class="line">    .hal_api_version    = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id = GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">    .name = <span class="string">&quot;Graphics Memory Module&quot;</span>,</span><br><span class="line">    .author = <span class="string">&quot;Code Aurora Forum&quot;</span>,</span><br><span class="line">    .methods = &amp;gralloc_module_methods,</span><br><span class="line">    .dso = <span class="number">0</span>,</span><br><span class="line">    .reserved = &#123;<span class="number">0</span>&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">hw_device_t</span> **device)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_MODULE_ID)) &#123;</span><br><span class="line">    gralloc1::GrallocImpl * <span class="comment">/*gralloc1_device_t*/</span> dev = gralloc1::GrallocImpl::GetInstance(<span class="keyword">module</span>);</span><br><span class="line">    *device = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span> *&gt;(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">      status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ALOGE(<span class="string">&quot;Fatal error opening gralloc1 device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Qcom 的gralloc是1.0版本～采用C++编写，具体实现的类为 GrallocImpl。GrallocImpl继承gralloc1_device_t。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GrallocImpl::GrallocImpl(<span class="keyword">const</span> <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>) &#123;</span><br><span class="line">  common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">  common.version = GRALLOC_MODULE_API_VERSION_1_0;</span><br><span class="line">  common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span> *&gt;(<span class="keyword">module</span>);</span><br><span class="line">  common.close = CloseDevice;</span><br><span class="line">  getFunction = GetFunction;</span><br><span class="line">  getCapabilities = GetCapabilities;</span><br><span class="line"></span><br><span class="line">  initalized_ = Init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gralloc1_device_t的getFunction初始化为GetFunction，getCapabilities初始化为GetCapabilities。<br>而在Init，申请了一个BufferManager。BufferManager是单例的用法。GrallocImpl也是单例的用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GrallocImpl::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf_mgr_ = BufferManager::GetInstance();</span><br><span class="line">  <span class="keyword">return</span> buf_mgr_ != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Qcom的Gralloc1支持 Capabilities 有3种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GrallocImpl::GetCapabilities</span><span class="params">(struct gralloc1_device *device, <span class="keyword">uint32_t</span> *out_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int32_t</span>  <span class="comment">/*gralloc1_capability_t*/</span> *out_capabilities)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (out_capabilities != <span class="literal">nullptr</span> &amp;&amp; *out_count &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">      out_capabilities[<span class="number">0</span>] = GRALLOC1_CAPABILITY_TEST_ALLOCATE;</span><br><span class="line">      out_capabilities[<span class="number">1</span>] = GRALLOC1_CAPABILITY_LAYERED_BUFFERS;</span><br><span class="line">      out_capabilities[<span class="number">2</span>] = GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE;</span><br><span class="line">    &#125;</span><br><span class="line">    *out_count = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Android对Capabilities的定义来看，Qcom Gralloc1支持Android要求的所有能力。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* hardware/libhardware/include/hardware/gralloc1.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    GRALLOC1_CAPABILITY_INVALID = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this capability is supported, then the outBuffers parameter to</span></span><br><span class="line"><span class="comment">     * allocate may be NULL, which instructs the device to report whether the</span></span><br><span class="line"><span class="comment">     * given allocation is possible or not. */</span></span><br><span class="line">    GRALLOC1_CAPABILITY_TEST_ALLOCATE = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this capability is supported, then the implementation supports</span></span><br><span class="line"><span class="comment">     * allocating buffers with more than one image layer. */</span></span><br><span class="line">    GRALLOC1_CAPABILITY_LAYERED_BUFFERS = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this capability is supported, then the implementation always closes</span></span><br><span class="line"><span class="comment">     * and deletes a buffer handle whenever the last reference is removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Supporting this capability is strongly recommended.  It will become</span></span><br><span class="line"><span class="comment">     * mandatory in future releases. */</span></span><br><span class="line">    GRALLOC1_CAPABILITY_RELEASE_IMPLY_DELETE = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    GRALLOC1_LAST_CAPABILITY = <span class="number">3</span>,</span><br><span class="line">&#125; <span class="keyword">gralloc1_capability_t</span>;</span><br></pre></td></tr></table></figure>
<p>GetFunction函数，初始化函数指针，gralloc1_function_descriptor_t对应的指针实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">gralloc1_function_pointer_t</span> <span class="title">GrallocImpl::GetFunction</span><span class="params">(<span class="keyword">gralloc1_device_t</span> *device, <span class="keyword">int32_t</span> function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!device) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (function) &#123;</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_DUMP:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(Dump);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_CREATE_DESCRIPTOR:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(CreateBufferDescriptor);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_DESTROY_DESCRIPTOR:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(DestroyBufferDescriptor);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_SET_CONSUMER_USAGE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(SetConsumerUsage);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_SET_DIMENSIONS:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(SetBufferDimensions);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_SET_FORMAT:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(SetColorFormat);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_SET_LAYER_COUNT:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(SetLayerCount);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_SET_PRODUCER_USAGE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(SetProducerUsage);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_BACKING_STORE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetBackingStore);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_CONSUMER_USAGE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetConsumerUsage);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_DIMENSIONS:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetBufferDimensions);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_FORMAT:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetColorFormat);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_LAYER_COUNT:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetLayerCount);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_PRODUCER_USAGE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetProducerUsage);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_STRIDE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetBufferStride);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_ALLOCATE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(AllocateBuffers);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_RETAIN:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(RetainBuffer);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_RELEASE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(ReleaseBuffer);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_GET_NUM_FLEX_PLANES:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(GetNumFlexPlanes);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_LOCK:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(LockBuffer);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_LOCK_FLEX:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(LockFlex);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_UNLOCK:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(UnlockBuffer);</span><br><span class="line">    <span class="keyword">case</span> GRALLOC1_FUNCTION_PERFORM:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gralloc1_function_pointer_t</span>&gt;(Gralloc1Perform);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      ALOGE(<span class="string">&quot;%s:Gralloc Error. Client Requested for unsupported function&quot;</span>, __FUNCTION__);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看Qcom Gralloc1的整体架构～<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG5.gralloc1-class.png" alt="Alt text | center"></p>
<ul>
<li>GrallocImpl继承gralloc1_device_t，这个Gralloc1具体的实现！</li>
<li>GrallocImpl采用一个BufferManager，管理Buffer，自己当领导！</li>
<li>BufferManager，抽像了一个Allocator，负责具体的Buffer分配！</li>
<li>Allocator说，我不具体干活，这个活外包给IonAlloc干，IonAlloc好好干，干不好，给就给别人来做了。</li>
<li>IonAlloc采用ion Buffer，负责具体的Buffer处理</li>
</ul>
<p>总的来说，设计清晰，扩展方便～</p>
<h5 id="allocate相关流程"><a href="#allocate相关流程" class="headerlink" title="allocate相关流程"></a>allocate相关流程</h5><p>我们来看下allocate Buffer的流程，代码就不贴了，给个流程图吧～</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG5.gralloc1-allocate.png" alt="Alt text | center"></p>
<p>这个流程图中，包括了release的流程～<br>Android中的importBuffer函数，在default中变为registerBuffer，在HAL中变成retain，高通对应的实现为RetainBuffer，IonAlloc中又变为ImportBuffer。（…不止72变了…比孙悟空还厉害）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* hardware/qcom/display/msm8998/libgralloc1/gr_ion_alloc.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IonAlloc::ImportBuffer</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ion_fd_data</span> <span class="title">fd_data</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">  fd_data.fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (ioctl(ion_dev_fd_, INT(ION_IOC_IMPORT), &amp;fd_data)) &#123;</span><br><span class="line">    err = -errno;</span><br><span class="line">    ALOGE(<span class="string">&quot;%s: ION_IOC_IMPORT failed with error - %s&quot;</span>, __FUNCTION__, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fd_data.handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import对应的ioctl为ION_IOC_IMPORT。</p>
<p>ion相关的定义，Android有标准的要求，可以参考：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">* system/core/libion/original-kernel-headers/linux/ion.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UAPI_LINUX_ION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UAPI_LINUX_ION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">ion_user_handle_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ion_heap_type &#123;</span><br><span class="line">    ION_HEAP_TYPE_SYSTEM,</span><br><span class="line">    ION_HEAP_TYPE_SYSTEM_CONTIG,</span><br><span class="line">    ION_HEAP_TYPE_CARVEOUT,</span><br><span class="line">    ION_HEAP_TYPE_CHUNK,</span><br><span class="line">    ION_HEAP_TYPE_DMA,</span><br><span class="line">    ION_HEAP_TYPE_CUSTOM, <span class="comment">/* must be last so device specific heaps always</span></span><br><span class="line"><span class="comment">                 are at the end of this enum */</span></span><br><span class="line">    ION_NUM_HEAPS = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_MASK        (1 &lt;&lt; ION_HEAP_TYPE_SYSTEM)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_SYSTEM_CONTIG_MASK (1 &lt;&lt; ION_HEAP_TYPE_SYSTEM_CONTIG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_CARVEOUT_MASK      (1 &lt;&lt; ION_HEAP_TYPE_CARVEOUT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_HEAP_TYPE_DMA_MASK      (1 &lt;&lt; ION_HEAP_TYPE_DMA)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_NUM_HEAP_IDS        sizeof(unsigned int) * 8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_FLAG_CACHED 1       <span class="comment">/* mappings of this buffer should be</span></span></span><br><span class="line"><span class="meta"><span class="comment">                       cached, ion will do cache</span></span></span><br><span class="line"><span class="meta"><span class="comment">                       maintenance when the buffer is</span></span></span><br><span class="line"><span class="meta"><span class="comment">                       mapped for dma */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_FLAG_CACHED_NEEDS_SYNC 2    <span class="comment">/* mappings of this buffer will created</span></span></span><br><span class="line"><span class="meta"><span class="comment">                       at mmap time, if this is set</span></span></span><br><span class="line"><span class="meta"><span class="comment">                       caches must be managed manually */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_allocation_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">size_t</span> align;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> heap_id_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">ion_user_handle_t</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_fd_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">ion_user_handle_t</span> handle;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_handle_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">ion_user_handle_t</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_custom_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_MAGIC       <span class="meta-string">&#x27;I&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ION_IOC_ALLOC       _IOWR(ION_IOC_MAGIC, 0, \</span></span><br><span class="line">                      <span class="class"><span class="keyword">struct</span> <span class="title">ion_allocation_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_FREE</span>        _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 1, <span class="title">struct</span> <span class="title">ion_handle_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_MAP</span>     _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 2, <span class="title">struct</span> <span class="title">ion_fd_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_SHARE</span>       _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 4, <span class="title">struct</span> <span class="title">ion_fd_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_IMPORT</span>      _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 5, <span class="title">struct</span> <span class="title">ion_fd_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_SYNC</span>        _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 7, <span class="title">struct</span> <span class="title">ion_fd_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">ION_IOC_CUSTOM</span>      _<span class="title">IOWR</span>(<span class="title">ION_IOC_MAGIC</span>, 6, <span class="title">struct</span> <span class="title">ion_custom_data</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">endif</span> /* _<span class="title">UAPI_LINUX_ION_H</span> */</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<p>Qcom对应的定义在msm_ion.h中，msm_ion.h在这里就不看了。</p>
<h5 id="Buffer的usage处理"><a href="#Buffer的usage处理" class="headerlink" title="Buffer的usage处理"></a>Buffer的usage处理</h5><p>usage分为两类，一个是Producer的，一个是Consumer的。在GetIonHeapInfo中对usage进行了处理。转换为ion对应的描述ion_heap_id，alloc_type以及ion_flags。这三个属性上面的头文件中有定义。usage的转换如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">* hardware/qcom/display/msm8998/libgralloc1/gr_allocator.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Allocator::GetIonHeapInfo</span><span class="params">(<span class="keyword">gralloc1_producer_usage_t</span> prod_usage,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">gralloc1_consumer_usage_t</span> cons_usage, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ion_heap_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_type, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ion_flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heap_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (prod_usage &amp; GRALLOC1_PRODUCER_USAGE_PROTECTED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cons_usage &amp; GRALLOC1_CONSUMER_USAGE_PRIVATE_SECURE_DISPLAY) &#123;</span><br><span class="line">      heap_id = ION_HEAP(SD_HEAP_ID);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * There is currently no flag in ION for Secure Display</span></span><br><span class="line"><span class="comment">       * VM. Please add it to the define once available.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      flags |= UINT(ION_SD_FLAGS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prod_usage &amp; GRALLOC1_PRODUCER_USAGE_CAMERA) &#123;</span><br><span class="line">      heap_id = ION_HEAP(SD_HEAP_ID);</span><br><span class="line">      <span class="keyword">if</span> (cons_usage &amp; GRALLOC1_CONSUMER_USAGE_HWCOMPOSER) &#123;</span><br><span class="line">        flags |= UINT(ION_SC_PREVIEW_FLAGS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= UINT(ION_SC_FLAGS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      heap_id = ION_HEAP(CP_HEAP_ID);</span><br><span class="line">      flags |= UINT(ION_CP_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prod_usage &amp; GRALLOC1_PRODUCER_USAGE_PRIVATE_MM_HEAP) &#123;</span><br><span class="line">    <span class="comment">// MM Heap is exclusively a secure heap.</span></span><br><span class="line">    <span class="comment">// If it is used for non secure cases, fallback to IOMMU heap</span></span><br><span class="line">    ALOGW(<span class="string">&quot;MM_HEAP cannot be used as an insecure heap. Using system heap instead!!&quot;</span>);</span><br><span class="line">    heap_id |= ION_HEAP(ION_SYSTEM_HEAP_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prod_usage &amp; GRALLOC1_PRODUCER_USAGE_PRIVATE_CAMERA_HEAP) &#123;</span><br><span class="line">    heap_id |= ION_HEAP(ION_CAMERA_HEAP_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prod_usage &amp; GRALLOC1_PRODUCER_USAGE_PRIVATE_ADSP_HEAP ||</span><br><span class="line">      prod_usage &amp; GRALLOC1_PRODUCER_USAGE_SENSOR_DIRECT_DATA) &#123;</span><br><span class="line">    heap_id |= ION_HEAP(ION_ADSP_HEAP_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; UINT(ION_SECURE)) &#123;</span><br><span class="line">    type |= <span class="keyword">private_handle_t</span>::PRIV_FLAGS_SECURE_BUFFER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if no ion heap flags are set, default to system heap</span></span><br><span class="line">  <span class="keyword">if</span> (!heap_id) &#123;</span><br><span class="line">    heap_id = ION_HEAP(ION_SYSTEM_HEAP_ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *alloc_type = type;</span><br><span class="line">  *ion_flags = flags;</span><br><span class="line">  *ion_heap_id = heap_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Qcom的Gralloc1就不多介绍了，需要注意的是Qcom对很多数据结构进行封装，增加了更多的信息，可以借助Qcom的文档进行理解。比如private_handle_t继承native_handle_t，对native_handle_t进行了扩展。定义在下面的头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hardware/qcom/display/msm8998/libgralloc1/gr_priv_handle.h</span><br></pre></td></tr></table></figure>

<h4 id="四、ION-Buffer"><a href="#四、ION-Buffer" class="headerlink" title="四、ION Buffer"></a>四、ION Buffer</h4><p>Ion Buffer是一种内存分配器，是Android 4.0版本开始引入的，用以取代被诟病的PMEM，完美解决内存碎片管理。Ion管理着一个或多个内存池，其中有一些会在启动的时候预先分配，供一些特殊的设备使用，比如GPU，Display。<br>IonAlloc初始化时，将会打开对应的ion驱动设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* hardware/qcom/display/msm8998/libgralloc1/gr_ion_alloc.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IonAlloc::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ion_dev_fd_ == FD_INIT) &#123;</span><br><span class="line">    ion_dev_fd_ = open(kIonDevice, O_RDONLY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ion_dev_fd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;%s: Failed to open ion device - %s&quot;</span>, __FUNCTION__, strerror(errno));</span><br><span class="line">    ion_dev_fd_ = FD_INIT;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="heap的类型"><a href="#heap的类型" class="headerlink" title="heap的类型"></a>heap的类型</h5><p>ION的驱动在kernel的驱动中，前面说到的system/core中的ion.h其实是自动生成的。我们基于这个开源的分支来看android-msm-wahoo-4.4-oreo-mr1<br>kernel/drivers/staging/android/ion</p>
<p>Ion定义了6种不同的heap类似，实现不同的分配策略：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/uapi/ion.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ion_heap_type &#123;</span><br><span class="line">    ION_HEAP_TYPE_SYSTEM,</span><br><span class="line">    ION_HEAP_TYPE_SYSTEM_CONTIG,</span><br><span class="line">    ION_HEAP_TYPE_CARVEOUT,</span><br><span class="line">    ION_HEAP_TYPE_CHUNK,</span><br><span class="line">    ION_HEAP_TYPE_DMA,</span><br><span class="line">    ION_HEAP_TYPE_CUSTOM, </span><br><span class="line">    ION_NUM_HEAPS = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>ION_HEAP_TYPE_SYSTEM<br>通过vmallc分配，vmalloc只保证内存在虚拟地址空间是连续的。</li>
<li>ION_HEAP_TYPE_SYSTEM_CONTIG<br>通过kmalloc分配，kmalloc保证物理地址也是连续的。</li>
<li>ION_HEAP_TYPE_CARVEOUT<br>从保留的carveout 中分配一个heap，分配的内存是物理连续的。</li>
<li>ION_HEAP_TYPE_CHUNK<br>分配一快大内存</li>
<li>ION_HEAP_TYPE_DMA<br>通过DMA API分配内存，DMA的Buffer</li>
<li>ION_HEAP_TYPE_CUSTOM<br>由用户自己定义，在enum中，必须是最后，这种heap比较特殊</li>
</ul>
<p>Qcom msm8998中，实现的Ion type如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">arch/arm/boot/dts/qcom/msm8998-ion.dtsi</span><br><span class="line"></span><br><span class="line">&amp;soc &#123;</span><br><span class="line">    qcom,ion &#123;</span><br><span class="line">        compatible = <span class="string">&quot;qcom,msm-ion&quot;</span>;</span><br><span class="line">        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">        system_heap: qcom,ion-heap@<span class="number">25</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">25</span>&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;SYSTEM&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        qcom,ion-heap@<span class="number">22</span> &#123; <span class="comment">/* ADSP HEAP */</span></span><br><span class="line">            reg = &lt;<span class="number">22</span>&gt;;</span><br><span class="line">            memory-region = &lt;&amp;adsp_mem&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;DMA&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        qcom,ion-heap@<span class="number">27</span> &#123; <span class="comment">/* QSEECOM HEAP */</span></span><br><span class="line">            reg = &lt;<span class="number">27</span>&gt;;</span><br><span class="line">            memory-region = &lt;&amp;qseecom_mem&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;DMA&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        qcom,ion-heap@<span class="number">13</span> &#123; <span class="comment">/* SPSS HEAP */</span></span><br><span class="line">            reg = &lt;<span class="number">13</span>&gt;;</span><br><span class="line">            memory-region = &lt;&amp;sp_mem&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;DMA&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        qcom,ion-heap@<span class="number">10</span> &#123; <span class="comment">/* SECURE DISPLAY HEAP */</span></span><br><span class="line">            reg = &lt;<span class="number">10</span>&gt;;</span><br><span class="line">            memory-region = &lt;&amp;secure_display_memory&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;HYP_CMA&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        qcom,ion-heap@<span class="number">9</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">9</span>&gt;;</span><br><span class="line">            qcom,ion-heap-type = <span class="string">&quot;SYSTEM_SECURE&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Qcom定义了更多的heap类型，做特殊之用。dts中的定义在驱动初始化时，将被读出来，构建ion_platform_heap，用ion_platform_heap进行描述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/msm/msm_ion.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ion_platform_data *<span class="title">msm_ion_parse_dt</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_platform_data</span> *<span class="title">pdata</span> = 0;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_platform_heap</span> *<span class="title">heaps</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">new_dev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">dt_node</span> = <span class="title">pdev</span>-&gt;<span class="title">dev</span>.<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> num_heaps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for_each_available_child_of_node(dt_node, node)</span><br><span class="line">        num_heaps++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!num_heaps)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    pdata = kzalloc(<span class="keyword">sizeof</span>(struct ion_platform_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!pdata)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    heaps = kzalloc(<span class="keyword">sizeof</span>(struct ion_platform_heap)*num_heaps, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!heaps) &#123;</span><br><span class="line">        kfree(pdata);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pdata-&gt;heaps = heaps;</span><br><span class="line">    pdata-&gt;nr = num_heaps;</span><br><span class="line"></span><br><span class="line">    for_each_available_child_of_node(dt_node, node) &#123;</span><br><span class="line">        new_dev = of_platform_device_create(node, <span class="literal">NULL</span>, &amp;pdev-&gt;dev);</span><br><span class="line">        <span class="keyword">if</span> (!new_dev) &#123;</span><br><span class="line">            pr_err(<span class="string">&quot;Failed to create device %s\n&quot;</span>, node-&gt;name);</span><br><span class="line">            <span class="keyword">goto</span> free_heaps;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pdata-&gt;heaps[idx].priv = &amp;new_dev-&gt;dev;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> Replace this with of_get_address() when this patch</span></span><br><span class="line"><span class="comment">         * gets merged: http://</span></span><br><span class="line"><span class="comment">         * permalink.gmane.org/gmane.linux.drivers.devicetree/18614</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ret = of_property_read_u32(node, <span class="string">&quot;reg&quot;</span>, &amp;val);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_err(<span class="string">&quot;%s: Unable to find reg key&quot;</span>, __func__);</span><br><span class="line">            <span class="keyword">goto</span> free_heaps;</span><br><span class="line">        &#125;</span><br><span class="line">        pdata-&gt;heaps[idx].id = val;</span><br><span class="line"></span><br><span class="line">        ret = msm_ion_populate_heap(node, &amp;pdata-&gt;heaps[idx]);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> free_heaps;</span><br><span class="line"></span><br><span class="line">        msm_ion_get_heap_dt_data(node, &amp;pdata-&gt;heaps[idx]);</span><br><span class="line"></span><br><span class="line">        ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pdata;</span><br><span class="line"></span><br><span class="line">free_heaps:</span><br><span class="line">    free_pdata(pdata);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ion_platform_heap定定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ion_platform_heap - defines a heap in the given platform</span></span><br><span class="line"><span class="comment"> * @type:   type of the heap from ion_heap_type enum</span></span><br><span class="line"><span class="comment"> * @id:     unique identifier for heap.  When allocating higher numbers</span></span><br><span class="line"><span class="comment"> *      will be allocated from first.  At allocation these are passed</span></span><br><span class="line"><span class="comment"> *      as a bit mask and therefore can not exceed ION_NUM_HEAP_IDS.</span></span><br><span class="line"><span class="comment"> * @name:   used for debug purposes</span></span><br><span class="line"><span class="comment"> * @base:   base address of heap in physical memory if applicable</span></span><br><span class="line"><span class="comment"> * @size:   size of the heap in bytes if applicable</span></span><br><span class="line"><span class="comment"> * @has_outer_cache:    set to 1 if outer cache is used, 0 otherwise.</span></span><br><span class="line"><span class="comment"> * @extra_data: Extra data specific to each heap type</span></span><br><span class="line"><span class="comment"> * @priv:   heap private data</span></span><br><span class="line"><span class="comment"> * @align:  required alignment in physical memory if applicable</span></span><br><span class="line"><span class="comment"> * @priv:   private info passed from the board file</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Provided by the board file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_platform_heap</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> ion_heap_type type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> base;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> has_outer_cache;</span><br><span class="line">    <span class="keyword">void</span> *extra_data;</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> align;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>type，就是dts中的ion-heap-type再加上ION_HEAP_TYPE_的前缀。<br>id，唯一的，是dts中reg的值<br>base，是物理地址的起始地址<br>name 是heap的名字，主要用来debug，以对应的id的形式定义在ion_heap_meta中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/msm/msm_ion.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_desc</span> <span class="title">ion_heap_meta</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SYSTEM_HEAP_ID,</span><br><span class="line">        .name   = ION_SYSTEM_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SYSTEM_CONTIG_HEAP_ID,</span><br><span class="line">        .name   = ION_KMALLOC_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SECURE_HEAP_ID,</span><br><span class="line">        .name   = ION_SECURE_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_CP_MM_HEAP_ID,</span><br><span class="line">        .name   = ION_MM_HEAP_NAME,</span><br><span class="line">        .permission_type = IPT_TYPE_MM_CARVEOUT,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_MM_FIRMWARE_HEAP_ID,</span><br><span class="line">        .name   = ION_MM_FIRMWARE_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_GOOGLE_HEAP_ID,</span><br><span class="line">        .name   = ION_GOOGLE_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_CP_MFC_HEAP_ID,</span><br><span class="line">        .name   = ION_MFC_HEAP_NAME,</span><br><span class="line">        .permission_type = IPT_TYPE_MFC_SHAREDMEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SF_HEAP_ID,</span><br><span class="line">        .name   = ION_SF_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_QSECOM_HEAP_ID,</span><br><span class="line">        .name   = ION_QSECOM_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SPSS_HEAP_ID,</span><br><span class="line">        .name   = ION_SPSS_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_AUDIO_HEAP_ID,</span><br><span class="line">        .name   = ION_AUDIO_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_PIL1_HEAP_ID,</span><br><span class="line">        .name   = ION_PIL1_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_PIL2_HEAP_ID,</span><br><span class="line">        .name   = ION_PIL2_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_CP_WB_HEAP_ID,</span><br><span class="line">        .name   = ION_WB_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_CAMERA_HEAP_ID,</span><br><span class="line">        .name   = ION_CAMERA_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_ADSP_HEAP_ID,</span><br><span class="line">        .name   = ION_ADSP_HEAP_NAME,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .id = ION_SECURE_DISPLAY_HEAP_ID,</span><br><span class="line">        .name   = ION_SECURE_DISPLAY_HEAP_NAME,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解析完dts，ion_platform_heap被放在ion_platform_data的heaps中。<br>创建ion设备，通过ion_device_create函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_ion_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    new_dev = ion_device_create(compat_msm_ion_ioctl);</span><br></pre></td></tr></table></figure>

<p>创建ion_device成功后，会根据解析出来的ion_platform_heap，通过msm_ion_heap_create创建对应的ion_heap。<br>msm_ion_allocate 函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/msm/msm_ion.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct ion_heap *<span class="title">msm_ion_heap_create</span><span class="params">(struct ion_platform_heap *heap_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">int</span>)heap_data-&gt;type) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_SECURE_DMA:</span><br><span class="line">        heap = ion_secure_cma_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_SYSTEM_SECURE:</span><br><span class="line">        heap = ion_system_secure_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_HYP_CMA:</span><br><span class="line">        heap = ion_cma_secure_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        heap = ion_heap_create(heap_data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_OR_NULL(heap)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: error creating heap %s type %d base %pa size %zu\n&quot;</span>,</span><br><span class="line">               __func__, heap_data-&gt;name, heap_data-&gt;type,</span><br><span class="line">               &amp;heap_data-&gt;base, heap_data-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap-&gt;name = heap_data-&gt;name;</span><br><span class="line">    heap-&gt;id = heap_data-&gt;id;</span><br><span class="line">    heap-&gt;priv = heap_data-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实际分配的heap有4种：<br>|类型|函数实现|<br>|——|——-|——-|——-|<br>|ION_HEAP_TYPE_SECURE_DMA|ion_secure_cma_heap_create|ion_cma_secure_heap|ion_secure_cma_ops|<br>|ION_HEAP_TYPE_SYSTEM_SECURE|ion_system_secure_heap_create|ion_system_secure_heap|system_secure_heap_ops|<br>|ION_HEAP_TYPE_HYP_CMA|ion_cma_secure_heap_create|ion_heap|ion_secure_cma_ops|<br>|ION_HEAP_TYPE_SYSTEM default|ion_heap_create|ion_system_heap|system_heap_ops|<br>创建的ion_heap通过ion_device_add_heap中的plist_add(&amp;heap-&gt;node, &amp;dev-&gt;heaps)，把每个创建的ion_heap-&gt;node链接到ion_device-&gt;heaps。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ion_device_add_heap</span><span class="params">(struct ion_device *dev, struct ion_heap *heap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debug_file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!heap-&gt;ops-&gt;allocate || !heap-&gt;ops-&gt;<span class="built_in">free</span> || !heap-&gt;ops-&gt;map_dma ||</span><br><span class="line">        !heap-&gt;ops-&gt;unmap_dma)</span><br><span class="line">        pr_err(<span class="string">&quot;%s: can not add heap with invalid ops struct.\n&quot;</span>,</span><br><span class="line">               __func__);</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;heap-&gt;free_lock);</span><br><span class="line">    heap-&gt;free_list_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;flags &amp; ION_HEAP_FLAG_DEFER_FREE)</span><br><span class="line">        ion_heap_init_deferred_free(heap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((heap-&gt;flags &amp; ION_HEAP_FLAG_DEFER_FREE) || heap-&gt;ops-&gt;shrink)</span><br><span class="line">        ion_heap_init_shrinker(heap);</span><br><span class="line"></span><br><span class="line">    heap-&gt;dev = dev;</span><br><span class="line">    down_write(&amp;dev-&gt;lock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * use negative heap-&gt;id to reverse the priority -- when traversing</span></span><br><span class="line"><span class="comment">     * the list later attempt higher id numbers first</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    plist_node_init(&amp;heap-&gt;node, -heap-&gt;id);</span><br><span class="line">    plist_add(&amp;heap-&gt;node, &amp;dev-&gt;heaps);</span><br><span class="line">    debug_file = debugfs_create_file(heap-&gt;name, <span class="number">0664</span>,</span><br><span class="line">                    dev-&gt;heaps_debug_root, heap,</span><br><span class="line">                    &amp;debug_heap_fops);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    up_write(&amp;dev-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ION_HEAP_TYPE_SECURE_DMA<br>SECURE_DMA类型相关的实现如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion_cma_secure_heap.c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_cma_secure_heap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects against races between threads allocating memory/adding to</span></span><br><span class="line"><span class="comment">     * pool at the same time. (e.g. thread 1 adds to pool, thread 2</span></span><br><span class="line"><span class="comment">     * allocates thread 1&#x27;s memory before thread 1 knows it needs to</span></span><br><span class="line"><span class="comment">     * allocate more.</span></span><br><span class="line"><span class="comment">     * Admittedly this is fairly coarse grained right now but the chance for</span></span><br><span class="line"><span class="comment">     * contention on this lock is unlikely right now. This can be changed if</span></span><br><span class="line"><span class="comment">     * this ever changes in the future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">alloc_lock</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * protects the list of memory chunks in this pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">chunk_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> <span class="title">heap</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Bitmap for allocation. This contains the aggregate of all chunks. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *bitmap;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * List of all allocated chunks</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is where things get &#x27;clever&#x27;. Individual allocations from</span></span><br><span class="line"><span class="comment">     * dma_alloc_coherent must be allocated and freed in one chunk.</span></span><br><span class="line"><span class="comment">     * We don&#x27;t just want to limit the allocations to those confined</span></span><br><span class="line"><span class="comment">     * within a single chunk (if clients allocate n small chunks we would</span></span><br><span class="line"><span class="comment">     * never be able to use the combined size). The bitmap allocator is</span></span><br><span class="line"><span class="comment">     * used to find the contiguous region and the parts of the chunks are</span></span><br><span class="line"><span class="comment">     * marked off as used. The chunks won&#x27;t be freed in the shrinker until</span></span><br><span class="line"><span class="comment">     * the usage is actually zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">chunks</span>;</span></span><br><span class="line">    <span class="keyword">int</span> npages;</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> last_alloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">shrinker</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> total_allocated;</span><br><span class="line">    <span class="keyword">atomic_t</span> total_pool_size;</span><br><span class="line">    <span class="keyword">atomic_t</span> total_leaked;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> heap_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> default_prefetch_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ion_cma_secure_heap继承ion_heap，又扩展了很多实现</p>
<p>SECURE_DMA对应的Ops如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">ion_secure_cma_ops</span> = &#123;</span></span><br><span class="line">    .allocate = ion_secure_cma_allocate,</span><br><span class="line">    .<span class="built_in">free</span> = ion_secure_cma_free,</span><br><span class="line">    .map_dma = ion_secure_cma_heap_map_dma,</span><br><span class="line">    .unmap_dma = ion_secure_cma_heap_unmap_dma,</span><br><span class="line">    .phys = ion_secure_cma_phys,</span><br><span class="line">    .map_user = ion_secure_cma_mmap,</span><br><span class="line">    .map_kernel = ion_secure_cma_map_kernel,</span><br><span class="line">    .unmap_kernel = ion_secure_cma_unmap_kernel,</span><br><span class="line">    .print_debug = ion_secure_cma_print_debug,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Ops就是ioctl下来的，相关cmd的实现。</p>
<ul>
<li>ION_HEAP_TYPE_SYSTEM_SECURE<br>SYSTEM_SECURE采用ion_system_secure_heap进行 描述，继承ion_heap。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion_system_secure_heap.c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_system_secure_heap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">sys_heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> <span class="title">heap</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects prefetch_list */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> work_lock;</span><br><span class="line">    <span class="keyword">bool</span> destroy_heap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">prefetch_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">prefetch_work</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的接口实现为system_secure_heap_ops</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">system_secure_heap_ops</span> = &#123;</span></span><br><span class="line">    .allocate = ion_system_secure_heap_allocate,</span><br><span class="line">    .<span class="built_in">free</span> = ion_system_secure_heap_free,</span><br><span class="line">    .map_dma = ion_system_secure_heap_map_dma,</span><br><span class="line">    .unmap_dma = ion_system_secure_heap_unmap_dma,</span><br><span class="line">    .map_kernel = ion_system_secure_heap_map_kernel,</span><br><span class="line">    .unmap_kernel = ion_system_secure_heap_unmap_kernel,</span><br><span class="line">    .map_user = ion_system_secure_heap_map_user,</span><br><span class="line">    .shrink = ion_system_secure_heap_shrink,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>ION_HEAP_TYPE_HYP_CMA<br>HYP_CMA主要用于Secure 显示。HYP_CMA没有做扩展，还是用ion_heap描述。但是采用Ops为ion_secure_cma_ops。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion_cma_heap.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">ion_secure_cma_ops</span> = &#123;</span></span><br><span class="line">    .allocate = ion_secure_cma_allocate,</span><br><span class="line">    .<span class="built_in">free</span> = ion_secure_cma_free,</span><br><span class="line">    .map_dma = ion_cma_heap_map_dma,</span><br><span class="line">    .unmap_dma = ion_cma_heap_unmap_dma,</span><br><span class="line">    .phys = ion_cma_phys,</span><br><span class="line">    .map_user = ion_cma_mmap,</span><br><span class="line">    .map_kernel = ion_cma_map_kernel,</span><br><span class="line">    .unmap_kernel = ion_cma_unmap_kernel,</span><br><span class="line">    .print_debug = ion_cma_print_debug,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>除上面3中类型外，其他的类型，通过ion_heap_create分配<br>具体的对应关系如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion_heap.c</span><br><span class="line"></span><br><span class="line"><span class="function">struct ion_heap *<span class="title">ion_heap_create</span><span class="params">(struct ion_platform_heap *heap_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (heap_data-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_SYSTEM_CONTIG:</span><br><span class="line">        pr_err(<span class="string">&quot;%s: Heap type is disabled: %d\n&quot;</span>, __func__,</span><br><span class="line">               heap_data-&gt;type);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_SYSTEM:</span><br><span class="line">        heap = ion_system_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_CARVEOUT:</span><br><span class="line">        heap = ion_carveout_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_CHUNK:</span><br><span class="line">        heap = ion_chunk_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ION_HEAP_TYPE_DMA:</span><br><span class="line">        heap = ion_cma_heap_create(heap_data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        pr_err(<span class="string">&quot;%s: Invalid heap type %d\n&quot;</span>, __func__,</span><br><span class="line">               heap_data-&gt;type);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_OR_NULL(heap)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: error creating heap %s type %d base %pa size %zu\n&quot;</span>,</span><br><span class="line">               __func__, heap_data-&gt;name, heap_data-&gt;type,</span><br><span class="line">               &amp;heap_data-&gt;base, heap_data-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    heap-&gt;name = heap_data-&gt;name;</span><br><span class="line">    heap-&gt;id = heap_data-&gt;id;</span><br><span class="line">    heap-&gt;priv = heap_data-&gt;priv;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，ion_system_heap_create类型,采用ion_system_heap描述，继承ion_heap.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion_system_heap.c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_system_heap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> <span class="title">heap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_page_pool</span> **<span class="title">uncached_pools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_page_pool</span> **<span class="title">cached_pools</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_page_pool</span> **<span class="title">secure_pools</span>[<span class="title">VMID_LAST</span>];</span></span><br><span class="line">    <span class="comment">/* Prevents unnecessary page splitting */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">split_page_mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的Ops为system_heap_ops：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> <span class="title">system_heap_ops</span> = &#123;</span></span><br><span class="line">    .allocate = ion_system_heap_allocate,</span><br><span class="line">    .<span class="built_in">free</span> = ion_system_heap_free,</span><br><span class="line">    .map_dma = ion_system_heap_map_dma,</span><br><span class="line">    .unmap_dma = ion_system_heap_unmap_dma,</span><br><span class="line">    .map_kernel = ion_heap_map_kernel,</span><br><span class="line">    .unmap_kernel = ion_heap_unmap_kernel,</span><br><span class="line">    .map_user = ion_heap_map_user,</span><br><span class="line">    .shrink = ion_system_heap_shrink,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="Ion-API"><a href="#Ion-API" class="headerlink" title="Ion API"></a>Ion API</h5><p>在用户空间，提供了系统调用ioctl，对应内存空间的API，内核空间的API对应具体类型的Heap的API。Heap的API用ion_heap_ops描述，前面我们已经说过了每种类型的API对应的ion_heap_ops。<br>除了Ion的标准API外，Qcom又定制了一些自己的ioctl，定制的ioctl实现为compat_msm_ion_ioctl，在下面的代码中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/compat_msm_ion.c</span><br></pre></td></tr></table></figure>
<p>Ion标准的ioctl，在ion_ioctl中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* drivers/staging/android/ion/ion.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ion_fops</span> = &#123;</span></span><br><span class="line">    .owner          = THIS_MODULE,</span><br><span class="line">    .open           = ion_open,</span><br><span class="line">    .release        = ion_release,</span><br><span class="line">    .unlocked_ioctl = ion_ioctl,</span><br><span class="line">    .compat_ioctl   = compat_ion_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在我们的测试代码中，Producer设置是usage为GRALLOC_USAGE_SW_WRITE_OFTEN，Consumer中设置的usage为USAGE_HW_COMPOSER，Layer创建的时候设置的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Layer::getEffectiveUsage</span><span class="params">(<span class="keyword">uint32_t</span> usage)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> should we do something special if mSecure is set?</span></span><br><span class="line">    <span class="keyword">if</span> (mProtectedByApp) &#123;</span><br><span class="line">        <span class="comment">// need a hardware-protected path to external video sink</span></span><br><span class="line">        usage |= GraphicBuffer::USAGE_PROTECTED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPotentialCursor) &#123;</span><br><span class="line">        usage |= GraphicBuffer::USAGE_CURSOR;</span><br><span class="line">    &#125;</span><br><span class="line">    usage |= GraphicBuffer::USAGE_HW_COMPOSER;</span><br><span class="line">    <span class="keyword">return</span> usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GRALLOC_USAGE_SW_WRITE_OFTEN将被转换为 GRALLOC1_PRODUCER_USAGE_CPU_WRITE_OFTEN；USAGE_HW_COMPOSER将被转换为GRALLOC1_CONSUMER_USAGE_HWCOMPOSER；对应的heap id为ION_SYSTEM_HEAP_ID。<br>下面，以ION_HEAP_TYPE_SYSTEM为例，我们通过一个表格来描述他们直接的关系，和API的用途</p>
<table>
<thead>
<tr>
<th align="center">用户空间API</th>
<th align="center">内核空间API</th>
<th align="center">Heap API</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open</td>
<td align="center">ion_client_create</td>
<td align="center">null</td>
<td align="center">分配一个Ion的客户端，客户端负责和Ion设备进行通信</td>
</tr>
<tr>
<td align="center">close</td>
<td align="center">ion_client_destroy</td>
<td align="center">null</td>
<td align="center">释放一个Ion的客户端</td>
</tr>
<tr>
<td align="center">ION_IOC_ALLOC</td>
<td align="center">ion_buffer_create</td>
<td align="center">ion_system_heap_allocate，map_dma</td>
<td align="center">申请一块Ion内存，返回Ion Handle</td>
</tr>
<tr>
<td align="center">ION_IOC_FREE</td>
<td align="center">ion_free ion_free_nolock</td>
<td align="center">ion_system_heap_free</td>
<td align="center">释放Ion handle</td>
</tr>
<tr>
<td align="center">ION_IOC_SHARE &amp; ION_IOC_MAP</td>
<td align="center">ion_share_dma_buf_fd</td>
<td align="center">null</td>
<td align="center">为制定的Buffer创建DMA映射，返回DMA Buffer的FD</td>
</tr>
<tr>
<td align="center">ION_IOC_IMPORT</td>
<td align="center">ion_import_dma_buf</td>
<td align="center">null</td>
<td align="center">通过DMA的FD，返回Ion Buffer的Handle</td>
</tr>
<tr>
<td align="center">ION_IOC_CUSTOM</td>
<td align="center">mmap</td>
<td align="center">ion_mmap</td>
<td align="center">ion_heap_map_user  map内存到user空间</td>
</tr>
</tbody></table>
<p>Qcom定制的Ioctl，ION_IOC_CUSTOM还有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ION_IOC_CLEAN_CACHES</span><br><span class="line">ION_IOC_INV_CACHES</span><br><span class="line">ION_IOC_CLEAN_INV_CACHES</span><br><span class="line">ION_IOC_PREFETCH</span><br><span class="line">ION_IOC_DRAIN</span><br></pre></td></tr></table></figure>

<p>ION是通过handle而非buffer地址来实现驱动间共享内存，用户空间共享内存也是利用同样原理，所以，map，import都是通过handle来完成。另外，Ion Buffer创建后，映射到 DMA Buffer，后续通过DMA Buffer来处理。<br>我们我们来看他们之间的关系类图～</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG5.ion.png" alt="Alt text | center"></p>
<h5 id="Ion-Debug"><a href="#Ion-Debug" class="headerlink" title="Ion Debug"></a>Ion Debug</h5><p>Ion 在/sys/kernel/debug/ion/ 提供一个debugfs 接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... /sys/kernel/debug/ion <span class="meta"># ls</span></span><br><span class="line">clients egl heaps </span><br></pre></td></tr></table></figure>

<p>每个heap都有自己的debugfs目录，client内存使用状况显示在/sys/kernel/debug/ion/heaps/&lt;<heap name>&gt;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... /sys/kernel/debug/ion/heaps <span class="meta"># ls </span></span><br><span class="line">carveout_fb carveout_fb_shrink carveout_overlay carveout_overlay_shrink system system_shrink</span><br></pre></td></tr></table></figure>

<p>比如这个system的分配情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">... /sys/kernel/debug/ion/heaps <span class="meta"># cat system</span></span><br><span class="line">          client              pid             size</span><br><span class="line">----------------------------------------------------</span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="function">orphaned <span class="title">allocations</span> <span class="params">(info is from last known client)</span>:</span></span><br><span class="line"><span class="function">          client      pid             user user_pid             size  mcnt  rcnt</span></span><br><span class="line"> allocator@2.0-s      257  composer@2.1-se      258          7372800     0     1</span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>           <span class="number">139264</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>           <span class="number">139264</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>          <span class="number">3686400</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>          <span class="number">3686400</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>          <span class="number">3686400</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"> allocator@<span class="number">2.0</span>-s      <span class="number">257</span>  composer@<span class="number">2.1</span>-se      <span class="number">258</span>           <span class="number">139264</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">  total orphaned         <span class="number">18849792</span></span><br><span class="line">          total          <span class="number">18849792</span></span><br><span class="line">   deferred <span class="built_in">free</span>                <span class="number">0</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line"><span class="number">4</span> order <span class="number">8</span> highmem pages                     in uncached pool = <span class="number">4194304</span> total</span><br><span class="line"><span class="number">2</span> order <span class="number">8</span> lowmem pages              in uncached pool = <span class="number">2097152</span> total</span><br><span class="line"><span class="number">14</span> order <span class="number">4</span> highmem pages                    in uncached pool = <span class="number">917504</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">4</span> lowmem pages              in uncached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">0</span> highmem pages                     in uncached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">838</span> order <span class="number">0</span> lowmem pages                in uncached pool = <span class="number">3432448</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">8</span> highmem pages                     in cached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">8</span> lowmem pages                  in cached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">4</span> highmem pages                     in cached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">4</span> lowmem pages                  in cached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">0</span> highmem pages                     in cached pool = <span class="number">0</span> total</span><br><span class="line"><span class="number">0</span> order <span class="number">0</span> lowmem pages                  in cached pool = <span class="number">0</span> total</span><br></pre></td></tr></table></figure>

<p>前面是ion Client的pid，这里的<a href="mailto:&#x61;&#108;&#108;&#x6f;&#99;&#x61;&#116;&#x6f;&#114;&#x40;&#x32;&#46;&#48;&#x2d;&#115;&#101;&#114;&#118;&#x69;&#99;&#x65;">&#x61;&#108;&#108;&#x6f;&#99;&#x61;&#116;&#x6f;&#114;&#x40;&#x32;&#46;&#48;&#x2d;&#115;&#101;&#114;&#118;&#x69;&#99;&#x65;</a>。然后是使用者pid，这里是<a href="mailto:&#99;&#x6f;&#109;&#112;&#111;&#x73;&#x65;&#114;&#x40;&#x32;&#x2e;&#49;&#x2d;&#x73;&#x65;&#x72;&#x76;&#x69;&#99;&#x65;">&#99;&#x6f;&#109;&#112;&#111;&#x73;&#x65;&#114;&#x40;&#x32;&#x2e;&#49;&#x2d;&#x73;&#x65;&#x72;&#x76;&#x69;&#99;&#x65;</a>（大部分Buffer都是这个进分配的，用于显示）。<br>小结<br>本章主要讲述GraphicBuffer相关的流程，结合 Qcom的msm8998，讲述了Gralloc1.0的接口实现，介绍了Ion使用及Ion驱动实现。</p>
<h4 id="四、参考文档（特别感谢）："><a href="#四、参考文档（特别感谢）：" class="headerlink" title="四、参考文档（特别感谢）："></a>四、参考文档（特别感谢）：</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd0b38832346">（1）【GraphicBuffer和Gralloc分析（转载于： 夕月风）】</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190724/">https://zhoujinjian.com/posts/20190724/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.40.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190725/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.41.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android P Graphics System（六）：Activity启动流程 &amp;&amp; Surface创建分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190716/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.39.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android P Graphics System（四）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81GraphicBuffer%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">一、GraphicBuffer定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E9%85%8D%E4%B8%80%E5%9D%97Buffer"><span class="toc-number">2.</span> <span class="toc-text">二、分配一块Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gralloc1-0-%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">Gralloc1.0 接口介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IAllocator%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">IAllocator接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gralloc1-Allocator-HAL%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Gralloc1 Allocator HAL层接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMapper%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">IMapper接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMapper2-0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">IMapper2.0的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMapper2-1%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">IMapper2.1的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gralloc1-Mapper-HAL%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">Gralloc1 Mapper HAL层接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81Qcom%E9%AB%98%E9%80%9A%E5%B9%B3%E5%8F%B0Gralloc-HAL%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.</span> <span class="toc-text">三、Qcom高通平台Gralloc HAL实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gralloc1%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">gralloc1整体架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#allocate%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B"><span class="toc-number">10.2.</span> <span class="toc-text">allocate相关流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Buffer%E7%9A%84usage%E5%A4%84%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">Buffer的usage处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ION-Buffer"><span class="toc-number">11.</span> <span class="toc-text">四、ION Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#heap%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">heap的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ion-API"><span class="toc-number">11.2.</span> <span class="toc-text">Ion API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Ion-Debug"><span class="toc-number">11.3.</span> <span class="toc-text">Ion Debug</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%EF%BC%88%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%EF%BC%89%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">四、参考文档（特别感谢）：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>