<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android O Treble 架构 - HIDL源代码分析➺➺➺(๑乛◡乛๑)➺➺➺ | zhoujinjian</title><meta name="keywords" content="Android,Treble,HIDL"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。 首先感谢：">
<meta property="og:type" content="article">
<meta property="og:title" content="Android O Treble 架构 - HIDL源代码分析➺➺➺(๑乛◡乛๑)➺➺➺">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190308/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。 首先感谢：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.28.jpg">
<meta property="article:published_time" content="2019-03-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.960Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Treble">
<meta property="article:tag" content="HIDL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190308/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.28.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android O Treble 架构 - HIDL源代码分析➺➺➺(๑乛◡乛๑)➺➺➺</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-03-08T01:25:00.000Z" title="发表于 2019-03-08 09:25:00">2019-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.960Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HIDL/">HIDL</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。</p>
<p>首先感谢：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123">【YANGWEN123】Android O Treble架构（系列分析文章）</a><br><a target="_blank" rel="noopener" href="https://www.slideshare.net/opersys/androids-hidl-treble-in-the-hal">【Karim Yaghmour】Android’s HIDL: Treble in the HAL - SlideShare</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，再次感谢！！！</p>
<p>Google Pixel、Pixel XL 内核代码（==<strong>文章基于 Kernel-4.x</strong>==）：<br> <a target="_blank" rel="noopener" href="https://github.com/nathanchance/wahoo">Kernel source for Pixel 2 (walleye) and Pixel 2 XL (taimen) - GitHub</a></p>
<p>AOSP 源码（==<strong>文章基于 Android 8.x</strong>==）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<hr>
<p>==源码（部分）==：</p>
<blockquote>
<p>Java框架</p>
</blockquote>
<p>/frameworks/base/core/java/android/os/（JAVA）</p>
<ul>
<li>IHwInterface.java</li>
<li>HwBinder.java</li>
<li>HwRemoteBinder.java</li>
<li>IHwBinder.java</li>
<li>HwParcel.java</li>
</ul>
<p>/frameworks/base/core/jni/（JNI）</p>
<ul>
<li>android_os_HwRemoteBinder.cpp</li>
<li>android_os_HwBinder.cpp</li>
<li>android_os_HwParcel.cpp</li>
</ul>
<blockquote>
<p>Native框架</p>
</blockquote>
<p>/system/libhwbinder/</p>
<ul>
<li>Binder.cpp</li>
<li>BpHwBinder.cpp</li>
<li>IInterface.cpp</li>
<li>IPCThreadState.cpp</li>
<li>Parcel.cpp</li>
<li>ProcessState.cpp</li>
</ul>
<p>/system/libhidl/transport/</p>
<ul>
<li>HidlBinderSupport.cpp</li>
<li>HidlTransportSupport.cpp</li>
<li>ServiceManagement.cpp</li>
<li>/manager/1.0/IServiceManager.hal</li>
<li>/manager/1.0/IServiceNotification.hal</li>
</ul>
<p>/system/hwservicemanager/</p>
<ul>
<li>HidlService.cpp</li>
<li>hwservicemanager.rc</li>
<li>ServiceManager.cpp</li>
<li>service.cpp</li>
</ul>
<blockquote>
<p>Binder Driver（Kernel）</p>
</blockquote>
<p>/drivers/android/</p>
<ul>
<li>binder.c</li>
<li>binder_alloc.c</li>
</ul>
<blockquote>
<p>源码编译生成路径（Java）：</p>
</blockquote>
<p>\out\target\common\gen\JAVA_LIBRARIES</p>
<ul>
<li>android.hardware.light-V2.0-java_intermediates</li>
<li>android.hidl.manager-V1.0-java_intermediates</li>
<li>……</li>
</ul>
<blockquote>
<p>源码编译生成路径（hardware/interfaces/）：</p>
</blockquote>
<p>\out\soong.intermediates\system\</p>
<ul>
<li>libhidl\transport\manager\1.1\android.hidl.manager@1.1_genc++</li>
</ul>
<p>\out\soong.intermediates\hardware\interfaces*</p>
<ul>
<li>light\2.0\android.hardware.light@2.0_genc++</li>
<li>audio\2.0\android.hardware.audio@2.0_genc++</li>
<li>camera*</li>
<li>graphics*</li>
<li>media*</li>
<li>wifi*</li>
<li>……</li>
</ul>
<hr>
<blockquote>
<p>注：文中图文许多参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/">快乐安卓</a>，由于博主有点小小的强迫症，把图片水印都去掉了，请各位见谅！</p>
</blockquote>
<h4 id="（一）、Android-O-Treble-架构介绍"><a href="#（一）、Android-O-Treble-架构介绍" class="headerlink" title="（一）、Android O Treble 架构介绍"></a>（一）、Android O Treble 架构介绍</h4><h6 id="1-0、Android整体架构变化（VNDK、VINTF、HIDL）"><a href="#1-0、Android整体架构变化（VNDK、VINTF、HIDL）" class="headerlink" title="1.0、Android整体架构变化（VNDK、VINTF、HIDL）"></a>1.0、Android整体架构变化（VNDK、VINTF、HIDL）</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-01-HIDL-treble-after.png.png" alt="Alt text | center"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-02-HIDL-treble-architecture.png.png" alt="Alt text | center"></p>
<p>AndroidO引入Treble架构后的变化:</p>
<ol>
<li><p>增加了2个服务管家，Android O 之前版本有且只有一个servicemanager，现在增加到3个(servicemanager、hwservicemanager、vndservicemanager)，他们分管不同的服务。</p>
</li>
<li><p>增加了binder通信库，这是为了适配binder域的扩展。</p>
</li>
<li><p>增加了binder域，系统定义了3个binder设备节点，binder驱动分别处理这3个binder设备节点上的binder通信事件。</p>
</li>
</ol>
<h6 id="1-1、Binder通信域变化"><a href="#1-1、Binder通信域变化" class="headerlink" title="1.1、Binder通信域变化"></a>1.1、Binder通信域变化</h6><p>Treble架构的引入足以说明Binder通信的重要性，之前APP和Framework之间通过binder实现跨进程调用，当然这个调用对开发者来说是透明的，相当于函数本地调用。Treble引入后，Framework和HAL又实现了进程分离，Framework和HAL之间依然使用binder通信，通过HIDL来定义通信接口。那binder通信有什么变化呢？ 在Treble中，引入了多个binder域，主要是增加了多个binder设备，binder驱动实现原理基本没变，变化了一些细节。增加binder设备应该是为了实现更换的权限控制，使用不同binder设备的主体和客体之间的selinux权限有所不同，同时，Android 框架和 HAL 现在使用 Binder 互相通信。由于这种通信方式极大地增加了 Binder 流量。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-03-HIDL-Binder-enhancement.png" alt="Alt text | center"></p>
<p>为了明确地拆分框架（与设备无关）和供应商（与具体设备相关）代码之间的 Binder 流量，Android O 引入了“Binder 上下文”这一概念。每个 Binder 上下文都有自己的设备节点和上下文（服务）管理器。您只能通过上下文管理器所属的设备节点对其进行访问，并且在通过特定上下文传递 Binder 节点时，只能由另一个进程从相同的上下文访问上下文管理器，从而确保这些域完全互相隔离。为了显示 /dev/vndbinder，请确保内核配置项 CONFIG_ANDROID_BINDER_DEVICES 设为”binder,hwbinder,vndbinder”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;kernel/android/configs/android-base.cfg]</span><br><span class="line">CONFIG_ANDROID_BINDER_DEVICES=binder,hwbinder,vndbinder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[-&gt;kernel/drivers/android/binder.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span><br><span class="line">module_param_named(devices, binder_devices_param, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Copy the module_parameter string, because we don&#x27;t want to</span></span><br><span class="line"><span class="comment">     * tokenize it in-place.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">&quot;,&quot;</span>))) &#123;</span><br><span class="line">        ret = init_binder_device(device_name);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">    ......</span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以kernel参数形式得到配置的binder设备节点名称，然后在binder驱动中创建不同的binder设备：<br>这样在驱动中就创建了binder、vndbinder、hwbinder三个驱动设备，并保存在binder设备列表binder_devices中。/dev/binder 设备节点成为了框架进程的专属节点，这意味着oem进程将无法再访问该节点。oem进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。</p>
<h6 id="1-2、vndbinder-amp-amp-vndservicemanager"><a href="#1-2、vndbinder-amp-amp-vndservicemanager" class="headerlink" title="1.2、vndbinder &amp;&amp; vndservicemanager"></a>1.2、vndbinder &amp;&amp; vndservicemanager</h6><p>一直以来，供应商进程都使用 Binder 进程间通信 (IPC) 技术进行通信。在 Android O 中，/dev/binder 设备节点成为了框架进程的专属节点，这意味着供应商进程将无法再访问该节点。供应商进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。对于想要继续在供应商进程之间使用 AIDL 接口的供应商，Android 会按以下方式支持 Binder IPC。</p>
<h6 id="1-2-1、vndbinder"><a href="#1-2-1、vndbinder" class="headerlink" title="1.2.1、vndbinder"></a>1.2.1、vndbinder</h6><p>Android O 支持供应商服务使用新的 Binder 域，这可通过使用 /dev/vndbinder（而非 /dev/binder）进行访问。添加 /dev/vndbinder 后，Android 现在拥有以下 3 个 IPC 域：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-04-HIDL-hwbinder-vndbinder.png" alt="Alt text | center"></p>
<p>通常，供应商进程不直接打开 Binder 驱动程序，而是链接到打开 Binder 驱动程序的 libbinder 用户空间库。为 ::android::ProcessState() 添加方法可为 libbinder 选择 Binder 驱动程序。供应商进程应该在调用 ProcessState,、IPCThreadState 或发出任何普通 Binder 调用之前调用此方法。要使用该方法，请在供应商进程（客户端和服务器）的 main() 后放置以下调用：</p>
<p>ProcessState::initWithDriver(“/dev/vndbinder”);</p>
<h6 id="1-2-2、vndservicemanager"><a href="#1-2-2、vndservicemanager" class="headerlink" title="1.2.2、vndservicemanager"></a>1.2.2、vndservicemanager</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-05-HIDL-hwservicemanager.png" alt="Alt text | center"></p>
<p>以前，Binder 服务通过 servicemanager 注册，其他进程可从中检索这些服务。在 Android O 中，servicemanager 现在专用于框架和应用进程，供应商进程无法再对其进行访问。</p>
<p>不过，供应商服务现在可以使用 vndservicemanager，这是一个使用 /dev/vndbinder（**作为构建基础的源代码与框架 servicemanager 相同/frameworks/native/cmds/servicemanager/**）而非 /dev/binder 的 servicemanager 的新实例。供应商进程无需更改即可与 vndservicemanager 通信；当供应商进程打开 /dev/vndbinder 时，服务查询会自动转至 vndservicemanager。</p>
<p>vndservicemanager 二进制文件包含在 Android 的默认设备 Makefile 中。<br>servicemanager和vndservicemanager使用的是同一份代码，都是由service_manager.c编译而来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/]</span><br><span class="line">Android.bp</span><br><span class="line">bctest.c</span><br><span class="line">binder.c</span><br><span class="line">binder.h</span><br><span class="line">service_manager.c</span><br><span class="line">servicemanager.rc</span><br><span class="line">vndservicemanager.rc</span><br><span class="line"></span><br><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/service_manager.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>]; <span class="comment">/* /dev/vndbinder */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在启动servicemanager 时，并没有传参，而启动vndservicemanager时，传递了binder设备节点。</p>
<blockquote>
<p>service servicemanager /system/bin/servicemanager<br>service vndservicemanager /vendor/bin/vndservicemanager ==<strong>/dev/vndbinder</strong>==</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/vndservicemanager.rc]</span><br><span class="line">service vndservicemanager /vendor/bin/vndservicemanager /dev/vndbinder</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/servicemanager.rc]</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">healthd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">surfaceflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">inputflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">drm</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">keystore</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">gatekeeperd</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<h6 id="1-2-3、servicemanager"><a href="#1-2-3、servicemanager" class="headerlink" title="1.2.3、servicemanager"></a>1.2.3、servicemanager</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-05-HIDL-servicemanager.png.png" alt="Alt text | center"></p>
<h6 id="1-3、hwservicemanager"><a href="#1-3、hwservicemanager" class="headerlink" title="1.3、hwservicemanager"></a>1.3、hwservicemanager</h6><p>hwservicemanager用于管理hidl服务，因此其实现和servicemanager完全不同，使用的binder库也完全不同。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-05-HIDL-vndservicemanager.png.png" alt="Alt text | center"></p>
<h6 id="1-4、Binder库变化"><a href="#1-4、Binder库变化" class="headerlink" title="1.4、Binder库变化"></a>1.4、Binder库变化</h6><p>servicemanager和vndservicemanager都使用libbinder库，只是他们使用的binder驱动不同而已，而hwservicemanager使用libhwbinder库，binder驱动也不同。</p>
<p>libbinder库源码(\frameworks\native\libs\binder)<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-06-libbinder-sourcecode.png" alt="Alt text | center"></p>
<p>libhwbinder库源码：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-07-libhwbinder-sourcecode.png" alt="Alt text | center"></p>
<p>文件对比：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-08-HIDL-binder-hwbinder-file-compare.png" alt="Alt text | center"></p>
<h6 id="1-5、Binder通信框架变化"><a href="#1-5、Binder通信框架变化" class="headerlink" title="1.5、Binder通信框架变化"></a>1.5、Binder通信框架变化</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p>
<p>1.在普通Java Binder框架中，Client端Proxy类完成数据打包，然后交给mRemotebinder代理来完成数据传输。Server端Stub类完成数据解析，然后交给其子类实现。</p>
<p>2.在普通Native Binder框架中，Client端BpXXX类完成数据打包，然后交给mRemoteBpBinder来完成数据传输。Server端BnXXX类完成数据解析，然后交个其子类实现。</p>
<ol start="3">
<li>在HwBinder框架中，Client端的BpHwXXX类完成数据打包，然后交给mRemoteBpHwBinder来完成数据传输。Server端的BnHwXXX类完成数据解析，然后交给_hidl_mImpl来实现。</li>
</ol>
<h6 id="1-6、框架层Binder对象变化"><a href="#1-6、框架层Binder对象变化" class="headerlink" title="1.6、框架层Binder对象变化"></a>1.6、框架层Binder对象变化</h6><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/79836109">【AndroidO Treble架构下的变化】</a><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-10-HIDL-binder-hwbinder-fw-compare.png" alt="Alt text | center"><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-11-HIDL-hwbinder-object.png" alt="Alt text | center"></p>
<h4 id="（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译"><a href="#（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译" class="headerlink" title="（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译"></a>（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译</h4><p>HIDL是一种接口定义语言，描述了HAL和它的用户之间的接口。同aidi类似，我们只需要为hal定义相关接口，然后通过hidl-gen工具即可自动编译生成对应的C++或者java源文件，定义hal接口的文件命名为xxx.hal，为了编译这些.hal文件，需要编写相应的Android.bp或者Android.mk文件:</p>
<ol>
<li><p>Android.bp文件用于编译C++；</p>
</li>
<li><p>Android.mk文件用于编译Java；</p>
</li>
</ol>
<h5 id="2-1、生成子Android-mk和Android-bp文件"><a href="#2-1、生成子Android-mk和Android-bp文件" class="headerlink" title="2.1、生成子Android.mk和Android.bp文件"></a>2.1、生成子Android.mk和Android.bp文件</h5><p>所有的HIDL Interface 都是通过一个.hal文件来描述，为了方便编译生成每一个子hal。Google在系统默认提供了一个脚本update-makefiles.sh，位于hardware/interfaces/、frameworks/hardware/interfaces/、system/hardware/interfaces/、system/libhidl/。以hardware/interfaces/里面的代码为实例做介绍：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">source system/tools/hidl/update-makefiles-helper.sh</span><br><span class="line"> </span><br><span class="line">do_makefiles_update \</span><br><span class="line">  <span class="string">&quot;android.hardware:hardware/interfaces&quot;</span> \</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个脚本的主要作用：根据hal文件生成Android.mk(makefile)和Android.bp(blueprint)文件。在hardware/interfaces的子目录里面，存在.hal文件的目录，都会产生Android.bp和Android.mk文件。详细分析如下：</p>
<ol>
<li>source system/tools下面的update-makefiles-helper.sh，然后执行do_makefiles_update</li>
<li>解析传入进去的参数。参数android.hardware:hardware/interfaces:<br> android.hardware: android.hardware表示包名。<br> hardware/interfaces：表示相对于根目录的文件路径。<br> 会输出如下LOG：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Updating makefiles <span class="keyword">for</span> android.hardware in hardware/interfaces.</span><br><span class="line">Updating ….</span><br></pre></td></tr></table></figure>
<p>3.获取所有的包名。通过function get_packages()函数，获取hardware/interfaces路径下面的所有hal文件所在的目录路径，比如子目录Light里面的hal文件的路径是\hardware\interfaces\light\2.0，加上当前的参数包名hardware/interfaces，通过点的方式连接，将light/2.0+hardware/interfaces里面的斜线转换成点,最终获取的包名就是 <a href="mailto:&#x61;&#x6e;&#x64;&#114;&#x6f;&#x69;&#x64;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#114;&#101;&#x2e;&#108;&#105;&#x67;&#104;&#116;&#x40;&#x32;&#46;&#48;">&#x61;&#x6e;&#x64;&#114;&#x6f;&#x69;&#x64;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#114;&#101;&#x2e;&#108;&#105;&#x67;&#104;&#116;&#x40;&#x32;&#46;&#48;</a>，依次类推获取所有的包名。<br>4.执行hidl-gen命令.将c步骤里面获取的参数和包名还有类名传入hidl-gen命令，在\hardware\interfaces\light\2.0目录下产生Android.mk和Android.bp文件。<br>    Android.mk: hidl-gen -Lmakefile -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport <a href="mailto:&#97;&#x6e;&#100;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#x65;&#x2e;&#108;&#105;&#103;&#x68;&#x74;&#x40;&#50;&#x2e;&#48;">&#97;&#x6e;&#100;&#x72;&#111;&#105;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#x65;&#x2e;&#108;&#105;&#103;&#x68;&#x74;&#x40;&#50;&#x2e;&#48;</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-12-HIDL-android-hal-make.png" alt="Alt text | center"></p>
<p>编译最终在./out/target/common/gen/JAVA_LIBRARIES目录下生成Java源文件。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-13-HIDL-android-make-java.png" alt="Alt text | center"></p>
<pre><code>Android.bp: hidl-gen -Landroidbp -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport android.hidl.manager@1.0</code></pre>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-14-HIDL-android-hal-manager.png" alt="Alt text | center"></p>
<p>编译最终在./out/soong/.intermediates/hardware/interfaces目录下生成C++源文件。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-15-HIDL-android-hal-manager-gen-c++.png" alt="Alt text | center"></p>
<p>5.在hardware/interfaces的每个子目录下面产生Android.bp文件，文件内容主要是subdirs的初始化，存放当前目录需要包含的子目录。比如hardware/interfaces/light/下面的Android.bp文件。</p>
<p>经过以上步骤，就会在对应的子目录产生Android.mk和Android.bp文件。这样以后我们就可以执行正常的编译命令进行编译了。比如mmm hardware/interfaces/light/,默认情况下，在源码中，Android.mk和Android.bp文件已经存在。</p>
<h5 id="2-2、hidl-gen工具"><a href="#2-2、hidl-gen工具" class="headerlink" title="2.2、hidl-gen工具"></a>2.2、hidl-gen工具</h5><p>在Treble架构中，系统定义的所有的.hal接口，都是通过hidl-gen工具转换成对应的代码。比如\hardware\interfaces\light\2.0\ILight.hal，会通过hidl-gen转换成\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp文件。<br>hidl-gen源码路径：system/tools/hidl，是在ubuntu上可执行的二进制文件。<br>使用方法：hidl-gen -o output-path -L language (-r interface-root) fqname<br>参数含义：<br>    -L： 语言类型，包括c++, c++-headers, c++-sources, export-header, c++-impl, java, java-constants, vts, makefile, androidbp, androidbp-impl, hash等。hidl-gen可根据传入的语言类型产生不同的文件。fqname：完全限定名称的输入文件。比如本例中<a href="mailto:&#x61;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#46;&#104;&#97;&#x72;&#100;&#x77;&#97;&#114;&#101;&#46;&#x6c;&#105;&#103;&#104;&#116;&#x40;&#50;&#46;&#48;">&#x61;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#46;&#104;&#97;&#x72;&#100;&#x77;&#97;&#114;&#101;&#46;&#x6c;&#105;&#103;&#104;&#116;&#x40;&#50;&#46;&#48;</a>，要求在源码目录下必须有hardware/interfaces/light/2.0/目录。<br>        对于单个文件来说，格式如下：package@version::fileName，比如<a href="mailto:&#97;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x6c;&#x69;&#103;&#104;&#x74;&#64;&#49;&#x2e;&#48;">&#97;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x6c;&#x69;&#103;&#104;&#x74;&#64;&#49;&#x2e;&#48;</a>::types.Feature。<br>        对于目录来说。格式如下package@version，比如<a href="mailto:&#97;&#110;&#100;&#x72;&#111;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#x64;&#x77;&#97;&#114;&#x65;&#x2e;&#x6c;&#x69;&#x67;&#x68;&#116;&#x40;&#50;&#x2e;&#48;">&#97;&#110;&#100;&#x72;&#111;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#x64;&#x77;&#97;&#114;&#x65;&#x2e;&#x6c;&#x69;&#x67;&#x68;&#116;&#x40;&#50;&#x2e;&#48;</a>。<br>    -r： 格式package:path，可选，对fqname对应的文件来说，用来指定包名和文件所在的目录到Android系统源码根目录的路径。如果没有制定，前缀默认是：android.hardware，目录是Android源码的根目录。<br>    -o ： 存放hidl-gen产生的中间文件的路径。我们查看\hardware\interfaces\light\2.0\Android.bp，可以看到，-o参数都是写的$(genDir),一般都是在\out\soong.intermediates\hardware\interfaces\light\2.0\下面，根据-L的不同，后面产生的路径可能不太一样，比如c++，那么就会就是\out\soong.intermediates\hardware\interfaces\light\2.0\gen，如果是c++-headers，那么就是\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++_headers\gen。</p>
<p>对于实例来说，fqname是：<a href="mailto:&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#104;&#x61;&#114;&#100;&#119;&#x61;&#x72;&#x65;&#46;&#x6c;&#105;&#x67;&#104;&#116;&#64;&#50;&#46;&#x30;">&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#104;&#x61;&#114;&#100;&#119;&#x61;&#x72;&#x65;&#46;&#x6c;&#105;&#x67;&#104;&#116;&#64;&#50;&#46;&#x30;</a>，包名是android.hardware，文件所在的目录是hardware/interfaces。例子中的命令会在\out\soong.intermediates\hardware\interfaces\light\2.0\下面产生对应的c++文件。</p>
<p>在\hardware\interfaces\light\2.0\目录下mm编译将生成：</p>
<p>\system\lib64\android.hardware.light@2.0.so<br>\symbols\vendor\lib64\hw\android.hardware.light@2.0-impl.so<br>\vendor\etc\init\android.hardware.light@2.0-service.rc<br>\vendor\bin\hw\android.hardware.light@2.0-service</p>
<p><a href="mailto:&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#x64;&#46;&#x68;&#x61;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x6c;&#x69;&#x67;&#x68;&#x74;&#x40;&#50;&#x2e;&#x30;&#x2d;&#115;&#101;&#x72;&#x76;&#105;&#x63;&#x65;">&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#x64;&#46;&#x68;&#x61;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x6c;&#x69;&#x67;&#x68;&#x74;&#x40;&#50;&#x2e;&#x30;&#x2d;&#115;&#101;&#x72;&#x76;&#105;&#x63;&#x65;</a>为hal进程的可执行文件，在<a href="mailto:&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#x2e;&#104;&#97;&#x72;&#x64;&#119;&#x61;&#114;&#101;&#x2e;&#108;&#x69;&#x67;&#104;&#x74;&#x40;&#x32;&#46;&#x30;&#45;&#115;&#101;&#x72;&#x76;&#105;&#99;&#101;&#46;&#x72;&#x63;">&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#x2e;&#104;&#97;&#x72;&#x64;&#119;&#x61;&#114;&#101;&#x2e;&#108;&#x69;&#x67;&#104;&#x74;&#x40;&#x32;&#46;&#x30;&#45;&#115;&#101;&#x72;&#x76;&#105;&#99;&#101;&#46;&#x72;&#x63;</a>是hal进程启动的配置脚本文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line"></span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说AndroidO的Treble架构下，所有hal都运行在独立的进程空间：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-16-HIDL-hal-process-.png" alt="Alt text | center"></p>
<h4 id="（三）、Android-O-Treble-之-hwservicemanager-启动过程"><a href="#（三）、Android-O-Treble-之-hwservicemanager-启动过程" class="headerlink" title="（三）、Android O Treble 之 hwservicemanager 启动过程"></a>（三）、Android O Treble 之 hwservicemanager 启动过程</h4><p>hwservicemanager是hidl服务管理中心，负责管理系统中的所有hidl服务，由init进程启动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/rootdir/init.rc]</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop <span class="keyword">and</span></span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    <span class="meta"># start essential services</span></span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到在文件系统刚初始化没多久，就启动了系统非常重要的三个管理服务，接下来分析hwservicemanager的启动流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\hwservicemanager.rc]</span><br><span class="line">service hwservicemanager /system/bin/hwservicemanager</span><br><span class="line">    user system</span><br><span class="line">    disabled</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart setprop hwservicemanager.ready <span class="literal">false</span></span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animation</span></span></span><br></pre></td></tr></table></figure>
<p>hwservicemanager的源码位于system\hwservicemanager\s。<br>我们从system\hwservicemanager\service.cpp 的main()入口函数开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\hwservicemanager\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line">    <span class="comment">//创建ServiceManager对象</span></span><br><span class="line">    ServiceManager *manager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line">    <span class="comment">//将ServiceManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, manager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to register hwservicemanager with itself.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建TokenManager对象</span></span><br><span class="line">    TokenManager *tokenManager = <span class="keyword">new</span> TokenManager();</span><br><span class="line">    <span class="comment">//将TokenManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, tokenManager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to register ITokenManager with hwservicemanager.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立消息循环</span></span><br><span class="line">    <span class="function">sp&lt;Looper&gt; <span class="title">looper</span><span class="params">(Looper::prepare(<span class="number">0</span> <span class="comment">/* opts */</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//将主线程加入binder线程池，并得到/dev/hwbinder句柄</span></span><br><span class="line">    IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">    <span class="keyword">if</span> (binder_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to aquire binder FD. Aborting...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">    <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">    <span class="comment">//主线程监听EVENT_INPUT，通过回调BinderCallback处理</span></span><br><span class="line">    <span class="function">sp&lt;BinderCallback&gt; <span class="title">cb</span><span class="params">(<span class="keyword">new</span> BinderCallback)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,</span><br><span class="line">            <span class="literal">nullptr</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to add hwbinder FD to Looper. Aborting...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建BnHwServiceManager对象</span></span><br><span class="line">    <span class="comment">// Tell IPCThreadState we&#x27;re the service manager</span></span><br><span class="line">    sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line">    <span class="comment">// Then tell binder kernel</span></span><br><span class="line">    ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Only enable FIFO inheritance for hwbinder</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> remove define when in the kernel</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_INHERIT_FIFO_PRIO    _IO(<span class="meta-string">&#x27;b&#x27;</span>, 10)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rc = ioctl(binder_fd, BINDER_SET_INHERIT_FIFO_PRIO);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;BINDER_SET_INHERIT_FIFO_PRIO failed with error %d\n&quot;</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过属性方式告知其他进程，hwservicemanager已经就绪</span></span><br><span class="line">    rc = property_set(<span class="string">&quot;hwservicemanager.ready&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to set \&quot;hwservicemanager.ready\&quot; (error %d). &quot;</span>\</span><br><span class="line">              <span class="string">&quot;HAL services will not start!\n&quot;</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入消息循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hwservicemanager启动过程比较简单，最重要的就是以下几行：</p>
<h5 id="3-1、创建BnHwServiceManager"><a href="#3-1、创建BnHwServiceManager" class="headerlink" title="3.1、创建BnHwServiceManager"></a>3.1、创建BnHwServiceManager</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line"><span class="comment">// Then tell binder kernel</span></span><br><span class="line">ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听请求</span></span><br><span class="line"><span class="function">sp&lt;BinderCallback&gt; <span class="title">cb</span><span class="params">(<span class="keyword">new</span> BinderCallback)</span></span>;</span><br><span class="line">looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure>
<p>这里创建一个binder本地对象BnHwServiceManager，然后注册到binder驱动中，让其他client进程都可以找到这个binder本地对象，然后为其创建binder代理对象。需要注意的是BnHwServiceManager的成员变量_hidl_mImpl保存的是ServiceManager实例，ServiceManager类实现了IServiceManager接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.1</span>\android.hidl.manager@<span class="number">1.1</span>_genc++\gen\android\hidl\manager\<span class="number">1.1</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">BnHwServiceManager::BnHwServiceManager(<span class="keyword">const</span> ::android::sp&lt;IServiceManager&gt; &amp;_hidl_impl)</span><br><span class="line">        : ::android::hidl::base::V1_0::BnHwBase(_hidl_impl, <span class="string">&quot;android.hidl.manager@1.1&quot;</span>, <span class="string">&quot;IServiceManager&quot;</span>) &#123; </span><br><span class="line">            _hidl_mImpl = _hidl_impl;</span><br><span class="line">            <span class="keyword">auto</span> prio = ::android::hardware::details::gServicePrioMap.get(_hidl_impl, &#123;SCHED_NORMAL, <span class="number">0</span>&#125;);</span><br><span class="line">            mSchedPolicy = prio.sched_policy;</span><br><span class="line">            mSchedPriority = prio.prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2、IPCThreadState-gt-setTheContextObject-service"><a href="#3-2、IPCThreadState-gt-setTheContextObject-service" class="headerlink" title="3.2、IPCThreadState-&gt;setTheContextObject(service)"></a>3.2、IPCThreadState-&gt;setTheContextObject(service)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将BnHwServiceManager设置到IPCThreadState内部对象当中：</span></span><br><span class="line">sp&lt;BHwBinder&gt;         mContextObject;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::setTheContextObject</span><span class="params">(sp&lt;BHwBinder&gt; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mContextObject = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、BinderCallback"><a href="#3-3、BinderCallback" class="headerlink" title="3.3、BinderCallback"></a>3.3、BinderCallback</h5><p>通过循环监听binder_fd，当有请求时会回调BinderCallback的handleEvent()函数，这部分的知识请参考<br><a href="">【Android 7.1.2 (Android N) Android消息机制–Handler、Looper、Message 分析】</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\core\libutils\Looper.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理请求 handlePolledCommands</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinderCallback() &#123;&#125;</span><br><span class="line">    ~BinderCallback() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进一步通过talkWithDriver() 和 executeCommand(cmd) 处理请求，这一部分跟普通的binder通信就没有区别了，这里就不做分析了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        .......</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4、hwservicemanager-继续关系"><a href="#3-4、hwservicemanager-继续关系" class="headerlink" title="3.4、hwservicemanager 继续关系"></a>3.4、hwservicemanager 继续关系</h5><p>hwservicemanager进程中的servicemanager作为hidl服务，同样适用了hwbinder框架，其类继承关系图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-17-HIDL-binder-bnservicemanager.png" alt="Alt text | center"></p>
<h4 id="（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程"><a href="#（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程" class="headerlink" title="（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程"></a>（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程</h4><p>这里以light模块为例子（其他模块类似）:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ly890700/article/details/62424821">Android 7.0 init.rc的一点改变</a><br>在Android 7之前的版本中，系统Native服务，不管它们的可执行文件位于系统什么位置都定义在根分区的init.*.rc文件中。这造成init＊.rc文件臃肿庞大，给维护带来了一些不便，而且其中定义的一些服务的二进制文件根本不存在。</p>
<p>但在Android 7.0中，对该机制做了一些改变 。</p>
<p>单一的init＊.rc，被拆分，服务根据其二进制文件的位置（/system，/vendor，/odm）定义到对应分区的etc/init目录中，每个服务一个rc文件。与该服务相关的触发器、操作等也定义在同一rc文件中。</p>
<ul>
<li>/system/etc/init，包含系统核心服务的定义，如SurfaceFlinger、MediaServer、Logcatd等。</li>
<li>/vendor/etc/init， SOC厂商针对SOC核心功能定义的一些服务。比如高通、MTK某一款SOC的相关的服务。</li>
<li>/odm/etc/init，OEM/ODM厂商如小米、华为、OPP其产品所使用的外设以及差异化功能相关的服务。</li>
</ul>
<p>这样的目录结构拆分，也与Android产品的开发流程相吻合，减轻了维护的负担。下图为Android7.0<br>模拟器/system/etc/init中定义的服务。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[源代码路径]</span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">[编译生成路径（真机 /<span class="title">vendor</span>/<span class="title">etc</span>/<span class="title">init</span>）]</span></span><br><span class="line"><span class="class">[-&gt;\<span class="title">out</span>\<span class="title">target</span>\<span class="title">product</span>\<span class="title">msm8909go</span>\<span class="title">vendor</span>\<span class="title">etc</span>\<span class="title">init</span>\<span class="title">android</span>.<span class="title">hardware</span>.<span class="title">light</span>@2.0-<span class="title">service</span>.<span class="title">rc</span>]</span></span><br></pre></td></tr></table></figure>
<p>开机会注册<a href="mailto:&#x61;&#x6e;&#x64;&#114;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#108;&#x69;&#103;&#x68;&#x74;&#x40;&#x32;&#x2e;&#48;&#x2d;&#x73;&#101;&#114;&#x76;&#x69;&#x63;&#101;">&#x61;&#x6e;&#x64;&#114;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#108;&#x69;&#103;&#x68;&#x74;&#x40;&#x32;&#x2e;&#48;&#x2d;&#x73;&#101;&#114;&#x76;&#x69;&#x63;&#101;</a>， 直接看main()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;ILight&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用defaultPassthroughServiceImplementation<ILight>()模板函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\LegacySupport.h]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">std</span>:</span>:<span class="built_in">string</span> name,</span><br><span class="line">                                            <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line">    ......</span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(<span class="string">&quot;default&quot;</span>, maxThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp]</span><br><span class="line">&#x2F;&#x2F; static</span><br><span class="line">::android::sp&lt;ILight&gt; ILight::getService(const std::string &amp;serviceName, const bool getStub) &#123;</span><br><span class="line">    using ::android::hardware::defaultServiceManager;</span><br><span class="line">    using ::android::hardware::details::waitForHwService;</span><br><span class="line">    using ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    using ::android::hardware::Return;</span><br><span class="line">    using ::android::sp;</span><br><span class="line">    using Transport &#x3D; ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface &#x3D; nullptr;</span><br><span class="line"></span><br><span class="line">    const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm &#x3D; defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet &#x3D; sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport &#x3D; transportRet;</span><br><span class="line">    const bool vintfHwbinder &#x3D; (transport &#x3D;&#x3D; Transport::HWBINDER);</span><br><span class="line">    const bool vintfPassthru &#x3D; (transport &#x3D;&#x3D; Transport::PASSTHROUGH);</span><br><span class="line">    ......</span><br><span class="line">    if (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm &#x3D; getPassthroughServiceManager();</span><br><span class="line">        if (pm !&#x3D; nullptr) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret &#x3D; </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            if (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface &#x3D; ret;</span><br><span class="line">                if (baseInterface !&#x3D; nullptr) &#123;</span><br><span class="line">                    iface &#x3D; ILight::castFrom(baseInterface);</span><br><span class="line">                    if (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface &#x3D; new BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return iface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sp<Interface> service = Interface::getService(name, true /* getStub */)所以getStub=true. 这里通过PassthroughServiceManager来获取ILight对象。其实所有的Hal 进程都是通过PassthroughServiceManager来得到hidl服务对象的，而作为Hal进程的Client端Framework进程在获取hidl服务对象时，需要通过hal的Transport类型来选择获取方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">&quot;hidl&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-18-HIDL-treble_cpp_legacy_hal_progression.png" alt="Alt text | center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IServiceManager1_0&gt; <span class="title">getPassthroughServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPassthroughServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IServiceManager1_1&gt; <span class="title">getPassthroughServiceManager1_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;PassthroughServiceManager&gt; <span class="title">manager</span><span class="params">(<span class="keyword">new</span> PassthroughServiceManager())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassthroughServiceManager</span> :</span> IServiceManager1_1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openLibs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fqName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span> <span class="comment">/* continue */</span>(<span class="keyword">void</span>* <span class="comment">/* handle */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="comment">/* lib */</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="comment">/* sym */</span>)&gt; eachLib)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></span><br><span class="line">        <span class="keyword">size_t</span> idx = fqName.find(<span class="string">&quot;::&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = fqName.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = fqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">&quot;::&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">&quot;-impl&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">&quot;HIDL_FETCH_&quot;</span> + ifaceName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</span><br><span class="line">        <span class="keyword">void</span> *handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR,</span><br><span class="line">                                          HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;;</span><br><span class="line">                                          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path : paths) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">&quot;.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path != HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里只是简单的创建了一个PassthroughServiceManager对象。PassthroughServiceManager也实现了IServiceManager接口。然后通过PassthroughServiceManager询服务：</p>
<p>根据传入的fqName获取当前的接口名ILight，拼接出后面需要查找的函数名HIDL_FETCH_ILight和库名字<a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#x6c;&#x69;&#103;&#x68;&#x74;&#64;&#50;&#46;&#x30;&#45;&#105;&#109;&#112;&#x6c;&#46;&#x73;&#x6f;">&#97;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#x6c;&#x69;&#103;&#x68;&#x74;&#64;&#50;&#46;&#x30;&#45;&#105;&#109;&#112;&#x6c;&#46;&#x73;&#x6f;</a>,然后查找”/system/lib64/hw/“、”/vendor/lib64/hw/“、”/odm/lib64/hw/“下是否有对应的so库。接着通过dlopen载入/vendor/lib/hw/android.hardware.light@2.0-impl.so，然后通过dlsym查找并调用HIDL_FETCH_ILight函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\Light.cpp]</span><br><span class="line"><span class="function">ILight* <span class="title">HIDL_FETCH_ILight</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;Type, <span class="keyword">light_device_t</span>*&gt; lights;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span> &amp;<span class="built_in">pair</span> : kLogicalLights) &#123;</span><br><span class="line">        Type type = <span class="built_in">pair</span>.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="built_in">pair</span>.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">light_device_t</span>* light = getLightDevice(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (light != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lights[type] = light;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lights.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Log information, but still return new Light.</span></span><br><span class="line">        <span class="comment">// Some devices may not have any lights.</span></span><br><span class="line">        ALOGI(<span class="string">&quot;Could not open any lights.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Light(<span class="built_in">std</span>::move(lights));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-19-HIDL-binder-ILight-so-dlopen.png" alt="Alt text | center"></p>
<h6 id="4-1、ILight-registerAsService"><a href="#4-1、ILight-registerAsService" class="headerlink" title="4.1、ILight::registerAsService()"></a>4.1、ILight::registerAsService()</h6><p>首先会调用registerAsService()注册服务，然后joinRpcThreadpool()加入线程池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">ILight::registerAsService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> </span>&#123;</span><br><span class="line">    ::android::hardware::details::onRegistration(<span class="string">&quot;android.hardware.light@2.0&quot;</span>, <span class="string">&quot;ILight&quot;</span>, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</span><br><span class="line">            = ::android::hardware::defaultServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过defaultServiceManager()获取IServiceManager，接着add()添加服务</p>
<p>首先根据属性”hwservicemanager.ready”值判断hwservicemanager进程是否启动就绪，如果hwservicemanager已经启动，那么通过fromBinder&lt;IServiceManager, BpHwServiceManager, BnHwServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL))来获取hwservicemanager的代理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line"><span class="function">sp&lt;IServiceManager1_0&gt; <span class="title">defaultServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sp&lt;IServiceManager1_1&gt; <span class="title">defaultServiceManager1_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(details::gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (details::gDefaultServiceManager != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access(<span class="string">&quot;/dev/hwbinder&quot;</span>, F_OK|R_OK|W_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForHwServiceManager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            details::gDefaultServiceManager =</span><br><span class="line">                    fromBinder&lt;IServiceManager1_1, BpHwServiceManager, BnHwServiceManager&gt;(</span><br><span class="line">                        ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先看看ProcessState::getContextObject()</p>
<p>因此通过ProcessState::self()-&gt;getContextObject(NULL)将得到一个BpHwBinder对象，然后通过fromBinder&lt;IServiceManager, BpHwServiceManager, BnHwServiceManager&gt;进行转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\ProcessState.cpp]</span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpHwBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用会调用fromBinder()函数，在这里将创建一个BpHwServiceManager对象，ProcessState::self()-&gt;getContextObject(NULL)如果返回的是远程binder对象，那么基于BpHwBinder创建BpHwServiceManager对象，BpHwBinder负责数据传输，而BpHwServiceManager服务数据业务，业务数据在BpHwServiceManager层打包好后，转交给BpHwBinder发送。如果getContextObject(NULL)返回的是本地binder对象，那么将这个本地binder对象强制转换为BnHwBase类型，从上图可知BnHwBase继承BHwBinder类，BHwBinder即是本地binder对象。<br>static_cast&lt;BnHwBase*&gt;(binderIface.get()) 然后通过BnHwBase的getImpl()函数得到其业务实现对象IBase。<br>sp<IBase> base =static_cast&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</p>
<p>然后检查业务接口是否相同：<br>if (details::canCastInterface(base.get(),IType::descriptor))<br>如果业务接口类型相同，那么再次将这个本地binder对象转换为孙类BnHwServiceManager类型：<br>BnHwServiceManager* stub = static_cast&lt;BnHwServiceManager*&gt;(binderIface.get());<br>然后返回业务实现类对象ServiceManager对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\HidlBinderSupport.h]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IType, <span class="keyword">typename</span> ProxyType, <span class="keyword">typename</span> StubType&gt;</span><br><span class="line"><span class="function">sp&lt;IType&gt; <span class="title">fromBinder</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binderIface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::BnHwBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binderIface.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binderIface-&gt;localBinder() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyType(binderIface);</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="keyword">static_cast</span>&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</span><br><span class="line">    <span class="keyword">if</span> (details::canCastInterface(base.get(), IType::descriptor)) &#123;</span><br><span class="line">        StubType* stub = <span class="keyword">static_cast</span>&lt;StubType*&gt;(binderIface.get());</span><br><span class="line">        <span class="keyword">return</span> stub-&gt;getImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 getImpl()函数实现，返回的是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++_headers\gen\android\hidl\manager\<span class="number">1.0</span>\BnHwServiceManager.h]</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; _hidl_mImpl;</span><br><span class="line">    </span><br><span class="line">    ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">getImpl</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _hidl_mImpl; &#125;;</span><br></pre></td></tr></table></figure>


<h6 id="4-2、sm-gt-add-serviceName-c-str-this-添加light-service"><a href="#4-2、sm-gt-add-serviceName-c-str-this-添加light-service" class="headerlink" title="4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service"></a>4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="function">hardware::Return&lt;<span class="keyword">bool</span>&gt; <span class="title">BpHwServiceManager::add</span><span class="params">(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service)</span></span>&#123;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_add(<span class="keyword">this</span>, <span class="keyword">this</span>, name, service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; BpHwServiceManager::_hidl_add(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ::android::hardware::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(<span class="number">2</span> <span class="comment">/* add */</span>, _hidl_data, &amp;_hidl_reply);</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\BpHwBinder.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpHwBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags, TransactCallback <span class="comment">/*callback*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/IPCThreadState.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION_SG, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>waitForResponse()会通过底层binder 驱动进入到服务端，服务端监听消息来到处理过后会调用onTransact()函数</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-20-HIDL-ioctl-kernel.png.png" alt="Alt text | center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/Binder.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BHwBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags, TransactCallback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags,</span><br><span class="line">                    [&amp;](<span class="keyword">auto</span> &amp;replyParcel) &#123;</span><br><span class="line">                        replyParcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                            callback(replyParcel);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">BnHwServiceManager::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> _hidl_code,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        ::android::hardware::Parcel *_hidl_reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> _hidl_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        TransactCallback _hidl_cb)</span> </span>&#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err = ::android::OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (_hidl_code) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> <span class="comment">/* add */</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> _hidl_is_oneway = _hidl_flags &amp; ::android::hardware::IBinder::FLAG_ONEWAY;</span><br><span class="line">            <span class="keyword">if</span> (_hidl_is_oneway != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ::android::UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _hidl_err = ::android::hidl::manager::V1_0::BnHwServiceManager::_hidl_add(<span class="keyword">this</span>, _hidl_data, _hidl_reply, _hidl_cb);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_add(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_service_binder;</span><br><span class="line">        _hidl_err = _hidl_data.readNullableStrongBinder(&amp;_hidl_service_binder);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">        service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atrace_begin(ATRACE_TAG_HAL, <span class="string">&quot;HIDL::IServiceManager::add::server&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _hidl_out_success = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;add(*name, service);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处的_hidl_mImpl即之前得到的::android::sp<IServiceManager> ==_hidl_mImpl== 对象，所以会调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\ServiceManager.cpp]</span><br><span class="line"><span class="function">Return&lt;<span class="keyword">bool</span>&gt; <span class="title">ServiceManager::add</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">pid_t</span> pid = IPCThreadState::self()-&gt;getCallingPid();</span><br><span class="line">    <span class="keyword">auto</span> context = mAcl.getContext(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = service-&gt;interfaceChain([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;interfaceChain) &#123;</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; interfaceChain.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> fqName = interfaceChain[i];</span><br><span class="line"></span><br><span class="line">            PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName];</span><br><span class="line">            HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ifaceMap.insertService(</span><br><span class="line">                    <span class="built_in">std</span>::make_unique&lt;HidlService&gt;(fqName, name, service, pid));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hidlService-&gt;getService() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> ret = hidlService-&gt;getService()-&gt;unlinkToDeath(<span class="keyword">this</span>);</span><br><span class="line">                    ret.isOk(); <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                hidlService-&gt;setService(service, pid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifaceMap.sendPackageRegistrationNotification(fqName, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> linkRet = service-&gt;linkToDeath(<span class="keyword">this</span>, <span class="number">0</span> <span class="comment">/*cookie*/</span>);</span><br><span class="line">        linkRet.isOk(); <span class="comment">// ignore</span></span><br><span class="line">        isValidService = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> isValidService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完成插入到PackageInterfaceMap &amp;ifaceMap 对象中，并添加一些监听。之后就可以查询到light service了。</p>
<h6 id="4-3、joinRpcThreadpool"><a href="#4-3、joinRpcThreadpool" class="headerlink" title="4.3、joinRpcThreadpool()"></a>4.3、joinRpcThreadpool()</h6><p>加入线程池，至此Light service 就启动起来了，可以等待Client的请求了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\HidlTransportSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(b/32756130) this should be transport-dependent</span></span><br><span class="line">    joinBinderRpcThreadpool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhidl\transport\HidlBinderSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinBinderRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此就完成了hidl服务注册。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-21-HIDL-hwbinder-ILight-add.png" alt="Alt text | center"></p>
<h4 id="（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程"><a href="#（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程" class="headerlink" title="（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程"></a>（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程</h4><p>这里以light模块为例子（其他模块类似）：<br>通过前面的分析我们知道，Hal进程启动时，会向hwservicemanager进程注册hidl服务，那么当Framework Server需要通过hal访问硬件设备时，首先需要查询对应的hidl服务，那么Client进程是如何查询hidl服务的呢？这篇文章将展开分析，这里再次以ILight为例进行展开。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-22-android-hwservicemanager-get.png" alt="Alt text | center"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/java/com/android/server/lights/LightsService.java]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(<span class="keyword">int</span> light, <span class="keyword">int</span> color, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS, <span class="keyword">int</span> brightnessMode)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint light,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint colorARGB,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint flashMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint onMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint offMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint brightnessMode)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;ILight&gt; hal = LightHal::associate();</span><br><span class="line">    .......</span><br><span class="line">    Type type = <span class="keyword">static_cast</span>&lt;Type&gt;(light);</span><br><span class="line">    LightState state = constructState(</span><br><span class="line">        colorARGB, flashMode, onMS, offMS, brightnessMode);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        android::base::Timer t;</span><br><span class="line">        Return&lt;Status&gt; ret = hal-&gt;setLight(type, state);</span><br><span class="line">        processReturn(ret, type, state);</span><br><span class="line">        <span class="keyword">if</span> (t.duration() &gt; <span class="number">50</span>ms) ALOGD(<span class="string">&quot;Excessive delay setting light&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>associate() 会获取ILight::getService();这里通过ILight::getService()函数来查询ILight这个HIDL服务，由于这里没有传递任何参数，因此函数最终会调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++_headers\gen\android\hardware\light\<span class="number">2.0</span>\ILight.h]</span><br><span class="line">    <span class="keyword">static</span> ::<span class="function">android::sp&lt;ILight&gt; <span class="title">getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">&quot;default&quot;</span>, <span class="keyword">bool</span> getStub=<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意，这里的getStub为false，说明加载hidl服务方式是由当前hidl服务的transport类型决定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">&quot;hidl&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure>
<p>由于ILight的transport是hwbinder类型，那么将从hwservicemanager中查询hidl服务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">::<span class="function">android::sp&lt;ILight&gt; <span class="title">ILight::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::details::waitForHwService;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line">    <span class="keyword">using</span> ::android::sp;</span><br><span class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport = transportRet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; (vintfHwbinder || (vintfLegacy &amp;&amp; tries == <span class="number">0</span>)); tries++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (vintfHwbinder &amp;&amp; tries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            waitForHwService(ILight::descriptor, serviceName);</span><br><span class="line">        &#125;</span><br><span class="line">        Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                sm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line"></span><br><span class="line">        sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret;</span><br><span class="line"></span><br><span class="line">        Return&lt;sp&lt;ILight&gt;&gt; castRet = ILight::castFrom(base, <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line"></span><br><span class="line">        iface = castRet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> iface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    iface = ILight::castFrom(baseInterface);</span><br><span class="line">                    <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = <span class="keyword">new</span> BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过sm-&gt;get(ILight::descriptor, serviceName)查询ILight这个hidl服务，得到IBase对象后，在通过ILight::castFrom转换为ILight对象。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-23-HIDL-castFrom.png" alt="Alt text | center"></p>
<h5 id="5-1、服务查询-hidl-get"><a href="#5-1、服务查询-hidl-get" class="headerlink" title="5.1、服务查询_hidl_get()"></a>5.1、服务查询_hidl_get()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.1</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.1</span>\ServiceManagerAll.cpp]</span><br><span class="line">::android::<span class="function">hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; <span class="title">BpHwServiceManager::get</span><span class="params">(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; fqName, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name)</span></span>&#123;</span><br><span class="line">    ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_get(<span class="keyword">this</span>, <span class="keyword">this</span>, fqName, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::_hidl_get(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; fqName, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name) &#123;</span><br><span class="line">    </span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeInterfaceToken(BpHwServiceManager::descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;fqName, <span class="keyword">sizeof</span>(fqName), &amp;_hidl_fqName_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            fqName,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;name, <span class="keyword">sizeof</span>(name), &amp;_hidl_name_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            name,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(<span class="number">1</span> <span class="comment">/* get */</span>, _hidl_data, &amp;_hidl_reply);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readFromParcel(&amp;_hidl_status, _hidl_reply);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl__hidl_out_service_binder;</span><br><span class="line">        _hidl_err = _hidl_reply.readNullableStrongBinder(&amp;_hidl__hidl_out_service_binder);</span><br><span class="line"></span><br><span class="line">        _hidl_out_service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_status.setFromStatusT(_hidl_err);</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;(_hidl_out_service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个调用过程和hidl 添加服务过程完全一致，就是一个从BpHwServiceManager –&gt; BnHwServiceManager –&gt; ServiceManager的过程。但需要注意，BpHwServiceManager得到BnHwServiceManager返回过来的binder代理后，会通过fromBinder函数进行对象转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder)</span><br></pre></td></tr></table></figure>

<p>hwservicemanager将ILight的binder代理BpHwBinder发给Framework Server进程，Framework Server进程拿到的依然是ILight的binder代理BpHwBinder对象，因此在fromBinder函数中将创建BpHwBase对象来封装BpHwBinder。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_get(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* fqName;</span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*fqName), &amp;_hidl_fqName_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;fqName));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*fqName),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;get(*fqName, *name);</span><br><span class="line"></span><br><span class="line">    ::android::hardware::writeToParcel(::android::hardware::Status::ok(), _hidl_reply);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_out_service == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _hidl_err = _hidl_reply-&gt;writeStrongBinder(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_binder = ::android::hardware::toBinder&lt;</span><br><span class="line">                ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_binder.get() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _hidl_err = _hidl_reply-&gt;writeStrongBinder(_hidl_binder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _hidl_err = ::android::UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb(*_hidl_reply);</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BnHwServiceManager通过ServiceManager对象查询到对应的hidl服务，返回IBase对象后，会调用toBinder函数转换为IBinder类型对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::toBinder&lt; ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service)</span><br></pre></td></tr></table></figure>

<p>由于在hwservicemanager这边，保存的是ILight的BpHwBase对象，因此在toBinder函数中将调用IInterface::asBinder来得到BpHwBase的成员变量中的BpHwBinder对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ifacePtr-&gt;isRemote()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::IInterface::asBinder(<span class="keyword">static_cast</span>&lt;ProxyType *&gt;(ifacePtr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务查询过程其实就是根据接口包名及服务名称，从hwservicemanager管理的表中查询对应的IBase服务对象，然后在Client进程空间分别创建BpHwBinder和BpHwBase对象。</p>
<h5 id="5-2、接口转换IXXX-castFrom"><a href="#5-2、接口转换IXXX-castFrom" class="headerlink" title="5.2、接口转换IXXX::castFrom()"></a>5.2、接口转换IXXX::castFrom()</h5><p>Framework Server进程通过上述hidl服务查询，得到了BpHwBase对象后，需要将其转换为与业务相关的代理对象，这就是通过：Return&lt;sp<ILight>&gt; castRet = ILight::castFrom(base, true /* emitError */)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="function">hardware::Return&lt;::android::sp&lt;ILight&gt;&gt; <span class="title">ILight::castFrom</span><span class="params">(<span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; parent, <span class="keyword">bool</span> emitError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::castInterface&lt;ILight, ::android::hidl::base::V1_0::IBase, BpHwLight&gt;(</span><br><span class="line">            parent, <span class="string">&quot;android.hardware.light@2.0::ILight&quot;</span>, emitError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>system\libhidl\transport\include\hidl\HidlTransportSupport.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cast the interface IParent to IChild.</span></span><br><span class="line"><span class="comment">// Return nonnull if cast successful.</span></span><br><span class="line"><span class="comment">// Return nullptr if:</span></span><br><span class="line"><span class="comment">// 1. parent is null</span></span><br><span class="line"><span class="comment">// 2. cast failed because IChild is not a child type of IParent.</span></span><br><span class="line"><span class="comment">// 3. !emitError, calling into parent fails.</span></span><br><span class="line"><span class="comment">// Return an error Return object if:</span></span><br><span class="line"><span class="comment">// 1. emitError, calling into parent fails.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IChild, <span class="keyword">typename</span> IParent, <span class="keyword">typename</span> BpChild, <span class="keyword">typename</span> BpParent&gt;</span><br><span class="line"><span class="function">Return&lt;sp&lt;IChild&gt;&gt; <span class="title">castInterface</span><span class="params">(sp&lt;IParent&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;IChild&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;IChild&gt;&gt;(sp&lt;IChild&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">new</span> BpChild(toBinder&lt;IParent, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">static_cast</span>&lt;IChild *&gt;(parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br></pre></td></tr></table></figure>
<p>这个模板函数展开后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Return&lt;sp&lt;ILight&gt;&gt; <span class="title">castInterface</span><span class="params">(sp&lt;IBase&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;ILight&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;ILight&gt;&gt;(sp&lt;ILight&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">new</span> BpHwLight(toBinder&lt;IBase, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">static_cast</span>&lt;ILight*&gt;(parent.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此最终会创建一个BpHwLight对象。new BpHwLight(toBinder&lt;IBase, BpParent&gt;(parent))</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-24-HIDL-binder-bphwxxxx.png" alt="Alt text | center"></p>
<h4 id="（六）、Android-O-Treble-之-HIDL服务Java框架实现"><a href="#（六）、Android-O-Treble-之-HIDL服务Java框架实现" class="headerlink" title="（六）、Android O Treble 之 HIDL服务Java框架实现"></a>（六）、Android O Treble 之 HIDL服务Java框架实现</h4><p>前面介绍了HIDL服务在native层的实现过程，包括HIDL服务加载创建、服务注册、服务查询过程等，那么Java层是否也实现了相关的服务框架呢？ 通常情况下，所有的Hal都实现在native层面，每个hal进程都是一个native进程，由init进程启动，在hal进程启动时会完成HIDL服务注册，Framework Server进程不一定完全是native进程，比如system_server进程，它运行在虚拟机环境中，由zygote进程fork而来，这时，Java层也需要请求HIDL服务，因此Android不仅在native层HIDL化了hal，在Java层同样也定义了相关的服务框架。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-25-Java-binder.png" alt="Alt text | center"></p>
<p>上图是Java层binder和hwbinder之间的类基础图对比。当我们定义一个.hal接口文件时，通过hidl-gen编译为Java文件后，将按上图中的类继承关系自动生成代码。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-26-Java-binder-class-inherit.png" alt="Alt text | center"></p>
<p>如上图所示，当我们定义IXXX.hal文件后，通过编译将在out/target/common/gen/JAVA_LIBRARIES目录下生成对应的IXXX.java，该文件按上述类继承关系自动生成相关代码，我们只需要定义一个XXXImp类，继承Stub并实现所有方法，然后在某个服务进程中创建一个XXXImp对象，并调用registerService（）函数进行hidl服务注册，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXXImp mXXXImp = <span class="keyword">new</span> XXXImp();</span><br><span class="line">mXXXImp.registerAsService(<span class="string">&quot;XXXImp&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就完成了一个Java层的hidl服务注册，当然在当前Android系统中，大部分还是native层的hidl服务，Java层的hidl服务还是比较少的。从上述可知，Java层的hidl服务包括2个步骤：</p>
<ol>
<li>hidl服务对象创建；</li>
</ol>
<p>2.hidl服务注册；</p>
<h5 id="6-1、Java-hidl服务创建过程"><a href="#6-1、Java-hidl服务创建过程" class="headerlink" title="6.1、Java hidl服务创建过程"></a>6.1、Java hidl服务创建过程</h5><p>从上面的类继承图可知，hidl服务实现类继承于Stub，Stub又继承于HwBinder，因此创建一个XXXImp对象时，会调用HwBinder的构造函数。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-27-HwBinder.java.setup.png" alt="Alt text | center"></p>
<p>frameworks\base\core\java\android\os\HwBinder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HwBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    native_setup();</span><br><span class="line"> </span><br><span class="line">    sNativeRegistry.registerNativeAllocation(</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            mNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> freeFunction = native_init();</span><br><span class="line"> </span><br><span class="line">    sNativeRegistry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">            HwBinder.class.getClassLoader(),</span><br><span class="line">            freeFunction,</span><br><span class="line">            <span class="number">128</span> <span class="comment">/* size */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建HwBinder对象会首先执行native_init()函数，然后调用native_setup()函数。<br>frameworks\base\core\jni\android_os_HwBinder.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">JHwBinder_native_init</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    JHwBinder::InitClass(env);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;releaseNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JHwBinder_native_setup</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; context = <span class="keyword">new</span> JHwBinderHolder;</span><br><span class="line">    JHwBinder::SetNativeContext(env, thiz, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建一个JHwBinderHolder 对象，并保存在HwBinder类的mNativeContext变量中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;JHwBinderHolder&gt; <span class="title">JHwBinder::SetNativeContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env, jobject thiz, <span class="keyword">const</span> sp&lt;JHwBinderHolder&gt; &amp;context)</span> </span>&#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; old =</span><br><span class="line">        (JHwBinderHolder *)env-&gt;GetLongField(thiz, gFields.contextID);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        context-&gt;incStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    env-&gt;SetLongField(thiz, gFields.contextID, (<span class="keyword">long</span>)context.get());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了多个binder类型：HwBinder、JHwBinderHolder、JHwBinder他们的类继承图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-28-Java-binder---.png" alt="Alt text | center"></p>
<p>红线标识了这3个类对象之间的关系，为了更加清晰地描述他们之间的关联关系，如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-29-HIDL-java-object.png" alt="Alt text | center"></p>
<h5 id="6-2、Java层服务注册（add）查询（get）过程"><a href="#6-2、Java层服务注册（add）查询（get）过程" class="headerlink" title="6.2、Java层服务注册（add）查询（get）过程"></a>6.2、Java层服务注册（add）查询（get）过程</h5><p>服务注册查询过程本质也是通过Native层的hwservicemanager来进行的。<br>（略）请参考大牛博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/79876534">Android O Treble架构下HIDL服务Java框架实现</a><br>到此Treble架构下的hwBinder实现过程就基本介绍完成。<br>总体架构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p>
<h4 id="（七）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考资料(特别感谢各位前辈的分析和图示)："></a>（七）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123">Android O Treble架构（系列分析文章） -  CSDN博客</a><br><a href="">Android 7.1.2 (Android N) Android Binder 系统分析</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190308/">https://zhoujinjian.com/posts/20190308/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Treble/">Treble</a><a class="post-meta__tags" href="/tags/HIDL/">HIDL</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190408/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.33.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Graphics Tests 程序学习（1）： 使用OpenGL EGL一般顺序（configdump &amp; tritex &amp; textures &amp; fillrate &amp; filter&amp; finish）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190216/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.31.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Video System（9）：Android Multimedia Codecs - H264编解码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Android-O-Treble-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">（一）、Android O Treble 架构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-0%E3%80%81Android%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%98%E5%8C%96%EF%BC%88VNDK%E3%80%81VINTF%E3%80%81HIDL%EF%BC%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.0、Android整体架构变化（VNDK、VINTF、HIDL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1%E3%80%81Binder%E9%80%9A%E4%BF%A1%E5%9F%9F%E5%8F%98%E5%8C%96"><span class="toc-number">1.0.2.</span> <span class="toc-text">1.1、Binder通信域变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2%E3%80%81vndbinder-amp-amp-vndservicemanager"><span class="toc-number">1.0.3.</span> <span class="toc-text">1.2、vndbinder &amp;&amp; vndservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-1%E3%80%81vndbinder"><span class="toc-number">1.0.4.</span> <span class="toc-text">1.2.1、vndbinder</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-2%E3%80%81vndservicemanager"><span class="toc-number">1.0.5.</span> <span class="toc-text">1.2.2、vndservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-3%E3%80%81servicemanager"><span class="toc-number">1.0.6.</span> <span class="toc-text">1.2.3、servicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-3%E3%80%81hwservicemanager"><span class="toc-number">1.0.7.</span> <span class="toc-text">1.3、hwservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-4%E3%80%81Binder%E5%BA%93%E5%8F%98%E5%8C%96"><span class="toc-number">1.0.8.</span> <span class="toc-text">1.4、Binder库变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-5%E3%80%81Binder%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6%E5%8F%98%E5%8C%96"><span class="toc-number">1.0.9.</span> <span class="toc-text">1.5、Binder通信框架变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-6%E3%80%81%E6%A1%86%E6%9E%B6%E5%B1%82Binder%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8C%96"><span class="toc-number">1.0.10.</span> <span class="toc-text">1.6、框架层Binder对象变化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-HIDL%E6%96%87%E4%BB%B6%EF%BC%88-hal%E6%96%87%E4%BB%B6%EF%BC%89%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81%E7%94%9F%E6%88%90%E5%AD%90Android-mk%E5%92%8CAndroid-bp%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、生成子Android.mk和Android.bp文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E3%80%81hidl-gen%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、hidl-gen工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-hwservicemanager-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">（三）、Android O Treble 之 hwservicemanager 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81%E5%88%9B%E5%BB%BABnHwServiceManager"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、创建BnHwServiceManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81IPCThreadState-gt-setTheContextObject-service"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、IPCThreadState-&gt;setTheContextObject(service)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E3%80%81BinderCallback"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、BinderCallback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4%E3%80%81hwservicemanager-%E7%BB%A7%E7%BB%AD%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4、hwservicemanager 继续关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-hwservicemanager-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%EF%BC%88add%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1%E3%80%81ILight-registerAsService"><span class="toc-number">4.0.1.</span> <span class="toc-text">4.1、ILight::registerAsService()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2%E3%80%81sm-gt-add-serviceName-c-str-this-%E6%B7%BB%E5%8A%A0light-service"><span class="toc-number">4.0.2.</span> <span class="toc-text">4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-3%E3%80%81joinRpcThreadpool"><span class="toc-number">4.0.3.</span> <span class="toc-text">4.3、joinRpcThreadpool()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-hwservicemanager-%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%EF%BC%88get%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%9F%A5%E8%AF%A2-hidl-get"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、服务查询_hidl_get()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E3%80%81%E6%8E%A5%E5%8F%A3%E8%BD%AC%E6%8D%A2IXXX-castFrom"><span class="toc-number">5.2.</span> <span class="toc-text">5.2、接口转换IXXX::castFrom()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-HIDL%E6%9C%8D%E5%8A%A1Java%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">（六）、Android O Treble 之 HIDL服务Java框架实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1%E3%80%81Java-hidl%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">6.1、Java hidl服务创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2%E3%80%81Java%E5%B1%82%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%EF%BC%88add%EF%BC%89%E6%9F%A5%E8%AF%A2%EF%BC%88get%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">6.2、Java层服务注册（add）查询（get）过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">（七）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>