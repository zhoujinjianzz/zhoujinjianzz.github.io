<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Video System（9）：Android Multimedia Codecs - H264编解码分析 | zhoujinjian</title><meta name="keywords" content="Android,Video,Multimedia"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。 首先感谢：">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Video System（9）：Android Multimedia Codecs - H264编解码分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190216/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。 首先感谢：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.31.jpg">
<meta property="article:published_time" content="2019-02-16T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.968Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Video">
<meta property="article:tag" content="Multimedia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.31.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190216/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.31.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Video System（9）：Android Multimedia Codecs - H264编解码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-16T01:25:00.000Z" title="发表于 2019-02-16 09:25:00">2019-02-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.968Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Multimedia/">Multimedia</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。</p>
<p>首先感谢：</p>
<p><a target="_blank" rel="noopener" href="http://www.iosxxx.com/blog/2017-08-09-%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3H264%E7%BB%93%E6%9E%84.html">【从零了解H264结构】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，再次感谢！！！</p>
<p>Google Pixel、Pixel XL 内核代码（==<strong>文章基于 Kernel-3.x</strong>==）：<br> <a target="_blank" rel="noopener" href="https://github.com/nathanchance/wahoo">Kernel source for Pixel 2 (walleye) and Pixel 2 XL (taimen) - GitHub</a></p>
<p>AOSP 源码（==<strong>文章基于 Android 7.x</strong>==）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\frameworks\av\media\libstagefright\omx\SoftOMXPlugin.cpp</span><br><span class="line">kComponents[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.decoder&quot;</span>, <span class="string">&quot;avcdec&quot;</span>, <span class="string">&quot;video_decoder.avc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.encoder&quot;</span>, <span class="string">&quot;avcenc&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span> &#125;,</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>==源码（部分）==：</p>
<blockquote>
<p>PATH : \frameworks\av\media\libstagefright\codecs （Android Codecs）</p>
</blockquote>
<ul>
<li>avc</li>
<li>avcdec</li>
<li>avcenc</li>
</ul>
<blockquote>
<p>\external\libavc（libavc 库）</p>
</blockquote>
<ul>
<li>encoder</li>
<li>decoder</li>
<li>common</li>
</ul>
<blockquote>
<p>hardware\qcom\media（Qcom）</p>
</blockquote>
<ul>
<li>mm-core</li>
<li>libstagefrighthw</li>
<li>mm-video-v4l2</li>
</ul>
<p>Log：<br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/H264-Decorder-Google-log.md">H264-Decorder-Google-log.md</a><br><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/H264-Encorder-QCom-log.md">H264-Encorder-QCom-log.md</a></p>
<hr>
<h4 id="（一）、从零了解H264结构（概览）"><a href="#（一）、从零了解H264结构（概览）" class="headerlink" title="（一）、从零了解H264结构（概览）"></a>（一）、从零了解H264结构（概览）</h4><h5 id="1-0、前言"><a href="#1-0、前言" class="headerlink" title="1.0、前言"></a>1.0、前言</h5><p>为什么需要编码呢？比如当前屏幕是1280*720.一秒24张图片.那么我们一秒的视频数据是</p>
<blockquote>
<p>1280*720(位像素)*24(张) / 8(1字节8位)(结果:B) / 1024(结果:KB) / 1024 (结果:MB) = 2.64MB</p>
</blockquote>
<p>一秒的数据有2.64MB数据量。1分钟就会有100多MB。这对用户来说真心是灾难。所以现在我们需要一种压缩方式减小数据的大小.在更低 比特率(bps)的情况下依然提供清晰的视频。<br>H264: H264/AVC是广泛采用的一种编码方式。我们这边会带大家了解。从大到小排序依次是 序列，图像，片组，片，NALU，宏块，亚宏块，块，像素。</p>
<h5 id="1-1、原理"><a href="#1-1、原理" class="headerlink" title="1.1、原理"></a>1.1、原理</h5><p>H.264原始码流(裸流)是由一个接一个NALU组成，它的功能分为两层，VCL(视频编码层)和 NAL(网络提取层).</p>
<blockquote>
<p>VCL(Video Coding Layer) + NAL(Network Abstraction Layer).</p>
</blockquote>
<p>1.VCL：包括核心压缩引擎和块，宏块和片的语法级别定义，设计目标是尽可能地独立于网络进行高效的编码；<br>2.NAL：负责将VCL产生的比特字符串适配到各种各样的网络和多元环境中，覆盖了所有片级以上的语法级别。</p>
<p>在VCL进行数据传输或存储之前，这些编码的VCL数据，被映射或封装进NAL单元。（NALU）。</p>
<blockquote>
<p>一个NALU = 一组对应于视频编码的NALU头部信息 + 一个原始字节序列负荷(RBSP,Raw Byte Sequence Payload).</p>
</blockquote>
<p>如图所示，下图中的NALU的头 + RBSP 就相当于一个NALU(Nal Unit),每个单元都按独立的NALU传送。H.264的结构全部都是以NALU为主，理解了NALU，就理解了H.264的结构。<br>一个原始的H.264 NALU 单元常由 [StartCode] [NALU Header] [NALU Payload] 三部分组成，其中 Start Code 用于标示这是一个NALU 单元的开始，必须是”00 00 00 01” 或”00 00 01”<br>![Alt text | center](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-01-H264">https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-01-H264</a> NALU headerRBSP.png)</p>
<h5 id="1-1-1-NAL-Header"><a href="#1-1-1-NAL-Header" class="headerlink" title="1.1.1. NAL Header"></a>1.1.1. NAL Header</h5><p>由三部分组成，forbidden_bit(1bit)，nal_reference_bit(2bits)（优先级），nal_unit_type(5bits)（类型）。</p>
<p>![Alt text | center](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-02-H264.NAL">https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-02-H264.NAL</a> Header.png)</p>
<p>举例来说：</p>
<blockquote>
<p>00 00 00 01 06:  SEI信息<br>00 00 00 01 67:  0x67&amp;0x1f = 0x07 :SPS<br>00 00 00 01 68:  0x68&amp;0x1f = 0x08 :PPS<br>00 00 00 01 65:  0x65&amp;0x1f = 0x05: IDR Slice</p>
</blockquote>
<h5 id="1-1-2-RBSP"><a href="#1-1-2-RBSP" class="headerlink" title="1.1.2. RBSP"></a>1.1.2. RBSP</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-03-H264.RBSP.png" alt="Alt text | center"></p>
<p>图 6.69 RBSP 序列举例</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-04-H264.RBSP.describle.png" alt="Alt text | center"></p>
<p><strong>SODB与RBSP</strong><br>SODB 数据比特串 -&gt; 是编码后的原始数据.<br>RBSP 原始字节序列载荷 -&gt; 在原始编码数据的后面添加了 结尾比特。一个 bit“1”若干比特“0”，以便字节对齐。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-05-H264.RBSP.SODB.png" alt="Alt text | center"></p>
<h5 id="1-2、从NALU出发了解H-264里面的专业词语"><a href="#1-2、从NALU出发了解H-264里面的专业词语" class="headerlink" title="1.2、从NALU出发了解H.264里面的专业词语"></a>1.2、从NALU出发了解H.264里面的专业词语</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-06-H264.Slice.Layer.png" alt="Alt text | center"></p>
<blockquote>
<p>1帧 = n个片<br>1片 = n个宏块<br>1宏块 = 16x16yuv数据</p>
</blockquote>
<h5 id="1-2-1-Slice-片"><a href="#1-2-1-Slice-片" class="headerlink" title="1.2.1. Slice(片)"></a>1.2.1. Slice(片)</h5><p>如图所示，NALU的主体中包含了Slice(片).</p>
<blockquote>
<p>一个片 = Slice Header + Slice Data</p>
</blockquote>
<p>片是H.264提出的新概念，通过编码图片后切分通过高效的方式整合出来的概念。一张图片有一个或者多个片，而片由NALU装载并进行网络传输的。但是NALU不一定是切片，这是充分不必要条件，因为 NALU 还有可能装载着其他用作描述视频的信息.</p>
<p>那么为什么要设置片呢?<br>设置片的目的是为了限制误码的扩散和传输，应使编码片相互间是独立的。某片的预测不能以其他片中的宏块为参考图像，这样某一片中的预测误差才不会传播到其他片中。</p>
<p>可以看到上图中，每个图像中，若干宏块(Macroblock)被排列成片。一个视频图像可编程一个或更多个片，每片包含整数个宏块 (MB),每片至少包含一个宏块。<br>片有一下五种类型:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-07-H264.I.P.B..png" alt="Alt text | center"></p>
<h5 id="1-2-2-宏块-Macroblock"><a href="#1-2-2-宏块-Macroblock" class="headerlink" title="1.2.2. 宏块(Macroblock)"></a>1.2.2. 宏块(Macroblock)</h5><p>刚才在片中提到了宏块.那么什么是宏块呢？<br>宏块是视频信息的主要承载者。一个编码图像通常划分为多个宏块组成.包含着每一个像素的亮度和色度信息。视频解码最主要的工作则是提供高效的方式从码流中获得宏块中像素阵列。</p>
<blockquote>
<p>一个宏块 = 一个16*16的亮度像素 + 一个8×8Cb + 一个8×8Cr彩色像素块组成。(YCbCr 是属于 YUV<br>家族的一员,在YCbCr 中 Y 是指亮度分量，Cb 指蓝色色度分量，而 Cr 指红色色度分量)</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-08-H264.Macroblock.png" alt="Alt text | center"></p>
<p>分层结构,在 H.264 中，句法元素共被组织成 序列、图像、片、宏块、子宏块五个层次。<br>句法元素的分层结构有助于更有效地节省码流。例如，再一个图像中，经常会在各个片之间有相同的数据，如果每个片都同时携带这些数据，势必会造成码流的浪费。更为有效的做法是将该图像的公共信息抽取出来，形成图像一级的句法元素，而在片级只携带该片自身独有的句法元素。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-09-H264.slice.header.data.png" alt="Alt text | center"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-10-H264.slice.header.data-detail.png" alt="Alt text | center"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-11-H264.Macroblock_type.png.png" alt="Alt text | center"></p>
<h5 id="1-2-3-图像-场和帧"><a href="#1-2-3-图像-场和帧" class="headerlink" title="1.2.3. 图像,场和帧"></a>1.2.3. 图像,场和帧</h5><p>图像是个集合概念，顶 场、底场、帧都可以称为图像。对于H.264 协议来说，我们平常所熟悉的那些称呼，例如： I 帧、P 帧、B帧等等，实际上都是我们把图像这个概念具体化和细小化了。我们 在 H.264里提到的“帧”通常就是指不分场的图像；</p>
<p>视频的一场或一帧可用来产生一个编码图像。一帧通常是一个完整的图像。当采集视频信号时，如果采用隔行扫描(奇.偶数行),则扫描下来的一帧图像就被分为了两个部分,这每一部分就被称为 [场],根据次序氛围: [顶场] 和 [底场]。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-12-H264.zuoyongyu.png" alt="Alt text | center"></p>
<h5 id="1-2-4-I-P-B帧与pts-dts"><a href="#1-2-4-I-P-B帧与pts-dts" class="headerlink" title="1.2.4. I,P,B帧与pts/dts"></a>1.2.4. I,P,B帧与pts/dts</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-13-H264.PTS.DTS.png" alt="Alt text | center"></p>
<p>DTS与PTS的不同:<br>DTS主要用户视频的解码，在解码阶段使用。PTS主要用于视频的同步和输出，在display的时候使用。再没有B frame的时候输出顺序一样。</p>
<h5 id="1-2-5-GOP"><a href="#1-2-5-GOP" class="headerlink" title="1.2.5. GOP"></a>1.2.5. GOP</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-14-H264.GOP.png" alt="Alt text | center"></p>
<p>GOP是画面组，一个GOP是一组连续的画面。<br>GOP一般有两个数字，如M=3，N=12.M制定I帧与P帧之间的距离，N指定两个I帧之间的距离。那么现在的GOP结构是</p>
<blockquote>
<p>I BBP BBP BBP BB I</p>
</blockquote>
<p>增大图片组能有效的减少编码后的视频体积，但是也会降低视频质量，至于怎么取舍，得看需求了</p>
<h5 id="1-2-6-IDR"><a href="#1-2-6-IDR" class="headerlink" title="1.2.6 . IDR"></a>1.2.6 . IDR</h5><p>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。<br>I和IDR帧都使用帧内预测。I帧不用参考任何帧，但是之后的P帧和B帧是有可能参考这个I帧之前的帧的。IDR就不允许这样。<br>比如这种情况:<br>IDR1 P4 B2 B3 P7 B5 B6 I10 B8 B9 P13 B11 B12 P16 B14 B15 这里的B8可以跨过I10去参考P7</p>
<p>核心作用：<br>H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>
<h5 id="1-3-帧内预测和帧间预测"><a href="#1-3-帧内预测和帧间预测" class="headerlink" title="1.3. 帧内预测和帧间预测"></a>1.3. 帧内预测和帧间预测</h5><h5 id="1-3-1-帧内预测（也叫帧内压缩）"><a href="#1-3-1-帧内预测（也叫帧内压缩）" class="headerlink" title="1.3. 1. 帧内预测（也叫帧内压缩）"></a>1.3. 1. 帧内预测（也叫帧内压缩）</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-15-H264.zenjianyuce.png" alt="Alt text | center"></p>
<p>我们可以通过第 1、2、3、4、5 块的编码来推测和计算第 6 块的编码，因此就不需要对第 6 块进行编码了，从而压缩了第 6 块，节省了空间</p>
<h5 id="1-3-2-帧间预测（也叫帧间压缩）"><a href="#1-3-2-帧间预测（也叫帧间压缩）" class="headerlink" title="1.3. 2. 帧间预测（也叫帧间压缩）"></a>1.3. 2. 帧间预测（也叫帧间压缩）</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-16-H264.zenjianyasuo.png" alt="Alt text | center"></p>
<p>可以看到前后两帧的差异其实是很小的，这时候用帧间压缩就很有意义。<br>这里涉及到几个重要的概念：块匹配，残差，运动搜索(运动估计),运动补偿.</p>
<p>帧间压缩最常用的方式就是块匹配(Block Matching)。找找看前面已经编码的几帧里面，和我当前这个块最类似的一个块，这样我不用编码当前块的内容了，只需要编码当前块和我找到的快的差异(残差)即可。找最想的块的过程叫运动搜索(Motion Search),又叫运动估计。用残差和原来的块就能推算出当前块的过程叫运动补偿(Motion Compensation).</p>
<h4 id="（二）、Android-H264编码"><a href="#（二）、Android-H264编码" class="headerlink" title="（二）、Android  H264编码"></a>（二）、Android  H264编码</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-17-H264-Encoder-google.png" alt="Alt text | center"></p>
<p>由于博主的手机为Qcom平台，支持h264编解码，博主保留了Qcom h264 Encoder ，将Decoder使用Google的，但分析主要还是以Google的H264 Encoder/Decoder 为主。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[/system/etc/media_codecs.xml]</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Decoder capabilities for thorium</span></span><br><span class="line"><span class="comment">   _________________________________________________________________________</span></span><br><span class="line"><span class="comment">  | Codec    | W       H       fps     Mbps    MB/s    | Encode Secure-dec |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|___________________|</span></span><br><span class="line"><span class="comment">  | h264     | 1920    1088    30      20      244800  |  Y       N        |</span></span><br><span class="line"><span class="comment">  | hevc     | 1920    1088    30      20      244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | mpeg4    | 1920    1088    30      6       244800  |  Y       N        |</span></span><br><span class="line"><span class="comment">  | vp8      | 1920    1088    30      20      244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | div4/5/6 | 1920    1088    30      6       244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | h263     |  864     480    30      2       48600   |  Y       N        |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|___________________|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Encoder capabilities for thorium</span></span><br><span class="line"><span class="comment">   ____________________________________________________</span></span><br><span class="line"><span class="comment">  | Codec    | W       H       fps     Mbps    MB/s    |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|</span></span><br><span class="line"><span class="comment">  | h264     | 1920    1088    30      20      244800  |</span></span><br><span class="line"><span class="comment">  | mpeg4    | 864      480    30       2       48600  |</span></span><br><span class="line"><span class="comment">  | h263     | 864      480    30       2       48600  |</span></span><br><span class="line"><span class="comment">  |____________________________________________________|</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">MediaCodecs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">&quot;media_codecs_google_audio.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">&quot;media_codecs_google_telephony.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Setting</span> <span class="attr">name</span>=<span class="string">&quot;max-video-encoder-input-buffers&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Encoders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Video Hardware  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">&quot;OMX.qcom.video.encoder.avc&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/avc&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">&quot;requires-allocate-on-input-ports&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">&quot;requires-allocate-on-output-ports&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">&quot;requires-loaded-to-idle-after-allocation&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span> <span class="attr">min</span>=<span class="string">&quot;96x96&quot;</span> <span class="attr">max</span>=<span class="string">&quot;1920x1088&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;alignment&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2x2&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;block-size&quot;</span> <span class="attr">value</span>=<span class="string">&quot;16x16&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;blocks-per-second&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;244800&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;bitrate&quot;</span> <span class="attr">range</span>=<span class="string">&quot;1-20000000&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">&quot;concurrent-instances&quot;</span> <span class="attr">max</span>=<span class="string">&quot;8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">&quot;can-swap-width-height&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Encoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Decoders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Audio Software  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">&quot;OMX.qti.audio.decoder.flac&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/flac&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Decoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">&quot;media_codecs_google_video.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MediaCodecs</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下分析以’OMX.google.h264.decoder’为主：</p>
<h5 id="2-1、SoftAVC-initEncoder"><a href="#2-1、SoftAVC-initEncoder" class="headerlink" title="2.1、SoftAVC::initEncoder()"></a>2.1、SoftAVC::initEncoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcenc\SoftAVCEnc.cpp]</span><br><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">SoftAVC::initEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IV_STATUS_T status;</span><br><span class="line">    WORD32 level;</span><br><span class="line">    <span class="keyword">uint32_t</span> displaySizeY;</span><br><span class="line"></span><br><span class="line">    CHECK(!mStarted);</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE errType = OMX_ErrorNone;</span><br><span class="line"></span><br><span class="line">    displaySizeY = mWidth * mHeight;</span><br><span class="line">    <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">1920</span> * <span class="number">1088</span>)) &#123;</span><br><span class="line">        level = <span class="number">50</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">1280</span> * <span class="number">720</span>)) &#123;</span><br><span class="line">        level = <span class="number">40</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">720</span> * <span class="number">576</span>)) &#123;</span><br><span class="line">        level = <span class="number">31</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">624</span> * <span class="number">320</span>)) &#123;</span><br><span class="line">        level = <span class="number">30</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">352</span> * <span class="number">288</span>)) &#123;</span><br><span class="line">        level = <span class="number">21</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAVCEncLevel = MAX(level, mAVCEncLevel);</span><br><span class="line"></span><br><span class="line">    mStride = mWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_CONVERSION_BUFFERS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mConversionBuffers[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(mConversionBuffers[i]);</span><br><span class="line">                mConversionBuffers[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">uint64_t</span>)mStride * mHeight) &gt; ((<span class="keyword">uint64_t</span>)INT32_MAX / <span class="number">3</span>)) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Buffer size is too big.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">            &#125;</span><br><span class="line">            mConversionBuffers[i] = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(mStride * mHeight * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mConversionBuffers[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Allocating conversion buffer failed.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mConversionBuffersFree[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mColorFormat) &#123;</span><br><span class="line">        <span class="keyword">case</span> OMX_COLOR_FormatYUV420SemiPlanar:</span><br><span class="line">            mIvVideoColorFormat = IV_YUV_420SP_UV;</span><br><span class="line">            ALOGV(<span class="string">&quot;colorFormat YUV_420SP&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> OMX_COLOR_FormatYUV420Planar:</span><br><span class="line">            mIvVideoColorFormat = IV_YUV_420P;</span><br><span class="line">            ALOGV(<span class="string">&quot;colorFormat YUV_420P&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">&quot;Params width %d height %d level %d colorFormat %d&quot;</span>, mWidth,</span><br><span class="line">            mHeight, mAVCEncLevel, mIvVideoColorFormat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Getting Number of MemRecords */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_num_mem_rec_ip_t</span> s_num_mem_rec_ip;</span><br><span class="line">        <span class="keyword">iv_num_mem_rec_op_t</span> s_num_mem_rec_op;</span><br><span class="line"></span><br><span class="line">        s_num_mem_rec_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_num_mem_rec_ip_t</span>);</span><br><span class="line">        s_num_mem_rec_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_num_mem_rec_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_num_mem_rec_ip.e_cmd = IV_CMD_GET_NUM_MEM_REC;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(<span class="number">0</span>, &amp;s_num_mem_rec_ip, &amp;s_num_mem_rec_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Get number of memory records failed = 0x%x\n&quot;</span>,</span><br><span class="line">                    s_num_mem_rec_op.u4_error_code);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNumMemRecords = s_num_mem_rec_op.u4_num_mem_rec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate array to hold memory records */</span></span><br><span class="line">    <span class="keyword">if</span> (mNumMemRecords &gt; SIZE_MAX / <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;requested memory size is too big.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    mMemRecords = (<span class="keyword">iv_mem_rec_t</span> *)<span class="built_in">malloc</span>(mNumMemRecords * <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mMemRecords) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to allocate memory for hold memory records: Size %zu&quot;</span>,</span><br><span class="line">                mNumMemRecords * <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>));</span><br><span class="line">        mSignalledError = <span class="literal">true</span>;</span><br><span class="line">        notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_mem_rec_t</span> *ps_mem_rec;</span><br><span class="line">        ps_mem_rec = mMemRecords;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumMemRecords; i++) &#123;</span><br><span class="line">            ps_mem_rec-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>);</span><br><span class="line">            ps_mem_rec-&gt;pv_base = <span class="literal">NULL</span>;</span><br><span class="line">            ps_mem_rec-&gt;u4_mem_size = <span class="number">0</span>;</span><br><span class="line">            ps_mem_rec-&gt;u4_mem_alignment = <span class="number">0</span>;</span><br><span class="line">            ps_mem_rec-&gt;e_mem_type = IV_NA_MEM_TYPE;</span><br><span class="line"></span><br><span class="line">            ps_mem_rec++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Getting MemRecords Attributes */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_fill_mem_rec_ip_t</span> s_fill_mem_rec_ip;</span><br><span class="line">        <span class="keyword">iv_fill_mem_rec_op_t</span> s_fill_mem_rec_op;</span><br><span class="line"></span><br><span class="line">        s_fill_mem_rec_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_fill_mem_rec_ip_t</span>);</span><br><span class="line">        s_fill_mem_rec_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_fill_mem_rec_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_fill_mem_rec_ip.e_cmd = IV_CMD_FILL_NUM_MEM_REC;</span><br><span class="line">        s_fill_mem_rec_ip.ps_mem_rec = mMemRecords;</span><br><span class="line">        s_fill_mem_rec_ip.u4_num_mem_rec = mNumMemRecords;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_wd = mWidth;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_ht = mHeight;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_level = mAVCEncLevel;</span><br><span class="line">        s_fill_mem_rec_ip.e_color_format = DEFAULT_INP_COLOR_FORMAT;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_ref_cnt = DEFAULT_MAX_REF_FRM;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_reorder_cnt = DEFAULT_MAX_REORDER_FRM;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_srch_rng_x = DEFAULT_MAX_SRCH_RANGE_X;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_srch_rng_y = DEFAULT_MAX_SRCH_RANGE_Y;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(<span class="number">0</span>, &amp;s_fill_mem_rec_ip, &amp;s_fill_mem_rec_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Fill memory records failed = 0x%x\n&quot;</span>,</span><br><span class="line">                    s_fill_mem_rec_op.u4_error_code);</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocating Memory for Mem Records */</span></span><br><span class="line">    &#123;</span><br><span class="line">        WORD32 total_size;</span><br><span class="line">        <span class="keyword">iv_mem_rec_t</span> *ps_mem_rec;</span><br><span class="line">        total_size = <span class="number">0</span>;</span><br><span class="line">        ps_mem_rec = mMemRecords;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumMemRecords; i++) &#123;</span><br><span class="line">            ps_mem_rec-&gt;pv_base = ive_aligned_malloc(</span><br><span class="line">                    ps_mem_rec-&gt;u4_mem_alignment, ps_mem_rec-&gt;u4_mem_size);</span><br><span class="line">            <span class="keyword">if</span> (ps_mem_rec-&gt;pv_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Allocation failure for mem record id %zu size %u\n&quot;</span>, i,</span><br><span class="line">                        ps_mem_rec-&gt;u4_mem_size);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            total_size += ps_mem_rec-&gt;u4_mem_size;</span><br><span class="line"></span><br><span class="line">            ps_mem_rec++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Codec Instance Creation */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ive_init_ip_t</span> s_init_ip;</span><br><span class="line">        <span class="keyword">ive_init_op_t</span> s_init_op;</span><br><span class="line"></span><br><span class="line">        mCodecCtx = (<span class="keyword">iv_obj_t</span> *)mMemRecords[<span class="number">0</span>].pv_base;</span><br><span class="line">        mCodecCtx-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_obj_t</span>);</span><br><span class="line">        mCodecCtx-&gt;pv_fxns = (<span class="keyword">void</span> *)ive_api_function;</span><br><span class="line"></span><br><span class="line">        s_init_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ive_init_ip_t</span>);</span><br><span class="line">        s_init_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ive_init_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_init_ip.e_cmd = IV_CMD_INIT;</span><br><span class="line">        s_init_ip.u4_num_mem_rec = mNumMemRecords;</span><br><span class="line">        s_init_ip.ps_mem_rec = mMemRecords;</span><br><span class="line">        s_init_ip.u4_max_wd = mWidth;</span><br><span class="line">        s_init_ip.u4_max_ht = mHeight;</span><br><span class="line">        s_init_ip.u4_max_ref_cnt = DEFAULT_MAX_REF_FRM;</span><br><span class="line">        s_init_ip.u4_max_reorder_cnt = DEFAULT_MAX_REORDER_FRM;</span><br><span class="line">        s_init_ip.u4_max_level = mAVCEncLevel;</span><br><span class="line">        s_init_ip.e_inp_color_fmt = mIvVideoColorFormat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReconEnable || mPSNREnable) &#123;</span><br><span class="line">            s_init_ip.u4_enable_recon = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s_init_ip.u4_enable_recon = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s_init_ip.e_recon_color_fmt = DEFAULT_RECON_COLOR_FORMAT;</span><br><span class="line">        s_init_ip.e_rc_mode = DEFAULT_RC_MODE;</span><br><span class="line">        s_init_ip.u4_max_framerate = DEFAULT_MAX_FRAMERATE;</span><br><span class="line">        s_init_ip.u4_max_bitrate = DEFAULT_MAX_BITRATE;</span><br><span class="line">        s_init_ip.u4_num_bframes = mBframes;</span><br><span class="line">        s_init_ip.e_content_type = IV_PROGRESSIVE;</span><br><span class="line">        s_init_ip.u4_max_srch_rng_x = DEFAULT_MAX_SRCH_RANGE_X;</span><br><span class="line">        s_init_ip.u4_max_srch_rng_y = DEFAULT_MAX_SRCH_RANGE_Y;</span><br><span class="line">        s_init_ip.e_slice_mode = mSliceMode;</span><br><span class="line">        s_init_ip.u4_slice_param = mSliceParam;</span><br><span class="line">        s_init_ip.e_arch = mArch;</span><br><span class="line">        s_init_ip.e_soc = DEFAULT_SOC;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(mCodecCtx, &amp;s_init_ip, &amp;s_init_op);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get Codec Version */</span></span><br><span class="line">    logVersion();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set processor details */</span></span><br><span class="line">    setNumCores();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Frame dimensions */</span></span><br><span class="line">    setDimensions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Frame rates */</span></span><br><span class="line">    setFrameRate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set IPE Params */</span></span><br><span class="line">    setIpeParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Bitrate */</span></span><br><span class="line">    setBitRate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set QP */</span></span><br><span class="line">    setQp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set AIR params */</span></span><br><span class="line">    setAirParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set VBV params */</span></span><br><span class="line">    setVbvParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Motion estimation params */</span></span><br><span class="line">    setMeParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set GOP params */</span></span><br><span class="line">    setGopParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Deblock params */</span></span><br><span class="line">    setDeblockParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Profile params */</span></span><br><span class="line">    setProfileParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set in Encode header mode */</span></span><br><span class="line">    setEncMode(IVE_ENC_MODE_HEADER);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;init_codec successfull&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSpsPpsHeaderReceived = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2、SoftAVC-onQueueFilled"><a href="#2-2、SoftAVC-onQueueFilled" class="headerlink" title="2.2、SoftAVC::onQueueFilled()"></a>2.2、SoftAVC::onQueueFilled()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcenc\SoftAVCEnc.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftAVC::onQueueFilled</span><span class="params">(OMX_U32 portIndex)</span> </span>&#123;</span><br><span class="line">    IV_STATUS_T status;</span><br><span class="line">    WORD32 timeDelay, timeTaken;</span><br><span class="line"></span><br><span class="line">    UNUSED(portIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize encoder if not already initialized</span></span><br><span class="line">    <span class="keyword">if</span> (mCodecCtx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OMX_ErrorNone != initEncoder()) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Failed to initialize encoder&quot;</span>);</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span> <span class="comment">/* arg2 */</span>, <span class="literal">NULL</span> <span class="comment">/* data */</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSignalledError) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;inQueue = getPortQueue(<span class="number">0</span>);</span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;outQueue = getPortQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mSawOutputEOS &amp;&amp; !outQueue.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        OMX_ERRORTYPE error;</span><br><span class="line">        <span class="keyword">ive_video_encode_ip_t</span> s_encode_ip;</span><br><span class="line">        <span class="keyword">ive_video_encode_op_t</span> s_encode_op;</span><br><span class="line">        BufferInfo *outputBufferInfo = *outQueue.begin();</span><br><span class="line">        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo-&gt;mHeader;</span><br><span class="line"></span><br><span class="line">        BufferInfo *inputBufferInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *inputBufferHeader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSawInputEOS) &#123;</span><br><span class="line">            inputBufferHeader = <span class="literal">NULL</span>;</span><br><span class="line">            inputBufferInfo = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!inQueue.empty()) &#123;</span><br><span class="line">            inputBufferInfo = *inQueue.begin();</span><br><span class="line">            inputBufferHeader = inputBufferInfo-&gt;mHeader;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputBufferHeader-&gt;nTimeStamp = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nFlags = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nFilledLen = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags = inputBufferHeader-&gt;nFlags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *outPtr = (<span class="keyword">uint8_t</span> *)outputBufferHeader-&gt;pBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mSpsPpsHeaderReceived) &#123;</span><br><span class="line">            error = setEncodeArgs(&amp;s_encode_ip, &amp;s_encode_op, <span class="literal">NULL</span>, outputBufferHeader);</span><br><span class="line">            <span class="keyword">if</span> (error != OMX_ErrorNone) &#123;</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            status = ive_api_function(mCodecCtx, &amp;s_encode_ip, &amp;s_encode_op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IV_SUCCESS != status) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Encode Frame failed = 0x%x\n&quot;</span>,</span><br><span class="line">                        s_encode_op.u4_error_code);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Bytes Generated in header %d\n&quot;</span>,</span><br><span class="line">                        s_encode_op.s_out_buf.u4_bytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSpsPpsHeaderReceived = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            outputBufferHeader-&gt;nFlags = OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">            outputBufferHeader-&gt;nFilledLen = s_encode_op.s_out_buf.u4_bytes;</span><br><span class="line">            <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                outputBufferHeader-&gt;nTimeStamp = inputBufferHeader-&gt;nTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            outQueue.erase(outQueue.begin());</span><br><span class="line">            outputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            DUMP_TO_FILE(</span><br><span class="line">                    mOutFile, outputBufferHeader-&gt;pBuffer,</span><br><span class="line">                    outputBufferHeader-&gt;nFilledLen);</span><br><span class="line">            notifyFillBufferDone(outputBufferHeader);</span><br><span class="line"></span><br><span class="line">            setEncMode(IVE_ENC_MODE_PICTURE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mUpdateFlag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kUpdateBitrate) &#123;</span><br><span class="line">                setBitRate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kRequestKeyFrame) &#123;</span><br><span class="line">                setFrameType(IV_IDR_FRAME);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kUpdateAIRMode) &#123;</span><br><span class="line">                setAirParams();</span><br><span class="line">                notify(OMX_EventPortSettingsChanged, kOutputPortIndex,</span><br><span class="line">                        OMX_IndexConfigAndroidIntraRefresh, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mUpdateFlag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((inputBufferHeader != <span class="literal">NULL</span>)</span><br><span class="line">                &amp;&amp; (inputBufferHeader-&gt;nFlags &amp; OMX_BUFFERFLAG_EOS)) &#123;</span><br><span class="line">            mSawInputEOS = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* In normal mode, store inputBufferInfo and this will be returned</span></span><br><span class="line"><span class="comment">           when encoder consumes this input */</span></span><br><span class="line">        <span class="keyword">if</span> (!mInputDataIsMeta &amp;&amp; (inputBufferInfo != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_INPUT_BUFFER_HEADERS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == mInputBufferInfo[i]) &#123;</span><br><span class="line">                    mInputBufferInfo[i] = inputBufferInfo;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        error = setEncodeArgs(</span><br><span class="line">                &amp;s_encode_ip, &amp;s_encode_op, inputBufferHeader, outputBufferHeader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error != OMX_ErrorNone) &#123;</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DUMP_TO_FILE(</span><br><span class="line">                mInFile, s_encode_ip.s_inp_buf.apv_bufs[<span class="number">0</span>],</span><br><span class="line">                (mHeight * mStride * <span class="number">3</span> / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        GETTIME(&amp;mTimeStart, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Compute time elapsed between end of previous decode()</span></span><br><span class="line"><span class="comment">         * to start of current decode() */</span></span><br><span class="line">        TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);</span><br><span class="line">        status = ive_api_function(mCodecCtx, &amp;s_encode_ip, &amp;s_encode_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IV_SUCCESS != status) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Encode Frame failed = 0x%x\n&quot;</span>,</span><br><span class="line">                    s_encode_op.u4_error_code);</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GETTIME(&amp;mTimeEnd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Compute time taken for decode() */</span></span><br><span class="line">        TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">&quot;timeTaken=%6d delay=%6d numBytes=%6d&quot;</span>, timeTaken, timeDelay,</span><br><span class="line">                s_encode_op.s_out_buf.u4_bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* In encoder frees up an input buffer, mark it as free */</span></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_CONVERSION_BUFFERS; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mConversionBuffers[i] == s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>]) &#123;</span><br><span class="line">                        mConversionBuffersFree[i] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* In normal mode, call EBD on inBuffeHeader that is freed by the codec */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_INPUT_BUFFER_HEADERS; i++) &#123;</span><br><span class="line">                    <span class="keyword">uint8_t</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">                    OMX_BUFFERHEADERTYPE *bufHdr = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mInputBufferInfo[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        bufHdr = mInputBufferInfo[i]-&gt;mHeader;</span><br><span class="line">                        buf = bufHdr-&gt;pBuffer + bufHdr-&gt;nOffset;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>] == buf) &#123;</span><br><span class="line">                        mInputBufferInfo[i]-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                        notifyEmptyBufferDone(bufHdr);</span><br><span class="line">                        mInputBufferInfo[i] = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputBufferHeader-&gt;nFilledLen = s_encode_op.s_out_buf.u4_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IV_IDR_FRAME == s_encode_op.u4_encoded_frame_type) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags |= OMX_BUFFERFLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inQueue.erase(inQueue.begin());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If in meta data, call EBD on input */</span></span><br><span class="line">            <span class="comment">/* In case of normal mode, EBD will be done once encoder</span></span><br><span class="line"><span class="comment">            releases the input buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">                inputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                notifyEmptyBufferDone(inputBufferHeader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.u4_is_last) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line">            mSawOutputEOS = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags &amp;= ~OMX_BUFFERFLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outputBufferHeader-&gt;nFilledLen || s_encode_op.u4_is_last) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp = s_encode_op.u4_timestamp_high;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp |= s_encode_op.u4_timestamp_low;</span><br><span class="line">            outputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">            outQueue.erase(outQueue.begin());</span><br><span class="line">            DUMP_TO_FILE(mOutFile, outputBufferHeader-&gt;pBuffer,</span><br><span class="line">                    outputBufferHeader-&gt;nFilledLen);</span><br><span class="line">            notifyFillBufferDone(outputBufferHeader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.u4_is_last == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3、ih264e-encode"><a href="#2-3、ih264e-encode" class="headerlink" title="2.3、ih264e_encode()"></a>2.3、ih264e_encode()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\Ph55c74\PH55C74\android\external\libavc\encoder\ih264e_encode.c]</span><br><span class="line"><span class="function">WORD32 <span class="title">ih264e_encode</span><span class="params">(<span class="keyword">iv_obj_t</span> *ps_codec_obj, <span class="keyword">void</span> *pv_api_ip, <span class="keyword">void</span> *pv_api_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* error status */</span></span><br><span class="line">    IH264E_ERROR_T error_status = IH264E_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec ctxt */</span></span><br><span class="line">    <span class="keyword">codec_t</span> *ps_codec = (<span class="keyword">codec_t</span> *)ps_codec_obj-&gt;pv_codec_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* input frame to encode */</span></span><br><span class="line">    <span class="keyword">ih264e_video_encode_ip_t</span> *ps_video_encode_ip = pv_api_ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* output buffer to write stream */</span></span><br><span class="line">    <span class="keyword">ih264e_video_encode_op_t</span> *ps_video_encode_op = pv_api_op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* i/o structures */</span></span><br><span class="line">    <span class="keyword">inp_buf_t</span> s_inp_buf;</span><br><span class="line">    <span class="keyword">out_buf_t</span> s_out_buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* temp var */</span></span><br><span class="line">    WORD32 ctxt_sel = <span class="number">0</span>, i, i4_rc_pre_enc_skip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********************************************************************/</span></span><br><span class="line">    <span class="comment">/*                            BEGIN INIT                            */</span></span><br><span class="line">    <span class="comment">/********************************************************************/</span></span><br><span class="line">    <span class="comment">/* reset output structure */</span></span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.u4_error_code = IV_SUCCESS;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.output_present  = <span class="number">0</span>;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.dump_recon = <span class="number">0</span>;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.u4_encoded_frame_type = IV_NA_FRAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for output memory allocation size */</span></span><br><span class="line">    <span class="keyword">if</span> (ps_video_encode_ip-&gt;s_ive_ip.s_out_buf.u4_bufsize &lt; MIN_STREAM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        error_status |= IH264E_INSUFFICIENT_OUTPUT_BUFFER;</span><br><span class="line">        SET_ERROR_ON_RETURN(error_status,</span><br><span class="line">                            IVE_UNSUPPORTEDPARAM,</span><br><span class="line">                            ps_video_encode_op-&gt;s_ive_op.u4_error_code,</span><br><span class="line">                            IV_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy output info. to internal structure */</span></span><br><span class="line">    s_out_buf.s_bits_buf = ps_video_encode_ip-&gt;s_ive_ip.s_out_buf;</span><br><span class="line">    s_out_buf.u4_is_last = <span class="number">0</span>;</span><br><span class="line">    s_out_buf.u4_timestamp_low = ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_low;</span><br><span class="line">    s_out_buf.u4_timestamp_high = ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* api call cnt */</span></span><br><span class="line">    ps_codec-&gt;i4_encode_api_call_cnt += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec context selector */</span></span><br><span class="line">    ctxt_sel = ps_codec-&gt;i4_encode_api_call_cnt % MAX_CTXT_SETS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset status flags */</span></span><br><span class="line">    ps_codec-&gt;ai4_pic_cnt[ctxt_sel] = <span class="number">-1</span>;</span><br><span class="line">    ps_codec-&gt;s_rate_control.post_encode_skip[ctxt_sel] = <span class="number">0</span>;</span><br><span class="line">    ps_codec-&gt;s_rate_control.pre_encode_skip[ctxt_sel] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pass output buffer to codec */</span></span><br><span class="line">    ps_codec-&gt;as_out_buf[ctxt_sel] = s_out_buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize codec ctxt with default params for the first encode api call */</span></span><br><span class="line">    <span class="keyword">if</span> (ps_codec-&gt;i4_encode_api_call_cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ih264e_codec_init(ps_codec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse configuration params */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ACTIVE_CONFIG_PARAMS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">cfg_params_t</span> *ps_cfg = &amp;ps_codec-&gt;as_cfg[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == ps_cfg-&gt;u4_is_valid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ((ps_cfg-&gt;u4_timestamp_high == ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_high) &amp;&amp;</span><br><span class="line">                            (ps_cfg-&gt;u4_timestamp_low == ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_low)) ||</span><br><span class="line">                            ((WORD32)ps_cfg-&gt;u4_timestamp_high == <span class="number">-1</span>) ||</span><br><span class="line">                            ((WORD32)ps_cfg-&gt;u4_timestamp_low == <span class="number">-1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                error_status |= ih264e_codec_update_config(ps_codec, ps_cfg);</span><br><span class="line">                SET_ERROR_ON_RETURN(error_status,</span><br><span class="line">                                    IVE_UNSUPPORTEDPARAM,</span><br><span class="line">                                    ps_video_encode_op-&gt;s_ive_op.u4_error_code,</span><br><span class="line">                                    IV_FAIL);</span><br><span class="line"></span><br><span class="line">                ps_cfg-&gt;u4_is_valid = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Send the input to encoder so that it can free it if possible */</span></span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.s_out_buf = s_out_buf.s_bits_buf;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.s_inp_buf = s_inp_buf.s_raw_buf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == s_inp_buf.u4_is_last)</span><br><span class="line">    &#123;</span><br><span class="line">        ps_video_encode_op-&gt;s_ive_op.output_present = <span class="number">0</span>;</span><br><span class="line">        ps_video_encode_op-&gt;s_ive_op.dump_recon = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IV_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到编码过程极其复杂…精髓在libavc库里面，第四节详细分析（Todo）。</p>
<h4 id="（三）、Android-H264解码"><a href="#（三）、Android-H264解码" class="headerlink" title="（三）、Android  H264解码"></a>（三）、Android  H264解码</h4><h5 id="3-1、SoftAVC-initDecoder"><a href="#3-1、SoftAVC-initDecoder" class="headerlink" title="3.1、SoftAVC::initDecoder()"></a>3.1、SoftAVC::initDecoder()</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.codecs/VS9-18-H264-Decoder-google.png" alt="Alt text | center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcdec\SoftAVCDec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SoftAVC::initDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IV_API_CALL_STATUS_T status;</span><br><span class="line"></span><br><span class="line">    mNumCores = GetCPUCoreCount();</span><br><span class="line">    mCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mStride = outputBufferWidth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the decoder */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ivdext_create_ip_t</span> s_create_ip;</span><br><span class="line">        <span class="keyword">ivdext_create_op_t</span> s_create_op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *dec_fxns = (<span class="keyword">void</span> *)ivdec_api_function;</span><br><span class="line"></span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivdext_create_ip_t</span>);</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.e_cmd = IVD_CMD_CREATE;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.u4_share_disp_buf = <span class="number">0</span>;</span><br><span class="line">        s_create_op.<span class="keyword">s_ivd_create_op_t</span>.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivdext_create_op_t</span>);</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.e_output_format = mIvColorFormat;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pf_aligned_alloc = ivd_aligned_malloc;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pf_aligned_free = ivd_aligned_free;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pv_mem_ctxt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        status = ivdec_api_function(mCodecCtx, (<span class="keyword">void</span> *)&amp;s_create_ip, (<span class="keyword">void</span> *)&amp;s_create_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Error in create: 0x%x&quot;</span>,</span><br><span class="line">                    s_create_op.<span class="keyword">s_ivd_create_op_t</span>.u4_error_code);</span><br><span class="line">            deInitDecoder();</span><br><span class="line">            mCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecCtx = (<span class="keyword">iv_obj_t</span>*)s_create_op.<span class="keyword">s_ivd_create_op_t</span>.pv_handle;</span><br><span class="line">        mCodecCtx-&gt;pv_fxns = dec_fxns;</span><br><span class="line">        mCodecCtx-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_obj_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the plugin state */</span></span><br><span class="line">    resetPlugin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the run time (dynamic) parameters */</span></span><br><span class="line">    setParams(mStride);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set number of cores/threads to be used by the codec */</span></span><br><span class="line">    setNumCores();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get codec version */</span></span><br><span class="line">    logVersion();</span><br><span class="line"></span><br><span class="line">    mFlushNeeded = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-2、SoftAVC-onQueueFilled"><a href="#3-2、SoftAVC-onQueueFilled" class="headerlink" title="3.2、SoftAVC::onQueueFilled()"></a>3.2、SoftAVC::onQueueFilled()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcdec\SoftAVCDec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SoftAVC::onQueueFilled</span><span class="params">(OMX_U32 portIndex)</span> </span>&#123;</span><br><span class="line">    UNUSED(portIndex);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span> (outputBufferWidth() != mStride) &#123;</span><br><span class="line">        <span class="comment">/* Set the run-time (dynamic) parameters */</span></span><br><span class="line">        mStride = outputBufferWidth();</span><br><span class="line">        setParams(mStride);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;inQueue = getPortQueue(kInputPortIndex);</span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;outQueue = getPortQueue(kOutputPortIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!outQueue.empty()) &#123;</span><br><span class="line">        BufferInfo *inInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *inHeader;</span><br><span class="line"></span><br><span class="line">        BufferInfo *outInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *outHeader;</span><br><span class="line">        <span class="keyword">size_t</span> timeStampIx;</span><br><span class="line"></span><br><span class="line">        inInfo = <span class="literal">NULL</span>;</span><br><span class="line">        inHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        outInfo = *outQueue.begin();</span><br><span class="line">        outHeader = outInfo-&gt;mHeader;</span><br><span class="line">        outHeader-&gt;nFlags = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nTimeStamp = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get a free slot in timestamp array to hold input timestamp */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> i;</span><br><span class="line">            timeStampIx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_TIME_STAMPS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mTimeStampsValid[i]) &#123;</span><br><span class="line">                    timeStampIx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mTimeStampsValid[timeStampIx] = <span class="literal">true</span>;</span><br><span class="line">                mTimeStamps[timeStampIx] = inHeader-&gt;nTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">ivd_video_decode_ip_t</span> s_dec_ip;</span><br><span class="line">            <span class="keyword">ivd_video_decode_op_t</span> s_dec_op;</span><br><span class="line">            WORD32 timeDelay, timeTaken;</span><br><span class="line">            <span class="keyword">size_t</span> sizeY, sizeUV;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!setDecodeArgs(&amp;s_dec_ip, &amp;s_dec_op, inHeader, outHeader, timeStampIx)) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Decoder arg setup failed&quot;</span>);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If input dump is enabled, then write to file</span></span><br><span class="line">            DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);</span><br><span class="line"></span><br><span class="line">            GETTIME(&amp;mTimeStart, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* Compute time elapsed between end of previous decode()</span></span><br><span class="line"><span class="comment">             * to start of current decode() */</span></span><br><span class="line">            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);</span><br><span class="line"></span><br><span class="line">            IV_API_CALL_STATUS_T status;</span><br><span class="line">            status = ivdec_api_function(mCodecCtx, (<span class="keyword">void</span> *)&amp;s_dec_ip, (<span class="keyword">void</span> *)&amp;s_dec_op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> unsupportedResolution =</span><br><span class="line">                (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Check for unsupported dimensions */</span></span><br><span class="line">            <span class="keyword">if</span> (unsupportedResolution) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Unsupported resolution : %dx%d&quot;</span>, mWidth, mHeight);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line">            <span class="keyword">if</span> (allocationFailed) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Allocation failure in decoder&quot;</span>);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">            getVUIParams();</span><br><span class="line"></span><br><span class="line">            GETTIME(&amp;mTimeEnd, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* Compute time taken for decode() */</span></span><br><span class="line">            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);</span><br><span class="line"></span><br><span class="line">            PRINT_TIME(<span class="string">&quot;timeTaken=%6d delay=%6d numBytes=%6d&quot;</span>, timeTaken, timeDelay,</span><br><span class="line">                   s_dec_op.u4_num_bytes_consumed);</span><br><span class="line">            <span class="keyword">if</span> (s_dec_op.u4_frame_decoded_flag &amp;&amp; !mFlushNeeded) &#123;</span><br><span class="line">                mFlushNeeded = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((inHeader != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">1</span> != s_dec_op.u4_frame_decoded_flag)) &#123;</span><br><span class="line">                <span class="comment">/* If the input did not contain picture data, then ignore</span></span><br><span class="line"><span class="comment">                 * the associated timestamp */</span></span><br><span class="line">                mTimeStampsValid[timeStampIx] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the decoder is in the changing resolution mode and there is no output present,</span></span><br><span class="line">            <span class="comment">// that means the switching is done and it&#x27;s ready to reset the decoder and the plugin.</span></span><br><span class="line">            <span class="keyword">if</span> (mChangingResolution &amp;&amp; !s_dec_op.u4_output_present) &#123;</span><br><span class="line">                mChangingResolution = <span class="literal">false</span>;</span><br><span class="line">                resetDecoder();</span><br><span class="line">                resetPlugin();</span><br><span class="line">                mStride = outputBufferWidth();</span><br><span class="line">                setParams(mStride);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resChanged) &#123;</span><br><span class="line">                mChangingResolution = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (mFlushNeeded) &#123;</span><br><span class="line">                    setFlushMode();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Combine the resolution change and coloraspects change in one PortSettingChange event</span></span><br><span class="line">            <span class="comment">// if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> &lt; s_dec_op.u4_pic_wd) &amp;&amp; (<span class="number">0</span> &lt; s_dec_op.u4_pic_ht)) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> width = s_dec_op.u4_pic_wd;</span><br><span class="line">                <span class="keyword">uint32_t</span> height = s_dec_op.u4_pic_ht;</span><br><span class="line">                <span class="keyword">bool</span> portWillReset = <span class="literal">false</span>;</span><br><span class="line">                handlePortSettingsChange(&amp;portWillReset, width, height);</span><br><span class="line">                <span class="keyword">if</span> (portWillReset) &#123;</span><br><span class="line">                    resetDecoder();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mUpdateColorAspects) &#123;</span><br><span class="line">                notify(OMX_EventPortSettingsChanged, kOutputPortIndex,</span><br><span class="line">                    kDescribeColorAspectsIndex, <span class="literal">NULL</span>);</span><br><span class="line">                mUpdateColorAspects = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s_dec_op.u4_output_present) &#123;</span><br><span class="line">                outHeader-&gt;nFilledLen = (outputBufferWidth() * outputBufferHeight() * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                outHeader-&gt;nTimeStamp = mTimeStamps[s_dec_op.u4_ts];</span><br><span class="line">                mTimeStampsValid[s_dec_op.u4_ts] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                outQueue.erase(outQueue.begin());</span><br><span class="line">                outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                notifyFillBufferDone(outHeader);</span><br><span class="line">                outHeader = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsInFlush) &#123;</span><br><span class="line">                <span class="comment">/* If in flush mode and no output is returned by the codec,</span></span><br><span class="line"><span class="comment">                 * then come out of flush mode */</span></span><br><span class="line">                mIsInFlush = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If EOS was recieved on input port and there is no output</span></span><br><span class="line"><span class="comment">                 * from the codec, then signal EOS on output port */</span></span><br><span class="line">                <span class="keyword">if</span> (mReceivedEOS) &#123;</span><br><span class="line">                    outHeader-&gt;nFilledLen = <span class="number">0</span>;</span><br><span class="line">                    outHeader-&gt;nFlags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line"></span><br><span class="line">                    outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                    outQueue.erase(outQueue.begin());</span><br><span class="line">                    outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                    notifyFillBufferDone(outHeader);</span><br><span class="line">                    outHeader = <span class="literal">NULL</span>;</span><br><span class="line">                    resetPlugin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、WORD32-ih264d-video-decode"><a href="#3-3、WORD32-ih264d-video-decode" class="headerlink" title="3.3、WORD32 ih264d_video_decode()"></a>3.3、WORD32 ih264d_video_decode()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\Ph55c74\PH55C74\android\external\libavc\decoder\ih264d_api.c]</span><br><span class="line"><span class="function">WORD32 <span class="title">ih264d_video_decode</span><span class="params">(<span class="keyword">iv_obj_t</span> *dec_hdl, <span class="keyword">void</span> *pv_api_ip, <span class="keyword">void</span> *pv_api_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* ! */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dec_struct_t</span> * ps_dec = (<span class="keyword">dec_struct_t</span> *)(dec_hdl-&gt;pv_codec_handle);</span><br><span class="line"></span><br><span class="line">    WORD32 i4_err_status = <span class="number">0</span>;</span><br><span class="line">    UWORD8 *pu1_buf = <span class="literal">NULL</span>;</span><br><span class="line">    WORD32 buflen;</span><br><span class="line">    UWORD32 u4_max_ofst, u4_length_of_start_code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UWORD32 bytes_consumed = <span class="number">0</span>;</span><br><span class="line">    UWORD32 cur_slice_is_nonref = <span class="number">0</span>;</span><br><span class="line">    UWORD32 u4_next_is_aud;</span><br><span class="line">    UWORD32 u4_first_start_code_found = <span class="number">0</span>;</span><br><span class="line">    WORD32 ret = <span class="number">0</span>,api_ret_value = IV_SUCCESS;</span><br><span class="line">    WORD32 header_data_left = <span class="number">0</span>,frame_data_left = <span class="number">0</span>;</span><br><span class="line">    UWORD8 *pu1_bitstrm_buf;</span><br><span class="line">    <span class="keyword">ivd_video_decode_ip_t</span> *ps_dec_ip;</span><br><span class="line">    <span class="keyword">ivd_video_decode_op_t</span> *ps_dec_op;</span><br><span class="line"></span><br><span class="line">    ithread_set_name((<span class="keyword">void</span>*)<span class="string">&quot;Parse_thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ps_dec_ip = (<span class="keyword">ivd_video_decode_ip_t</span> *)pv_api_ip;</span><br><span class="line">    ps_dec_op = (<span class="keyword">ivd_video_decode_op_t</span> *)pv_api_op;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 u4_size;</span><br><span class="line">        u4_size = ps_dec_op-&gt;u4_size;</span><br><span class="line">        <span class="built_in">memset</span>(ps_dec_op, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>));</span><br><span class="line">        ps_dec_op-&gt;u4_size = u4_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;pv_dec_out = ps_dec_op;</span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;init_done != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Data memory barries instruction,so that bitstream write by the application is complete*/</span></span><br><span class="line">    DATA_SYNC();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u1_flushfrm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec_ip-&gt;pv_stream_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec_ip-&gt;u4_num_Bytes &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DEC_NUMBYTES_INV;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ps_dec-&gt;u1_pic_decode_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec_op-&gt;u4_num_bytes_consumed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;ps_out_buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec_ip-&gt;u4_size</span><br><span class="line">                    &gt;= offsetof(<span class="keyword">ivd_video_decode_ip_t</span>, s_out_buffer))</span><br><span class="line">        ps_dec-&gt;ps_out_buffer = &amp;ps_dec_ip-&gt;s_out_buffer;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_fmt_conv_cur_row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_output_present = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;s_disp_op.u4_error_code = <span class="number">1</span>;</span><br><span class="line">    ps_dec-&gt;u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u4_share_disp_buf</span><br><span class="line">                    &amp;&amp; ps_dec-&gt;i4_decode_header == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 i;</span><br><span class="line">        <span class="keyword">if</span>((ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs == <span class="number">0</span>) ||</span><br><span class="line">           (ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs &gt; IVD_VIDDEC_MAX_IO_BUFFERS))</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;ps_out_buffer-&gt;pu1_bufs[i] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;</span><br><span class="line">                <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;ps_out_buffer-&gt;u4_min_out_buf_size[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |=</span><br><span class="line">                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;</span><br><span class="line">                <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u4_total_frames_decoded &gt;= NUM_FRAMES_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">        ps_dec_op-&gt;u4_error_code = ERROR_FRAME_LIMIT_OVER;</span><br><span class="line">        <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ! */</span></span><br><span class="line">    ps_dec-&gt;u4_ts = ps_dec_ip-&gt;u4_ts;</span><br><span class="line"></span><br><span class="line">    ps_dec_op-&gt;u4_error_code = <span class="number">0</span>;</span><br><span class="line">    ps_dec_op-&gt;e_pic_type = <span class="number">-1</span>;</span><br><span class="line">    ps_dec_op-&gt;u4_output_present = <span class="number">0</span>;</span><br><span class="line">    ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;i4_frametype = <span class="number">-1</span>;</span><br><span class="line">    ps_dec-&gt;i4_content_type = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_slice_start_code_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In case the deocder is not in flush mode(in shared mode),</span></span><br><span class="line"><span class="comment">     then decoder has to pick up a buffer to write current frame.</span></span><br><span class="line"><span class="comment">     Check if a frame is available in such cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_init_dec_flag == <span class="number">1</span> &amp;&amp; ps_dec-&gt;u4_share_disp_buf == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; ps_dec-&gt;u1_flushfrm == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 i;</span><br><span class="line"></span><br><span class="line">        WORD32 disp_avail = <span class="number">0</span>, free_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if at least one buffer is available with the codec */</span></span><br><span class="line">        <span class="comment">/* If not then return to application with error */</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ps_dec-&gt;u1_pic_bufs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u4_disp_buf_mapping[i]</span><br><span class="line">                            || <span class="number">1</span> == ps_dec-&gt;u4_disp_buf_to_be_freed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                disp_avail = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == disp_avail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* If something is queued for display wait for that buffer to be returned */</span></span><br><span class="line"></span><br><span class="line">            ps_dec_op-&gt;u4_error_code = IVD_DEC_REF_BUF_NULL;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">pic_buffer_t</span> *ps_pic_buf;</span><br><span class="line">            ps_pic_buf = (<span class="keyword">pic_buffer_t</span> *)ih264_buf_mgr_get_next_free(</span><br><span class="line">                            (<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr, &amp;free_id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_pic_buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                UWORD32 i, display_queued = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* check if any buffer was given for display which is not returned yet */</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (MAX_DISP_BUFS_NEW); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> != ps_dec-&gt;u4_disp_buf_mapping[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        display_queued = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* If some buffer is queued for display, then codec has to singal an error and wait</span></span><br><span class="line"><span class="comment">                 for that buffer to be returned.</span></span><br><span class="line"><span class="comment">                 If nothing is queued for display then codec has ownership of all display buffers</span></span><br><span class="line"><span class="comment">                 and it can reuse any of the existing buffers and continue decoding */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == display_queued)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* If something is queued for display wait for that buffer to be returned */</span></span><br><span class="line">                    ps_dec_op-&gt;u4_error_code = IVD_DEC_REF_BUF_NULL;</span><br><span class="line">                    ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span></span><br><span class="line">                                    &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">                    <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* If the buffer is with display, then mark it as in use and then look for a buffer again */</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == ps_dec-&gt;u4_disp_buf_mapping[free_id])</span><br><span class="line">                &#123;</span><br><span class="line">                    ih264_buf_mgr_set_status(</span><br><span class="line">                                    (<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr,</span><br><span class="line">                                    free_id,</span><br><span class="line">                                    BUF_MGR_IO);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  Found a free buffer for present call. Release it now.</span></span><br><span class="line"><span class="comment">                     *  Will be again obtained later.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ih264_buf_mgr_release((<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr,</span><br><span class="line">                                          free_id,</span><br><span class="line">                                          BUF_MGR_IO);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_flushfrm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;u1_init_dec_flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*Come out of flush mode and return*/</span></span><br><span class="line">            ps_dec-&gt;u1_flushfrm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ih264d_get_next_display_field(ps_dec, ps_dec-&gt;ps_out_buffer,</span><br><span class="line">                                      &amp;(ps_dec-&gt;s_disp_op));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;s_disp_op.u4_error_code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* check output buffer size given by the application */</span></span><br><span class="line">            <span class="keyword">if</span>(check_app_out_buf_size(ps_dec) != IV_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;</span><br><span class="line">                <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_cur_row = <span class="number">0</span>;</span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_num_rows = ps_dec-&gt;s_disp_frame_info.u4_y_ht;</span><br><span class="line">            ih264d_format_convert(ps_dec, &amp;(ps_dec-&gt;s_disp_op),</span><br><span class="line">                                  ps_dec-&gt;u4_fmt_conv_cur_row,</span><br><span class="line">                                  ps_dec-&gt;u4_fmt_conv_num_rows);</span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_cur_row += ps_dec-&gt;u4_fmt_conv_num_rows;</span><br><span class="line">            ps_dec-&gt;u4_output_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ih264d_release_display_field(ps_dec, &amp;(ps_dec-&gt;s_disp_op));</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_pic_wd = (UWORD32)ps_dec-&gt;u2_disp_width;</span><br><span class="line">        ps_dec_op-&gt;u4_pic_ht = (UWORD32)ps_dec-&gt;u2_disp_height;</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_new_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_output_present = ps_dec-&gt;u4_output_present;</span><br><span class="line">        ps_dec_op-&gt;u4_progressive_frame_flag =</span><br><span class="line">                        ps_dec-&gt;s_disp_op.u4_progressive_frame_flag;</span><br><span class="line">        ps_dec_op-&gt;e_output_format =</span><br><span class="line">                        ps_dec-&gt;s_disp_op.e_output_format;</span><br><span class="line">        ps_dec_op-&gt;s_disp_frm_buf = ps_dec-&gt;s_disp_op.s_disp_frm_buf;</span><br><span class="line">        ps_dec_op-&gt;e4_fld_type = ps_dec-&gt;s_disp_op.e4_fld_type;</span><br><span class="line">        ps_dec_op-&gt;u4_ts = ps_dec-&gt;s_disp_op.u4_ts;</span><br><span class="line">        ps_dec_op-&gt;u4_disp_buf_id = ps_dec-&gt;s_disp_op.u4_disp_buf_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*In the case of flush ,since no frame is decoded set pic type as invalid*/</span></span><br><span class="line">        ps_dec_op-&gt;u4_is_ref_flag = <span class="number">-1</span>;</span><br><span class="line">        ps_dec_op-&gt;e_pic_type = IV_NA_FRAME;</span><br><span class="line">        ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;s_disp_op.u4_error_code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (IV_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_res_changed == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*if resolution has changed and all buffers have been flushed, reset decoder*/</span></span><br><span class="line">        ih264d_init_decoder(ps_dec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_prev_nal_skipped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u2_cur_mb_addr = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u2_total_mbs_coded = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u2_cur_slice_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;cur_dec_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;cur_recon_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_first_slice_in_pic = <span class="number">1</span>;</span><br><span class="line">    ps_dec-&gt;u1_slice_header_done = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u1_dangling_field = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_dec_thread_created = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_bs_deblk_thread_created = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_cur_bs_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_start_recon_deblk  = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_sps_cnt_in_process = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DEBUG_THREADS_PRINTF(<span class="string">&quot; Starting process call\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_pic_buf_got = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        WORD32 buf_size;</span><br><span class="line"></span><br><span class="line">        pu1_buf = (UWORD8*)ps_dec_ip-&gt;pv_stream_buffer</span><br><span class="line">                        + ps_dec_op-&gt;u4_num_bytes_consumed;</span><br><span class="line"></span><br><span class="line">        u4_max_ofst = ps_dec_ip-&gt;u4_num_Bytes</span><br><span class="line">                        - ps_dec_op-&gt;u4_num_bytes_consumed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If dynamic bitstream buffer is not allocated and</span></span><br><span class="line"><span class="comment">         * header decode is done, then allocate dynamic bitstream buffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="literal">NULL</span> == ps_dec-&gt;pu1_bits_buf_dynamic) &amp;&amp;</span><br><span class="line">           (ps_dec-&gt;i4_header_decoded &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            WORD32 size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> *pv_buf;</span><br><span class="line">            <span class="keyword">void</span> *pv_mem_ctxt = ps_dec-&gt;pv_mem_ctxt;</span><br><span class="line">            size = MAX(<span class="number">256000</span>, ps_dec-&gt;u2_pic_wd * ps_dec-&gt;u2_pic_ht * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">            pv_buf = ps_dec-&gt;pf_aligned_alloc(pv_mem_ctxt, <span class="number">128</span>,</span><br><span class="line">                                              size + EXTRA_BS_OFFSET);</span><br><span class="line">            RETURN_IF((<span class="literal">NULL</span> == pv_buf), IV_FAIL);</span><br><span class="line">            ps_dec-&gt;pu1_bits_buf_dynamic = pv_buf;</span><br><span class="line">            ps_dec-&gt;u4_dynamic_bits_buf_size = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;pu1_bits_buf_dynamic)</span><br><span class="line">        &#123;</span><br><span class="line">            pu1_bitstrm_buf = ps_dec-&gt;pu1_bits_buf_dynamic;</span><br><span class="line">            buf_size = ps_dec-&gt;u4_dynamic_bits_buf_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pu1_bitstrm_buf = ps_dec-&gt;pu1_bits_buf_static;</span><br><span class="line">            buf_size = ps_dec-&gt;u4_static_bits_buf_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u4_next_is_aud = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        buflen = ih264d_find_start_code(pu1_buf, <span class="number">0</span>, u4_max_ofst,</span><br><span class="line">                                               &amp;u4_length_of_start_code,</span><br><span class="line">                                               &amp;u4_next_is_aud);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buflen == <span class="number">-1</span>)</span><br><span class="line">            buflen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Ignore bytes beyond the allocated size of intermediate buffer */</span></span><br><span class="line">        <span class="comment">/* Since 8 bytes are read ahead, ensure 8 bytes are free at the</span></span><br><span class="line"><span class="comment">        end of the buffer, which will be memset to 0 after emulation prevention */</span></span><br><span class="line">        buflen = MIN(buflen, buf_size - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        bytes_consumed = buflen + u4_length_of_start_code;</span><br><span class="line">        ps_dec_op-&gt;u4_num_bytes_consumed += bytes_consumed;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            UWORD8 u1_firstbyte, u1_nal_ref_idc;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;i4_app_skip_mode == IVD_SKIP_B)</span><br><span class="line">            &#123;</span><br><span class="line">                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);</span><br><span class="line">                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));</span><br><span class="line">                <span class="keyword">if</span>(u1_nal_ref_idc == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*skip non reference frames*/</span></span><br><span class="line">                    cur_slice_is_nonref = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">1</span> == cur_slice_is_nonref)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/*We have encountered a referenced frame,return to app*/</span></span><br><span class="line">                        ps_dec_op-&gt;u4_num_bytes_consumed -=</span><br><span class="line">                                        bytes_consumed;</span><br><span class="line">                        ps_dec_op-&gt;e_pic_type = IV_B_FRAME;</span><br><span class="line">                        ps_dec_op-&gt;u4_error_code =</span><br><span class="line">                                        IVD_DEC_FRM_SKIPPED;</span><br><span class="line">                        ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span></span><br><span class="line">                                        &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">                        ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line">                        ps_dec_op-&gt;u4_size =</span><br><span class="line">                                        <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>);</span><br><span class="line">                        <span class="comment">/*signal the decode thread*/</span></span><br><span class="line">                        ih264d_signal_decode_thread(ps_dec);</span><br><span class="line">                        <span class="comment">/* close deblock thread if it is not closed yet*/</span></span><br><span class="line">                        <span class="keyword">if</span>(ps_dec-&gt;u4_num_cores == <span class="number">3</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ih264d_signal_bs_deblk_thread(ps_dec);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buflen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,</span><br><span class="line">                   buflen);</span><br><span class="line">            <span class="comment">/* Decoder may read extra 8 bytes near end of the frame */</span></span><br><span class="line">            <span class="keyword">if</span>((buflen + <span class="number">8</span>) &lt; buf_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(pu1_bitstrm_buf + buflen, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            u4_first_start_code_found = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*start code not found*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(u4_first_start_code_found == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*no start codes found in current process call*/</span></span><br><span class="line"></span><br><span class="line">                ps_dec-&gt;i4_error_code = ERROR_START_CODE_NOT_FOUND;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_INSUFFICIENTDATA;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ps_dec-&gt;u4_pic_buf_got == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    ih264d_fill_output_struct_from_context(ps_dec,</span><br><span class="line">                                                           ps_dec_op);</span><br><span class="line"></span><br><span class="line">                    ps_dec_op-&gt;u4_error_code = ps_dec-&gt;i4_error_code;</span><br><span class="line">                    ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ps_dec-&gt;u1_pic_decode_done = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* a start code has already been found earlier in the same process call*/</span></span><br><span class="line">                frame_data_left = <span class="number">0</span>;</span><br><span class="line">                header_data_left = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps_dec-&gt;u4_return_to_app = <span class="number">0</span>;</span><br><span class="line">        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,</span><br><span class="line">                              pu1_bitstrm_buf, buflen);</span><br><span class="line">        <span class="keyword">if</span>(ret != OK)</span><br><span class="line">        &#123;</span><br><span class="line">            UWORD32 error =  ih264d_map_error(ret);</span><br><span class="line">            ps_dec_op-&gt;u4_error_code = error | ret;</span><br><span class="line">            api_ret_value = IV_FAIL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((ret == IVD_RES_CHANGED)</span><br><span class="line">                            || (ret == IVD_MEM_ALLOC_FAILED)</span><br><span class="line">                            || (ret == ERROR_UNAVAIL_PICBUF_T)</span><br><span class="line">                            || (ret == ERROR_UNAVAIL_MVBUF_T)</span><br><span class="line">                            || (ret == ERROR_INV_SPS_PPS_T)</span><br><span class="line">                            || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec-&gt;u4_slice_start_code_found = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_num_bytes_consumed -= bytes_consumed;</span><br><span class="line">                api_ret_value = IV_FAIL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == ERROR_IN_LAST_SLICE_OF_PIC)</span><br><span class="line">            &#123;</span><br><span class="line">                api_ret_value = IV_FAIL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;u4_return_to_app)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*We have encountered a referenced frame,return to app*/</span></span><br><span class="line">            ps_dec_op-&gt;u4_num_bytes_consumed -= bytes_consumed;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code = IVD_DEC_FRM_SKIPPED;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">            ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line">            ps_dec_op-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>);</span><br><span class="line">            <span class="comment">/*signal the decode thread*/</span></span><br><span class="line">            ih264d_signal_decode_thread(ps_dec);</span><br><span class="line">            <span class="comment">/* close deblock thread if it is not closed yet*/</span></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;u4_num_cores == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ih264d_signal_bs_deblk_thread(ps_dec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        header_data_left = ((ps_dec-&gt;i4_decode_header == <span class="number">1</span>)</span><br><span class="line">                        &amp;&amp; (ps_dec-&gt;i4_header_decoded != <span class="number">3</span>)</span><br><span class="line">                        &amp;&amp; (ps_dec_op-&gt;u4_num_bytes_consumed</span><br><span class="line">                                        &lt; ps_dec_ip-&gt;u4_num_Bytes));</span><br><span class="line">        frame_data_left = (((ps_dec-&gt;i4_decode_header == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; ((ps_dec-&gt;u1_pic_decode_done == <span class="number">0</span>)</span><br><span class="line">                                        || (u4_next_is_aud == <span class="number">1</span>)))</span><br><span class="line">                        &amp;&amp; (ps_dec_op-&gt;u4_num_bytes_consumed</span><br><span class="line">                                        &lt; ps_dec_ip-&gt;u4_num_Bytes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(( header_data_left == <span class="number">1</span>)||(frame_data_left == <span class="number">1</span>));</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码还是超级多，就不详细分析了，，，编解码知识需要长时间积累再做第四节分析了。</p>
<h4 id="（四）、libavc库分析"><a href="#（四）、libavc库分析" class="headerlink" title="（四）、libavc库分析"></a>（四）、libavc库分析</h4><p><strong>Todo—</strong></p>
<blockquote>
<p>\external\libavc（libavc 库）</p>
</blockquote>
<ul>
<li>encoder</li>
<li>decoder</li>
<li>common</li>
</ul>
<h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="http://www.iosxxx.com/blog/2017-08-09-%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3H264%E7%BB%93%E6%9E%84.html">从零了解H264结构</a><br><a target="_blank" rel="noopener" href="http://read.pudn.com/downloads147/ebook/635957/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86H.264.pdf">新一代视频压缩编码标准H.264</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190216/">https://zhoujinjian.com/posts/20190216/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Video/">Video</a><a class="post-meta__tags" href="/tags/Multimedia/">Multimedia</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190308/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.28.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android O Treble 架构 - HIDL源代码分析➺➺➺(๑乛◡乛๑)➺➺➺</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190215/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.30.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Video System（8）：Android Multimedia Codecs - AMR编解码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20190208/" title="Android Video System（1）：Video System(视频系统)框架分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-08</div><div class="title">Android Video System（1）：Video System(视频系统)框架分析</div></div></a></div><div><a href="/posts/20190209/" title="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-09</div><div class="title">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</div></div></a></div><div><a href="/posts/20190210/" title="Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-10</div><div class="title">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</div></div></a></div><div><a href="/posts/20190211/" title="Android Video System（4）：Android Multimedia - OpenMax实现分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-11</div><div class="title">Android Video System（4）：Android Multimedia - OpenMax实现分析</div></div></a></div><div><a href="/posts/20190212/" title="Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-12</div><div class="title">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</div></div></a></div><div><a href="/posts/20190213/" title="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-13</div><div class="title">Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3H264%E7%BB%93%E6%9E%84%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">（一）、从零了解H264结构（概览）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-0%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">1.0、前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">1.1、原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-NAL-Header"><span class="toc-number">1.3.</span> <span class="toc-text">1.1.1. NAL Header</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-RBSP"><span class="toc-number">1.4.</span> <span class="toc-text">1.1.2. RBSP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81%E4%BB%8ENALU%E5%87%BA%E5%8F%91%E4%BA%86%E8%A7%A3H-264%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%93%E4%B8%9A%E8%AF%8D%E8%AF%AD"><span class="toc-number">1.5.</span> <span class="toc-text">1.2、从NALU出发了解H.264里面的专业词语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-Slice-%E7%89%87"><span class="toc-number">1.6.</span> <span class="toc-text">1.2.1. Slice(片)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-%E5%AE%8F%E5%9D%97-Macroblock"><span class="toc-number">1.7.</span> <span class="toc-text">1.2.2. 宏块(Macroblock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E5%9B%BE%E5%83%8F-%E5%9C%BA%E5%92%8C%E5%B8%A7"><span class="toc-number">1.8.</span> <span class="toc-text">1.2.3. 图像,场和帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-I-P-B%E5%B8%A7%E4%B8%8Epts-dts"><span class="toc-number">1.9.</span> <span class="toc-text">1.2.4. I,P,B帧与pts&#x2F;dts</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-GOP"><span class="toc-number">1.10.</span> <span class="toc-text">1.2.5. GOP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-6-IDR"><span class="toc-number">1.11.</span> <span class="toc-text">1.2.6 . IDR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B%E5%92%8C%E5%B8%A7%E9%97%B4%E9%A2%84%E6%B5%8B"><span class="toc-number">1.12.</span> <span class="toc-text">1.3. 帧内预测和帧间预测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E5%B8%A7%E5%86%85%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B9%9F%E5%8F%AB%E5%B8%A7%E5%86%85%E5%8E%8B%E7%BC%A9%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">1.3. 1. 帧内预测（也叫帧内压缩）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%B8%A7%E9%97%B4%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B9%9F%E5%8F%AB%E5%B8%A7%E9%97%B4%E5%8E%8B%E7%BC%A9%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">1.3. 2. 帧间预测（也叫帧间压缩）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-H264%E7%BC%96%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android  H264编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81SoftAVC-initEncoder"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、SoftAVC::initEncoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E3%80%81SoftAVC-onQueueFilled"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、SoftAVC::onQueueFilled()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E3%80%81ih264e-encode"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、ih264e_encode()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android-H264%E8%A7%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">（三）、Android  H264解码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81SoftAVC-initDecoder"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、SoftAVC::initDecoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81SoftAVC-onQueueFilled"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、SoftAVC::onQueueFilled()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3%E3%80%81WORD32-ih264d-video-decode"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、WORD32 ih264d_video_decode()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81libavc%E5%BA%93%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">（四）、libavc库分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">（五）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>