<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android N Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL | zhoujinjian</title><meta name="keywords" content="Android,Graphics,Display"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Android N Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL">
<meta property="og:url" content="https://zhoujinjian.com/posts/20180508/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg">
<meta property="article:published_time" content="2018-05-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.952Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Graphics">
<meta property="article:tag" content="Display">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20180508/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android N Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-05-08T01:25:00.000Z" title="发表于 2018-05-08 09:25:00">2018-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.952Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Display/">Display</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="http://www.kandroid.org/board/data/board/conference/file_in_body/1/3AndroidGraphicsAndAndroidEGL.pdf">【特别感谢 - Android Graphics and Android EGL】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/17427491">【特别感谢 - Android 4.4 (KitKat) Design Pattern-Graphics Subsystem】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/17293325">【特别感谢 - Android 4.4 (KitKat) in virtualization VSync signal】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/details/22647255">【特别感谢 - Android显示系统设计框架介绍】</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/samchen2009/p/3367496.html">【特别感谢 - 图解Android - Android GUI 系统 (2) - 窗口管理 (View, Canvas, Window Manager)】</a></p>
<p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p>
<p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】</p>
<hr>
<blockquote>
<p><strong>Android EGL、GLES_CM、GLES2：</strong></p>
</blockquote>
<p>\frameworks\native\opengl\libs\EGL</p>
<ul>
<li>egl.cpp</li>
<li>egl_display.cpp</li>
<li>eglApi.cpp</li>
<li>Loader.cpp</li>
</ul>
<p>\frameworks\native\opengl\libs\GLES_CM</p>
<ul>
<li>gl.cpp</li>
<li>gl_api.in</li>
<li>glext_api.in</li>
</ul>
<p>\frameworks\native\opengl\libs\GLES2</p>
<ul>
<li>gl2.cpp</li>
<li>gl2_api.in</li>
<li>gl2ext_api.in</li>
</ul>
<blockquote>
<p><strong>OpenGL Native &amp;&amp; JNI ：</strong></p>
</blockquote>
<p>\frameworks\base\core\jni\</p>
<ul>
<li>android_opengl_GLES10.cpp</li>
<li>android_opengl_GLES10Ext.cpp</li>
<li>android_opengl_GLES11.cpp</li>
<li>android_opengl_GLES11Ext.cpp</li>
<li>android_opengl_GLES20.cpp</li>
<li>android_opengl_GLES30.cpp</li>
<li>android_opengl_GLES31.cpp</li>
<li>android_opengl_GLES31Ext.cpp</li>
<li>android_opengl_GLES32.cpp</li>
<li>com_google_android_gles_jni_EGLImpl.cpp</li>
<li>com_google_android_gles_jni_GLImpl.cpp</li>
</ul>
<blockquote>
<p><strong>Opengl Java：</strong></p>
</blockquote>
<p>\frameworks\base\opengl\java\android\opengl</p>
<ul>
<li>GLES10.java</li>
<li>GLES10Ext.java</li>
<li>GLLogWrapper.java</li>
<li>GLSurfaceView.java</li>
<li>EGLDisplay.java</li>
<li>EGLConfig.java</li>
<li>EGLContext.java</li>
<li>EGLSurface.java</li>
</ul>
<p>\frameworks\base\opengl\java\javax\microedition\khronos\opengles</p>
<ul>
<li>GL10.java</li>
<li>GL11.java</li>
</ul>
<p>\frameworks\base\opengl\java\com\google\android\gles_jni</p>
<ul>
<li>GLImpl.java</li>
<li>EGLImpl.java</li>
<li>EGLConfigImpl.java</li>
<li>EGLContextImpl.java</li>
<li>EGLDisplayImpl.java</li>
</ul>
<hr>
<p>总体架构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-01-Android-Graphics-Architecture-EGL.png" alt="Alt text | center"></p>
<p><a target="_blank" rel="noopener" href="http://charlesvincent.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a><br>####（一）、 Android EGL 应用实例</p>
<h5 id="1-1、Android-Graphics-测试程序"><a href="#1-1、Android-Graphics-测试程序" class="headerlink" title="1.1、Android Graphics 测试程序"></a>1.1、Android Graphics 测试程序</h5><p>首先看一下Android测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">参考\frameworks\native\services\surfaceflinger\tests\Transaction_test.cpp</span><br><span class="line">拷贝同目录下.mk文件push到手机运行即可看到效果。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/native_window.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IMemory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/ISurfaceComposer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/Surface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/SurfaceComposerClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/ComposerService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/LayerState.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/String8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ui/DisplayInfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an RGBA_8888 formatted surface with a single color.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillSurfaceRGBA8</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceControl&gt;&amp; sc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint8_t</span> r, <span class="keyword">uint8_t</span> g, <span class="keyword">uint8_t</span> b)</span> </span>&#123;</span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    sp&lt;Surface&gt; s = sc-&gt;getSurface();</span><br><span class="line">    ASSERT_TRUE(s != <span class="literal">NULL</span>);</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;lock(&amp;outBuffer, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* img = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(outBuffer.bits);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; outBuffer.height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; outBuffer.width; x++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span>* pixel = img + (<span class="number">4</span> * (y*outBuffer.stride + x));</span><br><span class="line">            pixel[<span class="number">0</span>] = r;</span><br><span class="line">            pixel[<span class="number">1</span>] = g;</span><br><span class="line">            pixel[<span class="number">2</span>] = b;</span><br><span class="line">            pixel[<span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;unlockAndPost());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"></span><br><span class="line">        <span class="function">sp&lt;IBinder&gt; <span class="title">display</span><span class="params">(SurfaceComposerClient::getBuiltInDisplay(</span></span></span><br><span class="line"><span class="function"><span class="params">                ISurfaceComposer::eDisplayIdMain))</span></span>;</span><br><span class="line">        DisplayInfo info;</span><br><span class="line">        SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line">        <span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Background surface black</span></span><br><span class="line">        mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;BG Test Surface&quot;</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl-&gt;isValid());</span><br><span class="line">        fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface red</span></span><br><span class="line">        mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;FG Test Surface&quot;</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface blue</span></span><br><span class="line">        mFGSurfaceControlBlue = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;FG Test Surface&quot;</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface green</span></span><br><span class="line">        mFGSurfaceControlGreen = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;FG Test Surface&quot;</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronization surface</span></span><br><span class="line">        mSyncSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;Sync Test Surface&quot;</span>), <span class="number">1</span>, <span class="number">1</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SurfaceComposerClient::openGlobalTransaction()</span></span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">        mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//black</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line">        <span class="comment">//red</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line">        <span class="comment">//blue</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line">        <span class="comment">//green</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line"></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">                displayHeight<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        waitForPostedBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient-&gt;dispose();</span><br><span class="line">        mBGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mFGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mSyncSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mComposerClient = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waitForPostedBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Since the sync surface is in synchronous mode (i.e. double buffered)</span></span><br><span class="line">        <span class="comment">// posting three buffers to it should ensure that at least two</span></span><br><span class="line">        <span class="comment">// SurfaceFlinger::handlePageFlip calls have been made, which should</span></span><br><span class="line">        <span class="comment">// guaranteed that a buffer posted to another Surface has been retired.</span></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlBlue, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlGreen, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControl;<span class="comment">//red</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlBlue;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlGreen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This surface is used to ensure that the buffers posted to</span></span><br><span class="line">    <span class="comment">// mFGSurfaceControl have been picked up by SurfaceFlinger.</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mSyncSurfaceControl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(LayerTest, LayerWorks) &#123;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">display</span><span class="params">(SurfaceComposerClient::getBuiltInDisplay(</span></span></span><br><span class="line"><span class="function"><span class="params">            ISurfaceComposer::eDisplayIdMain))</span></span>;</span><br><span class="line">    DisplayInfo info;</span><br><span class="line">    SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line">    <span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    </span><br><span class="line">    mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line">    <span class="comment">//red</span></span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line">    <span class="comment">//blue</span></span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line">    <span class="comment">//green</span></span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line">    <span class="comment">//Sync</span></span><br><span class="line">    ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">            displayHeight<span class="number">-2</span>));</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果（保持运行，可以看到界面最顶层会绘制黑色背景和红绿蓝三个色块）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-02-Android-graphics-surface-test.gif" alt="Alt text | center"></p>
<p>可以看到比较关键的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SurfaceComposerClient</span></span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"><span class="comment">//获取display信息</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">display</span><span class="params">(SurfaceComposerClient::getBuiltInDisplay(</span></span></span><br><span class="line"><span class="function"><span class="params">        ISurfaceComposer::eDisplayIdMain))</span></span>;</span><br><span class="line">DisplayInfo info;</span><br><span class="line">SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line"><span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background surface black</span></span><br><span class="line"><span class="comment">//请求SurfaceFlinger创建Surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">&quot;BG Test Surface&quot;</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">        PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//填充Surface</span></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置Layer层级</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line"><span class="comment">//SurfaceControl-&gt;show()显示surface</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br></pre></td></tr></table></figure>
<p>这部分的分析请参考<a target="_blank" rel="noopener" href="http://charlesvincent.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a><br>我们这里主要为了引出Android底层如何利用EGL绘图。</p>
<h5 id="1-2、Android-BootAnimation-开机动画-EGL在Android中应用"><a href="#1-2、Android-BootAnimation-开机动画-EGL在Android中应用" class="headerlink" title="1.2、Android BootAnimation 开机动画(EGL在Android中应用)"></a>1.2、Android BootAnimation 开机动画(EGL在Android中应用)</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-03-Android-boot-egl.png" alt="Alt text | center"></p>
<p>关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\cmds\bootanimation\BootAnimation.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BootAnimation::readyToRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAssets.addDefaultAssets();</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">dtoken</span><span class="params">(SurfaceComposerClient::getBuiltInDisplay(</span></span></span><br><span class="line"><span class="function"><span class="params">            ISurfaceComposer::eDisplayIdMain))</span></span>;</span><br><span class="line">    DisplayInfo dinfo;</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// create the native surface</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(<span class="string">&quot;BootAnimation&quot;</span>),</span><br><span class="line">            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    control-&gt;setLayer(<span class="number">0x40000000</span>);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; s = control-&gt;getSurface();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize opengl and egl</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// (1)、获得 EGLDisplay 对象。</span></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">// (2)、初始化 EGLDisplay 对象</span></span><br><span class="line">    eglInitialize(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// (3)、选择 EGLConfig</span></span><br><span class="line">    eglChooseConfig(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    <span class="comment">// (4)、创建 Windows Surface</span></span><br><span class="line">    surface = eglCreateWindowSurface(display, config, s.get(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// (5)、创建 EGL context</span></span><br><span class="line">    context = eglCreateContext(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH, &amp;w);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h);</span><br><span class="line">    <span class="comment">// (6)、启用前面创建的 EGL context</span></span><br><span class="line">    <span class="keyword">if</span> (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootAnimation::playAnimation</span><span class="params">(<span class="keyword">const</span> Animation&amp; animation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">                <span class="comment">// (7)、OpenGL ES API 绘制图形：gl_*()</span></span><br><span class="line">                glDrawTexiOES(xc, mHeight - (yc + frame.trimHeight),</span><br><span class="line">                              <span class="number">0</span>, frame.trimWidth, frame.trimHeight);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// (8)、SwapBuffers显示</span></span><br><span class="line">                eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用EGL一般会经历以上几个步骤。</p>
<h5 id="1-2、Understanding-Android-Graphics-Internals"><a href="#1-2、Understanding-Android-Graphics-Internals" class="headerlink" title="1.2、Understanding Android Graphics Internals"></a>1.2、Understanding Android Graphics Internals</h5><p>要深入了解Android Graphics机制，需要了解熟悉以下知识（包括但不限于）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-04-understand-android-graphics-internals.png" alt="Alt text | center"></p>
<p>####（二）、OpenGL ES 2.0 知识串讲<br>在了解EGL之前，先来看看前人总结的知识<a target="_blank" rel="noopener" href="http://geekfaner.com/shineengine/index.html">OPENGL ES 2.0 知识串讲</a>：</p>
<h5 id="2-1、写在前面的话"><a href="#2-1、写在前面的话" class="headerlink" title="2.1、写在前面的话"></a>2.1、写在前面的话</h5><h5 id="2-1-1、电脑是做什么用的"><a href="#2-1-1、电脑是做什么用的" class="headerlink" title="2.1.1、电脑是做什么用的?"></a>2.1.1、电脑是做什么用的?</h5><p>电脑又被称为计算机,那么最重要的工作就是计算。看过三体的同学都知道, 电脑中有无数纳米级别的计算单元,通过 0 和 1 的转换,完成加减乘除的操作。</p>
<h5 id="2-1-2、是什么使得电脑工作"><a href="#2-1-2、是什么使得电脑工作" class="headerlink" title="2.1.2、是什么使得电脑工作?"></a>2.1.2、是什么使得电脑工作?</h5><p>驱动,驱使着硬件完成工作。</p>
<h5 id="2-1-3、谁来写驱动"><a href="#2-1-3、谁来写驱动" class="headerlink" title="2.1.3、谁来写驱动?"></a>2.1.3、谁来写驱动?</h5><p>制造电脑的公司自己来写驱动,因为他们对自己的底层硬件架构最熟悉。</p>
<h5 id="2-1-4、谁会使用驱动"><a href="#2-1-4、谁会使用驱动" class="headerlink" title="2.1.4、谁会使用驱动?"></a>2.1.4、谁会使用驱动?</h5><p>所有的软件工程师都会直接或者间接的使用到驱动。</p>
<p>那么问题来了,如果说不同的电脑公司,制造出来不同的硬件,使用不同的 驱动,提供出来不同的接口供软件工程师进行使用,那么软件工程师就要崩溃了。</p>
<p>所以,一定是需要一个标准,来统一一下。</p>
<h5 id="2-1-5、那么在哪里进行统一"><a href="#2-1-5、那么在哪里进行统一" class="headerlink" title="2.1.5、那么在哪里进行统一?"></a>2.1.5、那么在哪里进行统一?</h5><p>硬件没有办法统一,每个电脑公司为了优化自己电脑性能和功耗,制造出来 不同的硬件架构,这是需要无数的心血完成的,如果统一了,那么就不需要那么 多电脑公司了。</p>
<p>所以只能统一驱动的接口。</p>
<p>电脑组件大致分为:CPU、GPU、内存、总线等。而 OpenGL 就是 GPU 驱动 的一套标准接口(OpenGL ES 为嵌入式设备 GPU 驱动的标准接口,比如手机, OpenGL ES 全称:OpenGL for Embedded Systems)。</p>
<p>所以综上所述,我使用了 5 个问题,引出了 OpenGL 的用处:就是将复杂的、 各种各样的 GPU 硬件包装起来,各个电脑公司编写自家的驱动,然后提供出来 一套统一的接口,供上层软件工程师调用。这样,世界就和平了。</p>
<h5 id="2-1-6、谁这么牛-定义了-OpenGL-这套标准"><a href="#2-1-6、谁这么牛-定义了-OpenGL-这套标准" class="headerlink" title="2.1.6、谁这么牛,定义了 OpenGL 这套标准?"></a>2.1.6、谁这么牛,定义了 OpenGL 这套标准?</h5><p>Khronos。每当我打这几个字母的时候,都会抱有一种敬畏的心理,因为它 不是一家公司,它是一个组织,它是由众多大公司联合组建而来,比如 Apple、 Intel、AMD、Google、ARM、Qualcomm、Nvidia 等等等等。各个大公司投入了大 量的人力、资金等创建了这个组织。对电脑 GPU 定义了统一的接口 OpenGL,对 手机 GPU 定义了统一的接口 OpenGL ES(我也非常有幸,在 Intel 工作期间,跟 Intel 驻 Khronos 的 3D 负责人共事了一段时间,每周一次的跨洋电话,都会让我受益匪浅)</p>
<p>这个组织除了定义了 OpenGL 接口之外,还定义了很多其他接口。目前针对 GPU 又提出了另外一套更底层的接口 Vulkan,这是一套比 OpenGL 更底层的接口, 使用其可以更容易优化,不过目前硬件厂商的驱动还有待开发,可能普及 Vulkan 还需要很多年。就好比 OpenGL ES 已经发展到了 3.1,而市面上的手机很多还是 只能支持 OpenGL ES 2.0 一样。所以新的科技从提出,到实现,到量产,到使用, 到普及,是一段很长的路。</p>
<p>所以,我们现在学习 OpenGL ES 2.0 是适时的,且是非常必要的(不懂 2.0, 想直接学习更难的 3.0、3.1、Vulkan,很难)。</p>
<p>事先预告一下,OpenGL ES 2.0 会分十三个课程,结束之后,我会立即奉上 OpenGL ES 3.0 在 OpenGL ES 2.0 基础上的改变。</p>
<h5 id="2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系"><a href="#2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系" class="headerlink" title="2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?"></a>2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?</h5><p>电脑/手机屏幕上显示的东西,要么是 2D 的,要么是 3D 的,那么如果是 3D 的,不管是 App 也好,游戏也好,简单的图片界面也好,底层都是通过 GPU、 通过 OpenGL(ES)绘制出来的。</p>
<p>开发 App 的时候,是通过创建控件的方式,而控件已经对底层进行了一层封装,所以 App 开发者很少会接触到 OpenGL(ES)。</p>
<p>游戏的开发是通过游戏引擎,而游戏引擎的最底层,是直接调用了 OpenGL(ES),直接对 GPU 进行控制。</p>
<p>所以说游戏引擎工程师必须懂 OpenGL(ES),而游戏开发者,想要更好的对游戏进行更好的理解和优化,也建议学一些 OpenGL(ES)。</p>
<h5 id="2-1-8、DirectX-是什么"><a href="#2-1-8、DirectX-是什么" class="headerlink" title="2.1.8、DirectX 是什么?"></a>2.1.8、DirectX 是什么?</h5><p>最后一个问题。我们发现 Khronos 组织的成员中,我没有提到大名鼎鼎的微 软,因为微软不在组织中,而它提出了自己的 GPU 驱动标准,DirectX。</p>
<p>所以目前手机,不管是 iOS 还是 Android,都是支持 OpenGL ES。电脑,Windows 系统支持 DirectX 和 OpenGL,Linux/Mac(Unix)系统支持 OpenGL。</p>
<h4 id="2-2、OpenGL-ES-的两个小伙伴"><a href="#2-2、OpenGL-ES-的两个小伙伴" class="headerlink" title="2.2、OpenGL ES 的两个小伙伴"></a>2.2、OpenGL ES 的两个小伙伴</h4><p>虽然,我们教程的标题是 OpenGL ES,但是我们的内容将不仅限于 OpenGL ES。 OpenGL ES 是负责 GPU 工作的,目的是通过 GPU 计算,得到一张图片,这张图 片在内存中其实就是一块 buffer,存储有每个点的颜色信息等。而这张图片最终是要显示到屏幕上,所以还需要具体的窗口系统来操作,OpenGL ES 并没有相关的函数。所以,OpenGL ES 有一个好搭档 EGL。</p>
<p>EGL,全称:embedded Graphic Interface,是 OpenGL ES 和底层 Native 平台 视窗系统之间的接口。所以大概流程是这样的:首先,通过 EGL 获取到手机屏幕 的 handle,获取到手机支持的配置(RGBA8888/RGB565 之类,表示每个像素中包 含的颜色等信息的存储空间是多少位),然后根据这个配置创建一块包含默认 buffer 的 surface(buffer 的大小是根据屏幕分辨率乘以每个像素信息所占大小计 算而得)和用于存放 OpenGL ES 状态集的 context,并将它们 enable 起来。然后, 通过 OpenGL ES 操作 GPU 进行计算,将计算的结果保存在 surface 的 buffer 中。 最后,使用 EGL,将绘制的图片显示到手机屏幕上。</p>
<p>而在 OpenGL ES 操作 GPU 计算的时候,还需要介绍 OpenGL ES 的另外一个好搭档 GLSL。</p>
<p>GLSL,全称:OpenGL Shading Language,是 OpenGL ES 中使用到的着色器的 语言,用这个语言可以编写小程序运行在 GPU 上。</p>
<p>在这里需要先提到 CPU 和 GPU 的区别,它们的功能都是用于计算,也都是由很多核组成,区别在于 CPU 的核比较少,但是单个核的计算能力比较强,而 GPU 的核很多,但是每个核的计算能力都不算特别强。目前 GPU 的主要工作是用于生成图片(现在也有通过 GPU 进行高性能运算_并行运算,但是在这里不属于讨论的范围),原因就是图片是由很多像素组成,每个像素都包含有颜色、深度等信息,而为了得到这些信息数据,针对每个像素点的计算,是可以通过统一的算法来完成。GPU 就擅长处理针对这种大规模数据,使用同一个算法进行计算。而这个算法,就是使用 GLSL 写成 Shader,供 GPU 运算使用。</p>
<p>在图形学的视角中,所有的图片都是由三角形构成的。所以通过 OpenGL ES 绘制图片的时候,我们需要通过 OpenGL ES API 创建用于在 GPU 上运行的 shader, 然后将通过 CPU 获取到的图片顶点信息,传入 GPU 中的 Shader 中。在 Vertex Shader 中通过矩阵变换,将顶点坐标从模型坐标系转换到世界坐标系,再到观察坐标系,到裁剪坐标系,最后投影到屏幕坐标系中,计算出在屏幕上各个顶点的坐标。然后,通过光栅化,以插值的方法得到所有像素点的信息,并在 Fragment shader 中计算出所有像素点的颜色。最后,通过 OpenGL ES 的 API 设定的状态,将得到的像素信息进行 depth/stencil test、blend,得到最终的图片。</p>
<h4 id="2-3、屏幕图片的本质和产生过程"><a href="#2-3、屏幕图片的本质和产生过程" class="headerlink" title="2.3、屏幕图片的本质和产生过程"></a>2.3、屏幕图片的本质和产生过程</h4><p>当我们买一个手机的时候,我们会非常关注这个手机的分辨率。分辨率代表着像素的多少,比如我们熟知的 iphone6 的分辨率为 1334×750,而 iphone6 plus 的分辨率是1920×1080。</p>
<p>手机屏幕上的图片,是由一个一个的像素组成,那么可以计算出来,一个屏幕上的图片,是由上百万个像素点组成。而每个像素点都有自己的颜色,每种颜色都是由 RGB 三原色组成。三原色按照不同的比例混合,组成了手机所能显示出来的颜色。</p>
<p>每个像素的颜色信息都保存在 buffer 中,这块 buffer 可以分给 RGB 每个通 道各 8bit 进行信息保存,也可以分给 RGB 每个通道不同的空间进行信息保存, 比如由于人眼对绿色最敏感,那么可以分配给 G 通道 6 位,R 和 B 通道各 5 位。这些都是常见的手机配置。假如使用 RGB888 的手机配置,也就是每种颜色的取值从 0 到 255,0 最小,255 最大。那么红绿蓝都为 0 的时候,这个像素点的颜色就是黑色,红绿蓝都为 255 的时候,这个像素点的颜色就是白色。当红为 255, 绿蓝都为 0 的时候,这个像素点的颜色就是红色。当红绿为 255,蓝为 0 的时候, 这个像素点的颜色就是黄色。当然不是只取 0 或者 255,可以取 0-255 中间的值, 100,200,任意在 0 和 255 中间的值都没有问题。那么我们可以算一下,按照红绿蓝不同比例进行搭配,每个像素点,可以显示的颜色有 255<em>255</em>255=16581375 种,这个数字是非常恐怖,所以我们的手机可以显示出来各种各样的颜色。 这里在延伸的科普一下,我们看到手机可以显示那么多种颜色了,但是是不是说我们的手机在颜色上就已经发展到极致了呢?其实是远远没有的,在这个手机配置下,三原色中每一种的取值可以从 0 到 255,而在现实生活中,它们的取 值可以从 0 到 1 亿,而我们人类的眼睛所能看到的范围是,从 0 到 10 万。所以手机硬件还存在很大的提升空间。而在手机硬件提升之前,我们也可以通过 HDR 等技术尽量的在手机中多显示一些颜色。所以,讲到这里,我们知道了,手机屏幕上显示的图片,是由这上百万个像素点,以及这上百万个像素点对应的颜色组成的。</p>
<p>用程序员的角度来看,就是手机屏幕对应着一块 buffer,这块 buffer 对应上百万个像素点,每个像素点需要一定的空间来存储其颜色。如果使用更加形象的例子来比喻,手机屏幕对应的 buffer 就好像一块巨大的棋盘,棋盘上有上百万个格子,每个格子都有自己的颜色,那么从远处整体的看这个棋盘,就是我们看手机的时候显示的样子。这就是手机屏幕上图片的本质。</p>
<p>通过我们对 EGL、GLSL、OpenGL ES 的理解,借助一张图片,从专业的角度来解释一下手机屏幕上的图片是如何生成的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-05-OpenGL-Picture-Generate.png" alt="Alt text | center"></p>
<p>首先,通过 EGL 获取手机屏幕,进而获取到手机屏幕对应的这个棋盘,同时, 在手机的 GPU 中根据手机的配置信息,生成另外一个的棋盘和一个本子,本子是用于记录这个棋盘初始颜色等信息。</p>
<p>然后,OpenGL ES 就好像程序员的画笔,程序员需要知道自己想画什么东西,比如想画一个苹果,那么就需要通过为数不多的基本几何图元(如点、直线、三 角形)来创建所需要的模型。比如用几个三角形和点和线来近似的组成这个苹果 (图形学的根本就是点、线和三角形,所有的图形,都可以由这些基本图形组成, 比如正方形或者长方形,就可以由两个三角形组成,圆形可以由无数个三角形组成,只是三角形的数量越多,圆形看上去越圆润)。</p>
<p>根据这些几何图元,建立数学描述,比如每个三角形或者线的顶点坐标位置、每个顶点的颜色。得到这些信息之后,可以先通过 OpenGL ES 将 EGL 生成的棋盘 (buffer)进行颜色初始化,一般会被初始化为黑色。然后将刚才我们获取到的顶点坐标位置,通过矩阵变化的方式,进行模型变换、观察变换、投影变换,最后映射到屏幕上,得到屏幕上的坐标。这个步骤可以在 CPU 中完成,也就是在 OpenGL ES 把坐标信息传给 Shader 之前,在 CPU 中通过矩阵相乘等方式进行更新,或者是直接把坐标信息通过 OpenGL ES 传给 Shader,同时也把矩阵信息传给 Shader,通过 Shader 在 GPU 端进行坐标更新,更新的算法通过 GLSL 写在 Shader 中。这个进行坐标更新的 Shader 被称为 vertex shader,简称 VS,是 OpenGL ES2.0, 也是 GLSL130 版本对应的最重要两个 shader 之一,作用是完成顶点操作阶段中的所有操作。经过矩阵变换后的像素坐标信息,为屏幕坐标系中的坐标信息。在 VS 中,最重要的输入为顶点坐标、矩阵(还可以传入顶点的颜色、法线、纹理 坐标等信息),而最重要的运算结果,就是这个将要显示在屏幕上的坐标信息。 VS 会针对传入的所有顶点进行运算,比如在 OpenGL ES 中只想绘制一个三角形 和一条线,这两个图元不共享顶点,那么在 VS 中,也就传入了 5 个顶点信息, 根据矩阵变换,这 5 个顶点的坐标转换成了屏幕上的顶点坐标信息,从图上显示, 也就是从左上角的图一,更新成了中上图的图二。</p>
<p>再然后,当图二生成之后,我们知道了图元在屏幕上的顶点位置,而顶点的颜色在 VS 中没有发生变化,所以图元的顶点颜色我们也是知道的。下面就是根据 OpenGL ES 中设置的状态,表明哪些点连成线,哪些点组成三角形,进行图元装配,也就是我们在右上角的图三中看到的样子。这个样子在 GPU 中不会显示, 那几条线也是虚拟的线,是不会显示在棋盘 buffer 中的,而 GPU 做的是光珊化,这一步是发生在从 VS 出来,进入另外一个Shader (Pixel shader,也称 fragment shader)之前,在 GPU 中进行的。作用是把线上,或者三角形内部所有的像素点找到,并根据插值或者其他方式计算出其颜色等信息(如果不通过插值,可以使用其他的方法,这些在 OpenGL ES 和 GLSL 中都可以进行设置)。也就生成了下面一行的图四和图五。</p>
<p>我们大概可以看到在图 4 和图 5 种出现了大量的顶点,大概数一下估计有 40 个点左右,这些点全部都会进入 PS 进行操作,在 PS 中可以对这些点的颜色进行操作,比如可以只显示这些点的红色通道,其他的绿蓝通道的值设置为 0, 比如之前某个点的 RGB 为 200,100,100。在 PS 中可以将其通过计算,更新为 200,0,0。这样做的结果就是所显示的图片均为红色,只是深浅不同。这也就好像戴上了一层红色的滤镜,其他颜色均为滤掉了。所以用 PS 来做滤镜是非常方便的。再比如,假如一盏红色的灯照到了苹果上,那么显示出来的颜色就是在苹果原本的颜色基础上,红色值进行一定的增值。</p>
<p>所以,总结一下,经过 VS 和 PS 之后,程序员想要画的东西,就已经被画出来了。想要绘制的东西,也就是左下角图五的样子。然后再根据 OpenGL ES 的设置,对新绘制出来的东西进行 Depth/Stencil Test,剔除掉被遮挡的部分,将剩余部分与原图片进行 Blend,生成新的图片。 最后,通过 EGL,把这个生成的棋盘 buffer 和手机屏幕上对应的棋盘 buffer 进行调换,让手机屏幕显示这个新生成的棋盘,旧的那个棋盘再去绘制新的图片信息。周而复始,不停的把棋盘进行切换,也就像过去看连环画一样,动画就是由一幅幅的图片组成,当每秒切换的图片数量超过 30 张的时候,我们的手机也就看到了动态的效果。这就是屏幕上图片的产生过程。</p>
<p>在这里再进行一下延伸,这个例子中,VS 计算了 5 个顶点的数据,PS 计算 了大概 40 个顶点的数据,而我们刚才说过,手机中存在上百万个像素点,这上百万个像素点都可以是顶点,那么这个计算量是非常大的。而这也是为什么要将 shader 运算放在 GPU 中的原因,因为 GPU 擅长进行这种运算。</p>
<p>我们知道 CPU 现在一般都是双核或者 4 核,多的也就是 8 核或者 16 核,但是 GPU 动辄就是 72 核,多的还有上千核,这么多核的目的就是进行并行运算, 虽然单个的 GPU 核不如 CPU 核,但是单个的 GPU 核足够进行加减乘除运算,所以大量的 GPU 核用在图形学像素点运算上,是非常有效的。而 CPU 虽然单个很强大,而且也可以通过多级流水来提高吞吐率,但是终究还是不如 GPU 的多核来得快。但是在通过 GPU 进行多核运算的时候,需要注意的是:如果 shader 中存放判断语句,就会对 GPU 造成比较大的负荷,不同 GPU 的实现方式不同,多数 GPU 会对判断语句的两种情况都进行运算,然后根据判断结果取其中一个。</p>
<p>我们通过这个例子再次清楚了 OpenGL ES 绘制的整个流程,而这个例子也是最简单的一个例子,其中有很多 OpenGL ES 的其他操作没有被涉及到。比如,我们绘制物体的颜色大多是从纹理中采样出来,那么设计到通过 OpenGL ES 对纹理 进行操作。而 OpenGL ES 的这些功能,我们会在下面一点一点进行学习。</p>
<h4 id="2-4-2、OpenGL-流水线（pipeline）"><a href="#2-4-2、OpenGL-流水线（pipeline）" class="headerlink" title="2.4.2、OpenGL 流水线（pipeline）"></a>2.4.2、OpenGL 流水线（pipeline）</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-06-OpenGL-ES-pipeline.png" alt="Alt text | center"></p>
<p>EGL 是用于与手机设备打交道,比如获取绘制 buffer,将绘制 buffer 展现到手机屏幕中。那么抛开 EGL 不说,OpenGL ES 与 GLSL 的主要功能,就是往这块 buffer 上绘制图片。</p>
<p>所以,我们可以把OpenGL ES和GLSL的流程单独拿出来进行归纳总结,而这幅流程图就是著名的 OpenGL ES2.0 pipeline。</p>
<p>首先,最左边的 API 指的就是 OpenGL ES 的 API,OpenGL ES 其实是一个图形学库,由 109 个 API 组成,只要明白了这 109 个 API 的意义和用途,就掌握了OpenGL ES 2.0。</p>
<p>然后,我们通过 API 先设定了顶点的信息,顶点的坐标、索引、颜色等信息,将这些信息传入 VS。</p>
<p>在 VS 中进行运算,得到最终的顶点坐标。再把算出来的顶点坐标进行图元装配,构建成虚拟的线和三角形。再进行光珊化(在光珊化的时候,把顶点连接起来形成直线,或者填充多边形的时候,需要考虑直线和多边形的直线宽度、点的大小、渐变算法以及是否使用支持抗锯齿处理的覆盖算法。最终的每个像素点,都具有各自的颜色和深度值)。</p>
<p>将光珊化的结果传入 PS,进行最终的颜色计算。</p>
<p>然后,这所谓最终的结果在被实际存储到绘制 buffer 之前,还需要进行一系列的操作。这些操作可能会修改甚至丢弃这些像素点。</p>
<p>这些操作主要为 alpha test、Depth/Stencil test、Blend、Dither。</p>
<p>Alpha Test 采用一种很霸道极端的机制,只要一个像素的 alpha 不满足条件, 那么它就会被 fragment shader 舍弃,被舍弃的 fragments 不会对后面的各种 Tests 产生影响;否则,就会按正常方式继续下面的检验。Alpha Test 产生的效果也很极端,要么完全透明,即看不到,要么完全不透明。</p>
<p>Depth/stencil test 比较容易理解。由于我们绘制的是 3D 图形,那么坐标为 XYZ,而 Z 一般就是深度值,OpenGL ES 可以对深度测试进行设定,比如设定深度值大的被抛弃,那么假如绘制 buffer 上某个像素点的深度值为 0,而 PS 输出的 像素点的深度值为 1,那么 PS 输出的像素点就被抛弃了。而 stencil 测试更加简单,其又被称为蒙版测试,比如可以通过 OpenGL ES 设定不同 stencil 值的配抛弃, 那么假如绘制 buffer 上某个像素点的 stencil 值为 0,而 PS 输出的像素点的 stencil 值为 1,那么 PS 输出的像素点就被抛弃了。</p>
<p>既然说到了 Depth/stencil,那么就在这里说一下绘制 buffer 到底有多大,存 储了多少信息。按照我们刚才的说法,手机可以支持一百万个像素,那么生成的 绘制 buffer 就需要存储这一百万个像素所包含的信息,而每个像素包含的信息, 与手机配置有关,假如手机支持 Depth/stencil。那么通过 EGL 获取的绘制 buffer 中,每个像素点就包含了 RGBA 的颜色值,depth 值和 stencil 值,其中 RGBA 每个分量一般占据 8 位,也就是 8bit,也就是 1byte,而 depth 大多数占 24 位,stencil 占 8 位。所以每个像素占 64bit,也就是 8byte。那么 iphone6 plus 的绘制 buffer 的尺寸为 1920×1080×8=16588800byte=16200KB=15.8MB。</p>
<p>下面还有 blend,通过 OpenGL ES 可以设置 blend 混合模式。由于绘制 buffer 中原本每个像素点已经有颜色了,那么 PS 输出的颜色与绘制 buffer 中的颜色如何混合,生成新的颜色存储在绘制 buffer 中,就是通过 blend 来进行设定。</p>
<p>最后的 dither,dither 是一种图像处理技术,是故意造成的噪音,用以随机化量化误差,阻止大幅度拉升图像时,导致的像 banding(色带)这样的问题。也 是通过OpenGL ES 可以开启或者关闭。</p>
<p>经过了这一系列的运算和测试,也就得到了最终的像素点信息,将其存储到绘制 buffer 上之后,OpenGL ES 的 pipeline 也就结束了。</p>
<p>整个pipeline中，纵向按照流水线作业，横线按照独立作业，多级并行、提高渲染性能</p>
<p>####（三）、 Android EGL Overview： OpenGL ES 和 EGL 介绍</p>
<h4 id="3-1-0、OpenGL-ES"><a href="#3-1-0、OpenGL-ES" class="headerlink" title="3.1.0、OpenGL ES"></a>3.1.0、OpenGL ES</h4><p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，各显卡制造商和系统制造商来实现这组 API。</p>
<h4 id="3-1-1、OpenGL-基本概念"><a href="#3-1-1、OpenGL-基本概念" class="headerlink" title="3.1.1、OpenGL 基本概念"></a>3.1.1、OpenGL 基本概念</h4><p>OpenGL 的结构可以从逻辑上划分为下面 3 个部分：</p>
<p>☯ 图元（Primitives）<br>☯ 缓冲区（Buffers）<br>☯ 光栅化（Rasterize）<br> <strong>图元（Primitives）</strong><br>在 OpenGL 的世界里，我们只能画点、线、三角形这三种基本图形，而其它复杂的图形都可以通过三角形来组成。所以这里的图元指的就是这三种基础图形：</p>
<p>☯ 点：点存在于三维空间，坐标用（x,y,z）表示。<br>☯ 线：由两个三维空间中的点组成。<br>☯ 三角形：由三个三维空间的点组成。<br><strong>缓冲区（Buffers）</strong><br>OpenGL 中主要有 3 种 Buffer：</p>
<p><strong>帧缓冲区（Frame Buffers）</strong> 帧缓冲区：<strong>这个是存储OpenGL 最终渲染输出结果的地方</strong>，它是一个包含多个图像的集合，例如颜色图像、深度图像、模板图像等。</p>
<p><strong>渲染缓冲区（Render Buffers）</strong> 渲染缓冲区：渲染缓冲区就是一个图像，它是 Frame Buffer 的一个子集。</p>
<p><strong>缓冲区对象（Buffer Objects）</strong> 缓冲区对象就是程序员输入到 OpenGL 的数据，分为结构类和索引类的。前者被称为“数组缓冲区对象”或“顶点缓冲区对象”（“Array Buffer Object”或“Vertex Buff er Object”），即用来描述模型的数组，如顶点数组、纹理数组等； 后者被称为“索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</p>
<p><strong>光栅化（Rasterize）</strong><br>在介绍光栅化之前，首先来补充 OpenGL 中的两个非常重要的概念：</p>
<p>Vertex Vertex 就是图形中顶点，一系列的顶点就围成了一个图形。<br>Fragment Fragment 是三维空间的点、线、三角形这些基本图元映射到二维平面上的映射区域，通常一个 Fragment 对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个 Fragment，以减少 GPU 的工作。<br>而光栅化是把点、线、三角形映射到屏幕上的像素点的过程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-07-OpenGL-guangshanhua.png" alt="Alt text | center"></p>
<p>着色器程序（Shader）<br>Shader 用来描述如何绘制（渲染），GLSL 是 OpenGL 的编程语言，全称 OpenGL Shader Language，它的语法类似于 C 语言。OpenGL 渲染需要两种 Shader：Vertex Shader 和 Fragment Shader。</p>
<p>Vertex Shader Vertex Shader 对于3D模型网格的每个顶点执行一次，主要是确定该顶点的最终位置。<br>Fragment Shader Fragment Shader对光栅化之后2D图像中的每个像素处理一次。3D物体的表面最终显示成什么样将由它决定，例如为模型的可见表面添加纹理，处理光照、阴影的影响等等。</p>
<h4 id="3-2、EGL-Overview"><a href="#3-2、EGL-Overview" class="headerlink" title="3.2、EGL Overview"></a>3.2、EGL Overview</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-08-OpenGL-EGL-Overview.png.png" alt="Alt text | center"></p>
<p>What is the Direction?<br>SW : Standard API (Java, NDK Stable API)<br>HW : OpenGLES, OpenSLES, OpenMAX<br>EGL™ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system</p>
<h4 id="3-2-1、什么是-EGL？"><a href="#3-2-1、什么是-EGL？" class="headerlink" title="3.2.1、什么是 EGL？"></a>3.2.1、什么是 EGL？</h4><p>EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-09-eglCreateWindowSurface.png" alt="Alt text | center"></p>
<p>EGL提供如下机制：<br>与设备的原生窗口系统通信<br>查询绘图表面的可用类型和配置<br>创建绘图表面<br>在OpenGL ES 和其他图形渲染API之间同步渲染<br>管理纹理贴图等渲染资源<br>为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的桥梁。</p>
<h4 id="3-2-2、使用-EGL-绘图的基本步骤"><a href="#3-2-2、使用-EGL-绘图的基本步骤" class="headerlink" title="3.2.2、使用 EGL 绘图的基本步骤"></a>3.2.2、使用 EGL 绘图的基本步骤</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-10-egl-draw-surface.png.png" alt="Alt text | center"></p>
<p>☯  Display(EGLDisplay) 是对实际显示设备的抽象。<br>☯  Surface（EGLSurface）是对用来存储图像的内存区域<br>☯  FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。<br>使用EGL的绘图的一般步骤：</p>
<p>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p>
<h4 id="3-3、EGLSurface-and-ANativeWindow-关系"><a href="#3-3、EGLSurface-and-ANativeWindow-关系" class="headerlink" title="3.3、EGLSurface and ANativeWindow 关系"></a>3.3、EGLSurface and ANativeWindow 关系</h4><p>OpenGL ES 定义了一个渲染图形的 API，但没有定义窗口系统。为了让 GLES 能够适合各种平台，GLES 将与知道如何通过操作系统创建和访问窗口的库结合使用。用于 Android 的库称为 EGL。如果要绘制纹理多边形，应使用 GLES 调用；如果要在屏幕上进行渲染，应使用 EGL 调用。</p>
<p>在使用 GLES 进行任何操作之前，需要创建一个 GL 上下文。在 EGL 中，这意味着要创建一个 EGLContext 和一个 EGLSurface。GLES 操作适用于当前上下文，该上下文通过线程局部存储访问，而不是作为参数进行传递。这意味着您必须注意渲染代码在哪个线程上执行，以及该线程上的当前上下文。</p>
<h4 id="3-3-1、EGLSurface"><a href="#3-3-1、EGLSurface" class="headerlink" title="3.3.1、EGLSurface"></a>3.3.1、EGLSurface</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-11-eglsurface-anativewindwo.png" alt="Alt text | center"></p>
<p>EGLSurface 可以是由 EGL 分配的离屏缓冲区（称为“pbuffer”），或由操作系统分配的窗口。EGL 窗口 Surface 通过 eglCreateWindowSurface() 调用被创建。该调用将“窗口对象”作为参数，在 Android 上，该对象可以是 SurfaceView、SurfaceTexture、SurfaceHolder 或 Surface，所有这些对象下面都有一个 BufferQueue。当您进行此调用时，EGL 将创建一个新的 EGLSurface 对象，并将其连接到窗口对象的 BufferQueue 的生产方接口。此后，渲染到该 EGLSurface 会导致一个缓冲区离开队列、进行渲染，然后排队等待消耗方使用。（术语“窗口”表示预期用途，但请注意，输出内容不一定会显示在显示屏上。）</p>
<p>EGL 不提供锁定/解锁调用，而是由您发出绘制命令，然后调用 eglSwapBuffers() 来提交当前帧。方法名称来自传统的前后缓冲区交换，但实际实现可能会有很大的不同。</p>
<p>一个 Surface 一次只能与一个 EGLSurface 关联（您只能将一个生产方连接到一个 BufferQueue），但是如果您销毁该 EGLSurface，它将与该 BufferQueue 断开连接，并允许其他内容连接到该 BufferQueue。</p>
<p>通过更改“当前”EGLSurface，指定线程可在多个 EGLSurface 之间进行切换。一个 EGLSurface 一次只能在一个线程上处于当前状态。</p>
<p>关于 EGLSurface 最常见的一个错误理解就是假设它只是 Surface 的另一方面（如 SurfaceHolder）。它是一个相关但独立的概念。您可以在没有 Surface 作为支持的 EGLSurface 上绘制，也可以在没有 EGL 的情况下使用 Surface。EGLSurface 仅为 GLES 提供一个绘制的地方。</p>
<h4 id="3-3-2、ANativeWindow"><a href="#3-3-2、ANativeWindow" class="headerlink" title="3.3.2、ANativeWindow"></a>3.3.2、ANativeWindow</h4><p>公开的 Surface 类以 Java 编程语言实现。C/C++ 中的同等项是 ANATIONWindow 类，由 Android NDK 半公开。您可以使用 ANativeWindow_fromSurface() 调用从 Surface 获取 ANativeWindow。就像它的 Java 语言同等项一样，您可以对 ANativeWindow 进行锁定、在软件中进行渲染，以及解锁并发布。</p>
<p>要从原生代码创建 EGL 窗口 Surface，可将 EGLNativeWindowType 的实例传递到 eglCreateWindowSurface()。EGLNativeWindowType 是 ANativeWindow 的同义词，您可以自由地在它们之间转换。</p>
<p>基本的“原生窗口”类型只是封装 BufferQueue 的生产方，这一点并不足为奇。</p>
<h4 id="3-3-3、egl-surface-t-关系图"><a href="#3-3-3、egl-surface-t-关系图" class="headerlink" title="3.3.3、egl_surface_t 关系图"></a>3.3.3、egl_surface_t 关系图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-12-egl_surface_t.png" alt="Alt text | center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-13-framebufferwindow-surface.png" alt="Alt text | center"></p>
<h4 id="3-3-4、EGLContext-and-Thread-Local-Storage"><a href="#3-3-4、EGLContext-and-Thread-Local-Storage" class="headerlink" title="3.3.4、EGLContext and Thread Local Storage"></a>3.3.4、EGLContext and Thread Local Storage</h4><h4 id="3-3-4-1、EGLContext"><a href="#3-3-4-1、EGLContext" class="headerlink" title="3.3.4.1、EGLContext"></a>3.3.4.1、EGLContext</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-14-eglcontect-TLS.png" alt="Alt text | center"></p>
<h4 id="3-3-4-2、Thread-Local-Storage"><a href="#3-3-4-2、Thread-Local-Storage" class="headerlink" title="3.3.4.2、Thread Local Storage"></a>3.3.4.2、Thread Local Storage</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-15-eglcontect-Thread-Loacal.png.png" alt="Alt text | center"></p>
<h4 id="3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger"><a href="#3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger" class="headerlink" title="3.3.5、EGLImplementation : HWCompser and SurfaceFlinger"></a>3.3.5、EGLImplementation : HWCompser and SurfaceFlinger</h4><h4 id="3-3-5-1、HWCompser"><a href="#3-3-5-1、HWCompser" class="headerlink" title="3.3.5.1、HWCompser"></a>3.3.5.1、HWCompser</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-16-Android-graphics-components.png" alt="Alt text | center"></p>
<h4 id="3-3-5-2、SurfaceFlinger"><a href="#3-3-5-2、SurfaceFlinger" class="headerlink" title="3.3.5.2、SurfaceFlinger"></a>3.3.5.2、SurfaceFlinger</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-17-eglimp-hwrenderer-surfaceflinger.png" alt="Alt text | center"></p>
<p>####（四）、Android EGL：OpenGL ES 库和 EGL 库加载过程<br>在详细分析 EGL 绘图基本步骤 前，先来看看OpenGL ES 库和 EGL 库加载过程。</p>
<h5 id="4-1、OpenGL-ES-和-OpenGL-ES-库的区别"><a href="#4-1、OpenGL-ES-和-OpenGL-ES-库的区别" class="headerlink" title="4.1、OpenGL ES 和 OpenGL ES 库的区别"></a>4.1、OpenGL ES 和 OpenGL ES 库的区别</h5><p><strong>OpenGL ES ：</strong> 它本身只是一个协议规范，定义了一套可以供上层应用程序进行调用的 API，它抽象了 GPU 的功能，使应用开发者不必关心底层的 GPU 类型和具体实现。<br><strong>OpenGL ES 库：</strong>OpenGL ES 库就是上面 OpenGL ES 中定义的 API 的具体实现。由于每个显卡制造厂商的 GPU 硬件结构不同，从而导致各个厂商的OpenGL ES 库也各不相同，所以 Android 系统中的 OpenGL ES 库通常是由硬件厂商提供的，通常存放在 Android 系统中的 /system/lib64/（/system/lib/） 。<br><strong>OpenGL ES Wrapper 库：</strong>OpenGL ES Wrapper 库是一个对 OpenGL ES API 进行封装的一个包裹库，它向上为应用程序提供了标准的 OpenGL ES API，向下可以和不同厂商实现的 OpenGL ES 库进行绑定，将 OpenGL ES API 和对应的实现函数一一绑定在一起。<br>并且，OpenGL ES 库的实现分为：<br><strong>软件模拟实现</strong><br><strong>硬件加速实现</strong><br>现在，因为我们 Android 手机中的 Soc 片上芯片中都集成了 GPU 模块，所以这里使用的就是硬件加速实现的 OpenGL ES 库。但是，像 Android Emulator 中的 Android 系统，如果不支持将 OpenGL ES API 指令重定向到主机系统的 GPU 加速执行的话，它所采用的 OpenGL ES 库就是软件模拟实现的。</p>
<p>补充：如前面小节【OpenGL ES 和 EGL 介绍】中介绍的，EGL 也是一套 API，它的实现也需要系统厂商来提供。系统厂商通常会将这两套 API 的实现封装在一个共享链接库中，但是根据最新的标准，OpenGL ES API 实现的共享链接库和 EGL API 实现的共享链接库是独立分开的，例如  Nexus 9 平板设备中 OpenGL ES 和 EGL API 实现库就是独立分开的。</p>
<h5 id="4-2、Android-中-OpenGL-ES-软件层次栈"><a href="#4-2、Android-中-OpenGL-ES-软件层次栈" class="headerlink" title="4.2、Android 中 OpenGL ES 软件层次栈"></a>4.2、Android 中 OpenGL ES 软件层次栈</h5><p>按照分层理念的设计，Android 中的 OpenGL ES 实现也是层次设计的，形成一个软件层次栈。最上面的是 Java 层，接着下面是 JNI 层，再调用下面的 wrapper 层，wrapper 层下面则是 OpenGL ES API 的具体软件实或者硬件实现了。整个 OpenGL 软件层次栈的调用关系如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-18-OpenGL_ES_call_graph_so.png" alt="Alt text | center"></p>
<h5 id="4-3、OpenGL-ES-EGL-Wrapper-库"><a href="#4-3、OpenGL-ES-EGL-Wrapper-库" class="headerlink" title="4.3、OpenGL ES/EGL Wrapper 库"></a>4.3、OpenGL ES/EGL Wrapper 库</h5><p>前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：/frameworks/native/opengl/libs/，其中:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLESv1_CM.so：OpenGL ES <span class="number">1.</span>x API 的 Wrapper 库</span><br><span class="line">libGLESv2.so：OpenGL ES <span class="number">2.0</span> 的 Wrapper 库</span><br><span class="line">libGLESv3.so：OpenGL ES <span class="number">3.0</span> 的 Wrapper 库</span><br></pre></td></tr></table></figure>

<p>其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 libGLESv2.so 库本质上和 libGLESv3.so 库是一样的。</p>
<h5 id="4-3-1、OpenGL-ES-EGL-实现库"><a href="#4-3-1、OpenGL-ES-EGL-实现库" class="headerlink" title="4.3.1、OpenGL ES/EGL 实现库"></a>4.3.1、OpenGL ES/EGL 实现库</h5><p>如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以.so的共享链接库的形式提供，例如，高通的实现：system\vendor\lib\egl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libEGL_adreno.so </span><br><span class="line">libGLESv1_CM_adreno.so</span><br><span class="line">libGLESv2_adreno.so</span><br></pre></td></tr></table></figure>

<p>如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： /system/lib64/egl/libGLES_android.so。而 libGLES_android.so 库在 Android 7.1 系统对应的实现源码路径为：/frameworks/native/opengl/libagl/ 。</p>
<h5 id="4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程"><a href="#4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程" class="headerlink" title="4.3.2、Android 7.1 中加载 OpenGL ES 库的过程"></a>4.3.2、Android 7.1 中加载 OpenGL ES 库的过程</h5><p>Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 /frameworks/native/opengl/libs/EGL/Loader.cpp 。</p>
<h5 id="4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明"><a href="#4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明" class="headerlink" title="4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明"></a>4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明</h5><p><a target="_blank" rel="noopener" href="http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead">How Android finds OpenGL libraries, and the death of egl.cfg</a> 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化）。</p>
<p>在 Android 4.4 之前，加载 OpenGL ES 库是由 /system/lib/egl/egl.cfg 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。</p>
<p>但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：</p>
<p>从 /system/lib/egl 或者 /system/vendor/lib/egl/ 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2_vendor.so 库文件。<br>为了向下兼容旧的库的命名方式，同样也会加载 /system/lib/egl 或者 /vendor/lib/egl/ 目录下的 libGLES_*.so 或者 libEGL_*.so，libGLESv1CM*.so，libGLESv2_*.so 库文件。</p>
<h5 id="4-3-2-2、硬件加速渲染-or-软件模拟渲染？"><a href="#4-3-2-2、硬件加速渲染-or-软件模拟渲染？" class="headerlink" title="4.3.2.2、硬件加速渲染 or 软件模拟渲染？"></a>4.3.2.2、硬件加速渲染 or 软件模拟渲染？</h5><p>前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？</p>
<p>Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：/frameworks/native/opengl/libs/EGL/Loader.cpp 文件中，这个文件中代码的主要入口函数是 Loader::open() 函数，而决定加载硬件加速渲染库还是软件模拟渲染库主要涉及到下面两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setEmulatorGlesValue()</span><br><span class="line">checkGlesEmulationStatus()</span><br></pre></td></tr></table></figure>

<p>下面就来简要的分析一下 Android 系统是如何选择加载硬件加速渲染库还是软件模拟渲染库：</p>
<p>首先，Loader::open() 入口函数会调用 setEmulatorGlesValue() 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEmulatorGlesValue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">     property_get(<span class="string">&quot;ro.kernel.qemu&quot;</span>, prop, <span class="string">&quot;0&quot;</span>); <span class="comment">//读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">     property_get(<span class="string">&quot;ro.kernel.qemu.gles&quot;</span>, prop, <span class="string">&quot;0&quot;</span>); <span class="comment">//读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) == <span class="number">1</span>) &#123;</span><br><span class="line">         ALOGD(<span class="string">&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;</span>);</span><br><span class="line">         property_set(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// for now, checking the following</span></span><br><span class="line">     <span class="comment">// directory is good enough for emulator system images</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* vendor_lib_path =</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">         <span class="string">&quot;/vendor/lib64/egl&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="string">&quot;/vendor/lib/egl&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">bool</span> has_vendor_lib = (access(vendor_lib_path, R_OK) == <span class="number">0</span>);</span><br><span class="line">     <span class="comment">//如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库</span></span><br><span class="line">     <span class="keyword">if</span> (has_vendor_lib) &#123;</span><br><span class="line">         ALOGD(<span class="string">&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;</span>);</span><br><span class="line">         property_set(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ALOGD(<span class="string">&quot;Emulator without GPU support detected. &quot;</span></span><br><span class="line">               <span class="string">&quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;</span>);</span><br><span class="line">         property_set(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;0&quot;</span>); <span class="comment">//最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 load_system_driver() 函数中，内部类 MatchFile 类中会调用 checkGlesEmulationStatus() 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">load_system_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">     ATRACE_CALL();</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">MatchFile</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">//这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径</span></span><br><span class="line">         <span class="function"><span class="keyword">static</span> String8 <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">             String8 result;</span><br><span class="line">             <span class="keyword">int</span> emulationStatus = checkGlesEmulationStatus(); <span class="comment">//检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能</span></span><br><span class="line">             <span class="keyword">switch</span> (emulationStatus) &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.setTo(<span class="string">&quot;/system/lib64/egl/libGLES_android.so&quot;</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.setTo(<span class="string">&quot;/system/lib/egl/libGLES_android.so&quot;</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行</span></span><br><span class="line">                 <span class="comment">// Use host-side OpenGL through the &quot;emulation&quot; library</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.appendFormat(<span class="string">&quot;/system/lib64/egl/lib%s_emulation.so&quot;</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.appendFormat(<span class="string">&quot;/system/lib/egl/lib%s_emulation.so&quot;</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="comment">// Not in emulator, or use other guest-side implementation</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             <span class="comment">// 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径</span></span><br><span class="line">             String8 pattern;</span><br><span class="line">             pattern.appendFormat(<span class="string">&quot;lib%s&quot;</span>, kind);</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> searchPaths[] = &#123;</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">                 <span class="string">&quot;/vendor/lib64/egl&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;/system/lib64/egl&quot;</span></span><br><span class="line"> #<span class="keyword">else</span></span><br><span class="line">                 <span class="string">&quot;/vendor/lib/egl&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;/system/lib/egl&quot;</span></span><br><span class="line"> #endif</span><br><span class="line">             &#125;;</span><br><span class="line">                </span><br><span class="line">             ......</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 emulationStatus 值 来确定是加软件模拟实现的 OpenGL ES API 库 libGLES_android.so，还是加载 libGLES_emulation.so库将 OpenGL ES 指令重定向到 Host 系统中去执行。</p>
<h5 id="4-3-3、OpenGL-ES-EGL-库加载和解析过程"><a href="#4-3-3、OpenGL-ES-EGL-库加载和解析过程" class="headerlink" title="4.3.3、OpenGL ES/EGL 库加载和解析过程"></a>4.3.3、OpenGL ES/EGL 库加载和解析过程</h5><p>正如前面分析，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 eglgGetDisplay() 函数被调用。在 eglGetDisplay() 里则会调用 egl_init_drivers() 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 egl_connection_t 类型的全局变量 gEGLImpl 的结构体的成员变量中。</p>
<p>下面以 SurfaceFlinger 进程init()为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-19-SF_init.png" alt="Alt text | center"></p>
<p>这里通过调用 EGL 库的 eglGetDisplay() 获得 Display。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\eglApi.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(EGLNativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (egl_init_drivers() == EGL_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = <span class="keyword">egl_display_t</span>::getFromNativeDisplay(display);</span><br><span class="line">    <span class="keyword">return</span> dpy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数EGLBoolean egl_init_drivers()就是负责OpenGL库的加载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_init_drivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EGLBoolean res;</span><br><span class="line">    pthread_mutex_lock(&amp;sInitDriverMutex);</span><br><span class="line">    res = egl_init_drivers_locked();</span><br><span class="line">    pthread_mutex_unlock(&amp;sInitDriverMutex);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为保证多线程访问的安全性，使用线程锁来放完另一个接口函数egl_init_drivers_locked()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="comment">//在该文件起始位置定义的全局变量</span></span><br><span class="line"><span class="keyword">egl_connection_t</span> gEGLImpl; <span class="comment">// 描述EGL实现内容的结构体对象</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooks[<span class="number">2</span>]; <span class="comment">// gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooksNoContext;</span><br><span class="line"><span class="keyword">pthread_key_t</span> gGLWrapperKey = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLBoolean <span class="title">egl_init_drivers_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sEarlyInitState) &#123;</span><br><span class="line">        <span class="comment">// initialized by static ctor. should be set here.</span></span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 Loader 对象单例</span></span><br><span class="line">    <span class="comment">// get our driver loader</span></span><br><span class="line">    <span class="function">Loader&amp; <span class="title">loader</span><span class="params">(Loader::getInstance())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型</span></span><br><span class="line">    <span class="comment">// dynamically load our EGL implementation</span></span><br><span class="line">    <span class="keyword">egl_connection_t</span>* cnx = &amp;gEGLImpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cnx-&gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (cnx-&gt;dso == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// &gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化</span></span><br><span class="line">        <span class="comment">//也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现</span></span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX];</span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库</span></span><br><span class="line">        cnx-&gt;dso = loader.open(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。</p>
<p>Loader::open() 函数的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="comment">// &gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Loader::open</span><span class="params">(<span class="keyword">egl_connection_t</span>* cnx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line">    <span class="keyword">driver_t</span>* hnd = <span class="number">0</span>;</span><br><span class="line">    setEmulatorGlesValue();</span><br><span class="line">    dso = load_driver(<span class="string">&quot;GLES&quot;</span>, cnx, EGL | GLESv1_CM | GLESv2);</span><br><span class="line">    <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">        hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Always load EGL first</span></span><br><span class="line">        dso = load_driver(<span class="string">&quot;EGL&quot;</span>, cnx, EGL);</span><br><span class="line">        <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">            hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">&quot;GLESv1_CM&quot;</span>, cnx, GLESv1_CM), GLESv1_CM );</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">&quot;GLESv2&quot;</span>,    cnx, GLESv2),    GLESv2 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR <span class="string">&quot;/libEGL.so&quot;</span>);</span><br><span class="line">    cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR <span class="string">&quot;/libGLESv2.so&quot;</span>);</span><br><span class="line">    cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR <span class="string">&quot;/libGLESv1_CM.so&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open() 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function">oid *<span class="title">Loader::load_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">egl_connection_t</span>* cnx, <span class="keyword">uint32_t</span> mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (mGetDriverNamespace) &#123;</span><br><span class="line">        <span class="keyword">android_namespace_t</span>* ns = mGetDriverNamespace();</span><br><span class="line">        <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">            dso = load_updated_driver(kind, ns); <span class="comment">//加载 OpenGL ES 实现库，放回打开的共享链接库的句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dso) &#123;</span><br><span class="line">        dso = load_system_driver(kind);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; EGL) &#123;</span><br><span class="line">        getProcAddress = (getProcAddressType)dlsym(dso, <span class="string">&quot;eglGetProcAddress&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">egl_t</span>* egl = &amp;cnx-&gt;egl; <span class="comment">//将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl</span></span><br><span class="line">        __eglMustCastToProperFunctionPointerType* curr =</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)egl;</span><br><span class="line">        <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> * api = egl_names; <span class="comment">//egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针</span></span><br><span class="line">        <span class="keyword">while</span> (*api) &#123;</span><br><span class="line">            <span class="keyword">char</span> <span class="keyword">const</span> * name = *api;</span><br><span class="line">            __eglMustCastToProperFunctionPointerType f =</span><br><span class="line">                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// couldn&#x27;t find the entry-point, use eglGetProcAddress()</span></span><br><span class="line">                f = getProcAddress(name);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    f = (__eglMustCastToProperFunctionPointerType)<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *curr++ = f; <span class="comment">//这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起</span></span><br><span class="line">            api++; <span class="comment">//指向下一个需要绑定的 api 函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv1_CM) &#123;</span><br><span class="line">        <span class="comment">// 调用 init_api 实现 OpenGL API 和对应实现函数的绑定</span></span><br><span class="line">        init_api(dso, gl_names, <span class="comment">// gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针</span></span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX]-&gt;gl, <span class="comment">//gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针</span></span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv2) &#123;</span><br><span class="line">        init_api(dso, gl_names,</span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX]-&gt;gl,</span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Loader::load_driver() 它主要实现了两个功能：</p>
<p>通过 load_system_driver()  函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。<br>调用 init_api()解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。</p>
<h5 id="4-4、小结"><a href="#4-4、小结" class="headerlink" title="4.4、小结"></a>4.4、小结</h5><p>Android OpenGL ES 图形库结构<br>Android 的 OpenGL ES 图形系统涉及多个库，根据设备类型的不同，这些库有着不同的结构。</p>
<p>对于模拟器，没有开启 OpenGL ES 的 GPU 硬件模拟的情况，Android OpenGL ES 图形库结构如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-20-opencl-egl-imp.png" alt="Alt text | center"></p>
<p>当为模拟器开启了 OpenGL ES 的 GPU 硬件模拟，实际的 EGL 和 OpenGL ES 实现库会采用由 android-7.1.1_r22/device/generic/goldfish-opengl 下的源码编译出来的几个库文件，即 libGLESv2_emulation.so、libGLESv1_CM_emulation.so 和 libEGL_emulation.so。此时，OpenGL ES 图形库结构如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-21-opencl-egl-imp-emulate.png" alt="Alt text | center"></p>
<p>对于真实的物理 Android 设备，OpenGL ES 图形库结构如下，例如高通实现（libEGL_adreno.so<br>libGLESv1_CM_adreno.so libGLESv2_adreno.so [\system\vendor\lib64\egl]）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/DS-02-22-opencl-egl-imp-qcom-adreno.png" alt="Alt text | center"></p>
<p>####（五）、OpenGL ES：EGL接口解析与理解</p>
<p>由前面的分析知道EGL的绘图的一般步骤如下，接下来分析主要的1-8个小步骤：</p>
<blockquote>
<p>使用EGL的绘图的一般步骤：<br>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p>
</blockquote>
<p>标准 EGL 数据类型如下所示：</p>
<p>EGLBoolean ——EGL_TRUE =1, EGL_FALSE=0<br>EGLint ——int 数据类型<br>EGLDisplay ——系统显示 ID 或句柄，可以理解为一个前端的显示窗口<br>EGLConfig ——Surface的EGL配置，可以理解为绘制目标framebuffer的配置属性<br>EGLSurface ——系统窗口或 frame buffer 句柄 ，可以理解为一个后端的渲染目标窗口。<br>EGLContext ——OpenGL ES 图形上下文，它代表了OpenGL状态机；如果没有它，OpenGL指令就没有执行的环境。</p>
<p>下面几个类型比较复杂，通过例子可以更深入的理解。这里要说明的是这几个类型在不同平台其实现是不同的，EGL只提供抽象标准。</p>
<p>NativeDisplayType——Native 系统显示类型，标识你所开发设备的物理屏幕<br>NativeWindowType ——Native 系统窗口缓存类型，标识系统窗口<br>NativePixmapType ——Native 系统 frame buffer，可以作为 Framebuffer 的系统图像（内存）数据类型，该类型只用于离屏渲染.</p>
<h5 id="5-1、eglGetDisplay"><a href="#5-1、eglGetDisplay" class="headerlink" title="5.1、eglGetDisplay()"></a>5.1、eglGetDisplay()</h5><p>EGLDisplay 是一个关联系统物理屏幕的通用数据类型，表示显示设备句柄，也可以认为是一个前端显示窗。为了使用系统的显示设备， EGL 提供了 EGLDisplay 数据类型，以及一组操作设备显示的 API 。<br>下面的函数原型用于获取 Native Display ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(NativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (display == EGL_DEFAULT_DISPLAY) &#123;</span><br><span class="line">        EGLDisplay dpy = (EGLDisplay)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line">        d.type = display;</span><br><span class="line">        <span class="keyword">return</span> dpy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EGL_NO_DISPLAY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">egl_display_t</span>&amp; <span class="title">egl_display_t::get_display</span><span class="params">(EGLDisplay dpy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDisplays[<span class="keyword">uintptr_t</span>(dpy)<span class="number">-1U</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其 中 display 参数是 native 系统的窗口显示 ID 值。如果你只是想得到一个系统默认的 Display ，你可以使用 EGL_DEFAULT_DISPLAY 参数。如果系统中没有一个可用的 native display ID 与给定的 display 参数匹配，函数将返回 EGL_NO_DISPLAY ，而没有任何 Error 状态被设置。</p>
<h5 id="5-2、eglInitialize"><a href="#5-2、eglInitialize" class="headerlink" title="5.2、eglInitialize()"></a>5.2、eglInitialize()</h5><p>每个 EGLDisplay 在使用前都需要初始化。初始化 EGLDisplay 的同时，你可以得到系统中 EGL 的实现版本号。了解当前的版本号在向后兼容性方面是非常有价值的。在移动设备上，通过动态查询 EGL 版本号，你可以为新旧版本的 EGL 附加额外的特性或运行环境。基于平台配置，软件开发可用清楚知道哪些 API 可用访问，这将会为你的代码提供最大限度的可移植性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglInitialize</span><span class="params">(EGLDisplay dpy, EGLint *major, EGLint *minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    EGLBoolean res = EGL_TRUE;</span><br><span class="line">    <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d.initialized.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acquire) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == EGL_TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (major != <span class="literal">NULL</span>) *major = VERSION_MAJOR;</span><br><span class="line">        <span class="keyword">if</span> (minor != <span class="literal">NULL</span>) *minor = VERSION_MINOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 dpy 应该是一个有效的 EGLDisplay 。函数返回时， major 和 minor 将被赋予当前 EGL 版本号。比如 EGL1.0 ， major 返回 1 ， minor 则返回 0 。给 major 和 minor 传 NULL 是有效的，如果你不关心版本号。<br>eglQueryString() 函数是另外一个获取版本信息和其他信息的途径。通过 eglQueryString() 获取版本信息需要解析版本字符串，所以通过传递一个指针给 eglInitializ() 函数比较容易获得这个信息。注意在调用 eglQueryString() 必须先使用 eglInitialize() 初始化 EGLDisplay ，否则将得到 EGL_NOT_INITIALIZED 错误信息。</p>
<h5 id="5-3、eglChooseConfig"><a href="#5-3、eglChooseConfig" class="headerlink" title="5.3、eglChooseConfig()"></a>5.3、eglChooseConfig()</h5><p>基 于 EGL 的属性，可以得到一个和需求接近的Config，但也可以选择自己需要的Config，只要平台支持。不是所有的Config都是有效的，也就是不是所有Config都会支持。 eglChooseConfig() 函数将适配一个所期望的配置，并且尽可能接近一个有效的系统配置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglChooseConfig</span><span class="params">( EGLDisplay dpy, <span class="keyword">const</span> EGLint *attrib_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLConfig *configs, EGLint config_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLint *num_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(num_config==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(attrib_list==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A NULL attrib_list should be treated as though it was an empty</span></span><br><span class="line"><span class="comment">         * one (terminated with EGL_NONE) as defined in</span></span><br><span class="line"><span class="comment">         * section 3.4.1 &quot;Querying Configurations&quot; in the EGL specification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> EGLint dummy = EGL_NONE;</span><br><span class="line">        attrib_list = &amp;dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numAttributes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numConfigs =  NELEM(gConfigs);</span><br><span class="line">    <span class="keyword">uint32_t</span> possibleMatch = (<span class="number">1</span>&lt;&lt;numConfigs)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(possibleMatch &amp;&amp; *attrib_list != EGL_NONE) &#123;</span><br><span class="line">        numAttributes++;</span><br><span class="line">        EGLint attr = *attrib_list++;</span><br><span class="line">        EGLint val  = *attrib_list++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAttributeMatching(i, attr, val) == <span class="number">0</span>) &#123;</span><br><span class="line">                possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, handle the attributes which have a useful default value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j=<span class="number">0</span> ; possibleMatch &amp;&amp; j&lt;NELEM(config_defaults) ; j++) &#123;</span><br><span class="line">        <span class="comment">// see if this attribute was specified, if not, apply its</span></span><br><span class="line">        <span class="comment">// default value</span></span><br><span class="line">        <span class="keyword">if</span> (binarySearch&lt;<span class="keyword">config_pair_t</span>&gt;(</span><br><span class="line">                (<span class="keyword">config_pair_t</span> <span class="keyword">const</span>*)attrib_list,</span><br><span class="line">                <span class="number">0</span>, numAttributes<span class="number">-1</span>,</span><br><span class="line">                config_defaults[j].key) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isAttributeMatching(i,</span><br><span class="line">                        config_defaults[j].key,</span><br><span class="line">                        config_defaults[j].value) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the configurations found</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (possibleMatch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; config_size &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    *configs++ = (EGLConfig)(<span class="keyword">uintptr_t</span>)i;</span><br><span class="line">                    config_size--;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num_config = n;</span><br><span class="line">     <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 attrib_list 指定了选择配置时需要参照的属性。参数 configs 将返回一个按照 attrib_list 排序的平台有效的所有 EGL framebuffer 配置列表。参数 config_size 指定了可以返回到 configs 的总配置个数。参数 num_config 返回了实际匹配的配置总数。</p>
<h5 id="5-4、eglCreateContext"><a href="#5-4、eglCreateContext" class="headerlink" title="5.4、eglCreateContext()"></a>5.4、eglCreateContext()</h5><p>OpenGL ES的pipeline从程序的角度看就是一个状态机，有当前的颜色、纹理坐标、变换矩阵、绚染模式等一大堆状态，这些状态作用于OpenGL API程序提交的顶点坐标等图元从而形成帧缓冲内的像素。在OpenGL的编程接口中，Context就代表这个状态机，OpenGL API程序的主要工作就是向Context提供图元、设置状态，偶尔也从Context里获取一些信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLContext <span class="title">eglCreateContext</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLContext <span class="comment">/*share_list*/</span>, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = ogles_init(<span class="keyword">sizeof</span>(<span class="keyword">egl_context_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gl) <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_NO_CONTEXT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_context_t</span>* c = <span class="keyword">static_cast</span>&lt;<span class="keyword">egl_context_t</span>*&gt;(gl-&gt;rasterizer.base);</span><br><span class="line">    c-&gt;flags = <span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">    c-&gt;dpy = dpy;</span><br><span class="line">    c-&gt;config = config;</span><br><span class="line">    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (EGLContext)gl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5、eglCreateWindowSurface"><a href="#5-5、eglCreateWindowSurface" class="headerlink" title="5.5、eglCreateWindowSurface()"></a>5.5、eglCreateWindowSurface()</h5><p>Surface实际上就是一个FrameBuffer，也就是渲染目的地，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    NativeWindowType window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> EGLint *attrib_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createWindowSurface(dpy, config, window, attrib_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!surface-&gt;initCheck()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> surface;</span><br><span class="line">        surface = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来创建一个可实际显示的Surface。</p>
<p>系统通常还支持另外两种Surface：PixmapSurface和PBufferSurface，这两种都不是可显示的Surface，PixmapSurface是保存在系统内存中的位图，PBuffer则是保存在显存中的帧。</p>
<p>对于这两种surface，Android系统中，支持PBufferSurface。</p>
<h5 id="5-6、eglMakeCurrent"><a href="#5-6、eglMakeCurrent" class="headerlink" title="5.6、eglMakeCurrent()"></a>5.6、eglMakeCurrent()</h5><p>该接口将申请到的display，draw（surface）和 context进行了绑定。也就是说，在context下的OpenGLAPI指令将draw（surface）作为其渲染最终目的地。而display作为draw（surface）的前端显示。调用后，当前线程使用的EGLContex为context。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(  EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that draw is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read &amp;&amp; read!=draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that read is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLContext current_ctx = EGL_NO_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read == EGL_NO_SURFACE &amp;&amp; draw == EGL_NO_SURFACE) &amp;&amp; (ctx != EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) &amp;&amp; (ctx == EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="comment">// if we&#x27;re detaching, we need the current context</span></span><br><span class="line">        current_ctx = (EGLContext)getGlThreadSpecific();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp;&amp; d-&gt;ctx &amp;&amp; d-&gt;ctx != ctx) ||</span><br><span class="line">            (r &amp;&amp; r-&gt;ctx &amp;&amp; r-&gt;ctx != ctx)) &#123;</span><br><span class="line">            <span class="comment">// one of the surface is bound to a context in another thread</span></span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = (<span class="keyword">ogles_context_t</span>*)ctx;</span><br><span class="line">    <span class="keyword">if</span> (makeCurrent(gl) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">            <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c-&gt;draw) &#123;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* s = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">egl_surface_t</span>*&gt;(c-&gt;draw);</span><br><span class="line">                s-&gt;disconnect();</span><br><span class="line">                s-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;zombie)</span><br><span class="line">                    <span class="keyword">delete</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;read) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            c-&gt;draw = draw;</span><br><span class="line">            c-&gt;read = read;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; <span class="keyword">egl_context_t</span>::NEVER_CURRENT) &#123;</span><br><span class="line">                c-&gt;flags &amp;= ~<span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">                GLint w = <span class="number">0</span>;</span><br><span class="line">                GLint h = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">                    w = d-&gt;getWidth();</span><br><span class="line">                    h = d-&gt;getHeight();</span><br><span class="line">                &#125;</span><br><span class="line">                ogles_surfaceport(gl, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                ogles_viewport(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">                ogles_scissor(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ctx = ctx;</span><br><span class="line">                d-&gt;bindDrawSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> lock/connect the read surface too </span></span><br><span class="line">                r-&gt;ctx = ctx;</span><br><span class="line">                r-&gt;bindReadSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if surfaces were bound to the context bound to this thread</span></span><br><span class="line">            <span class="comment">// mark then as unbound.</span></span><br><span class="line">            <span class="keyword">if</span> (current_ctx) &#123;</span><br><span class="line">                <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(current_ctx);</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)c-&gt;draw;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)c-&gt;read;</span><br><span class="line">                <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">                    d-&gt;disconnect();</span><br><span class="line">                    d-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="keyword">if</span> (d-&gt;zombie)</span><br><span class="line">                        <span class="keyword">delete</span> d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">                    r-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-7、绘制gl"><a href="#5-7、绘制gl" class="headerlink" title="5.7、绘制gl_*()"></a>5.7、绘制gl_*()</h5><p>应用程序通过OpenGL API进行绘制，一帧完成之后，调用eglSwapBuffers(EGLDisplay dpy, EGLContext ctx)来显示。</p>
<h5 id="5-8、eglSwapBuffers接口实现说明"><a href="#5-8、eglSwapBuffers接口实现说明" class="headerlink" title="5.8、eglSwapBuffers接口实现说明"></a>5.8、eglSwapBuffers接口实现说明</h5><p>Android平台：</p>
<p>为了实现eglSwapBuffers， eglSurface其实代表了一个从NativeWindow 申请到的一个Buffer（Dequeue操作）。当调用eglSwapBuffers时，对于一般应用窗口而言，NativeWindow将该Surface的Buffer 提交回去给SurfaceFlinger（Queue操作)，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::swapBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">nativeWindow-&gt;queueBuffer(nativeWindow, buffer); </span><br><span class="line">nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后又重新从NativeWindow中重新Dequeue出来一个新的Buffer给eglSurface。而eglDisplay并不代表实际的意义。我们只是从接口上感觉是，surface和display进行了交换。（注：现在是Triple Buffer）</p>
<blockquote>
<p><strong>总结：从前面关于Android EGL、OpenGL ES的分析知道，现在我们可以通过SurfaceFlinger申请一块Surface（Buffer），然后可以利用OpenGL ES接口在Native 层绘制相关的图片、文字；那么疑问来了，Android上层绚丽多彩的App界面是如何绘制而成的呢、App层如何通过底层的OpenGL ES接口来完成绘制呢？？？</strong></p>
</blockquote>
<h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="https://www.khronos.org/">Khronos Group</a><br><a target="_blank" rel="noopener" href="https://source.android.com/devices/graphics/architecture">Android图形架构 官方文档</a><br><a target="_blank" rel="noopener" href="http://geekfaner.com/shineengine/index.html">OPENGL ES 2.0 知识串讲</a><br><a target="_blank" rel="noopener" href="https://www.slideshare.net/namjungsoo/egl-31239467">OpenGL ES EGL Spec&amp;APIs</a><br><a target="_blank" rel="noopener" href="https://www.slideshare.net/SuhanLee2/understaing-android-egl">Understaing-Android-Egl</a><br><a target="_blank" rel="noopener" href="https://woshijpf.github.io/category/android/">Android 系统图形栈(1) &amp;&amp;(2)： OpenGL ES 和 EGL</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hovan/article/details/43198399">Android L 的开机动画流程 - CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20180508/">https://zhoujinjian.com/posts/20180508/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a><a class="post-meta__tags" href="/tags/Display/">Display</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20180608/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.21.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android N Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20180408/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20180408/" title="Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-08</div><div class="title">Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析</div></div></a></div><div><a href="/posts/20180608/" title="Android N Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-08</div><div class="title">Android N Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析</div></div></a></div><div><a href="/posts/20180708/" title="Android N Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-07-08</div><div class="title">Android N Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析</div></div></a></div><div><a href="/posts/20180808/" title="Android N Display System（5）：Android Display System 系统分析之Display Driver Architecture"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-08-08</div><div class="title">Android N Display System（5）：Android Display System 系统分析之Display Driver Architecture</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81Android-Graphics-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">1.1、Android Graphics 测试程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81Android-BootAnimation-%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB-EGL%E5%9C%A8Android%E4%B8%AD%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">1.2、Android BootAnimation 开机动画(EGL在Android中应用)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81Understanding-Android-Graphics-Internals"><span class="toc-number">3.</span> <span class="toc-text">1.2、Understanding Android Graphics Internals</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D"><span class="toc-number">4.</span> <span class="toc-text">2.1、写在前面的话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1%E3%80%81%E7%94%B5%E8%84%91%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">2.1.1、电脑是做什么用的?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E5%BE%97%E7%94%B5%E8%84%91%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">2.1.2、是什么使得电脑工作?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3%E3%80%81%E8%B0%81%E6%9D%A5%E5%86%99%E9%A9%B1%E5%8A%A8"><span class="toc-number">7.</span> <span class="toc-text">2.1.3、谁来写驱动?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4%E3%80%81%E8%B0%81%E4%BC%9A%E4%BD%BF%E7%94%A8%E9%A9%B1%E5%8A%A8"><span class="toc-number">8.</span> <span class="toc-text">2.1.4、谁会使用驱动?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5%E3%80%81%E9%82%A3%E4%B9%88%E5%9C%A8%E5%93%AA%E9%87%8C%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80"><span class="toc-number">9.</span> <span class="toc-text">2.1.5、那么在哪里进行统一?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-6%E3%80%81%E8%B0%81%E8%BF%99%E4%B9%88%E7%89%9B-%E5%AE%9A%E4%B9%89%E4%BA%86-OpenGL-%E8%BF%99%E5%A5%97%E6%A0%87%E5%87%86"><span class="toc-number">10.</span> <span class="toc-text">2.1.6、谁这么牛,定义了 OpenGL 这套标准?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-7%E3%80%81OpenGL-%E5%92%8C%E6%88%91%E4%BB%AC%E6%B8%B8%E6%88%8F%EF%BC%88Android-%EF%BC%89%E5%BC%80%E5%8F%91%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">11.</span> <span class="toc-text">2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-8%E3%80%81DirectX-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">12.</span> <span class="toc-text">2.1.8、DirectX 是什么?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81OpenGL-ES-%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E4%BC%99%E4%BC%B4"><span class="toc-number"></span> <span class="toc-text">2.2、OpenGL ES 的两个小伙伴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81%E5%B1%8F%E5%B9%95%E5%9B%BE%E7%89%87%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">2.3、屏幕图片的本质和产生过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E3%80%81OpenGL-%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88pipeline%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">2.4.2、OpenGL 流水线（pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-0%E3%80%81OpenGL-ES"><span class="toc-number"></span> <span class="toc-text">3.1.0、OpenGL ES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E3%80%81OpenGL-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number"></span> <span class="toc-text">3.1.1、OpenGL 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81EGL-Overview"><span class="toc-number"></span> <span class="toc-text">3.2、EGL Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-EGL%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">3.2.1、什么是 EGL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2%E3%80%81%E4%BD%BF%E7%94%A8-EGL-%E7%BB%98%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number"></span> <span class="toc-text">3.2.2、使用 EGL 绘图的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E3%80%81EGLSurface-and-ANativeWindow-%E5%85%B3%E7%B3%BB"><span class="toc-number"></span> <span class="toc-text">3.3、EGLSurface and ANativeWindow 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E3%80%81EGLSurface"><span class="toc-number"></span> <span class="toc-text">3.3.1、EGLSurface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E3%80%81ANativeWindow"><span class="toc-number"></span> <span class="toc-text">3.3.2、ANativeWindow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3%E3%80%81egl-surface-t-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number"></span> <span class="toc-text">3.3.3、egl_surface_t 关系图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4%E3%80%81EGLContext-and-Thread-Local-Storage"><span class="toc-number"></span> <span class="toc-text">3.3.4、EGLContext and Thread Local Storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-1%E3%80%81EGLContext"><span class="toc-number"></span> <span class="toc-text">3.3.4.1、EGLContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-2%E3%80%81Thread-Local-Storage"><span class="toc-number"></span> <span class="toc-text">3.3.4.2、Thread Local Storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5%E3%80%81EGLImplementation-HWCompser-and-SurfaceFlinger"><span class="toc-number"></span> <span class="toc-text">3.3.5、EGLImplementation : HWCompser and SurfaceFlinger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-1%E3%80%81HWCompser"><span class="toc-number"></span> <span class="toc-text">3.3.5.1、HWCompser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-2%E3%80%81SurfaceFlinger"><span class="toc-number"></span> <span class="toc-text">3.3.5.2、SurfaceFlinger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81OpenGL-ES-%E5%92%8C-OpenGL-ES-%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">4.1、OpenGL ES 和 OpenGL ES 库的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E3%80%81Android-%E4%B8%AD-OpenGL-ES-%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">4.2、Android 中 OpenGL ES 软件层次栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3%E3%80%81OpenGL-ES-EGL-Wrapper-%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">4.3、OpenGL ES&#x2F;EGL Wrapper 库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1%E3%80%81OpenGL-ES-EGL-%E5%AE%9E%E7%8E%B0%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">4.3.1、OpenGL ES&#x2F;EGL 实现库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2%E3%80%81Android-7-1-%E4%B8%AD%E5%8A%A0%E8%BD%BD-OpenGL-ES-%E5%BA%93%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">4.3.2、Android 7.1 中加载 OpenGL ES 库的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-1%E3%80%81-Android-7-1-OpenGL-ES-%E5%BA%93%E5%92%8C-EGL-%E5%BA%93%E5%8A%A0%E8%BD%BD%E8%AF%B4%E6%98%8E"><span class="toc-number">6.</span> <span class="toc-text">4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2%E3%80%81%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E6%B8%B2%E6%9F%93-or-%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9F%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">4.3.2.2、硬件加速渲染 or 软件模拟渲染？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3%E3%80%81OpenGL-ES-EGL-%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">4.3.3、OpenGL ES&#x2F;EGL 库加载和解析过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">4.4、小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E3%80%81eglGetDisplay"><span class="toc-number">10.</span> <span class="toc-text">5.1、eglGetDisplay()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E3%80%81eglInitialize"><span class="toc-number">11.</span> <span class="toc-text">5.2、eglInitialize()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E3%80%81eglChooseConfig"><span class="toc-number">12.</span> <span class="toc-text">5.3、eglChooseConfig()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4%E3%80%81eglCreateContext"><span class="toc-number">13.</span> <span class="toc-text">5.4、eglCreateContext()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5%E3%80%81eglCreateWindowSurface"><span class="toc-number">14.</span> <span class="toc-text">5.5、eglCreateWindowSurface()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-6%E3%80%81eglMakeCurrent"><span class="toc-number">15.</span> <span class="toc-text">5.6、eglMakeCurrent()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-7%E3%80%81%E7%BB%98%E5%88%B6gl"><span class="toc-number">16.</span> <span class="toc-text">5.7、绘制gl_*()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-8%E3%80%81eglSwapBuffers%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">17.</span> <span class="toc-text">5.8、eglSwapBuffers接口实现说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">（六）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>