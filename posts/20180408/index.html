<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析 | zhoujinjian</title><meta name="keywords" content="Android,Graphics,Display"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinge">
<meta property="og:type" content="article">
<meta property="og:title" content="Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20180408/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinge">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg">
<meta property="article:published_time" content="2018-04-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.952Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Graphics">
<meta property="article:tag" content="Display">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20180408/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-04-08T01:25:00.000Z" title="发表于 2018-04-08 09:25:00">2018-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.952Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Display/">Display</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。<br>● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）<br>● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。<br>● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。<br>● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。 嘿嘿(<em>^▽^</em>),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。 <a id="more"></a></p>
<h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/native/services/surfaceflinger/</strong></p>
<ul>
<li>tests/Transaction_test.cpp</li>
<li>tests/vsync/vsync.cpp</li>
</ul>
<p><strong>/frameworks/native/include/gui/</strong></p>
<ul>
<li>BitTube.h</li>
<li>BufferSlot.h</li>
<li>BufferQueueCore.h</li>
<li>BufferQueueProducer.h</li>
</ul>
<p><strong>/frameworks/base/core/java/android/app/</strong></p>
<ul>
<li>Activity.java</li>
<li>ActivityThread.java</li>
<li>Instrumentation.java</li>
</ul>
<p><strong>/frameworks/base/core/jni/</strong></p>
<ul>
<li>android_view_DisplayEventReceiver.cpp</li>
<li>android_view_SurfaceControl.cpp</li>
<li>android_view_Surface.cpp</li>
<li>android_view_SurfaceSession.cpp</li>
</ul>
<p><strong>/frameworks/native/include/gui/</strong></p>
<ul>
<li>SurfaceComposerClient.h</li>
<li>IDisplayEventConnection.h</li>
<li>SurfaceComposerClient.h</li>
</ul>
<p><strong>/frameworks/native/services/surfaceflinger/</strong></p>
<ul>
<li>SurfaceFlinger.cpp</li>
<li>Client.cpp</li>
<li>main_surfaceflinger.cpp</li>
<li>DisplayDevice.cpp</li>
<li>DispSync.cpp</li>
<li>EventControlThread.cpp</li>
<li>EventThread.cpp</li>
<li>Layer.cpp</li>
<li>MonitoredProducer.cpp</li>
</ul>
<p><strong>/frameworks/base/core/java/android/view/</strong></p>
<ul>
<li>WindowManagerImpl.java</li>
<li>ViewManager.java</li>
<li>WindowManagerGlobal.java</li>
<li>ViewRootImpl.java</li>
<li>Choreographer.java</li>
<li>IWindowSession.aidl</li>
<li>DisplayEventReceiver.java</li>
<li>SurfaceControl.java</li>
<li>Surface.java</li>
<li>SurfaceSession.java</li>
</ul>
<p><strong>/frameworks/native/include/ui/</strong></p>
<ul>
<li>GraphicBuffer.h</li>
<li>GraphicBufferAllocator.h</li>
</ul>
<p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p>
<ul>
<li>WindowManagerService.java</li>
<li>Session.java</li>
<li>WindowState.java</li>
<li>WindowStateAnimator.java</li>
<li>WindowSurfaceController.java</li>
</ul>
<h2 id="（一）、Android-Graphics-系统框架"><a href="#（一）、Android-Graphics-系统框架" class="headerlink" title="（一）、Android Graphics 系统框架"></a>（一）、Android Graphics 系统框架</h2><p>（试用限制？？？万恶的亿图(EDraw)强加水印<del>火</del>）<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/01-Android-Graphics-Architecture.png" alt="Markdown"></p>
<p><strong>App</strong> 基于Android系统的GUI框架开发完整的Apk应用。</p>
<p><strong>Android Graphics Stack Client(SurfaceFlinger Client)</strong><br>Android在客户端的绘图堆栈通常包括： OpenGL ES：使用GPU进行3D和2D的绘图的API EGL：衔接GLES和系统的Native Window系统的适配层 Vulkan：Vulkan为Khronos Group推出的下一代跨平台图形开发接口，用于替代历史悠久的OpenGL。Android从7.0(Nougat)开始加入了对其的支持。Vulkan与OpenGL相比，接口更底层，从而使开发者能更直接地控制GPU。由于更好的并行支持，及更小的开销，性能上也有一定的提升。<br><strong>Android Graphics Stack Server（SurfaceFlinger Server）</strong><br>SurfaceFlinger是Android用于管理Display和负责Window Composite（窗口混合），把应用的显示窗口输出到Display的系统服务。</p>
<p><strong>Android Drivers（HAL）</strong><br>Android的驱动层，通过Android本身的HAL（硬件抽象层）机制，运行于User Space，跟渲染相关的包括：</p>
<p>Hwcomposer：如果硬件支持，SurfaceFlinger可以请求hwcomposer去做窗口混合而不需要自己来做，这样的效率也会更高，减少对GPU资源的占用 Gralloc：用来管理Graphics Buffer的分配和管理系统的framebuffer OpenGL ES/EGL</p>
<p><strong>Linux Kernel and Drivers</strong><br>除了标准的Linux内核和驱动（例如fb是framebuffer驱动），硬件厂商自己的驱动外，Android自己的一些Patches：</p>
<p>Ashmem：异步共享内存，用于在进程间共享一块内存区域，并允许系统在资源紧张时回收不加锁的内存块 ION：内存管理器 ION是google在Android4.0 为了解决内存碎片管理而引入的通用内存管理器,在面向程序员编程方面，它和ashmem很相似。但ION比ashmem更强大 Binder：高效的进程间通信机制 Vsync：Android 4.1引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作 <strong>Hardware</strong> Display（显示器）、CPU、GPU、VPU（Video Process Unit）、和内存等等</p>
<h2 id="（二）、Android-Graphics-测试程序（C-）"><a href="#（二）、Android-Graphics-测试程序（C-）" class="headerlink" title="（二）、Android Graphics 测试程序（C++）"></a>（二）、Android Graphics 测试程序（C++）</h2><p>为了便于观察对原生测试程序显示图像大小做了如下修改：</p>
<blockquote>
<p>frameworks/native/services/surfaceflinger/tests/Transaction_test.cpp</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/others/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC">Disable_HWUI_GPU_HWC.patch</a></p>
<p>原生SurfaceFlinger测试程序编译：<br>1、编译Android 7.1.2源码-userdebug版本，烧录重启<br>2、编译/frameworks/native/services/surfaceflinger/tests/会生成SurfaceFlinger_test<br>3、连接手机执行命令 adb root、adb remount、adb push SurfaceFlinger_test /system/bin/<br>4、adb shell setenforce 0(暂时关闭SELinux权限)<br>5、adb shell、cd system/bin/、chmod 0777 SurfaceFlinger_test<br>6、运行测试程序：./SurfaceFlinger_test</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/02-Android-graphics-SurfaceFlinger-Test-00.gif" alt="Markdown"></p>
<p>可以看到在Android 显示屏接替绘制了多个图像，并且会变换形状、位置、颜色、透明度等。 我们先看一下主要步骤： 1、 创建SurfaceComposerClient</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br></pre></td></tr></table></figure>

<p>2、 客户端SurfaceComposerClient请求SurfaceFlinger创建Surface 注：App端对应SurfaceControl&lt;—&gt;SurfaceFlinger对应Layer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">sp&lt;SurfaceControl&gt; mFGSurfaceControl;</span><br><span class="line">       <span class="comment">// Background surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">&quot;BG Test Surface&quot;</span>), displayWidth, displayHeight,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">63</span>, <span class="number">63</span>, <span class="number">195</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/03-Android-Graphics-SF-test-color-blue.png" alt="Markdown"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foreground surface</span></span><br><span class="line">mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">&quot;FG Test Surface&quot;</span>), <span class="number">64</span>, <span class="number">64</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">195</span>, <span class="number">63</span>, <span class="number">63</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/04-Android-Graphics-SF-test-color-red.png" alt="Markdown"></p>
<p>3、处理事务，将SurfaceControl（App）的变化更新到Layer（SurfaceFlinger）图层</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">   mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">64</span>, <span class="number">64</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>4、接受Vsync同步信号，渲染合成，推送到显示屏显示<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/05-Android-Graphics-SF-test-frame_01_delay-1s.gif" alt="Markdown"></p>
<p>接下来开始Android Graphics系统神秘探索之谜。</p>
<h2 id="（三）、Android-Graphics-禁用hwc和GPU"><a href="#（三）、Android-Graphics-禁用hwc和GPU" class="headerlink" title="（三）、Android Graphics 禁用hwc和GPU"></a>（三）、Android Graphics 禁用hwc和GPU</h2><h3 id="3-1、Disable-HWUI-GPU-HWC"><a href="#3-1、Disable-HWUI-GPU-HWC" class="headerlink" title="3.1、Disable_HWUI_GPU_HWC"></a>3.1、Disable_HWUI_GPU_HWC</h3><p>注：基于Android 7.1.2 Qualcomm MSM89XX源码</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/others/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC">Disable_HWUI_GPU_HWC.patch</a></p>
<p>编译userdebug版本，烧录开机: 运行测试程序：./SurfaceFlinger_test 结果跟上述一致，这里不再贴图了。</p>
<h3 id="3-2、Vsync测试程序"><a href="#3-2、Vsync测试程序" class="headerlink" title="3.2、Vsync测试程序"></a>3.2、Vsync测试程序</h3><p>Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作。</p>
<p>查看frameworks/native/services/surfaceflinger/tests/下还有vsync测试程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/looper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/DisplayEventReceiver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Looper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver* q = (DisplayEventReceiver*)data;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">nsecs_t</span> oldTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n = q-&gt;getEvents(buffer, <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;event vsync: count=%d\t&quot;</span>, buffer[i].vsync.count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldTimeStamp) &#123;</span><br><span class="line">                <span class="keyword">float</span> t = <span class="keyword">float</span>(buffer[i].header.timestamp - oldTimeStamp) / s2ns(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%f ms (%f Hz)\n&quot;</span>, t*<span class="number">1000</span>, <span class="number">1.0</span>/t);</span><br><span class="line">            &#125;</span><br><span class="line">            oldTimeStamp = buffer[i].header.timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;error reading events (%s)\n&quot;</span>, strerror(-n));&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver myDisplayEvent;</span><br><span class="line">    sp&lt;Looper&gt; loop = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    loop-&gt;addFd(myDisplayEvent.getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT, receiver,</span><br><span class="line">            &amp;myDisplayEvent);</span><br><span class="line">    myDisplayEvent.setVsyncRate(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;about to poll...\n&quot;);</span></span><br><span class="line">        <span class="keyword">int32_t</span> ret = loop-&gt;pollOnce(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">                <span class="comment">//(&quot;ALOOPER_POLL_WAKE\n&quot;);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="comment">//(&quot;ALOOPER_POLL_CALLBACK\n&quot;);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ALOOPER_POLL_TIMEOUT\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ALOOPER_POLL_TIMEOUT\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ugh? poll returned %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行看看：可以看到vsync信号每隔16 ms一次，关于vsync知识稍后再分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event vsync: count=<span class="number">2631</span> <span class="number">16.168612</span> ms (<span class="number">61.848231</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2632</span> <span class="number">16.168613</span> ms (<span class="number">61.848224</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2633</span> <span class="number">16.168312</span> ms (<span class="number">61.849378</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2634</span> <span class="number">16.168682</span> ms (<span class="number">61.847961</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2635</span> <span class="number">16.168596</span> ms (<span class="number">61.848288</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2636</span> <span class="number">16.168867</span> ms (<span class="number">61.847255</span> Hz)</span><br></pre></td></tr></table></figure>

<h2 id="（四）、Android-SurfaceFlinger-内部机制"><a href="#（四）、Android-SurfaceFlinger-内部机制" class="headerlink" title="（四）、Android SurfaceFlinger 内部机制"></a>（四）、Android SurfaceFlinger 内部机制</h2><h3 id="4-1、APP与SurfaceFlinger的数据结构"><a href="#4-1、APP与SurfaceFlinger的数据结构" class="headerlink" title="4.1、APP与SurfaceFlinger的数据结构"></a>4.1、APP与SurfaceFlinger的数据结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/06-Android-Graphics-App-SurfaceFlinger.png" alt="Markdown"></p>
<h4 id="4-1-1、BufferQueue介绍"><a href="#4-1-1、BufferQueue介绍" class="headerlink" title="4.1.1、BufferQueue介绍"></a>4.1.1、BufferQueue介绍</h4><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。 从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/07-Android-Graphics-SurfaceFlinger-BufferQueue.png.png" alt="Markdown"><br>先来看一下图中几个状态代表的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure>

<p><strong>FREE :</strong> FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue”拥有”。 它转换到DEQUEUED 当调用dequeueBuffer时。</p>
<p><strong>DEQUEUED：</strong> DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer”拥有”。 它可以转换到QUEUED（通过 queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p>
<p><strong>QUEUED：</strong> QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续 修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue”拥有”。 它 可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p>
<p><strong>ACQUIRED：</strong> ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到 获得栅栏fence信号。 BufferSlot由Consumer”拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个 分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p>
<p><strong>SHARED：</strong> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合， 除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p>
<p><strong>简单描述一下状态转换过程：</strong></p>
<p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p>
<p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。</p>
<p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p>
<p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p>
<h4 id="4-1-2、生产者Producer"><a href="#4-1-2、生产者Producer" class="headerlink" title="4.1.2、生产者Producer"></a>4.1.2、生产者Producer</h4><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/08-Android-Graphics-SurfaceFlinger-IGraphicsBufferProducer.png" alt="Markdown"></p>
<p>这里介绍几个非常重要的函数： <strong>1、requestBuffer</strong> requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestBuffer requests a new buffer for the given index. The server (i.e.</span></span><br><span class="line"><span class="comment">// the IGraphicBufferProducer implementation) assigns the newly created</span></span><br><span class="line"><span class="comment">// buffer to the given slot index, and the client is expected to mirror the</span></span><br><span class="line"><span class="comment">// slot-&gt;buffer mapping so that it&#x27;s not necessary to transfer a</span></span><br><span class="line"><span class="comment">// GraphicBuffer for every dequeue operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、dequeueBuffer</strong> dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span></span><br><span class="line"><span class="comment">// of the slot is transfered to the client, meaning that the server will not</span></span><br><span class="line"><span class="comment">// use the contents of the buffer associated with that slot.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> usage)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp</p>
<p><graphicbuffer>（即必须调用requestBuffer）</graphicbuffer></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been dequeued, and the caller</span></span><br><span class="line"><span class="comment">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span></span><br><span class="line"><span class="comment">// requestBuffer).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was dequeued</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously dequeued.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3、消费者Consumer"><a href="#4-1-3、消费者Consumer" class="headerlink" title="4.1.3、消费者Consumer"></a>4.1.3、消费者Consumer</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/09-Android-Graphics-SurfaceFlinger-IGraphicsBufferConsumer.png" alt="Markdown"><br>这里介绍几个非常重要的函数： <strong>1、acquireBuffer</strong> acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span></span><br><span class="line"><span class="comment">// the BufferQueue.  If no buffer is pending then it returns</span></span><br><span class="line"><span class="comment">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span></span><br><span class="line"><span class="comment">// information about the buffer is returned in BufferItem.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、releaseBuffer</strong> releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releaseBuffer releases a buffer slot from the consumer back to the</span></span><br><span class="line"><span class="comment">// BufferQueue.  This may be done while the buffer&#x27;s contents are still</span></span><br><span class="line"><span class="comment">// being accessed.  The fence will signal when the buffer is no longer</span></span><br><span class="line"><span class="comment">// in use. frameNumber is used to indentify the exact buffer returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="keyword">int</span> buf, <span class="keyword">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR fence,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、App（Java层）请求创建Surface过程"><a href="#4-2、App（Java层）请求创建Surface过程" class="headerlink" title="4.2、App（Java层）请求创建Surface过程"></a>4.2、App（Java层）请求创建Surface过程</h2><h3 id="4-2-1、Activity启动流程"><a href="#4-2-1、Activity启动流程" class="headerlink" title="4.2.1、Activity启动流程"></a>4.2.1、Activity启动流程</h3><p>Activity创建过程这里不再叙述。 请参考<a href="">【Android 7.1.2 (Android N) Activity启动流程分析】</a> &amp;&amp; <a href="">【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</a></p>
<blockquote>
<p>● ActivityManagerService接收启动Activity的请求</p>
</blockquote>
<blockquote>
<p>Activity.startActivity()<br>Activity.startActivityForResult()<br>Instrumentation.execStartActivity()<br>ActivityManagerProxy.startActivity()<br>ActivityManagerNative.onTransact()<br>ActivityManagerService.startActivity()<br>ActivityStarter.startActivityMayWait()<br>ActivityStarter.startActivityLocked()<br>ActivityStarter.startActivityUnchecked()<br>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()<br>ActivityStack.resumeTopActivityInnerLocked()<br>ActivityStackSupervisor.startSpecificActivityLocked()</p>
</blockquote>
<blockquote>
<p>●● 创建Activity所属的应用进程 ActivityManagerService.startProcessLocked()</p>
</blockquote>
<blockquote>
<p>●●● Zygote通过socket通信fork一个新的进程，并根据”android.app.ActivityThread”字符串<br>  ●●● 反射出该对象并执行ActivityThread的main方法<br>  ActivityThread.main()<br>  ActivityThread.attach()<br>  ActivityManagerProxy.attachApplication()<br>  ActivityManagerNative.onTransact()<br>  ActivityManagerService.attachApplication()<br>  ActivityManagerService.attachApplicationLocked()<br>  ActivityStackSupervisor.attachApplicationLocked()<br>  ActivityStackSupervisor.realStartActivityLocked()</p>
</blockquote>
<blockquote>
<p>●●●● 执行启动Acitivity<br>IApplicationThread.scheduleLaunchActivity()<br>ActivityThread.ApplicationThread.scheduleLaunchActivity()<br>ActivityThread.sendMessage() ActivityThread.H.handleMessage()<br>ActivityThread.handleLauncherActivity()<br>ActivityThread.performLauncherActivity()<br>ActivityThread.handleResumeActivity()</p>
</blockquote>
<h5 id="4-2-2、Window加载显示流程"><a href="#4-2-2、Window加载显示流程" class="headerlink" title="4.2.2、Window加载显示流程"></a>4.2.2、Window加载显示流程</h5><blockquote>
<p>画图，需要重新分析一下下，嘿嘿(<em>^▽^</em>)~</p>
</blockquote>
<h5 id="4-2-2-1、ActivityThread-handleLaunchActivity"><a href="#4-2-2-1、ActivityThread-handleLaunchActivity" class="headerlink" title="4.2.2.1、ActivityThread.handleLaunchActivity()"></a>4.2.2.1、ActivityThread.handleLaunchActivity()</h5><blockquote>
<p>接着从ActivityThread的handleLaunchActivity方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建Activity  </span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//启动Activity  </span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-2、ActivityThread-handleResumeActivity"><a href="#4-2-2-2、ActivityThread-handleResumeActivity" class="headerlink" title="4.2.2.2、ActivityThread.handleResumeActivity()"></a>4.2.2.2、ActivityThread.handleResumeActivity()</h3><p>回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。performLaunchActivity()方法完成了两件事： 1) Activity窗口对象的创建，通过attach函数来完成； 2) Activity视图对象的创建，通过setContentView函数来完成； 这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。 [-&gt;ActivityThread.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。 ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowManagerImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowManagerGlobal.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-3、ViewRootImpl-构造过程："><a href="#4-2-2-3、ViewRootImpl-构造过程：" class="headerlink" title="4.2.2.3、ViewRootImpl()构造过程："></a>4.2.2.3、ViewRootImpl()构造过程：</h3><p>[ViewRootImpl.java # ViewRootImpl()]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> W mWindow;</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();<span class="comment">//IWindowSession的代理对象，该对象用于和WMS通信。</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    ......</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);<span class="comment">//创建了一个W本地Binder对象，用于WMS通知应用程序进程</span></span><br><span class="line">    ......</span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line">    mDensity = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">    mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi;</span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line">    mChoreographer = Choreographer.getInstance();<span class="comment">//Choreographer对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象：</p>
<p>(1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。</p>
<p>(2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。</p>
<p>(3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。</p>
<p>(4) 创建ViewRootHandler对象，用于处理当前视图消息。</p>
<p>(5) 构造一个AttachInfo对象；</p>
<p>●●●(6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/10-Android-Graphics-App-WMS-Surface.png.png" alt="Markdown"></p>
<h3 id="4-2-2-4、IWindowSession代理获取过程"><a href="#4-2-2-4、IWindowSession代理获取过程" class="headerlink" title="4.2.2.4、IWindowSession代理获取过程"></a>4.2.2.4、IWindowSession代理获取过程</h3><p>[-&gt;WindowManagerGlobal.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> IWindowSession sWindowSession;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="comment">//得到IWindowSession代理对象</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。 [-&gt;WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;null client&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputContext == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;null inputContext&quot;</span>);</span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。</p>
<h3 id="4-2-2-5、视图View添加过程ViewRootImpl-setView"><a href="#4-2-2-5、视图View添加过程ViewRootImpl-setView" class="headerlink" title="4.2.2.5、视图View添加过程ViewRootImpl.setView()"></a>4.2.2.5、视图View添加过程ViewRootImpl.setView()</h3><p>窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。 [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">////将DecorView保存到ViewRootImpl的成员变量mView中</span></span><br><span class="line">            mView = view;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//1）在添加窗口前进行UI布局  </span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">//2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象  </span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; ......</span><br><span class="line">            <span class="comment">//3)建立窗口消息通道  </span></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。</p>
<p>ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程： (1) requestLayout()在应用程序进程中进行窗口UI布局； (2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象； (3) 注册应用程序进程端的消息接收通道；</p>
<h3 id="4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；"><a href="#4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；" class="headerlink" title="4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；"></a>4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；</h3><p>2.10、窗口UI布局过程 requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里暂时不讨论Choreographer和Vsync知识，稍后再详细分析。 现在先说出结论：Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号。 此时FrameDisplayEventReceiver会Call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger。Vsync信号每隔16ms一次，此时Vsync信号还未来到，继续分析mWindowSession.addToDisplay()。</p>
<h3 id="4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；"><a href="#4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；" class="headerlink" title="4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；"></a>4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；</h3><p>[Session.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。 在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。 [WindowState.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(TAG, <span class="string">&quot;Attaching &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; token=&quot;</span> + mToken</span><br><span class="line">        + <span class="string">&quot;, list=&quot;</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Session.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">&quot;First window added to &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;, creating SurfaceSession&quot;</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="string">&quot;  NEW SURFACE SESSION &quot;</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-8、SurfaceSession建立过程"><a href="#4-2-2-8、SurfaceSession建立过程" class="headerlink" title="4.2.2.8、SurfaceSession建立过程"></a>4.2.2.8、SurfaceSession建立过程</h3><p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p>
<p>客户端请求 [SurfaceSession.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。 [android_view_SurfaceSession.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。 是否似曾相识，就是前面最开始SurfaceFlinger_Test程序第一步：new SurfaceComposerClient的过程。 [SurfaceComposerClient.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。</p>
<p>服务端处理 在SurfaceFlinger服务端为应用程序创建交互的Client对象 [SurfaceFlinger.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line"><span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(new Client(<span class="keyword">this</span>)</span>)</span>;</span><br><span class="line">status_t err = client-&gt;initCheck();</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    bclient = client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3、App（c层）请求创建SurfaceFlinger客户端-client-的过程"><a href="#4-2-3、App（c层）请求创建SurfaceFlinger客户端-client-的过程" class="headerlink" title="4.2.3、App（c层）请求创建SurfaceFlinger客户端(client)的过程"></a>4.2.3、App（c层）请求创建SurfaceFlinger客户端(client)的过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/11-Android-Graphics-App-Ask-SurfaceFlinger-Create-Client.png.png" alt="Markdown"></p>
<p>继续详细分析AppApp（c层）请求创建SurfaceFlinger客户端(client)的过程</p>
<p>SurfaceComposerClient第一次强引用时，会执行onFirstRef() [SurfaceComposerClient.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步：获取”SurfaceFlinger”服务 ComposerService::getComposerService()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">ComposerService::getComposerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">&quot;ComposerService reconnected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ComposerService::getInstance()会调用connectLocked()获取”SurfaceFlinger”服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComposerService::connectLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">&quot;SurfaceFlinger&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(<span class="number">250000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以前面instance.mComposerService其实返回的是”SurfaceFlinger”服务。 第二步：createConnection() 接下来就会调用”SurfaceFlinger”服务的createConnection()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    <span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(<span class="keyword">new</span> Client(<span class="keyword">this</span>))</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4、APP申请创建Surface过程"><a href="#4-2-4、APP申请创建Surface过程" class="headerlink" title="4.2.4、APP申请创建Surface过程"></a>4.2.4、APP申请创建Surface过程</h3><p>前面讲ViewRootImpl.setView时，requestLayout()需要Vsync trigger，加入现在Vsync信号来到，于是会继续执行。App申请创建Surface的过程就在其中。</p>
<p>当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。 [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performTraversals函数相当复杂，其主要实现以下几个重要步骤：</p>
<p>1.执行窗口测量；</p>
<p>2.执行窗口注册；</p>
<p>3.执行窗口布局；</p>
<p>4.执行窗口绘图；</p>
<p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、执行窗口测量performMeasure() [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-1、APP申请创建Surface过程-Java层"><a href="#4-2-4-1、APP申请创建Surface过程-Java层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(Java层)"></a>4.2.4.1、APP申请创建Surface过程(Java层)</h4><p>2、执行窗口注册relayoutWindow； [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量 [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure>

<p>[-&gt;Surface.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an empty surface, which will later be filled in by readFromParcel().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下： [-&gt;IWindowSession.java$ Proxy]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This file is auto-generated.  DO NOT MODIFY</span></span><br><span class="line"><span class="comment">*  * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(android.view.IWindow window, <span class="keyword">int</span> seq, android.view.WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"><span class="keyword">int</span> _result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">        outSurface.readFromParcel(_reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？</p>
<p>[-&gt;IWindowSession.java$ Stub]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> TRANSACTION_relayout:</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    android.view.Surface _arg15;</span><br><span class="line">    _arg15 = <span class="keyword">new</span> android.view.Surface();</span><br><span class="line">    <span class="keyword">int</span> _result = <span class="keyword">this</span>.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(_result);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((_arg15!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">    _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.view.Surface _arg15;</span><br><span class="line">_arg15 = <span class="keyword">new</span> android.view.Surface();</span><br></pre></td></tr></table></figure>

<p>然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。</p>
<p>到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？ [-&gt;Session.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowSurfaceController.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowStateAnimator.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>);</span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;WindowSurfaceController.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowSurfaceController</span><span class="params">(SurfaceSession s,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags, WindowStateAnimator animator)</span> </span>&#123;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">    mSurfaceW = w;</span><br><span class="line">    mSurfaceH = h;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (animator.mWin.isChildWindow() &amp;&amp;</span><br><span class="line">            animator.mWin.mSubLayer &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            animator.mWin.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">                s, name, w, h, format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-1、APP申请创建Surface过程-c层"><a href="#4-2-4-1、APP申请创建Surface过程-c层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(c层)"></a>4.2.4.1、APP申请创建Surface过程(c层)</h4><p>SurfaceControl创建过程 [-&gt;SurfaceControl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_SurfaceControl.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">    jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line"><span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj))</span></span>;</span><br><span class="line">sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">        String8(name.c_str()), w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/12-Android-Graphics-App-Ask-SurfaceFlinger-CreateSurface.png" alt="Markdown"></p>
<p>[-&gt;SurfaceComposerClient.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">    PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;SurfaceComposerClient::createSurface error %s&quot;</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。 [ISurfaceComposerClient.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Client.cpp] MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">Client::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">status_t</span> <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer: [-&gt;ISurfaceComposerClient.h]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = <span class="number">0x00000000</span>,</span><br><span class="line">eFXSurfaceDim       = <span class="number">0x00020000</span>,</span><br><span class="line">eFXSurfaceMask      = <span class="number">0x000F0000</span></span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createNormalLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span></span>&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;createNormalLayer() failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/13-Android-Graphics-App-Ask-SurfaceFlinger-Create-Layer.png.png.png" alt="Markdown"><br>第一次强引用Layer对象时，onFirstRef()函数被回调 [Layer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"><span class="comment">//创建BufferQueue对象</span></span><br><span class="line">BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">&quot;disabling triple buffering&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mFlinger-&gt;getDefaultDisplayDevice())</span></span>;</span><br><span class="line">updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的</p>
<h4 id="4-2-4-2、BufferQueue构造过程"><a href="#4-2-4-2、BufferQueue构造过程" class="headerlink" title="4.2.4.2、BufferQueue构造过程"></a>4.2.4.2、BufferQueue构造过程</h4><p>[-&gt;BufferQueue.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span></span><br><span class="line"><span class="function"><span class="params">    sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore(allocator))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">*outProducer = producer;</span><br><span class="line">*outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueCore.cpp] 所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueCore::BufferQueueCore(<span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :</span><br><span class="line">mAllocator(allocator),</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (allocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">composer</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    mAllocator = composer-&gt;createGraphicBufferAlloc();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;createGraphicBufferAlloc failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">        s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/14-Android-Graphics-App-SurfaceFlinger-BufferSlot.png.png" alt="Markdown"></p>
<p>[-&gt;ISurfaceComposer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">virtual</span> sp&lt;IGraphicBufferAlloc&gt; <span class="title">createGraphicBufferAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferAlloc&gt; <span class="title">SurfaceFlinger::createGraphicBufferAlloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">sp&lt;GraphicBufferAlloc&gt; <span class="title">gba</span><span class="params">(<span class="keyword">new</span> GraphicBufferAlloc())</span></span>;</span><br><span class="line"><span class="keyword">return</span> gba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GraphicBufferAlloc构造过程</strong></p>
<p>[-&gt;GraphicBufferAlloc.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">GraphicBufferAlloc::createGraphicBuffer</span><span class="params">(<span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span> requestorName, <span class="keyword">status_t</span>* error)</span> </span>&#123;</span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">graphicBuffer</span><span class="params">(<span class="keyword">new</span> GraphicBuffer(</span></span></span><br><span class="line"><span class="function"><span class="params">        width, height, format, usage, <span class="built_in">std</span>::move(requestorName)))</span></span>;</span><br><span class="line"><span class="keyword">status_t</span> err = graphicBuffer-&gt;initCheck();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> graphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图形缓冲区创建过程</strong> [-&gt;GraphicBuffer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">    PixelFormat inFormat, <span class="keyword">uint32_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">: BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">  mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">width  =</span><br><span class="line">height =</span><br><span class="line">stride =</span><br><span class="line">format =</span><br><span class="line">usage  = <span class="number">0</span>;</span><br><span class="line">handle = <span class="literal">NULL</span>;</span><br><span class="line">mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,</span><br><span class="line">        <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。</p>
<p>使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请以后作分析，图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。</p>
<p><strong>Android图形缓冲区分配过程源码分析</strong></p>
<p>[-&gt;Layer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">:   contentDirty(<span class="literal">false</span>),</span><br><span class="line">    sequence(<span class="keyword">uint32_t</span>(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">    mFlinger(flinger),</span><br><span class="line">    mTextureName(<span class="number">-1U</span>),</span><br><span class="line">    mPremultipliedAlpha(<span class="literal">true</span>),</span><br><span class="line">    mName(<span class="string">&quot;unnamed&quot;</span>),</span><br><span class="line">    mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">    ......&#123;</span><br><span class="line">mCurrentCrop.makeInvalid();</span><br><span class="line">mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/15-Android-Graphics-App-WMS-SurfaceFlinger-Surface-SurfaceControl.png" alt="Markdown"></p>
<p>到目前为止，应用程序和WMS一共创建了3个Java层Surface（SurfaceControl）对象，如上图所示，而真正能用于绘图的Surface只有3号，那么3号Surface与2号Surface之间是什么关系呢？outSurface.copyFrom(surface)</p>
<p>[Surface.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[android_view_Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj))</span></span>;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。 [Surface.java]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        @Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dest == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;dest must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">        dest.writeInt(mIsSingleBuffered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        nativeWriteToParcel(mNativeObject, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[android_view_Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject parcelObj)</span> </span>&#123;</span><br><span class="line">Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line"><span class="keyword">if</span> (parcel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    doThrowNPE(env);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">self</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line">android::view::Surface surfaceShim;</span><br><span class="line"><span class="keyword">if</span> (self != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calling code in Surface.java has already written the name of the Surface</span></span><br><span class="line"><span class="comment">// to the Parcel</span></span><br><span class="line">surfaceShim.writeToParcel(parcel, <span class="comment">/*nameAlreadyWritten*/</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;source must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// nativeReadFromParcel() will either return mNativeObject, or</span></span><br><span class="line">        <span class="comment">// create a new native Surface and return it after reducing</span></span><br><span class="line">        <span class="comment">// the reference count on mNativeObject.  Either way, it is</span></span><br><span class="line">        <span class="comment">// not necessary to call nativeRelease() here.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        mName = source.readString();</span><br><span class="line">        mIsSingleBuffered = source.readInt() != <span class="number">0</span>;</span><br><span class="line">        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj))</span></span>;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。</p>
<h4 id="4-2-4-2、生产者Producer构造过程"><a href="#4-2-4-2、生产者Producer构造过程" class="headerlink" title="4.2.4.2、生产者Producer构造过程"></a>4.2.4.2、生产者Producer构造过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例化BufferQueueProducer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueProducer::BufferQueueProducer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName(),</span><br><span class="line">    mStickyTransform(<span class="number">0</span>),</span><br><span class="line">    mLastQueueBufferFence(Fence::NO_FENCE),</span><br><span class="line">    mCallbackMutex(),</span><br><span class="line">    mNextCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCurrentCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCallbackCondition(),</span><br><span class="line">    mDequeueTimeout(<span class="number">-1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-3、消费者Consumer构造过程"><a href="#4-2-4-3、消费者Consumer构造过程" class="headerlink" title="4.2.4.3、消费者Consumer构造过程"></a>4.2.4.3、消费者Consumer构造过程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core))</span></span>;</span><br><span class="line"><span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例化BufferQueueConsumer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueConsumer::BufferQueueConsumer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-4、SurfaceFlinger设置监听"><a href="#4-2-4-4、SurfaceFlinger设置监听" class="headerlink" title="4.2.4.4、SurfaceFlinger设置监听"></a>4.2.4.4、SurfaceFlinger设置监听</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/16-Android-Graphics-App-Ask-SurfaceFlinger-ConsumeLisener-onFrameAvailable.png" alt="Markdown"></p>
<h4 id="4-2-4-5、应用程序本地窗口Surface创建过程"><a href="#4-2-4-5、应用程序本地窗口Surface创建过程" class="headerlink" title="4.2.4.5、应用程序本地窗口Surface创建过程"></a>4.2.4.5、应用程序本地窗口Surface创建过程</h4><p>从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？</p>
<p>为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。 [-&gt;SurfaceControl.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::getSurface</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mutex::Autolock _l(mLock);</span><br><span class="line"><span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn&#x27;t matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">: mGraphicBufferProducer(bufferProducer),</span><br><span class="line">  mCrop(Rect::EMPTY_RECT),</span><br><span class="line">  mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">  mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">  mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">  mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">  mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">  mNextFrameNumber(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">ANativeWindow::query            = hook_query;</span><br><span class="line">ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mReqWidth = <span class="number">0</span>;</span><br><span class="line">mReqHeight = <span class="number">0</span>;</span><br><span class="line">mReqFormat = <span class="number">0</span>;</span><br><span class="line">mReqUsage = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。</p>
<h4 id="4-2-4-5、执行窗口布局performLayout"><a href="#4-2-4-5、执行窗口布局performLayout" class="headerlink" title="4.2.4.5、执行窗口布局performLayout()"></a>4.2.4.5、执行窗口布局performLayout()</h4><p>[-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">                ......</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-7、执行窗口绘制performDraw"><a href="#4-2-4-7、执行窗口绘制performDraw" class="headerlink" title="4.2.4.7、执行窗口绘制performDraw()"></a>4.2.4.7、执行窗口绘制performDraw()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125;  ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Android是怎样将View画出来的？由于之前我们已经关闭了HWC、GPU、HWUI，这里只关注软件绘制。 [-&gt;ViewRootImpl.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于渲染这个流程很复杂，我们后续章节再分析。</p>
<h2 id="4-3、APP申请-lock-Buffer的过程"><a href="#4-3、APP申请-lock-Buffer的过程" class="headerlink" title="4.3、APP申请(lock)Buffer的过程"></a>4.3、APP申请(lock)Buffer的过程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/17-Android-Graphics-App-SurfaceFlinger-lock-unlockpost.png" alt="Markdown"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ......</span><br><span class="line">    &#125; ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看Surface的lockCanvas方法： [-&gt;Surface.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mCanvas 变量直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    checkNotReleasedLocked();</span><br><span class="line">    ......</span><br><span class="line">    mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取java层的Surface保存的long型句柄</span></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取java层dirty Rect的位置大小信息</span></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">    dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">    dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">    dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">    dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line"> <span class="comment">//调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?</span><br><span class="line">                                     kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">SkBitmap bitmap;</span><br><span class="line"><span class="comment">//创建一个SkBitmap</span></span><br><span class="line"><span class="comment">//图形缓冲区每一行像素大小</span></span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">bitmap.setInfo(info, bpr);</span><br><span class="line"><span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    bitmap.setPixels(outBuffer.bits);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">    bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">    nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">            dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</span><br><span class="line">lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line"><span class="keyword">return</span> (jlong) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑主要如下： 1）获取java层dirty 的Rect大小和位置信息； 2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer； 3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象； 4）将剪裁位置大小信息赋给java层Canvas对象。</p>
<h3 id="4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程"><a href="#4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程" class="headerlink" title="4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程"></a>4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</h3><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。 [-&gt;Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;dequeueBuffer failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backBufferSlot</span><span class="params">(getSlotFromBufferLocked(backBuffer.get()))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">copyback</span><span class="params">(oldDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can&#x27;t copy-back anything, modify the user&#x27;s dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt;&amp; <span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p>
<h2 id="4-4、APP提交-unlockAndPost-Buffer的过程"><a href="#4-4、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="4.4、APP提交(unlockAndPost)Buffer的过程"></a>4.4、APP提交(unlockAndPost)Buffer的过程</h2><p>Surface绘制完毕后，unlockCanvasAndPost操作。 [-&gt;android_view_Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。 [-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。 Folw：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/18-Android-Graphics-App-WMS-SurfaceFlinger-All-Flow.png" alt="Markdown"></p>
<h2 id="（五）、通知SF消费合成"><a href="#（五）、通知SF消费合成" class="headerlink" title="（五）、通知SF消费合成"></a>（五）、通知SF消费合成</h2><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。 listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现： [Layer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">&#123; <span class="comment">// Autolock scope</span></span><br><span class="line">    ......</span><br><span class="line">    mQueueItems.push_back(item);</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">    mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">    mQueueItemCondition.broadcast();</span><br><span class="line">&#125;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看： [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用MessageQueue的invalidate函数： [MessageQueue.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/19-Android-Graphics-vsync-surfaceflinger.png" alt="Markdown"></p>
<p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数： [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX;</span><br><span class="line">        ATRACE_INT(<span class="string">&quot;FrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">        <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">            signalLayerUpdate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">        refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">        refreshNeeded |= mRepaintEverything;</span><br><span class="line">        <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">            <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">            <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">            <span class="comment">// repaint</span></span><br><span class="line">            signalRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">    mHadClientComposition = mHadClientComposition ||</span><br><span class="line">            mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    layer-&gt;releasePendingBuffer();</span><br><span class="line">&#125;</span><br><span class="line">mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要看下下面几个函数。 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br></pre></td></tr></table></figure>

<h3 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h3><p>我们先来看第一个函数preComposition() [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。 记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; lbc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">// add this layer to the current state list</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(IInterface::asBinder(gbc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach this layer to the client</span></span><br><span class="line">client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。 回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。</p>
<h2 id="1-1、每个Layer的onFrameAvailable函数"><a href="#1-1、每个Layer的onFrameAvailable函数" class="headerlink" title="1.1、每个Layer的onFrameAvailable函数"></a>1.1、每个Layer的onFrameAvailable函数</h2><p>onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。 [Layer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Layer::onPreComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged || mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。 在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。 SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数 最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理 handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。</p>
<h2 id="1-2、绘制流程"><a href="#1-2、绘制流程" class="headerlink" title="1.2、绘制流程"></a>1.2、绘制流程</h2><p>用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。</p>
<h3 id="二、handleTransaction-handPageFlip更新Layer对象"><a href="#二、handleTransaction-handPageFlip更新Layer对象" class="headerlink" title="二、handleTransaction handPageFlip更新Layer对象"></a>二、handleTransaction handPageFlip更新Layer对象</h3><p>在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。</p>
<h2 id="2-1、handleTransaction函数"><a href="#2-1、handleTransaction函数" class="headerlink" title="2.1、handleTransaction函数"></a>2.1、handleTransaction函数</h2><p>handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数 handleTransactionLocked。 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransaction</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">Mutex::Autolock _l(mStateLock);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInTransaction = now;</span><br><span class="line"></span><br><span class="line">transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">handleTransactionLocked(transactionFlags);</span><br><span class="line"></span><br><span class="line">mLastTransactionTime = systemTime() - now;</span><br><span class="line">mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">invalidateHwcGeometry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。 handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。</p>
<h2 id="2-2、Layer的doTransaction函数"><a href="#2-2、Layer的doTransaction函数" class="headerlink" title="2.2、Layer的doTransaction函数"></a>2.2、Layer的doTransaction函数</h2><p>下面是Layer的doTransaction函数代码 [Layer.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">pushPendingState();<span class="comment">//上次绘制的State对象  </span></span><br><span class="line">Layer::State c = getCurrentState();<span class="comment">//当前使用的State对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                         (c.requested.h != s.requested.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">    <span class="comment">// the size changed, we need to ask our client to request a new buffer</span></span><br><span class="line">    <span class="comment">//如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸</span></span><br><span class="line">    <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">    <span class="comment">// a buffer, it&#x27;ll get the new size.</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">            c.requested.w, c.requested.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">        (c.requested.h != c.active.h);</span><br><span class="line"><span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resizePending &amp;&amp; mSidebandStream == NULL) &#123;</span><br><span class="line">    <span class="comment">//如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小  </span></span><br><span class="line">        flags |= eDontUpdateGeometryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有eDontUpdateGeometryState标志，更新active的值为request  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">    <span class="keyword">if</span> (mFreezePositionUpdates) &#123;</span><br><span class="line">        <span class="keyword">float</span> tx = c.active.transform.tx();</span><br><span class="line">        <span class="keyword">float</span> ty = c.active.transform.ty();</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">        c.active.transform.set(tx, ty);</span><br><span class="line">        editCurrentState.active = c.active;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editCurrentState.active = editCurrentState.requested;</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前state的active和以前的State的active不等，设置更新标志  </span></span><br><span class="line"><span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前state的sequence和以前state的sequence不等，设置更新标志</span></span><br><span class="line"><span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t type = c.active.transform.getType();</span><br><span class="line">    mNeedsFiltering = (!c.active.transform.preserveRects() ||</span><br><span class="line">            (type &gt;= Transform::SCALE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layer is hidden, signal and clear out all local sync points so</span></span><br><span class="line"><span class="comment">// that transactions for layers depending on this layer&#x27;s frames becoming</span></span><br><span class="line"><span class="comment">// visible are not blocked</span></span><br><span class="line"><span class="keyword">if</span> (c.flags &amp; layer_state_t::eLayerHidden) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; point : mLocalSyncPoints) &#123;</span><br><span class="line">        point-&gt;setFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mLocalSyncPoints.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">commitTransaction(c);</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。 Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。 State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。 State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。 layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。 sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。 doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState [Layer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::commitTransaction</span><span class="params">(<span class="keyword">const</span> State&amp; stateToCommit)</span> </span>&#123;</span><br><span class="line">mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、handleTransactionLocked函数"><a href="#2-3、handleTransactionLocked函数" class="headerlink" title="2.3、handleTransactionLocked函数"></a>2.3、handleTransactionLocked函数</h3><p>下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析</p>
<p>2.3.1 处理Layer的事务 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">currentLayers</span><span class="params">(mCurrentState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify all layers of available frames</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    currentLayers[i]-&gt;notifyAvailableFrames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">            mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象 这里用两个变量的目的是和Layer中使用两个变量是一样的。 上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true</p>
<h3 id="2-3-2、处理显示设备的变化"><a href="#2-3-2、处理显示设备的变化" class="headerlink" title="2.3.2、处理显示设备的变化"></a>2.3.2、处理显示设备的变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="comment">// here we take advantage of Vector&#x27;s copy-on-write semantics to</span></span><br><span class="line">    <span class="comment">// improve performance by skipping the transaction entirely when</span></span><br><span class="line">    <span class="comment">// know that the lists are identical</span></span><br><span class="line">    const KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    const KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">              <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the displays that were removed</span></span><br><span class="line">        <span class="comment">// (ie: in drawing state but not in current state)</span></span><br><span class="line">        <span class="comment">// also handle displays that changed</span></span><br><span class="line">        <span class="comment">// (ie: displays that are in both lists)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;dc ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (!draw[i].isMainDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Call makeCurrent() on the primary display so we can</span></span><br><span class="line">                    <span class="comment">// be sure that nothing associated with this display</span></span><br><span class="line">                    <span class="comment">// is current.</span></span><br><span class="line">                    <span class="function"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">defaultDisplay</span><span class="params">(getDefaultDisplayDevice())</span></span>;</span><br><span class="line">                    defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">                    <span class="function">sp&lt;DisplayDevice&gt; <span class="title">hw</span><span class="params">(getDisplayDevice(draw.keyAt(i)))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    <span class="keyword">if</span> (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(draw[i].type, <span class="literal">false</span>);</span><br><span class="line">                    mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;trying to remove the main display&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// this display is in both lists. see if something changed.</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="function"><span class="keyword">const</span> wp&lt;IBinder&gt;&amp; <span class="title">display</span><span class="params">(curr.keyAt(j))</span></span>;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    <span class="function">sp&lt;DisplayDevice&gt; <span class="title">hw</span><span class="params">(getDisplayDevice(display))</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--; i--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt; <span class="title">disp</span><span class="params">(getDisplayDevice(display))</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation)</span><br><span class="line">                            || (state.viewport != draw[i].viewport)</span><br><span class="line">                            || (state.frame != draw[i].frame))</span><br><span class="line">                    &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation,</span><br><span class="line">                                state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find displays that were added</span></span><br><span class="line">        <span class="comment">// (ie: in current state but not in drawing state)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;cc ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer,</span><br><span class="line">                        <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int32_t</span> hwcDisplayId = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Virtual displays without a surface are dormant:</span></span><br><span class="line">                    <span class="comment">// they have external state (layer stack, projection,</span></span><br><span class="line">                    <span class="comment">// etc.) but no internal state (i.e. a DisplayDevice).</span></span><br><span class="line">                    <span class="keyword">if</span> (state.surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">                        DisplayUtils* displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                        <span class="keyword">int</span> status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">&quot;Unable to query width (%d)&quot;</span>, status);</span><br><span class="line">                        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">                        status = state.surface-&gt;query(</span><br><span class="line">                            NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                            <span class="string">&quot;Unable to query height (%d)&quot;</span>, status);</span><br><span class="line">                        <span class="keyword">if</span> (MAX_VIRTUAL_DISPLAY_DIMENSION == <span class="number">0</span> ||</span><br><span class="line">                            (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp;</span><br><span class="line">                             height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> usage = <span class="number">0</span>;</span><br><span class="line">                            status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage);</span><br><span class="line">                            ALOGW_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">&quot;Unable to query usage (%d)&quot;</span>, status);</span><br><span class="line">                            <span class="keyword">if</span> ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                  displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface,</span><br><span class="line">                                dispSurface, producer, bqProducer, bqConsumer,</span><br><span class="line">                                state.displayName, state.isSecure, state.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface!=<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="string">&quot;adding a supported display, but rendering &quot;</span></span><br><span class="line">                            <span class="string">&quot;surface is provided (%p), ignoring it&quot;</span>,</span><br><span class="line">                            state.surface.get());</span><br><span class="line">                    hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                    <span class="comment">// for supported (by hwc) displays we provide our</span></span><br><span class="line">                    <span class="comment">// own rendering surface</span></span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(*mHwc, state.type,</span><br><span class="line">                            bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">const</span> wp&lt;IBinder&gt;&amp; <span class="title">display</span><span class="params">(curr.keyAt(i))</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">NULL</span> &amp;&amp; producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                            state.type, hwcDisplayId,</span><br><span class="line">                            mHwc-&gt;getFormat(hwcDisplayId), state.isSecure,</span><br><span class="line">                            display, dispSurface, producer,</span><br><span class="line">                            mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">                    hw-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    hw-&gt;setProjection(state.orientation,</span><br><span class="line">                            state.viewport, state.frame);</span><br><span class="line">                    hw-&gt;setDisplayName(state.displayName);</span><br><span class="line">                    <span class="comment">// When a new display device is added update the active</span></span><br><span class="line">                    <span class="comment">// config by querying HWC otherwise the default config</span></span><br><span class="line">                    <span class="comment">// (config 0) will be used.</span></span><br><span class="line">                    <span class="keyword">if</span> (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp;</span><br><span class="line">                            hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">                        <span class="keyword">int</span> activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId);</span><br><span class="line">                        <span class="keyword">if</span> (activeConfig &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            hw-&gt;setActiveConfig(activeConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.add(display, hw);</span><br><span class="line">                    <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hwcDisplayId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId,</span><br><span class="line">                                    hw-&gt;getWidth(), hw-&gt;getHeight(),</span><br><span class="line">                                    hw-&gt;getFormat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是处理显示设备的变化，分成3种情况： 1.显示设备减少了，需要把显示设备对应的DisplayDevice移除 2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性 3.显示设备增加了，创建新的DisplayDevice加入系统中。</p>
<h3 id="2-3-3、设置TransfromHit"><a href="#2-3-3、设置TransfromHit" class="headerlink" title="2.3.3、设置TransfromHit"></a>2.3.3、设置TransfromHit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we rely on the fact that layers are sorted by</span></span><br><span class="line">        <span class="comment">// layerStack first (so we don&#x27;t have to traverse the list</span></span><br><span class="line">        <span class="comment">// of displays for every layer).</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> layerStack = layer-&gt;getDrawingState().layerStack;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || currentlayerStack != layerStack) &#123;</span><br><span class="line">            currentlayerStack = layerStack;</span><br><span class="line">            <span class="comment">// figure out if this layerstack is mirrored</span></span><br><span class="line">            <span class="comment">// (more than one display) if so, pick the default display,</span></span><br><span class="line">            <span class="comment">// if not, pick the only display it&#x27;s on.</span></span><br><span class="line">            disp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (hw-&gt;getLayerStack() == currentlayerStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        disp = hw;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disp = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> TEMPORARY FIX ONLY. Real fix should cause layers to</span></span><br><span class="line">            <span class="comment">// redraw after transform hint changes. See bug 8508397.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// could be null when this layer is using a layerStack</span></span><br><span class="line">            <span class="comment">// that is not visible on any display. Also can occur at</span></span><br><span class="line">            <span class="comment">// screen off/on times.</span></span><br><span class="line">            disp = getDefaultDisplayDevice();</span><br><span class="line">        &#125;</span><br><span class="line">        layer-&gt;updateTransformHint(disp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。</p>
<h3 id="2-3-4、处理Layer增加情况"><a href="#2-3-4、处理Layer增加情况" class="headerlink" title="2.3.4、处理Layer增加情况"></a>2.3.4、处理Layer增加情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform our own transaction if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">    <span class="comment">// layers have been added</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some layers might have been removed, so</span></span><br><span class="line"><span class="comment">// we need to update the regions they&#x27;re exposing.</span></span><br><span class="line"><span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">            <span class="comment">//       compute the actual visible region</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">s</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">            Region visibleReg = s.active.transform.transform(</span><br><span class="line">                    Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">            invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。</p>
<h3 id="2-3-5、设置mDrawingState"><a href="#2-3-5、设置mDrawingState" class="headerlink" title="2.3.5、设置mDrawingState"></a>2.3.5、设置mDrawingState</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitTransaction();</span><br><span class="line">updateCursorAsync();</span><br></pre></td></tr></table></figure>

<p>调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。</p>
<p>2.3.6 小结 handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。</p>
<h2 id="2-4、handlePageFlip函数"><a href="#2-4、handlePageFlip函数" class="headerlink" title="2.4、handlePageFlip函数"></a>2.4、handlePageFlip函数</h2><p>handlePageFlip函数代码如下： [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Region dirtyRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line"><span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line"><span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line"><span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line"><span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line"><span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line"><span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line"><span class="comment">// Display is now waiting on Layer 1&#x27;s frame, which is behind layer 0&#x27;s</span></span><br><span class="line"><span class="comment">// second frame. But layer 0&#x27;s second frame could be waiting on display.</span></span><br><span class="line">Vector&lt;Layer*&gt; layersWithQueuedFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layers.size(); i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">        frameQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">            layersWithQueuedFrames.push_back(layer.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;useEmptyDamage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123;</span><br><span class="line">    Layer* layer = layersWithQueuedFrames[i];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions))</span></span>;</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">s</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">    invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line"><span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line"><span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line"><span class="keyword">return</span> !layersWithQueuedFrames.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。 我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1. 继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。 下面我们看看latchBuffer函数</p>
<p>LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。 如果不需要推迟处理，把mQueuedFrames的值减1. 最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。</p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。</p>
<h2 id="三、rebuildLayerStacks函数"><a href="#三、rebuildLayerStacks函数" class="headerlink" title="三、rebuildLayerStacks函数"></a>三、rebuildLayerStacks函数</h2><p>前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">updateExtendedMode();</span><br><span class="line"><span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line"><span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">    invalidateHwcGeometry();</span><br><span class="line">    <span class="comment">//计算每个显示设备上可见的Layer  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        Region opaqueRegion;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">        Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Transform&amp; <span class="title">tr</span><span class="params">(hw-&gt;getTransform())</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(hw-&gt;getBounds())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">//计算每个layer的可见区域，确定设备需要重新绘制的区域  </span></span><br><span class="line">            computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers,</span><br><span class="line">                    hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(layers[i])</span></span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只需要和显示设备的LayerStack相同的layer  </span></span><br><span class="line">                    <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line"><span class="function"><span class="params">                            layer-&gt;visibleNonTransparentRegion))</span></span>;</span><br><span class="line">                    drawRegion.andSelf(bounds);</span><br><span class="line">                    <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果Layer的显示区域和显示设备的窗口有交集  </span></span><br><span class="line">                        <span class="comment">//把Layer加入列表中</span></span><br><span class="line">                        layersSortedByZ.add(layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置显示设备的可见Layer列表  </span></span><br><span class="line">        hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">        hw-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">        hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。 computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。 而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。 其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。</p>
<h3 id="四、setUpHWComposer函数"><a href="#四、setUpHWComposer函数" class="headerlink" title="四、setUpHWComposer函数"></a>四、setUpHWComposer函数</h3><p>setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。 [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setUpHWComposer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到系统HWComposer对象  </span></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">hwc</span><span class="params">(getHwComposer())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">        mHwWorkListDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">                <span class="comment">//根据Layer数量在HWComposer中创建hwc_layer_list_t列表  </span></span><br><span class="line">                <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                        layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                        <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;</span><br><span class="line">                            cur-&gt;setSkip(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> freezeSurfacePresent = <span class="literal">false</span>;</span><br><span class="line">            isfreezeSurfacePresent(freezeSurfacePresent, hw, id);</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                 * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                <span class="comment">//将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">                layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                setOrientationEventControl(freezeSurfacePresent,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If possible, attempt to use the cursor overlay on each display.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> sp&lt;Layer&gt;&amp; <span class="title">layer</span><span class="params">(currentLayers[i])</span></span>;</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isPotentialCursor()) &#123;</span><br><span class="line">                    cur-&gt;setIsCursorLayerHint();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;HWComposer::prepare failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        hw-&gt;prepareFrame(hwc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。 setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组 创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。 HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。</p>
<h3 id="五、合成所有层的图像-（doComposition-函数）"><a href="#五、合成所有层的图像-（doComposition-函数）" class="headerlink" title="五、合成所有层的图像 （doComposition()函数）"></a>五、合成所有层的图像 （doComposition()函数）</h3><p>doComposition函数是合成所有层的图像，代码如下： [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen&#x27;s coordinate space</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">dirtyRegion</span><span class="params">(hw-&gt;getDirtyRegion(repaintEverything))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        hw-&gt;dirtyRegion.clear();</span><br><span class="line">        hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">        hw-&gt;swapRegion.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inform the h/w that we&#x27;re done compositing</span></span><br><span class="line">    hw-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br><span class="line">postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Region&amp; inDirtyRegion)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line"><span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line"><span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line"><span class="comment">// 2) There is work to be done (the dirty region isn&#x27;t empty)</span></span><br><span class="line"><span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGV(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the invalid region</span></span><br><span class="line"><span class="comment">//swapRegion设置为需要更新的区域  </span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();<span class="comment">//获得显示设备支持的更新方式标志  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">    <span class="comment">// we can redraw only what&#x27;s dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">    <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">    <span class="comment">// rectangle in that case</span></span><br><span class="line">    dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;<span class="comment">//支持部分更新  </span></span><br><span class="line">        <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">        <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">        <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">        <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">        <span class="comment">//将更新区域调整为整个窗口大小  </span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">        hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合成  </span></span><br><span class="line"><span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"><span class="comment">//没有硬件composer的情况，输出图像</span></span><br><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。 真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。 合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。</p>
<h3 id="六、postFramebuffer-函数"><a href="#六、postFramebuffer-函数" class="headerlink" title="六、postFramebuffer()函数"></a>六、postFramebuffer()函数</h3><p>上一节的doComposition函数最后调用了postFramebuffer函数，代码如下： [SurfaceFlinger.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFramebuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">hwc</span><span class="params">(getHwComposer())</span></span>;</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">        <span class="comment">// EGL spec says:</span></span><br><span class="line">        <span class="comment">//   &quot;surface must be bound to the calling thread&#x27;s current context,</span></span><br><span class="line">        <span class="comment">//    for the current rendering API.&quot;</span></span><br><span class="line">        getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">    &#125;</span><br><span class="line">    hwc.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the default display current because the VirtualDisplayDevice code cannot</span></span><br><span class="line"><span class="comment">// deal with dequeueBuffer() being called outside of the composition loop; however</span></span><br><span class="line"><span class="comment">// the code below can call glFlush() which is allowed (and does in some case) call</span></span><br><span class="line"><span class="comment">// dequeueBuffer().</span></span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; <span class="title">currentLayers</span><span class="params">(hw-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">    hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">    <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;=<span class="number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line"><span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">    logFrameStats();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。 [HWComposer.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line"><span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">// On version 1.0, the OpenGL ES target surface is communicated</span></span><br><span class="line">        <span class="comment">// by the (dpy, sur) fields and we are guaranteed to have only</span></span><br><span class="line">        <span class="comment">// a single display.</span></span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;dpy = eglGetCurrentDisplay();</span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;sur = eglGetCurrentSurface(EGL_DRAW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (disp.outbufHandle) &#123;</span><br><span class="line">            mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">            mLists[i]-&gt;outbufAcquireFenceFd =</span><br><span class="line">                    disp.outbufAcquireFence-&gt;dup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = mHwc-&gt;<span class="built_in">set</span>(mHwc, mNumDisplays, mLists);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        disp.lastDisplayFence = disp.lastRetireFence;</span><br><span class="line">        disp.lastRetireFence = Fence::NO_FENCE;</span><br><span class="line">        <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;retireFenceFd != <span class="number">-1</span>) &#123;</span><br><span class="line">                disp.lastRetireFence = <span class="keyword">new</span> Fence(disp.<span class="built_in">list</span>-&gt;retireFenceFd);</span><br><span class="line">                disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disp.<span class="built_in">list</span>-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合成效果图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/20-Android-Graphics-SurfaceFlinger-composition.png" alt="Markdown"></p>
<h2 id="（六）、Android-SurfaceFlinger-VSync工作原理"><a href="#（六）、Android-SurfaceFlinger-VSync工作原理" class="headerlink" title="（六）、Android SurfaceFlinger - VSync工作原理"></a>（六）、Android SurfaceFlinger - VSync工作原理</h2><h3 id="一、VSYNC-总体概念"><a href="#一、VSYNC-总体概念" class="headerlink" title="一、VSYNC 总体概念"></a>一、VSYNC 总体概念</h3><h3 id="6-1-1、VSYNC-概念"><a href="#6-1-1、VSYNC-概念" class="headerlink" title="6.1.1、VSYNC 概念"></a>6.1.1、VSYNC 概念</h3><p>VSYNC（Vertical Synchronization）是一个相当古老的概念，对于游戏玩家，它有一个更加大名鼎鼎的中文名字—垂直同步。 “垂直同步(vsync)”指的是显卡的输出帧数和屏幕的垂直刷新率相同，这完全是一个CRT显示器上的概念。其实无论是VSYNC还是垂直同步这个名字，因为LCD根本就没有垂直扫描的这种东西，因此这个名字本身已经没有意义。但是基于历史的原因，这个名称在图形图像领域被沿袭下来。 在当下，垂直同步的含义我们可以理解为，使得显卡生成帧的速度和屏幕刷新的速度的保持一致。举例来说，如果屏幕的刷新率为60Hz，那么生成帧的速度就应该被固定在1/60 s。</p>
<h3 id="6-1-2、Android-VSYNC-–-黄油计划"><a href="#6-1-2、Android-VSYNC-–-黄油计划" class="headerlink" title="6.1.2、Android VSYNC – 黄油计划"></a>6.1.2、Android VSYNC – 黄油计划</h3><p>谷歌为解决Android系统流畅性问题。在4.1版本引入了一个重大的改进–Project Butter黄油计划。 Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。 VSYNC最重要的作用是防止出现画面撕裂（screentearing）。所谓画面撕裂，就是指一个画面上出现了两帧画面的内容，如下图。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/21-Android-graphics-view-teaning.png" alt="Markdown"></p>
<p>为什么会出现这种情况呢？这种情况一般是因为显卡输出帧的速度高于显示器的刷新速度，导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题。这也就是我们所说的画面撕裂。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/22-Android-Graphics-Draw-whithout-vsync.png" alt="Markdown"></p>
<p>这个图中有三个元素，Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等。VSync用于指导双缓冲区的交换。 以时间的顺序来看下将会发生的异常： Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成 Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧 Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理 Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。这种情况被Android开发组命名为”Jank”。 Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。 所以总的来说，就是屏幕平白无故地多显示了一次第1帧。原因大家应该都看到了，就是CPU没有及时地开始着手处理第2帧的渲染工作，以致”延误军机”。</p>
<p>其实总结上面的这个情况之所以发生，首先的原因就在于第二帧没有及时的绘制（当然即使第二帧及时绘制，也依然可能出现Jank，这就是同时引入三重缓冲的作用。我们将在三重缓冲一节中再讲解这种情况）。那么如何使得第二帧即使被绘制呢？ 这就是我们在Graphic系统中引入VSYNC的原因，考虑下面这张图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/23-Android-Graphics-Draw-whit-vsync.png" alt="Markdown"></p>
<p>如上图所示，一旦VSync出现后，立刻就开始执行下一帧的绘制工作。这样就可以大大降低Jank出现的概率。另外，VSYNC引入后，要求绘制也只能在收到VSYNC消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现—CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况—引入VSYNC后，绘制的速度就和屏幕刷新的速度保持一致了。</p>
<h3 id="二、VSync信号产生"><a href="#二、VSync信号产生" class="headerlink" title="二、VSync信号产生"></a>二、VSync信号产生</h3><p>那么VSYNC信号是如何生成的呢？ Android系统中VSYNC信号分为两种，一种是硬件生成的信号，一种是软件模拟的信号。 硬件信号是由HardwareComposer提供的，HWC封装了相关的HAL层，如果硬件厂商提供的HAL层实现能定时产生VSYNC中断，则直接使用硬件的VSYNC中断，否则HardwareComposer内部会通过VSyncThread来模拟产生VSYNC中断（其实现很简单，就是sleep固定时间，然后唤醒）。</p>
<p>SurfaceFlinger的启动过程中inti()会创建一个HWComposer对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">&quot;debug.sf.no_hw_vsync&quot;</span>, value, <span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don&#x27;t need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don&#x27;t have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">&quot;debug.sf.no_hw_vsync&quot;</span>, value, <span class="string">&quot;0&quot;</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don&#x27;t need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don&#x27;t have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下上面这段代码。 首先mDebugForceFakeVSync是为了调制，可以通过这个变量设置强制使用软件VSYNC模拟。 然后针对不同的屏幕，初始化了他们的mLastHwVSync和mVSyncCounts值。 如果硬件支持，那么就把needVSyncThread设置为false，表示不需要软件模拟。 接着通过eventControl来暂时的关闭了VSYNC信号，这一点将在下面讲解eventControl时一并讲解。 最后，如果需要软件模拟Vsync信号的话，那么我们将通过一个单独的VSyncThread线程来做这个工作(fake VSYNC是这个线程唯一的作用)。我们来看下这个线程。</p>
<p><strong>软件模拟</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period = mRefreshPeriod;  </span><br><span class="line">    <span class="comment">//当前的时间  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime(CLOCK_MONOTONIC);  </span><br><span class="line">    <span class="comment">//下一次VSYNC到来的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> next_vsync = mNextFakeVSync;  </span><br><span class="line">    <span class="comment">//为了等待下个时间到来应该休眠的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> sleep = next_vsync - now;  </span><br><span class="line">    <span class="comment">//错过了VSYNC的时间  </span></span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// we missed, find where the next vsync should be  </span></span><br><span class="line">        <span class="comment">//重新计算下应该休息的时间  </span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));  </span><br><span class="line">        <span class="comment">//更新下次VSYNC的时间  </span></span><br><span class="line">        next_vsync = now + sleep;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//更新下下次VSYNC的时间  </span></span><br><span class="line">    mNextFakeVSync = next_vsync + period;  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">spec</span>;</span>  </span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;  </span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="comment">//纳秒精度级的休眠  </span></span><br><span class="line">        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//休眠之后，到了该发生VSYNC的时间了  </span></span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数其实很简单，无非就是一个简单的时间计算，计算过程我已经写在了程序注释里面。总之到了应该发生VSYNC信号的时候，就调用了mHwc.mEventHandler.onVSyncReceived(0, next_vsync)函数来通知VSYNC的到来。</p>
<p>我们注意到mEventHandler实际上是在HWC创建时被传入的，我们来看下HWC创建时的代码.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,  </span><br><span class="line">        *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> <span class="keyword">public</span> BnSurfaceComposer,  </span><br><span class="line">                   <span class="keyword">private</span> IBinder::DeathRecipient,  </span><br><span class="line">                   <span class="keyword">private</span> HWComposer::EventHandler</span><br></pre></td></tr></table></figure>

<p>可以看到这个mEventHandler实际上就是SurfaceFlinger。也就是说，VSYNC信号到来时，SurfaceFlinger的onVSyncReceived函数处理了这个消息。 这里我们暂时先不展开SurfaceFlinger内的逻辑处理，等我们下面分析完硬件实现后，一并进行分析</p>
<p><strong>硬件实现</strong> 上面我们讲了软件如何模拟一个VSYNC信号并通知SurfaceFlinger,那么硬件又是如何实现这一点的呢？ 我们再一次回到HWC的创建过程中来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mHwc) &#123;  </span><br><span class="line">       ALOGE(<span class="string">&quot;Lee Using %s version %u.%u&quot;</span>, HWC_HARDWARE_COMPOSER,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);  </span><br><span class="line">       <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;  </span><br><span class="line">           mCBContext-&gt;hwc = <span class="keyword">this</span>;  </span><br><span class="line">           mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;  </span><br><span class="line">           mCBContext-&gt;procs.vsync = &amp;hook_vsync;  </span><br><span class="line">           <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;  </span><br><span class="line">           <span class="keyword">else</span>  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;  </span><br><span class="line">           <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));  </span><br><span class="line">           mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>来看下上面这段实现。 当HWC有vsync信号生成时，硬件模块会通过procs.vsync来通知软件部分，因此也就是调用了hook_vsync函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HWComposer::hook_vsync</span><span class="params">(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int64_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));  </span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HWComposer::vsync</span><span class="params">(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//只有真实的硬件设备才会产生VSYNC  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;  </span><br><span class="line">        &#123;  </span><br><span class="line">            mLastHwVSync[disp] = timestamp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现最后殊途同归，硬件信号最终也通过onVSyncReceived函数通知到了SurfaceFlinger了。下面我们来分析下SurfaceFlinger的处理过程。</p>
<h3 id="三、Surfaceflinger对VSYNC消息的处理"><a href="#三、Surfaceflinger对VSYNC消息的处理" class="headerlink" title="三、Surfaceflinger对VSYNC消息的处理"></a>三、Surfaceflinger对VSYNC消息的处理</h3><p>先来直接看下Surfaceflinger的onVSyncReceived函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onVSyncReceived</span><span class="params">(<span class="keyword">int32_t</span> type, <span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPrimaryDispSync是什么？addResyncSample有什么作用？ 要回答这三个问题，我们首先还是得回到SurfaceFlinger的init函数中来。</p>
<h3 id="6-3-1、Surfaceflinger-init"><a href="#6-3-1、Surfaceflinger-init" class="headerlink" title="6.3.1、Surfaceflinger.init()"></a>6.3.1、Surfaceflinger.init()</h3><p>先看一下总体flow：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/24-Android-Graphics-Vsync-surfaceflinger.init.png" alt="Markdown"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(  <span class="string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span></span><br><span class="line">            <span class="string">&quot;Initializing graphics H/W...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// start the EventThread</span></span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line">        mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = <span class="keyword">new</span> EventControlThread(<span class="keyword">this</span>);</span><br><span class="line">    mEventControlThread-&gt;run(<span class="string">&quot;EventControl&quot;</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2个EventThread对象分别是mEventThread，给app用，mSFEventThread，给surfaceflinger自己用。 下面给出这4个Thread关系图。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/25-Android-Graphics-SurfaceFlinger.init.DispSyncThread.png.png" alt="Markdown"></p>
<p>这两个DispSyncSource就是KK引入的重大变化。Android 4.4(KitKat)引入了VSync的虚拟化，即把硬件的VSync信号先同步到一个本地VSync模型中，再从中一分为二，引出两条VSync时间与之有固定偏移的线程。示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/26-Android-Graphics-SurfaceFlinger-App-Vsync-offset.png.png" alt="Markdown"></p>
<p>Google这样修改的目的又是什么呢？ =在当前三重缓冲区的架构下，即对于一帧内容，先等App UI画完了，SurfaceFlinger再出场对其进行合并渲染后放入framebuffer，最后整到屏幕上。而现有的VSync模型是让大家一起开始干活。 这个架构其实会产生一个问题，因为App和SurfaceFlinger被同时唤醒，导致他们二者总是一起工作，必然导致VSync来临的时刻，这二者之间产生了CPU资源的抢占。因此，谷歌给这两个工作都加上一个小小的延迟，让这两个工作并不是同时被唤醒，这样大家就可以错开使用资源的高峰期，提高工作的效率。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/27-Android-graphics-SurfaceFlinger-Vsync-app-sf.png" alt="Markdown"></p>
<p>这两个延迟，其实就分别对应上面代码中的vsyncSrc（绘制延迟）和sfVsyncSrc（合成延迟）。 在创建了两个DispSyncSource变量后，我们使用它们来初始化了两个EventThread。下面我们来详细看下EventThread的创建流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(<span class="keyword">const</span> sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mFlinger(flinger),</span><br><span class="line">      mUseSoftwareVSync(<span class="literal">false</span>),</span><br><span class="line">      mVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mDebugVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mVsyncHintSent(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].vsync.count =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">se</span>;</span></span><br><span class="line">    se.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr = <span class="keyword">this</span>;</span><br><span class="line">    se.sigev_notify_function = vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    run(<span class="string">&quot;EventThread&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventThread的构造函数很简单。重点是它的onFirstRef函数启动了一个EventThread线程，于是下面的代码才是重点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数本身并不复杂，其中调用了一个waitForEvent的函数。这个函数相当之长，为了防止代码展开太多，我们这里暂时不再详细分析这个函数。我们目前只需要知道这个函数的最重要的作用是等待Event的到来，并且查找对event感兴趣的监听者，而在没有event到来时，线程处于休眠状态，等待event的唤醒（我们将下一篇VSYNC的接收和处理中展开分析这个函数）。 这样，EventThread线程就运行起来，处在等待被event唤醒的状态下。 <strong>MessageQueue和EventThread建立连接</strong> 简单说明完EventThread之后，我们再次回到SurfaceFlinger的init过程中来。回到init()函数代码中来： 将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接，这样SurfaceFlinger才能真正接收到来自HWC的VSYNC信号。 我们来看下这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    mEventThread = eventThread;  </span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();  </span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();  </span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,  </span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码逻辑其实很简单，就是创建了一个到EventThread的连接，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。 <strong>向Eventhread注册一个事件的监听者—-createEventConnection</strong> 在SurfaceFlinger的init函数中，我们调用了mEventQueue.setEventThread(mSFEventThread)函数，我们在前面一章中已经提到过，这个函数将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接。我们来看下这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThread::Connection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">EventThread::Connection::Connection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;  </span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;  </span><br><span class="line">    mDisplayEventConnections.add(connection);  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会导致一个Connection类的创建，而这个connection类会被保存在EventThread下的一个容器内。 通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p>
<h3 id="6-3-2、VSync信号的处理"><a href="#6-3-2、VSync信号的处理" class="headerlink" title="6.3.2、VSync信号的处理"></a>6.3.2、VSync信号的处理</h3><p>我们在前面一章也提到了无论是软件方式还是硬件方式，SurfaceFlinger收到VSync信号后，处理函数都是onVSyncReceived函数：</p>
<p><strong>VSync消息处理—-addResyncSample</strong><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/28-Android-Graphics-SF-Vsync-addResyncSample.png.png" alt="Markdown"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">    mResyncSamples[idx] = timestamp;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    updateModelLocked();  </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗略浏览下这个函数，发现前半部分其实在做一些简单的计数统计，重点实现显然是updateModelLocked函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DispSync::updateModelLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;  </span><br><span class="line">        <span class="keyword">nsecs_t</span> durationSum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            <span class="keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            <span class="keyword">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            durationSum += mResyncSamples[idx] - mResyncSamples[prev];  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> sampleAvgX = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">double</span> sampleAvgY = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="keyword">double</span>(mPeriod);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            <span class="keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            <span class="keyword">nsecs_t</span> sample = mResyncSamples[idx];  </span><br><span class="line">            <span class="keyword">double</span> samplePhase = <span class="keyword">double</span>(sample % mPeriod) * scale;  </span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);  </span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="keyword">double</span>(mNumResyncSamples);  </span><br><span class="line">        sampleAvgY /= <span class="keyword">double</span>(mNumResyncSamples);  </span><br><span class="line"></span><br><span class="line">        mPhase = <span class="keyword">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);  </span><br><span class="line">        ......</span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不得不说，前面大段的数学计算让人有些困惑，我们暂且跳过，先分析下主线流程，也就是mThread-&gt;updateModel(mPeriod, mPhase)这个调用：</p>
<p><strong>DispSyncThread.updateModel的用途</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(<span class="keyword">nsecs_t</span> period, <span class="keyword">nsecs_t</span> phase)</span> </span>&#123;  </span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">    mPeriod = period;  </span><br><span class="line">    mPhase = phase;  </span><br><span class="line">    mCond.signal();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>updateModel是DispSyncThread类的函数，这个函数本身代码很短，其实它的主要作用是mCond.signal发送一个信号给等待中的线程。那么究竟是谁在等待这个条件呢？ 其实等待这个条件的正是DispSyncThread的循环函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">status_t</span> err;  </span><br><span class="line">      <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">      <span class="keyword">nsecs_t</span> nextEventTime = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">          Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">          <span class="keyword">nsecs_t</span> targetTime = <span class="number">0</span>;  </span><br><span class="line">          &#123; <span class="comment">// Scope for lock  </span></span><br><span class="line">              <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">              ......</span><br><span class="line">              <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;  </span><br><span class="line">                  err = mCond.wait(mMutex);  </span><br><span class="line">                  ......</span><br><span class="line">              &#125;  </span><br><span class="line">              nextEventTime = computeNextEventTimeLocked(now);  </span><br><span class="line">              targetTime = nextEventTime;  </span><br><span class="line">              ......</span><br><span class="line">              &#125;  </span><br><span class="line">              now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">              ......</span><br><span class="line">              callbackInvocations = gatherCallbackInvocationsLocked(now);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              fireCallbackInvocations(callbackInvocations);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>大量的时间相关的计算和状态的转变我们不再深入研究，我们来看下这个线程被通知唤醒之后做的两个主要的函数的处理，gatherCallbackInvocationsLocked()和fireCallbackInvocations()。</p>
<p>gatherCallbackInvocationsLocked()的代码其实很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> now)</span> </span>&#123;  </span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">    <span class="keyword">nsecs_t</span> ref = now - mPeriod;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">nsecs_t</span> t = computeListenerNextEventTimeLocked(mEventListeners[i],  </span><br><span class="line">                ref);  </span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;  </span><br><span class="line">            CallbackInvocation ci;  </span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;  </span><br><span class="line">            ci.mEventTime = t;  </span><br><span class="line">            callbackInvocations.push(ci);  </span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是从mEventListeners取出之前注册的事件监听者，放入callbackInvocations中，等待后面的调用。至于监听者从何处而来？在waitforevent时通过enableVSyncLocked注册的。</p>
<p>继续看下fireCallbackInvocations()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;  </span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<p>我们目前只分析主线的走向,接下来调用了DispSyncSource的onDispSyncEvent在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span> </span>&#123;  </span><br><span class="line">        sp&lt;VSyncSource::Callback&gt; callback;  </span><br><span class="line">        &#123;  </span><br><span class="line">            callback = mCallback;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            callback-&gt;onVSyncEvent(when);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onVSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;  </span><br><span class="line">    Mutex::Autolock _l(mLock);  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这里mCondition.broadcas发出了命令，那么EventThread中waitforEvent的等待就会被唤醒。而一旦唤醒，我们就回到了EventThread的loop中，我们来看下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventThread::threadLoop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    DisplayEventReceiver::Event event;  </span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;  </span><br><span class="line">    signalConnections = waitForEvent(&amp;event);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;  </span><br><span class="line">        <span class="comment">// now see if we still need to report this event  </span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);  </span><br><span class="line">        ......</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要就是通过conn-&gt;postEvent来分发事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(  </span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">DisplayEventReceiver::sendEvents</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,  </span></span></span><br><span class="line"><span class="function"><span class="params">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/29-Android-Graphics-App-SurfaceFlinger-Vsync-postEvent.png.png" alt="Markdown"></p>
<p>其实看到这里的BitTube我们就明白了，在本文开始时候我们提到：</p>
<p>通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p>
<p>所以我们这里可以来看看MessageQueue::cb_eventReceiver函数了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;  </span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> n;  </span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];  </span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;  </span><br><span class="line">                mHandler-&gt;dispatchInvalidate();  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到收到消息之后MessageQueue对消息进行了分发，我们目前走的是dispatchInvalidate()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;  </span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;  </span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:  </span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> REFRESH:  </span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:  </span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> </span>&#123;  </span><br><span class="line">    ATRACE_CALL();  </span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        handleMessageInvalidate();  </span><br><span class="line">        signalRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:  </span><br><span class="line">        handleMessageRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，就进入了SurfaceFlinger的处理流程，我们看到对于INVALIDATE的消息，实际上系统在处理过程中实际还是会发送一个Refresh消息。</p>
<h3 id="6-4、App向Eventhread注册一个事件的监听者–createEventConnection"><a href="#6-4、App向Eventhread注册一个事件的监听者–createEventConnection" class="headerlink" title="6.4、App向Eventhread注册一个事件的监听者–createEventConnection()"></a>6.4、App向Eventhread注册一个事件的监听者–createEventConnection()</h3><p>在ViewRootImpl的构造函数中会实例化Choreographer对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">                . . . . .</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在mChoreographer 的构造函数中实例化FrameDisplayEventReceiver对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">               . . . . . .</span><br><span class="line">               mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在FrameDisplayEventReceiver的父类构造函数中会调用到，android_view_DisplayEventReceiver.cpp中的nativeInit方法,在nativeInit方法中有如下过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    . . . . . .</span><br></pre></td></tr></table></figure>

<p>创建NativeDisplayEventReceiver类 类型指针 在NativeDisplayEventReceiver的构造函数中会调用DisplayEventReceiver类的无参构造函数实例化成员mReceiver；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中获取Surfaceflinger服务的代理对象，然后通过Binder IPC创建BpDisplayEventConnection对象 该函数经由BnSurfaceComposer.onTransact函数辗转调用到SurfaceFlinger.createDisplayEventConnection函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了熟悉的面孔mEventThread，该对象是一个EventThread对象，该对象在SurfaceFlinger.init函数里面创建，但是创建运行以后，貌似还没有进行任何的动作，这里调用createEventConnection函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThread::Connection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后mEventConnection-&gt;getDataChannel()方法再次通过Binder IPC创建 BitTube对象mDataChannel ，在Binder IPC创建mDataChannel 过程中会从服务端EventThread::Connection::Connection中（在EventThread类中定义）接收一个socketpair创建的FIFO文件描述符；</p>
<p>EventThread::Connection::Connection创建描述符的代码： Connection构造函数调用BitTube的无参构造函数，在BitTube的构造函数中调用init函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitTube::init</span><span class="params">(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// sine we don&#x27;t use the &quot;return channel&quot;, we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd = sockets[<span class="number">0</span>];</span><br><span class="line">        mSendFd = sockets[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd = -errno;</span><br><span class="line">        ALOGE(<span class="string">&quot;BitTube: pipe creation failed (%s)&quot;</span>, strerror(-mReceiveFd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到NativeDisplayEventReceiver类的父类DisplayEventDispatcher中的initialize()方法， 将BpDisplayEventConnection对象获取到的mDataChannel （BitTube类型）中的文件描述符添加到UI主线程Looper的epoll中， 当文件描述符中被写入数据时，该epoll_wait会被唤醒； 直接看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeDisplayEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要代码是mMessageQueue-&gt;getLooper()-&gt;addFd()这一行，其中的参数mReceiver.getFd()返回的是在创建NativeDisplayEventReceiver时从SurfaceFlinger服务端接收回来的socket接收端描述符，前面分析到 mMessageQueue是与当前应用线程关联的java层的MessageQueue对应的native层的MessageQueue对象，下面看一下Looper.addFd这个函数，上面调用时传进来的this指针对应的是一个NativeDisplayEventReceiver对象，该类继承了LooperCallback：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, Looper_callbackFunc callback, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addFd(fd, ident, events, callback ? <span class="keyword">new</span> SimpleLooperCallback(callback) : <span class="literal">NULL</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollEvents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">        eventItem.events = epollEvents;</span><br><span class="line">        eventItem.data.fd = fd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将上面传进来的NativeDisplayEventReceiver对象封装成一个SimpleLooperCallback对象，调用下面的addFd函数的时候主要步骤如下： （1）创建一个struct epoll_event结构体对象，将对应的内存全部用清0，并作对应的初始化； （2）查询通过addFd方法已经添加到epoll中监听的文件描述符； （3）查询不到的话，则调用epoll_ctl方法设置EPOLL_CTL_ADD属性将对应的文件描述符添加到epoll监听的描述符中； （4）根据前面addFd传入的参数EVENT_INPUT，说明当前应用线程的native层的Looper对象中的epoll机制已经开始监听来自于SurfaceFlinger服务端socket端的写入事件。</p>
<h3 id="6-5、App请求Vsync信号"><a href="#6-5、App请求Vsync信号" class="headerlink" title="6.5、App请求Vsync信号"></a>6.5、App请求Vsync信号</h3><p>前面讲解ViewRootImpl.setView()的时候，因涉及到Vsync信号知识，requestLayout()没有具体讲解，现在继续。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;Choreographer.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。</p>
<h3 id="6-5-1、Vsync请求过程"><a href="#6-5-1、Vsync请求过程" class="headerlink" title="6.5.1、Vsync请求过程"></a>6.5.1、Vsync请求过程</h3><p>我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;DisplayEventReceiver.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;android_view_DisplayEventReceiver.cpp ]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">        reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">status_t status = receiver-&gt;scheduleVsync();</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">    String8 message;</span><br><span class="line">    message.appendFormat(<span class="string">&quot;Failed to schedule next vertical sync pulse.  status=%d&quot;</span>, status);</span><br><span class="line">    jniThrowRuntimeException(env, message.string());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VSync请求过程又转交给了DisplayEventReceiver： [-&gt;DisplayEventReceiver.cpp]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line"><span class="keyword">if</span> (mEventConnection != NULL) &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mEventConnection也是前面创建native层对象NativeDisplayEventReceiver时创建的，实际对象是一个BpDisplayEventConnection对象，也就是一个Binder客户端，对应的Binder服务端BnDisplayEventConnection是一个EventThread::Connection对象，对应的BpDisplayEventConnection.requestNextVsync函数和BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)函数没有进行特别的处理，下面就调用到EventThread::Connection.requestNextVsync函数，从BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)开始已经从用户进程将需要垂直同步信号的请求发送到了SurfaceFlinger进程，下面的函数调用开始进入SF进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::requestNextVsync() &#123;</span><br><span class="line">    mEventThread-&gt;requestNextVsync(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>辗转调用到EventThread.requestNextVsync函数，注意里面传了参数this，也就是当前的EventThread::Connection对象，需要明确的是，这里的mEventThread对象是创建EventThread::Connection对象的时候保存的，对应的是SurfaceFlinger对象的里面的mEventThread成员，该对象是一个在SurfaceFlinger.init里面创建并启动的线程对象，可见设计的时候就专门用这个SurfaceFlinger.mEventThread线程来接收来自应用进程的同步信号请求，每来一个应用进程同步信号请求，就通过SurfaceFlinger.mEventThread创建一个EventThread::Connection对象，并通过EventThread.registerDisplayEventConnection函数将创建的EventThread::Connection对象保存到EventThread.mDisplayEventConnections里面，上面有调用到了EventThread.requestNextVsync函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传进来的是一个前面创建的EventThread::Connection对象，里面判断到了EventThread::Connection.count成员变量，看一下EventThread::Connection构造函数中初始变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventThread::Connection::Connection(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到初始值是-1，这个值就是前面那个问题的关键，EventThread::Connection.count标示了这次应用进程的垂直同步信号的请求是一次性的，还是多次重复的，看一下注释里面对于这个变量的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count &gt;= 1 : continuous event. count is the vsync rate</span></span><br><span class="line"><span class="comment">// count == 0 : one-shot event that has not fired</span></span><br><span class="line"><span class="comment">// count ==-1 : one-shot event that fired this round / disabled</span></span><br><span class="line"><span class="keyword">int32_t</span> count;</span><br></pre></td></tr></table></figure>

<p>很清楚的说明了，count = 0说明当前的垂直同步信号请求是一个一次性的请求，并且还没有被处理。上面EventThread::requestNextVsync里面将count设置成0，同时调用了mCondition.broadcast()唤醒所有正在等待mCondition的线程，这个会触发EventThread.waitForEvent函数从：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCondition.wait(mLock);</span><br></pre></td></tr></table></figure>

<p>中醒来，醒来之后经过一轮do…while循环就会返回，返回以后调用序列如下： （1）EventThread::Connection.postEvent(event) （2）DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)，mChannel参数就是前面创建DisplayEventReceiver是创建的BitTube对象 （3）BitTube::sendObjects(dataChannel, events, count)，static函数，通过dataChannel指向BitTube对象 最终调用到BitTube::sendObjects函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::sendObjects</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span> <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续调用到BitTube::write函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::write</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span>* vaddr, <span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> err, len;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">        <span class="comment">// cannot return less than size, since we&#x27;re using SOCK_SEQPACKET</span></span><br><span class="line">        err = len &lt; <span class="number">0</span> ? errno : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == EINTR);</span><br><span class="line">    <span class="keyword">return</span> err == <span class="number">0</span> ? len : -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用到了::send函数，::是作用域描述符，如果前面没有类名之类的，代表的就是全局的作用域，也就是调用全局函数send，这里很容易就能想到这是一个socket的写入函数，也就是将event事件数据写入到BitTube中互联的socket中，这样在另一端马上就能收到写入的数据，前面分析到这个BitTube的socket的两端连接着SurfaceFlinger进程和应用进程，也就是说通过调用BitTube::write函数，将最初由SurfaceFlinger捕获到的垂直信号事件经由BitTube中互联的socket从SurfaceFlinger进程发送到了应用进程中BitTube的socket接收端。 下面就要分析应用进程是如何接收并使用这个垂直同步信号事件的。</p>
<h3 id="6-5-2、应用进程接收VSync"><a href="#6-5-2、应用进程接收VSync" class="headerlink" title="6.5.2、应用进程接收VSync"></a>6.5.2、应用进程接收VSync</h3><h4 id="6-5-2-1、解析VSync事件"><a href="#6-5-2-1、解析VSync事件" class="headerlink" title="6.5.2.1、解析VSync事件"></a>6.5.2.1、解析VSync事件</h4><p>VSync同步信号事件已经发送到用户进程中的socket接收端，在前面NativeDisplayEventReceiver.initialize中分析到应用进程端的socket接收描述符已经被添加到Choreographer所在线程的native层的Looper机制中，在epoll中监听EPOLLIN事件，当socket收到数据后，epoll会马上返回，下面分步骤看一下Looper.pollInner()数： （1）epoll_wait</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure>

<p>在监听到描述符对应的事件后，epoll_wait会马上返回，并将产生的具体事件类型写入到参数eventItems里面，最终返回的eventCount是监听到的事件的个数 （2）事件分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">     <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">     <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">     <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;   <span class="comment">//判断是不是pipe读管道的事件   这里如果是EventThread,这里就是一个socket的描述符,而不是mWakeReadPipeFd</span></span><br><span class="line">         <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">             awoken(); <span class="comment">// 清空读管道中的数据</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;</span>, epollEvents);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//EventThread接收到同步信号走的这里</span></span><br><span class="line">         <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">         <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">             pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</span></span><br><span class="line">                     <span class="string">&quot;no longer registered.&quot;</span>, epollEvents, fd);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Looper目前了解到的主要监听的文件描述符种类有两种： 1）消息事件，epoll_wait监听pipe管道的接收端描述符mWakeReadPipeFd 2）与VSync信号，epoll_wait监听socket接收端描述符，并在addFd的过程中将相关的信息封装在一个Request结构中，并以fd为key存储到了mRequests中，具体可以回过头看3.1.2关于addFd的分析； 因此，上面走的是else的分支，辨别出当前的事件类型后，调用pushResponse：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::pushResponse</span><span class="params">(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;  <span class="comment">//复制不是引用，调用拷贝构造函数</span></span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数将Request和events封装在一个Response对象里面，存储到了mResponses里面，也就是mResponses里面放的是”某某fd上接收到了类别为events的时间”记录，继续向下看Looper.pollInner函数 （3）事件分发处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke all response callbacks.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">        <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">        response.request.callback.clear();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的response.request是从pushResponse里面复制过来的，里面的request对应的Request对象是在addFd的时候创建的，ident成员就是POLL_CALLBACK，所以继续走到response.request.callback-&gt;handleEvent这个函数，回忆一下3.1.2里面的addFd函数，这里的callback实际上是一个SimpleLooperCallback（定义在Looper.cpp中）对象，看一下里面的handleEvent函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleLooperCallback::handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCallback(fd, events, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mCallback就是当时在addFd的时候传进来的callBack参数，实际上对应的就是NativeDisplayEventReceiver对象本身，因此最终就将垂直同步信号事件分发到了NativeDisplayEventReceiver.handleEvent函数中。</p>
<h3 id="6-5-3、VSync事件分发"><a href="#6-5-3、VSync事件分发" class="headerlink" title="6.5.3、VSync事件分发"></a>6.5.3、<strong>VSync事件分发</strong></h3><p>调用到NativeDisplayEventReceiver.handleEvent函数，该函数定义在android_view_DisplayEventReceiver.cpp中，直接列出该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NativeDisplayEventReceiver::handleEvent</span><span class="params">(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Display event receiver pipe was closed or an error occurred.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Received spurious callback for unhandled poll event.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;receiver %p ~ Vsync pulse: timestamp=%&quot;</span> PRId64 <span class="string">&quot;, id=%d, count=%d&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>, vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断事件是不是正确的Looper::EVENT_INPUT事件，然后调用到NativeDisplayEventReceiver.processPendingEvents函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NativeDisplayEventReceiver::processPendingEvents</span><span class="params">(<span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That&#x27;s fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">&quot;receiver %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed to get events from display event receiver, status=%d&quot;</span>, <span class="keyword">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mReceiver也就是前面创建NativeDisplayEventReceiver对象是创建的成员变量对象DisplayEventReceiver，下面调用到DisplayEventReceiver.getEvents函数，应该是要从出现同步信号事件的socket中读取数据，上面Looper机制中epoll中监听到socket以后，返回到NativeDisplayEventReceiver.handleEvent里面，但是socket里面的数据还没有读取，下面的调用流程为： （1）mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) —&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event _events, size_t count) （2）BitTube::recvObjects(dataChannel, events, count) —&gt; BitTube::recvObjects(const sp&amp; tube, void_ events, size_t count, size_t objSize) 看一下这个recvObjects函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">BitTube::recvObjects</span><span class="params">(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;read(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在NativeDisplayEventReceiver中创建了一个缓冲区，并在recvObjects中将socket中的Event数据读到这个缓冲区中，这个Event.header.type一般都是DISPLAY_EVENT_VSYNC，因此在上面的processPendingEvents函数中会将Event数据保存在outCount所指向的内存中，并返回true。 接下来返回到NativeDisplayEventReceiver.handleEvent后会调用到dispatchVsync函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的处理很直接，直接调用mReceiverObjGlobal对象在gDisplayEventReceiverClassInfo.dispatchVsync中指定的函数，将后面的timestamp（时间戳） id（设备ID） count（经过的同步信号的数量，一般没有设置采样频率应该都是1），下面分别看一下mReceiverObjGlobal以及gDisplayEventReceiverClassInfo.dispatchVsync代表的是什么？ （1）mReceiverObjGlobal</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;receiver %p ~ Initializing input event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到mReceiverObjGlobal是创建NativeDisplayEventReceiver对象时传进来的第二个参数，该对象是在nativeInit函数中创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env, receiverObj, messageQueue);</span><br></pre></td></tr></table></figure>

<p>进一步的，receiverObj是调用nativeInit函数时传进来的第一个参数（第一个参数env是系统用于连接虚拟机时自动加上的），nativeInit函数又是在Choreographer中创建FrameDisplayEventReceiver对象时，在基类DisplayEventReceiver构造器中调用的，因此这里的mReceiverObjGlobal对应的就是Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver。 （2）gDisplayEventReceiverClassInfo.dispatchVsync 在JNI中有很多这样的类似的结构体对象，这些对象都是全局结构体对象，这里的gDisplayEventReceiverClassInfo就是这样的一个对象，里面描述了一些在整个文件内可能会调用到的java层的相关类以及成员函数的相关信息，看一下gDisplayEventReceiverClassInfo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    jclass clazz;</span><br><span class="line">    jmethodID dispatchVsync;</span><br><span class="line">    jmethodID dispatchHotplug;</span><br><span class="line">&#125; gDisplayEventReceiverClassInfo;</span><br></pre></td></tr></table></figure>

<p>看一下里面的变量名称就能知道大致的含义，clazz成员代表的是某个java层的类的class信息，dispatchVsync和dispatchHotplug代表的是java层类的方法的方法信息，看一下该文件中注册JNI函数的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_view_DisplayEventReceiver</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = RegisterMethodsOrDie(env, <span class="string">&quot;android/view/DisplayEventReceiver&quot;</span>, gMethods, NELEM(gMethods));</span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">&quot;android/view/DisplayEventReceiver&quot;</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">&quot;dispatchVsync&quot;</span>, <span class="string">&quot;(JII)V&quot;</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">&quot;dispatchHotplug&quot;</span>, <span class="string">&quot;(JIZ)V&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RegisterMethodsOrDie调用注册了java层调用native方法时链接到的函数的入口，下面clazz对应的就是java层的”android/view/DisplayEventReceiver.java”类，gDisplayEventReceiverClassInfo.dispatchVsync里面保存的就是clazz类信息中与dispatchVsync方法相关的信息，同样dispatchHotplug也是。 分析到这里，就知道应用进程native接收到同步信号事件后，会调用Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver的dispatchVsync方法。</p>
<h3 id="6-5-4、应用接收Vsync"><a href="#6-5-4、应用接收Vsync" class="headerlink" title="6.5.4、应用接收Vsync"></a>6.5.4、应用接收Vsync</h3><p>看一下FrameDisplayEventReceiver.dispatchVsync方法，也就是DisplayEventReceiver.dispatchVsync方法(Choreographer.java)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.   </span></span><br><span class="line"> <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">     onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line"> &#125;</span><br><span class="line"> 注释表明这个方法是从<span class="keyword">native</span>代码调用的，该函数然后会调用FrameDisplayEventReceiver.onVsync方法：</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Ignore vsync from secondary display.</span></span><br><span class="line">         <span class="comment">// This can be problematic because the call to scheduleVsync() is a one-shot.</span></span><br><span class="line">         <span class="comment">// We need to ensure that we will still receive the vsync from the primary</span></span><br><span class="line">         <span class="comment">// display which is the one we really care about.  Ideally we should schedule</span></span><br><span class="line">         <span class="comment">// vsync for a particular display.</span></span><br><span class="line">         <span class="comment">// At this time Surface Flinger won&#x27;t send us vsyncs for secondary displays</span></span><br><span class="line">         <span class="comment">// but that could change in the future so let&#x27;s log a message to help us remember</span></span><br><span class="line">         <span class="comment">// that we need to fix this.</span></span><br><span class="line">         <span class="comment">//注释：忽略来自非主显示器的Vsync信号，但是我们前面调用的scheduleVsync函数只能请求到一次Vsync信号，因此需要重新调用scheduleVsync函数</span></span><br><span class="line">         <span class="comment">//请求来自主显示设备的Vsync信号</span></span><br><span class="line">         <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">             Log.d(TAG, <span class="string">&quot;Received vsync from secondary display, but we don&#x27;t support &quot;</span></span><br><span class="line">                     + <span class="string">&quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span></span><br><span class="line">                     + <span class="string">&quot;vsync for a specific display to ensure it doesn&#x27;t lose track &quot;</span></span><br><span class="line">                     + <span class="string">&quot;of its scheduled vsync.&quot;</span>);</span><br><span class="line">             scheduleVsync();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">         <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">         <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">         <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">         <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">         <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">         <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                     + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                     + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">             timestampNanos = now;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">             Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                     + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mTimestampNanos = timestampNanos;  <span class="comment">//同步信号时间戳</span></span><br><span class="line">         mFrame = frame;                <span class="comment">//同步信号的个数，理解就是从调用scheduleVsync到onVsync接收到信号之间经历的同步信号的个数，一般都是1</span></span><br><span class="line">         Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">         msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">         mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>貌似这里的处理只是往Choreographer对象中的mHandler对应的线程Looper中发送一个消息，消息的内容有两个特点： （1）将this，也就是当前的FrameDisplayEventReceiver对象作为参数，后面会回调到FrameDisplayEventReceiver.run方法； （2）为Message设置FLAG_ASYNCHRONOUS属性； 发送这个FLAG_ASYNCHRONOUS消息后，后面会回调到FrameDisplayEventReceiver.run方法，至于为什么，后面再写文章结合View.invalidate方法的过程分析，看一下FrameDisplayEventReceiver.run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Choreographer.doFrame方法，如果是重绘事件doFrame方法会最终调用到ViewRootImpl.performTraversals方法进入实际的绘制流程。经过上面的分析可以知道，调用一次Choreographer.scheduleVsyncLocked只会请求一次同步信号，也就是回调一次FrameDisplayEventReceiver.onVsync方法，在思考一个问题，一个应用进程需要多次请求Vsync同步信号会不会使用同样的一串对象？多个线程又是怎么样的？ 答：一般绘制操作只能在主线程里面进行，因此一般来说只会在主线程里面去请求同步信号，可以认为不会存在同一个应用的多个线程请求SF的Vsync信号，Choreographer是一个线程内的单例模式，存储在了 ThreadLocal sThreadInstance对象里面，所以主线程多次请求使用的是同一个Choreographer对象，所以后面的一串对象应该都是可以复用的。</p>
<p>总体架构： 伐木累:::终于完了，由于Android Graphics系统涉及模块代码纵横交叉复杂，其中代码图示有误的地方请见谅，也没有精力一一核对了，还请海涵<del>~</del>主要是分析Android Graphics总体的一个流程思想，有需要再一点点深挖。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.graphics/30-Android-Graphics-Arc-flow.png" alt="Markdown"></p>
<h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a target="_blank" rel="noopener" href="http://www.10tiao.com/html/431/201601/401709603/1.html">Android Vsync 原理</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/uiop78uiop78/article/category/1390680">林学森的Android专栏</a><br><a target="_blank" rel="noopener" href="http://coderprof.com/android_tutorials_pdf_examples_PDF.php?q=android+graphics+pdf">Android Graphics</a><br><a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/debug/systrace">了解 Systrace</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/samchen2009/category/524173.html">图解Android - Android GUI 系统</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/">Android SurfaceFlinger 学习之路&amp;Android多媒体开发</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/Gaugamela/article/category/6383486">Android7.0 基础业务AMS、数据业务、电源管理业务 源码分析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangwen123/article/category/1647761">【Android 显示模块】 - 深入剖析Android系统 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/innost/article/details/47208337">深入理解Android卷一全文-第八章(深入理解Surface系统)</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/armwind/article/category/6282972">android系统 - armwind的专栏 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/kc58236582/article/category/6436488">android显示系统 - kc58236582的博客 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wytiger/p/5693569.html">SurfaceView, TextureView, SurfaceTexture等的区别</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/armwind/article/details/73436532">【Demo】Android graphics 学习－生产者、消费者、BufferQueue介绍</a><br><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2765.html">深入Android Graphics Pipeline：从按钮到帧缓冲（第一部分）</a><br><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2766.html">深入Android Graphics Pipeline：从按钮到帧缓冲（第二部分）</a><br><a target="_blank" rel="noopener" href="https://software.intel.com/en-us/node/713326">窗口：Profiling 视图（OpenGL/OpenGL ES* 工作负载）</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinzhuojun/article/details/54234354">Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)</a><br><a target="_blank" rel="noopener" href="https://netaz.blogspot.jp/search/label/gralloc">Android’s Graphics Buffer Management System (Part I: gralloc)</a><br><a target="_blank" rel="noopener" href="https://netaz.blogspot.jp/search/label/Graphics">Android’s Graphics Buffer Management System (Part II: BufferQueue)</a><br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/digest/androidcore/149097">Android GDI之SurfaceFlinger</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/michaelcao1980/article/details/43233765">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/newchenxf/article/details/49131167">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/houliang120/article/details/50958212">Android消息机制Looper与VSync的传播</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/houliang120/article/details/50908098">Android垂直同步信号VSync的产生及传播结构详解</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinzhuojun/article/details/17293325">Android 4.4(KitKat)中VSync信号的虚拟化</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinzhuojun/article/details/37737439">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/ariesjzj/article/category/1087829/2">Android中用OpenGL ES Tracer分析绘制过程</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30372696?sort=created">android view的绘制中，View绘制的时间如何和vsync屏幕刷新频率保持同步的？</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/innost/article/details/47208337">【深入理解Android卷一全文-第八章】入理解Surface系统</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/april_12345/article/details/52933316">Android 窗口管理：Z-Order管理</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20180408/">https://zhoujinjian.com/posts/20180408/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a><a class="post-meta__tags" href="/tags/Display/">Display</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20180508/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android N Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</div></div></a></div><div class="next-post pull-right"><a href="/posts/20180308/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20180508/" title="Android N Display System（2）：Android Display System 系统分析之Android EGL && OpenGL"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-08</div><div class="title">Android N Display System（2）：Android Display System 系统分析之Android EGL && OpenGL</div></div></a></div><div><a href="/posts/20180608/" title="Android N Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-08</div><div class="title">Android N Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析</div></div></a></div><div><a href="/posts/20180708/" title="Android N Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-07-08</div><div class="title">Android N Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析</div></div></a></div><div><a href="/posts/20180808/" title="Android N Display System（5）：Android Display System 系统分析之Display Driver Architecture"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-08-08</div><div class="title">Android N Display System（5）：Android Display System 系统分析之Display Driver Architecture</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">源码（部分）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Android-Graphics-%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">（一）、Android Graphics 系统框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-Graphics-%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%EF%BC%88C-%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">（二）、Android Graphics 测试程序（C++）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android-Graphics-%E7%A6%81%E7%94%A8hwc%E5%92%8CGPU"><span class="toc-number">4.</span> <span class="toc-text">（三）、Android Graphics 禁用hwc和GPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81Disable-HWUI-GPU-HWC"><span class="toc-number">4.1.</span> <span class="toc-text">3.1、Disable_HWUI_GPU_HWC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81Vsync%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">3.2、Vsync测试程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Android-SurfaceFlinger-%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">（四）、Android SurfaceFlinger 内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81APP%E4%B8%8ESurfaceFlinger%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">4.1、APP与SurfaceFlinger的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">4.1.1、BufferQueue介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer"><span class="toc-number">5.1.2.</span> <span class="toc-text">4.1.2、生产者Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer"><span class="toc-number">5.1.3.</span> <span class="toc-text">4.1.3、消费者Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81App%EF%BC%88Java%E5%B1%82%EF%BC%89%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">4.2、App（Java层）请求创建Surface过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E3%80%81Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">4.2.1、Activity启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2%E3%80%81Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">4.2.2、Window加载显示流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-1%E3%80%81ActivityThread-handleLaunchActivity"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">4.2.2.1、ActivityThread.handleLaunchActivity()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-2%E3%80%81ActivityThread-handleResumeActivity"><span class="toc-number">6.2.</span> <span class="toc-text">4.2.2.2、ActivityThread.handleResumeActivity()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-3%E3%80%81ViewRootImpl-%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">4.2.2.3、ViewRootImpl()构造过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-4%E3%80%81IWindowSession%E4%BB%A3%E7%90%86%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="toc-number">6.4.</span> <span class="toc-text">4.2.2.4、IWindowSession代理获取过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-5%E3%80%81%E8%A7%86%E5%9B%BEView%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8BViewRootImpl-setView"><span class="toc-number">6.5.</span> <span class="toc-text">4.2.2.5、视图View添加过程ViewRootImpl.setView()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-6%E3%80%81requestLayout-%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%AA%97%E5%8F%A3UI%E5%B8%83%E5%B1%80%EF%BC%9B"><span class="toc-number">6.6.</span> <span class="toc-text">4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-7%E3%80%81mWindowSession-addToDisplay-%E5%90%91WMS%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1%EF%BC%9B"><span class="toc-number">6.7.</span> <span class="toc-text">4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-8%E3%80%81SurfaceSession%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">6.8.</span> <span class="toc-text">4.2.2.8、SurfaceSession建立过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3%E3%80%81App%EF%BC%88c%E5%B1%82%EF%BC%89%E8%AF%B7%E6%B1%82%E5%88%9B%E5%BB%BASurfaceFlinger%E5%AE%A2%E6%88%B7%E7%AB%AF-client-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.9.</span> <span class="toc-text">4.2.3、App（c层）请求创建SurfaceFlinger客户端(client)的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4%E3%80%81APP%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.</span> <span class="toc-text">4.2.4、APP申请创建Surface过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-1%E3%80%81APP%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B-Java%E5%B1%82"><span class="toc-number">6.10.1.</span> <span class="toc-text">4.2.4.1、APP申请创建Surface过程(Java层)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-1%E3%80%81APP%E7%94%B3%E8%AF%B7%E5%88%9B%E5%BB%BASurface%E8%BF%87%E7%A8%8B-c%E5%B1%82"><span class="toc-number">6.10.2.</span> <span class="toc-text">4.2.4.1、APP申请创建Surface过程(c层)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-2%E3%80%81BufferQueue%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.3.</span> <span class="toc-text">4.2.4.2、BufferQueue构造过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-2%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.4.</span> <span class="toc-text">4.2.4.2、生产者Producer构造过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-3%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.5.</span> <span class="toc-text">4.2.4.3、消费者Consumer构造过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-4%E3%80%81SurfaceFlinger%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC"><span class="toc-number">6.10.6.</span> <span class="toc-text">4.2.4.4、SurfaceFlinger设置监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-5%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E7%AA%97%E5%8F%A3Surface%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.7.</span> <span class="toc-text">4.2.4.5、应用程序本地窗口Surface创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-5%E3%80%81%E6%89%A7%E8%A1%8C%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80performLayout"><span class="toc-number">6.10.8.</span> <span class="toc-text">4.2.4.5、执行窗口布局performLayout()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-7%E3%80%81%E6%89%A7%E8%A1%8C%E7%AA%97%E5%8F%A3%E7%BB%98%E5%88%B6performDraw"><span class="toc-number">6.10.9.</span> <span class="toc-text">4.2.4.7、执行窗口绘制performDraw()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">4.3、APP申请(lock)Buffer的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1%E3%80%81Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA-APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81APP%E6%8F%90%E4%BA%A4-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">4.4、APP提交(unlockAndPost)Buffer的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E9%80%9A%E7%9F%A5SF%E6%B6%88%E8%B4%B9%E5%90%88%E6%88%90"><span class="toc-number">9.</span> <span class="toc-text">（五）、通知SF消费合成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81preComposition-%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">一、preComposition()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E6%AF%8F%E4%B8%AALayer%E7%9A%84onFrameAvailable%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">1.1、每个Layer的onFrameAvailable函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">1.2、绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81handleTransaction-handPageFlip%E6%9B%B4%E6%96%B0Layer%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.1.</span> <span class="toc-text">二、handleTransaction handPageFlip更新Layer对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81handleTransaction%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">2.1、handleTransaction函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81Layer%E7%9A%84doTransaction%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">2.2、Layer的doTransaction函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81handleTransactionLocked%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">2.3、handleTransactionLocked函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2%E3%80%81%E5%A4%84%E7%90%86%E6%98%BE%E7%A4%BA%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">13.2.</span> <span class="toc-text">2.3.2、处理显示设备的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3%E3%80%81%E8%AE%BE%E7%BD%AETransfromHit"><span class="toc-number">13.3.</span> <span class="toc-text">2.3.3、设置TransfromHit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4%E3%80%81%E5%A4%84%E7%90%86Layer%E5%A2%9E%E5%8A%A0%E6%83%85%E5%86%B5"><span class="toc-number">13.4.</span> <span class="toc-text">2.3.4、处理Layer增加情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5%E3%80%81%E8%AE%BE%E7%BD%AEmDrawingState"><span class="toc-number">13.5.</span> <span class="toc-text">2.3.5、设置mDrawingState</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81handlePageFlip%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">2.4、handlePageFlip函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">14.1.</span> <span class="toc-text">2.5 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81rebuildLayerStacks%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">三、rebuildLayerStacks函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81setUpHWComposer%E5%87%BD%E6%95%B0"><span class="toc-number">15.1.</span> <span class="toc-text">四、setUpHWComposer函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%90%88%E6%88%90%E6%89%80%E6%9C%89%E5%B1%82%E7%9A%84%E5%9B%BE%E5%83%8F-%EF%BC%88doComposition-%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">五、合成所有层的图像 （doComposition()函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81postFramebuffer-%E5%87%BD%E6%95%B0"><span class="toc-number">15.3.</span> <span class="toc-text">六、postFramebuffer()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Android-SurfaceFlinger-VSync%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">（六）、Android SurfaceFlinger - VSync工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81VSYNC-%E6%80%BB%E4%BD%93%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.</span> <span class="toc-text">一、VSYNC 总体概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E3%80%81VSYNC-%E6%A6%82%E5%BF%B5"><span class="toc-number">16.2.</span> <span class="toc-text">6.1.1、VSYNC 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2%E3%80%81Android-VSYNC-%E2%80%93-%E9%BB%84%E6%B2%B9%E8%AE%A1%E5%88%92"><span class="toc-number">16.3.</span> <span class="toc-text">6.1.2、Android VSYNC – 黄油计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81VSync%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F"><span class="toc-number">16.4.</span> <span class="toc-text">二、VSync信号产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Surfaceflinger%E5%AF%B9VSYNC%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">16.5.</span> <span class="toc-text">三、Surfaceflinger对VSYNC消息的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1%E3%80%81Surfaceflinger-init"><span class="toc-number">16.6.</span> <span class="toc-text">6.3.1、Surfaceflinger.init()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2%E3%80%81VSync%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">16.7.</span> <span class="toc-text">6.3.2、VSync信号的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81App%E5%90%91Eventhread%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E8%80%85%E2%80%93createEventConnection"><span class="toc-number">16.8.</span> <span class="toc-text">6.4、App向Eventhread注册一个事件的监听者–createEventConnection()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%E3%80%81App%E8%AF%B7%E6%B1%82Vsync%E4%BF%A1%E5%8F%B7"><span class="toc-number">16.9.</span> <span class="toc-text">6.5、App请求Vsync信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1%E3%80%81Vsync%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">16.10.</span> <span class="toc-text">6.5.1、Vsync请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2%E3%80%81%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6VSync"><span class="toc-number">16.11.</span> <span class="toc-text">6.5.2、应用进程接收VSync</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-1%E3%80%81%E8%A7%A3%E6%9E%90VSync%E4%BA%8B%E4%BB%B6"><span class="toc-number">16.11.1.</span> <span class="toc-text">6.5.2.1、解析VSync事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-3%E3%80%81VSync%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="toc-number">16.12.</span> <span class="toc-text">6.5.3、VSync事件分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-4%E3%80%81%E5%BA%94%E7%94%A8%E6%8E%A5%E6%94%B6Vsync"><span class="toc-number">16.13.</span> <span class="toc-text">6.5.4、应用接收Vsync</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">17.</span> <span class="toc-text">（七）、参考文档(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>