<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 10 Display System源码分析（7）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析（Android 10.0 &amp;&amp; Kernel 4.15） | zhoujinjian</title><meta name="keywords" content="Android,Linux,Graphics"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="我们首先去除掉系统的： 1234rk3399_Android10:&#x2F;system&#x2F;bin # rm -rf bootanimationrk3399_Android10:&#x2F;product&#x2F;priv-app # rm -rf Settings&#x2F;rk3399_Android10:&#x2F;product&#x2F;priv-app # rm -rf SystemUI&#x2F;rk3399_Android10:&#x2F;product&#x2F;p">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 10 Display System源码分析（7）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析（Android 10.0 &amp;&amp; Kernel 4.15）">
<meta property="og:url" content="https://zhoujinjian.com/posts/20210910/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="我们首先去除掉系统的： 1234rk3399_Android10:&#x2F;system&#x2F;bin # rm -rf bootanimationrk3399_Android10:&#x2F;product&#x2F;priv-app # rm -rf Settings&#x2F;rk3399_Android10:&#x2F;product&#x2F;priv-app # rm -rf SystemUI&#x2F;rk3399_Android10:&#x2F;product&#x2F;p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.28.jpg">
<meta property="article:published_time" content="2021-09-10T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.936Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20210910/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.28.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 10 Display System源码分析（7）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析（Android 10.0 &amp;&amp; Kernel 4.15）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-10T01:25:00.000Z" title="发表于 2021-09-10 09:25:00">2021-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.936Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Display/">Display</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>我们首先去除掉系统的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rk3399_Android10:/system/bin <span class="meta"># rm -rf bootanimation</span></span><br><span class="line">rk3399_Android10:/product/priv-app <span class="meta"># rm -rf Settings/</span></span><br><span class="line">rk3399_Android10:/product/priv-app <span class="meta"># rm -rf SystemUI/</span></span><br><span class="line">rk3399_Android10:/product/priv-app <span class="meta"># rm -rf Launcher3QuickStep/</span></span><br></pre></td></tr></table></figure>
<p>然后等待开机完成SurfaceFlinger_test_red，抓取Log。setprop vendor.dump true。抓取的帧会按数字排列，还带分辨率参数。adb pull /data/dump/。抓到的bin文件可以用软件7yuv打开查看，格式设定为RGBA8888<br>Layer test#0渲染图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/SurfaceFlinger_test_red_take_picture_Test.jpg"><br>FrameBuffer渲染图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/SurfaceFlinger_test_red_take_picture_FB.jpg"><br>效果图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/SurfaceFlinger_test_red_take_picture.jpg"></p>
<h4 id="（一）、Native-Surface创建过程"><a href="#（一）、Native-Surface创建过程" class="headerlink" title="（一）、Native Surface创建过程"></a>（一）、Native Surface创建过程</h4><h5 id="1-1-0-、Native-Surface创建步骤"><a href="#1-1-0-、Native-Surface创建步骤" class="headerlink" title="1.1.0 、Native Surface创建步骤"></a>1.1.0 、Native Surface创建步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">X:\packages\apps\SurfaceFlingerTestsRed\Transaction_test_red.cpp</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mClient-&gt;initCheck()) &lt;&lt; <span class="string">&quot;failed to create SurfaceComposerClient&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ASSERT_NO_FATAL_FAILURE(SetUpDisplay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;SurfaceControl&gt; <span class="title">createLayer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> layer =</span><br><span class="line">                mClient-&gt;createSurface(String8(name), width, height, PIXEL_FORMAT_RGBA_8888, flags);</span><br><span class="line">        EXPECT_NE(<span class="literal">nullptr</span>, layer.get()) &lt;&lt; <span class="string">&quot;failed to create SurfaceControl&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> error = Transaction()</span><br><span class="line">                                 .setLayerStack(layer, mDisplayLayerStack)</span><br><span class="line">                                 .setLayer(layer, mLayerZBase)</span><br><span class="line">                                 .apply();</span><br><span class="line">        <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">            ADD_FAILURE() &lt;&lt; <span class="string">&quot;failed to initialize SurfaceControl&quot;</span>;</span><br><span class="line">            layer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> layer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<p>[-&gt;SurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\libs\gui\SurfaceComposerClient.cpp</span><br><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        SurfaceControl* parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; s;</span><br><span class="line">    createSurfaceChecked(name, w, h, format, &amp;s, flags, parent, <span class="built_in">std</span>::move(metadata));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     SurfaceControl* parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    <span class="keyword">status_t</span> err = mStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">&quot;SurfaceComposerClient::createSurface error %s&quot;</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="literal">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\libs\gui\ISurfaceComposerClient.cpp</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                           sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callRemote&lt;<span class="keyword">decltype</span>(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE,</span><br><span class="line">                                                                            name, width, height,</span><br><span class="line">                                                                            format, flags, parent,</span><br><span class="line">                                                                            <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                                                            handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMPLEMENT_META_INTERFACE(SurfaceComposerClient, <span class="string">&quot;android.ui.ISurfaceComposerClient&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BnSurfaceComposerClient::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (code &lt; IBinder::FIRST_CALL_TRANSACTION || code &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(Tag::LAST)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tag = <span class="keyword">static_cast</span>&lt;Tag&gt;(code);</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> Tag::CREATE_SURFACE:</span><br><span class="line">            <span class="keyword">return</span> callLocal(data, reply, &amp;ISurfaceComposerClient::createSurface);</span><br><span class="line">        <span class="keyword">case</span> Tag::CREATE_WITH_SURFACE_PARENT:</span><br><span class="line">            <span class="keyword">return</span> callLocal(data, reply, &amp;ISurfaceComposerClient::createWithSurfaceParent);</span><br><span class="line">        <span class="keyword">case</span> Tag::CLEAR_LAYER_FRAME_STATS:</span><br><span class="line">            <span class="keyword">return</span> callLocal(data, reply, &amp;ISurfaceComposerClient::clearLayerFrameStats);</span><br><span class="line">        <span class="keyword">case</span> Tag::GET_LAYER_FRAME_STATS:</span><br><span class="line">            <span class="keyword">return</span> callLocal(data, reply, &amp;ISurfaceComposerClient::getLayerFrameStats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\Client.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Client::createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We rely on createLayer to check permissions.</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF createSurface %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;createLayer(name, <span class="keyword">this</span>, w, h, format, flags, <span class="built_in">std</span>::move(metadata), handle, gbp,</span><br><span class="line">                                 parentHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过Binder通信进入SurfaceFlinger创建Layer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> sp&lt;Layer&gt;&amp; parentLayer)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF createLayer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line"></span><br><span class="line">    String8 uniqueName = getUniqueLayerName(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> primaryDisplayOnly = <span class="literal">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = createBufferQueueLayer(client, uniqueName, w, h, flags, <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                            format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState:</span><br><span class="line">            result = createBufferStateLayer(client, uniqueName, w, h, flags, <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                            handle, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:</span><br><span class="line">            ......</span><br><span class="line">            result = createColorLayer(client, uniqueName, w, h, flags, <span class="built_in">std</span>::move(metadata), handle,</span><br><span class="line">                                      &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceContainer:</span><br><span class="line">            ......</span><br><span class="line">            result = createContainerLayer(client, uniqueName, w, h, flags, <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                          handle, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> addToCurrentState = callingThreadHasUnscopedSurfaceFlingerAccess();</span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                            addToCurrentState);</span><br><span class="line">    ......</span><br><span class="line">    mInterceptor-&gt;saveSurfaceCreation(layer);</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了4种类型的Layer:<br>  [-&gt;ISurfaceComposerClient.h]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flags for createSurface()</span></span><br><span class="line"> <span class="keyword">enum</span> &#123; <span class="comment">// (keep in sync with Surface.java)</span></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     eFXSurfaceBufferQueue = <span class="number">0x00000000</span>,</span><br><span class="line">     eFXSurfaceColor = <span class="number">0x00020000</span>,</span><br><span class="line">     eFXSurfaceBufferState = <span class="number">0x00040000</span>,</span><br><span class="line">     eFXSurfaceContainer = <span class="number">0x00080000</span>,</span><br><span class="line">     ......</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createBufferQueueLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                LayerMetadata metadata, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;Layer&gt;* outLayer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialize the surfaces</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF createBufferQueueLayer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">        format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">        format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;BufferQueueLayer&gt; layer = getFactory().createBufferQueueLayer(</span><br><span class="line">            LayerCreationArgs(<span class="keyword">this</span>, client, name, w, h, flags, <span class="built_in">std</span>::move(metadata)));</span><br><span class="line">    <span class="keyword">status_t</span> err = layer-&gt;setDefaultBufferProperties(w, h, format);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = layer-&gt;getHandle();</span><br><span class="line">        *gbp = layer-&gt;getProducer();</span><br><span class="line">        *outLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;createBufferQueueLayer() failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp</span><br><span class="line">        <span class="function">sp&lt;BufferQueueLayer&gt; <span class="title">createBufferQueueLayer</span><span class="params">(<span class="keyword">const</span> LayerCreationArgs&amp; args)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;zjj.rk3399.SF createBufferQueueLayer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BufferQueueLayer(args);</span><br><span class="line">        &#125;</span><br><span class="line">X:\frameworks\native\services\surfaceflinger\BufferQueueLayer.cpp</span><br><span class="line">BufferQueueLayer::BufferQueueLayer(<span class="keyword">const</span> LayerCreationArgs&amp; args) : BufferLayer(args) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueueLayer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferLayer::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, <span class="literal">true</span>);</span><br><span class="line">    mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger, <span class="keyword">this</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Grab the SF state lock during this since it&#x27;s the only safe way to access RenderEngine</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFlinger-&gt;mStateLock)</span></span>;</span><br><span class="line">        mConsumer =</span><br><span class="line">                <span class="keyword">new</span> BufferLayerConsumer(consumer, mFlinger-&gt;getRenderEngine(), mTextureName, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">    mConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">    mConsumer-&gt;setName(mName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BufferQueueCore::mMaxDequeuedBufferCount is default to 1</span></span><br><span class="line">    <span class="keyword">if</span> (!mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;</span><br><span class="line">        mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> display = mFlinger-&gt;getDefaultDisplayDevice()) &#123;</span><br><span class="line">        updateTransformHint(display);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建BufferQueueLayer 会首先调用onFirstRef()函数，创建IGraphicBufferProducer，IGraphicBufferConsumer，BufferQueue对象。设置最大setMaxDequeuedBufferCount为2。BufferQueueLayer继承BufferLayer，看看BufferLayer构造函数。</p>
<p>获取CompositionEngine创造对应layer，这个后面用于渲染作用。<br>看看Log：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10-28 09:41:00.086   179   523 V BufferLayerConsumer: [unnamed-179-2] BufferLayerConsumer</span><br><span class="line">10-28 09:41:00.086   179   523 V ConsumerBase: [unnamed-179-2] setFrameAvailableListener</span><br><span class="line">10-28 09:41:00.086   179   523 V BufferQueueProducer: [] setMaxDequeuedBufferCount: maxDequeuedBuffers = 2</span><br><span class="line">10-28 09:41:00.086   179   523 I BufferLayerConsumer: zjj.rk3399.SF setDefaultBufferSize frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp setDefaultBufferSize 86 </span><br><span class="line"></span><br><span class="line">10-28 09:41:00.086   179   523 I SurfaceFlinger: zjj.rk3399.SF addClientLayer frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp addClientLayer 3685 </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\BufferLayer.cpp</span><br><span class="line">BufferLayer::BufferLayer(<span class="keyword">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : Layer(args),</span><br><span class="line">        mTextureName(args.flinger-&gt;getNewTexture()),</span><br><span class="line">        mCompositionLayer&#123;mFlinger-&gt;getCompositionEngine().createLayer(</span><br><span class="line">                compositionengine::LayerCreationArgs&#123;<span class="keyword">this</span>&#125;)&#125; &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;Creating Layer %s&quot;</span>, args.name.<span class="built_in">string</span>());</span><br><span class="line">    ALOGD_CALLSTACK(<span class="string">&quot;BufferLayer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mPremultipliedAlpha = !(args.flags &amp; ISurfaceComposerClient::eNonPremultiplied);</span><br><span class="line"></span><br><span class="line">    mPotentialCursor = args.flags &amp; ISurfaceComposerClient::eCursorWindow;</span><br><span class="line">    mProtectedByApp = args.flags &amp; ISurfaceComposerClient::eProtectedByApp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use rk ashmem -------</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == g_gralloc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">                      (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;g_gralloc);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Failed to open gralloc module %d&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use rk ashmem -------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看看Log：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">10-28 09:41:00.066   179   523 I SurfaceFlinger: zjj.rk3399.SF createSurface frameworks/native/services/surfaceflinger/Client.cpp createSurface 80 </span><br><span class="line">10-28 09:41:00.066   179   523 I SurfaceFlinger: zjj.rk3399.SF createLayer frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp createLayer 4355 </span><br><span class="line">10-28 09:41:00.066   179   523 I SurfaceFlinger: zjj.rk3399.SF createBufferQueueLayer frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp createBufferQueueLayer 4476 </span><br><span class="line">10-28 09:41:00.066   179   523 I SurfaceFlinger: zjj.rk3399.SF createBufferQueueLayer frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp createBufferQueueLayer 132 </span><br><span class="line">10-28 09:41:00.066   179   523 I CompositionEngine: zjj.rk3399.SF createLayer frameworks/native/services/surfaceflinger/CompositionEngine/src/CompositionEngine.cpp createLayer 43 </span><br><span class="line">10-28 09:41:00.066   179   523 V BufferLayer: Creating Layer <span class="built_in">test</span><span class="comment">#0</span></span><br><span class="line">10-28 09:41:00.066   179   523 D BufferLayer: BufferLayer</span><br><span class="line"></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#00 pc 000000000007d14c  /system/lib64/libsurfaceflinger.so (android::BufferLayer::BufferLayer(android::LayerCreationArgs const&amp;)+300)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#01 pc 00000000000830b8  /system/lib64/libsurfaceflinger.so (android::BufferQueueLayer::BufferQueueLayer(android::LayerCreationArgs const&amp;)+88)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#02 pc 00000000001160ac  /system/lib64/libsurfaceflinger.so (_ZZN7android14surfaceflinger20createSurfaceFlingerEvEN7Factory22createBufferQueueLayerERKNS_17LayerCreationArgsE$f8e1ddd5c1a01af33e02be699775c0a6+84)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#03 pc 00000000000e9314  /system/lib64/libsurfaceflinger.so (android::SurfaceFlinger::createLayer(android::String8 const&amp;, android::sp&lt;android::Client&gt; const&amp;, unsigned int, unsigned int, int, unsigned int, android::LayerMetadata, android::sp&lt;android::IBinder&gt;*, android::sp&lt;android::IGraphicBufferProducer&gt;*, android::sp&lt;android::IBinder&gt; const&amp;, android::sp&lt;android::Layer&gt; const&amp;)+828)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#04 pc 000000000008bf88  /system/lib64/libsurfaceflinger.so (android::Client::createSurface(android::String8 const&amp;, unsigned int, unsigned int, int, unsigned int, android::sp&lt;android::IBinder&gt; const&amp;, android::LayerMetadata, android::sp&lt;android::IBinder&gt;*, android::sp&lt;android::IGraphicBufferProducer&gt;*)+232)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#05 pc 00000000000ac2a8  /system/lib64/libgui.so (_ZN7android15SafeBnInterfaceINS_22ISurfaceComposerClientEE12MethodCallerIJNSt3__15tupleIJRKNS_7String8EjjijRKNS_2spINS_22IGraphicBufferProducerEEENS_13LayerMetadataEPNS9_INS_7IBinderEEEPSB_EEEEE10callHelperIS2_MS1_FiS8_jjijSD_SE_SH_SI_ENS5_IJS6_jjijSB_SE_SG_SB_EEEJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8EEEEiPT_T0_PT1_NS4_16integer_sequenceImJXspT2_EEEE+136)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#06 pc 00000000000aa7ac  /system/lib64/libgui.so (_ZN7android15SafeBnInterfaceINS_22ISurfaceComposerClientEE9callLocalIMS1_FiRKNS_7String8EjjijRKNS_2spINS_7IBinderEEENS_13LayerMetadataEPS9_PNS7_INS_22IGraphicBufferProducerEEEEEEiRKNS_6ParcelEPSJ_T_+172)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#07 pc 000000000004c6b8  /system/lib64/libbinder.so (android::BBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+136)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#08 pc 0000000000058d08  /system/lib64/libbinder.so (android::IPCThreadState::executeCommand(int)+984)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#09 pc 000000000005887c  /system/lib64/libbinder.so (android::IPCThreadState::getAndExecuteCommand()+156)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#10 pc 0000000000058fc4  /system/lib64/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+60)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#11 pc 000000000007f578  /system/lib64/libbinder.so (android::PoolThread::threadLoop()+24)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#12 pc 00000000000137a4  /system/lib64/libutils.so (android::Thread::_threadLoop(void*)+284)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#13 pc 00000000000e230c  /apex/com.android.runtime/lib64/bionic/libc.so (__pthread_start(void*)+36)</span></span><br><span class="line">10-28 09:41:00.086   179   523 D BufferLayer:   <span class="comment">#14 pc 0000000000083d98  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（二）、Android-SurfaceFlinger内部机制"><a href="#（二）、Android-SurfaceFlinger内部机制" class="headerlink" title="（二）、Android SurfaceFlinger内部机制"></a>（二）、Android SurfaceFlinger内部机制</h4><h5 id="2-1-0-、BufferQueue介绍"><a href="#2-1-0-、BufferQueue介绍" class="headerlink" title="2.1.0 、BufferQueue介绍"></a>2.1.0 、BufferQueue介绍</h5><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。<br>从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/Android-Graphics-SurfaceFlinger-BufferQueue.png"></p>
<p>先来看一下图中几个状态代表的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure>
<p><strong>FREE :</strong><br>FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue“拥有”。 它转换到DEQUEUED<br>当调用dequeueBuffer时。</p>
<p><strong>DEQUEUED：</strong><br>DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer“拥有”。 它可以转换到QUEUED（通过<br>queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p>
<p><strong>QUEUED：</strong><br>QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续<br>  修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue“拥有”。 它<br>  可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p>
<p><strong>ACQUIRED：</strong><br>ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到<br>获得栅栏fence信号。 BufferSlot由Consumer“拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个<br>分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p>
<p><strong>SHARED：</strong><br> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合，<br>除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p>
<p><strong>简单描述一下状态转换过程：</strong></p>
<p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p>
<p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。 </p>
<p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p>
<p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p>
<h6 id="2-1-1、生产者Producer"><a href="#2-1-1、生产者Producer" class="headerlink" title="2.1.1、生产者Producer"></a>2.1.1、生产者Producer</h6><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/Android-Graphics-SurfaceFlinger-IGraphicsBufferProducer.png"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、requestBuffer</strong><br>requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestBuffer requests a new buffer for the given index. The server (i.e.</span></span><br><span class="line"><span class="comment">// the IGraphicBufferProducer implementation) assigns the newly created</span></span><br><span class="line"><span class="comment">// buffer to the given slot index, and the client is expected to mirror the</span></span><br><span class="line"><span class="comment">// slot-&gt;buffer mapping so that it&#x27;s not necessary to transfer a</span></span><br><span class="line"><span class="comment">// GraphicBuffer for every dequeue operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2、dequeueBuffer</strong><br>dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span></span><br><span class="line"><span class="comment">// of the slot is transfered to the client, meaning that the server will not</span></span><br><span class="line"><span class="comment">// use the contents of the buffer associated with that slot.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> usage)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp <GraphicBuffer>（即必须调用requestBuffer）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been dequeued, and the caller</span></span><br><span class="line"><span class="comment">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span></span><br><span class="line"><span class="comment">// requestBuffer).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was dequeued</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously dequeued.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="2-1-2、消费者Consumer"><a href="#2-1-2、消费者Consumer" class="headerlink" title="2.1.2、消费者Consumer"></a>2.1.2、消费者Consumer</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android10.Display.7/Android-Graphics-SurfaceFlinger-IGraphicsBufferConsumer.png"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、acquireBuffer</strong><br>acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span></span><br><span class="line"><span class="comment">// the BufferQueue.  If no buffer is pending then it returns</span></span><br><span class="line"><span class="comment">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span></span><br><span class="line"><span class="comment">// information about the buffer is returned in BufferItem.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2、releaseBuffer</strong><br>releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releaseBuffer releases a buffer slot from the consumer back to the</span></span><br><span class="line"><span class="comment">// BufferQueue.  This may be done while the buffer&#x27;s contents are still</span></span><br><span class="line"><span class="comment">// being accessed.  The fence will signal when the buffer is no longer</span></span><br><span class="line"><span class="comment">// in use. frameNumber is used to indentify the exact buffer returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="keyword">int</span> buf, <span class="keyword">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR fence,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="（三）、Surface管理图形缓冲区-lock-Buffer-amp-amp-unlockAndPost-Buffer的过程"><a href="#（三）、Surface管理图形缓冲区-lock-Buffer-amp-amp-unlockAndPost-Buffer的过程" class="headerlink" title="（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程"></a>（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程</h4><h5 id="3-1-0、APP申请-lock-Buffer的过程"><a href="#3-1-0、APP申请-lock-Buffer的过程" class="headerlink" title="3.1.0、APP申请(lock)Buffer的过程"></a>3.1.0、APP申请(lock)Buffer的过程</h5><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。<br>[-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line">X:\frameworks\native\libs\gui\Surface.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLockedBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Surface::lock failed, already locked&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mConnectedToCpu) &#123;</span><br><span class="line">        <span class="keyword">int</span> err = Surface::connect(NATIVE_WINDOW_API_CPU);</span><br><span class="line">        ......</span><br><span class="line">        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;dequeueBuffer failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line"></span><br><span class="line">        Region newDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">            newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">            newDirtyRegion.andSelf(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">                backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">                backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">            <span class="comment">// copy the area that is invalid and not repainted this round</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Region <span class="title">copyback</span><span class="params">(mDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!copyback.isEmpty()) &#123;</span><br><span class="line">                copyBlt(backBuffer, frontBuffer, copyback, &amp;fenceFd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if we can&#x27;t copy-back anything, modify the user&#x27;s dirty</span></span><br><span class="line">            <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">            newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            mDirtyRegion.clear();</span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">                mSlots[i].dirtyRegion.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">backBufferSlot</span><span class="params">(getSlotFromBufferLocked(backBuffer.get()))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (backBufferSlot &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function">Region&amp; <span class="title">dirtyRegion</span><span class="params">(mSlots[backBufferSlot].dirtyRegion)</span></span>;</span><br><span class="line">                mDirtyRegion.subtract(dirtyRegion);</span><br><span class="line">                dirtyRegion = newDirtyRegion;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDirtyRegion.orSelf(newDirtyRegion);</span><br><span class="line">        <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">            *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>* vaddr;</span><br><span class="line">        <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line"></span><br><span class="line">        ALOGW_IF(res, <span class="string">&quot;failed locking buffer (handle = %p)&quot;</span>,</span><br><span class="line">                backBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLockedBuffer = backBuffer;</span><br><span class="line">            outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">            outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">            outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">            outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">            outBuffer-&gt;bits   = vaddr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看看Log：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                                                                        FILE:LINE</span><br><span class="line">  <span class="number">000000000001f</span>c18  android::Gralloc2Mapper::lock(native_handle <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, android::Rect <span class="keyword">const</span>&amp;, <span class="keyword">int</span>, <span class="keyword">void</span>**, <span class="keyword">int</span>*, <span class="keyword">int</span>*) <span class="keyword">const</span>+<span class="number">224</span>                     frameworks/native/libs/ui/Gralloc2.cpp:<span class="number">276</span></span><br><span class="line">  <span class="number">0000000000025310</span>  android::GraphicBufferMapper::lockAsync(native_handle <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, android::Rect <span class="keyword">const</span>&amp;, <span class="keyword">void</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>*, <span class="keyword">int</span>*)+<span class="number">152</span>  frameworks/native/libs/ui/GraphicBufferMapper.cpp:<span class="number">146</span></span><br><span class="line">  v--------------&gt;  android::GraphicBuffer::lockAsync(<span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, android::Rect <span class="keyword">const</span>&amp;, <span class="keyword">void</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>*, <span class="keyword">int</span>*)                                  frameworks/native/libs/ui/GraphicBuffer.cpp:<span class="number">336</span></span><br><span class="line">  <span class="number">0000000000022e0</span>c  android::GraphicBuffer::lockAsync(<span class="keyword">unsigned</span> <span class="keyword">int</span>, android::Rect <span class="keyword">const</span>&amp;, <span class="keyword">void</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>*, <span class="keyword">int</span>*)+<span class="number">164</span>                                              frameworks/native/libs/ui/GraphicBuffer.cpp:<span class="number">322</span></span><br><span class="line">  <span class="number">00000000000b</span>c11c  android::Surface::lock(ANativeWindow_Buffer*, ARect*)+<span class="number">1172</span>                                                                                      frameworks/native/libs/gui/Surface.cpp:<span class="number">1878</span></span><br><span class="line">  <span class="number">0000000000011048</span>  android::LayerTransactionTest::getLayerBuffer(android::sp&lt;android::SurfaceControl&gt; <span class="keyword">const</span>&amp;)+<span class="number">248</span>                                                  /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">000000000000f</span>1e4  android::LayerTransactionTest_SetPositionBasic_Test::TestBody()+<span class="number">404</span>                                                                             /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">0000000000017b</span>8c  testing::Test::Run()+<span class="number">668</span>                                                                                                                        /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">00000000000188</span>dc  testing::TestInfo::Run()+<span class="number">676</span>                                                                                                                    /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">0000000000018</span>d70  testing::TestSuite::Run()+<span class="number">272</span>                                                                                                                   /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">0000000000025678</span>  testing::internal::UnitTestImpl::RunAllTests()+<span class="number">1112</span>                                                                                             /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">00000000000251</span>cc  testing::UnitTest::Run()+<span class="number">340</span>                                                                                                                    /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">0000000000012210</span>  main+<span class="number">72</span>                                                                                                                                         /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  <span class="number">000000000007</span>d844  __libc_init+<span class="number">108</span>                                                                                                                                 bionic/libc/bionic/libc_init_dynamic.cpp:<span class="number">136</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有：<br>       1）调用connect函数完成一些初始化；<br>       2）调用dequeueBuffer函数，申请图形缓冲区；<br>       3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。<br>       [-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\libs\gui\BufferQueueProducer.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">uint64_t</span> usage, <span class="keyword">uint64_t</span>* outBufferAge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            FrameEventHistoryDelta* outTimestamps)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line">        mConsumerName = mCore-&gt;mConsumerName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mConnectedApi == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: BufferQueue has no connected producer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: w=%u h=%u format=%#x, usage=%#&quot;</span> PRIx64, width, height, format, usage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((width &amp;&amp; !height) || (!width &amp;&amp; height)) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;dequeueBuffer: invalid size: w=%u h=%u&quot;</span>, width, height);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> returnFlags = NO_ERROR;</span><br><span class="line">    EGLDisplay eglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">    EGLSyncKHR eglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">    <span class="keyword">bool</span> attachedByConsumer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we don&#x27;t have a free buffer, but we are currently allocating, we wait until allocation</span></span><br><span class="line">        <span class="comment">// is finished such that we don&#x27;t allocate in parallel.</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mFreeBuffers.empty() &amp;&amp; mCore-&gt;mIsAllocating) &#123;</span><br><span class="line">            mDequeueWaitingForAllocation = <span class="literal">true</span>;</span><br><span class="line">            mCore-&gt;waitWhileAllocatingLocked(lock);</span><br><span class="line">            mDequeueWaitingForAllocation = <span class="literal">false</span>;</span><br><span class="line">            mDequeueWaitingForAllocationCondition.notify_all();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (format == <span class="number">0</span>) &#123;</span><br><span class="line">            format = mCore-&gt;mDefaultBufferFormat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable the usage bits the consumer requested</span></span><br><span class="line">        usage |= mCore-&gt;mConsumerUsageBits;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> useDefaultSize = !width &amp;&amp; !height;</span><br><span class="line">        <span class="keyword">if</span> (useDefaultSize) &#123;</span><br><span class="line">            width = mCore-&gt;mDefaultWidth;</span><br><span class="line">            height = mCore-&gt;mDefaultHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">        <span class="keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue, lock, &amp;found);</span><br><span class="line">            <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This should not happen</span></span><br><span class="line">            <span class="keyword">if</span> (found == BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                BQ_LOGE(<span class="string">&quot;dequeueBuffer: no available buffer slots&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EBUSY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we are not allowed to allocate new buffers,</span></span><br><span class="line">            <span class="comment">// waitForFreeSlotThenRelock must have returned a slot containing a</span></span><br><span class="line">            <span class="comment">// buffer. If this buffer would require reallocation to meet the</span></span><br><span class="line">            <span class="comment">// requested attributes, we free it and attempt to get another one.</span></span><br><span class="line">            <span class="keyword">if</span> (!mCore-&gt;mAllowAllocation) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot == found) &#123;</span><br><span class="line">                        BQ_LOGE(<span class="string">&quot;dequeueBuffer: cannot re-allocate a sharedbuffer&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCore-&gt;mFreeSlots.insert(found);</span><br><span class="line">                    mCore-&gt;clearBufferSlotLocked(found);</span><br><span class="line">                    found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot == found &amp;&amp;</span><br><span class="line">                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: cannot re-allocate a shared&quot;</span></span><br><span class="line">                    <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;</span><br><span class="line">            mCore-&gt;mActiveBuffers.insert(found);</span><br><span class="line">        &#125;</span><br><span class="line">        *outSlot = found;</span><br><span class="line">        ATRACE_BUFFER_INDEX(found);</span><br><span class="line"></span><br><span class="line">        attachedByConsumer = mSlots[found].mNeedsReallocation;</span><br><span class="line">        mSlots[found].mNeedsReallocation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        mSlots[found].mBufferState.dequeue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((buffer == <span class="literal">nullptr</span>) ||</span><br><span class="line">                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))</span><br><span class="line">        &#123;</span><br><span class="line">            mSlots[found].mAcquireCalled = <span class="literal">false</span>;</span><br><span class="line">            mSlots[found].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">            mSlots[found].mRequestBufferCalled = <span class="literal">false</span>;</span><br><span class="line">            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">            mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">            mCore-&gt;mBufferAge = <span class="number">0</span>;</span><br><span class="line">            mCore-&gt;mIsAllocating = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We add 1 because that will be the frame number when this buffer</span></span><br><span class="line">            <span class="comment">// is queued</span></span><br><span class="line">            mCore-&gt;mBufferAge = mCore-&gt;mFrameCounter + <span class="number">1</span> - mSlots[found].mFrameNumber;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BQ_LOGV(<span class="string">&quot;dequeueBuffer: setting buffer age to %&quot;</span> PRIu64,</span><br><span class="line">                mCore-&gt;mBufferAge);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CC_UNLIKELY(mSlots[found].mFence == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: about to return a NULL fence - &quot;</span></span><br><span class="line">                    <span class="string">&quot;slot=%d w=%d h=%d format=%u&quot;</span>,</span><br><span class="line">                    found, buffer-&gt;width, buffer-&gt;height, buffer-&gt;format);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eglDisplay = mSlots[found].mEglDisplay;</span><br><span class="line">        eglFence = mSlots[found].mEglFence;</span><br><span class="line">        <span class="comment">// Don&#x27;t return a fence in shared buffer mode, except for the first</span></span><br><span class="line">        <span class="comment">// frame.</span></span><br><span class="line">        *outFence = (mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                mCore-&gt;mSharedBufferSlot == found) ?</span><br><span class="line">                Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">        mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">        mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If shared buffer mode has just been enabled, cache the slot of the</span></span><br><span class="line">        <span class="comment">// first buffer that is dequeued and mark it as the shared buffer.</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot ==</span><br><span class="line">                BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">            mCore-&gt;mSharedBufferSlot = found;</span><br><span class="line">            mSlots[found].mBufferState.mShared = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        BQ_LOGV(<span class="string">&quot;dequeueBuffer: allocating a new buffer for slot %d&quot;</span>, *outSlot);</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">                width, height, format, BQ_LAYER_COUNT, usage,</span><br><span class="line">                &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.size()&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> error = graphicBuffer-&gt;initCheck();</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);</span><br><span class="line">                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCore-&gt;mIsAllocating = <span class="literal">false</span>;</span><br><span class="line">            mCore-&gt;mIsAllocatingCondition.notify_all();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">                mCore-&gt;mFreeSlots.insert(*outSlot);</span><br><span class="line">                mCore-&gt;clearBufferSlotLocked(*outSlot);</span><br><span class="line">                BQ_LOGE(<span class="string">&quot;dequeueBuffer: createGraphicBuffer failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">                mCore-&gt;mFreeSlots.insert(*outSlot);</span><br><span class="line">                mCore-&gt;clearBufferSlotLocked(*outSlot);</span><br><span class="line">                BQ_LOGE(<span class="string">&quot;dequeueBuffer: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> NO_INIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            VALIDATE_CONSISTENCY();</span><br><span class="line">        &#125; <span class="comment">// Autolock scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attachedByConsumer) &#123;</span><br><span class="line">        returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eglFence != EGL_NO_SYNC_KHR) &#123;</span><br><span class="line">        EGLint result = eglClientWaitSyncKHR(eglDisplay, eglFence, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1000000000</span>);</span><br><span class="line">        <span class="comment">// If something goes wrong, log the error, but return the buffer without</span></span><br><span class="line">        <span class="comment">// synchronizing access to it. It&#x27;s too late at this point to abort the</span></span><br><span class="line">        <span class="comment">// dequeue operation.</span></span><br><span class="line">        <span class="keyword">if</span> (result == EGL_FALSE) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: error %#x waiting for fence&quot;</span>,</span><br><span class="line">                    eglGetError());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == EGL_TIMEOUT_EXPIRED_KHR) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: timeout waiting for fence&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eglDestroySyncKHR(eglDisplay, eglFence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: returning slot=%d/%&quot;</span> PRIu64 <span class="string">&quot; buf=%p flags=%#x&quot;</span>,</span><br><span class="line">            *outSlot,</span><br><span class="line">            mSlots[*outSlot].mFrameNumber,</span><br><span class="line">            mSlots[*outSlot].mGraphicBuffer-&gt;handle, returnFlags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outBufferAge) &#123;</span><br><span class="line">        *outBufferAge = mCore-&gt;mBufferAge;</span><br><span class="line">    &#125;</span><br><span class="line">    addAndGetFrameTimestamps(<span class="literal">nullptr</span>, outTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看Log：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.093</span>   <span class="number">884</span>   <span class="number">884</span> <span class="symbol">V</span> <span class="symbol">Surface</span> : <span class="symbol">Surface</span>::connect</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.093</span>   <span class="number">884</span>   <span class="number">884</span> <span class="symbol">V</span> <span class="symbol">Surface</span> : <span class="symbol">Surface</span>::setUsage</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.093</span>   <span class="number">884</span>   <span class="number">884</span> <span class="symbol">V</span> <span class="symbol">Surface</span> : <span class="symbol">Surface</span>::dequeueBuffer</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.093</span>   <span class="number">179</span>   <span class="number">523</span> <span class="symbol">V</span> <span class="symbol">BufferQueueProducer</span>: [test#<span class="number">0</span>] dequeueBuffer: w=<span class="number">0</span> h=<span class="number">0</span> format=<span class="number">0</span>, usage=<span class="number">0x33</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Stack</span> <span class="symbol">Trace</span>:</span><br><span class="line">  <span class="symbol">RELADDR</span>           <span class="symbol">FUNCTION</span>                                                                                                                                                                                                                                                 <span class="symbol">FILE</span>:<span class="symbol">LINE</span></span><br><span class="line">  <span class="number">00000000000203</span>cc  android::<span class="symbol">Gralloc2Allocator</span>::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const+<span class="number">172</span>                                                                                         frameworks/native/libs/ui/<span class="symbol">Gralloc2</span>.cpp:<span class="number">444</span></span><br><span class="line">  <span class="number">00000000000243</span>f4  android::<span class="symbol">GraphicBufferAllocator</span>::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, native_handle const**, unsigned int*, unsigned long, std::<span class="symbol">__1</span>::basic_string&lt;char, std::<span class="symbol">__1</span>::char_traits&lt;char&gt;, std::<span class="symbol">__1</span>::allocator&lt;char&gt; &gt;)+<span class="number">284</span>  frameworks/native/libs/ui/<span class="symbol">GraphicBufferAllocator</span>.cpp:<span class="number">134</span></span><br><span class="line">  <span class="number">0000000000022234</span>  android::<span class="symbol">GraphicBuffer</span>::initWithSize(unsigned int, unsigned int, int, unsigned int, unsigned long, std::<span class="symbol">__1</span>::basic_string&lt;char, std::<span class="symbol">__1</span>::char_traits&lt;char&gt;, std::<span class="symbol">__1</span>::allocator&lt;char&gt; &gt;)+<span class="number">212</span>                                                            frameworks/native/libs/ui/<span class="symbol">GraphicBuffer</span>.cpp:<span class="number">207</span></span><br><span class="line">  <span class="number">0000000000022114</span>  android::<span class="symbol">GraphicBuffer</span>::<span class="symbol">GraphicBuffer</span>(unsigned int, unsigned int, int, unsigned int, unsigned long, std::<span class="symbol">__1</span>::basic_string&lt;char, std::<span class="symbol">__1</span>::char_traits&lt;char&gt;, std::<span class="symbol">__1</span>::allocator&lt;char&gt; &gt;)+<span class="number">124</span>                                                           frameworks/native/libs/ui/<span class="symbol">GraphicBuffer</span>.cpp:<span class="number">92</span></span><br><span class="line">  <span class="number">0000000000070</span>a8c  android::<span class="symbol">BufferQueueProducer</span>::dequeueBuffer(int*, android::sp&lt;android::<span class="symbol">Fence</span>&gt;*, unsigned int, unsigned int, int, unsigned long, unsigned long*, android::<span class="symbol">FrameEventHistoryDelta</span>*)+<span class="number">1516</span>                                                                   frameworks/native/libs/gui/<span class="symbol">BufferQueueProducer</span>.cpp:<span class="number">515</span></span><br><span class="line">  <span class="number">000000000007</span>ef34  android::<span class="symbol">BnGraphicBufferProducer</span>::onTransact(unsigned int, android::<span class="symbol">Parcel</span> const&amp;, android::<span class="symbol">Parcel</span>*, unsigned int)+<span class="number">1300</span>                                                                                                                                  frameworks/native/libs/gui/<span class="symbol">IGraphicBufferProducer</span>.cpp:<span class="number">806</span></span><br><span class="line">  <span class="number">000000000004</span>c6b8  android::<span class="symbol">BBinder</span>::transact(unsigned int, android::<span class="symbol">Parcel</span> const&amp;, android::<span class="symbol">Parcel</span>*, unsigned int)+<span class="number">136</span>                                                                                                                                                     frameworks/native/libs/binder/<span class="symbol">Binder</span>.cpp:<span class="number">134</span></span><br><span class="line">  <span class="number">0000000000058</span>d08  android::<span class="symbol">IPCThreadState</span>::executeCommand(int)+<span class="number">984</span>                                                                                                                                                                                                         frameworks/native/libs/binder/<span class="symbol">IPCThreadState</span>.cpp:<span class="number">1213</span></span><br><span class="line">  <span class="number">000000000005887</span>c  android::<span class="symbol">IPCThreadState</span>::getAndExecuteCommand()+<span class="number">156</span>                                                                                                                                                                                                      frameworks/native/libs/binder/<span class="symbol">IPCThreadState</span>.cpp:<span class="number">514</span></span><br><span class="line">  <span class="number">0000000000058</span>fc4  android::<span class="symbol">IPCThreadState</span>::joinThreadPool(bool)+<span class="number">60</span>                                                                                                                                                                                                         frameworks/native/libs/binder/<span class="symbol">IPCThreadState</span>.cpp:<span class="number">594</span></span><br><span class="line">  <span class="number">000000000007</span>f578  android::<span class="symbol">PoolThread</span>::threadLoop()+<span class="number">24</span>                                                                                                                                                                                                                     frameworks/native/libs/binder/<span class="symbol">ProcessState</span>.cpp:<span class="number">67</span></span><br><span class="line">  <span class="number">00000000000137</span>a4  android::<span class="symbol">Thread</span>::<span class="symbol">_threadLoop</span>(void*)+<span class="number">284</span>                                                                                                                                                                                                                  system/core/libutils/<span class="symbol">Threads</span>.cpp:<span class="number">746</span></span><br><span class="line">  <span class="number">00000000000e230</span>c  <span class="symbol">__pthread_start</span>(void*)+<span class="number">36</span>                                                                                                                                                                                                                                bionic/libc/bionic/pthread_create.cpp:<span class="number">338</span></span><br><span class="line">  <span class="number">0000000000083</span>d98  <span class="symbol">__start_thread</span>+<span class="number">64</span>                                                                                                                                                                                                                                        bionic/libc/bionic/clone.cpp:<span class="number">53</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着就会创建GraphicBuffer对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line">        BQ_LOGV(<span class="string">&quot;dequeueBuffer: allocating a new buffer for slot %d&quot;</span>, *outSlot);</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer = <span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">                width, height, format, BQ_LAYER_COUNT, usage,</span><br><span class="line">                &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.size()&#125;);</span><br><span class="line">X:\frameworks\native\libs\ui\GraphicBuffer.cpp</span><br><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight, PixelFormat inFormat,</span><br><span class="line">                             <span class="keyword">uint32_t</span> inLayerCount, <span class="keyword">uint64_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">      : GraphicBuffer() &#123;</span><br><span class="line">    mInitCheck = initWithSize(inWidth, inHeight, inFormat, inLayerCount, inUsage,</span><br><span class="line">                              <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBuffer::initWithSize</span><span class="params">(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">        PixelFormat inFormat, <span class="keyword">uint32_t</span> inLayerCount, <span class="keyword">uint64_t</span> inUsage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();</span><br><span class="line">    <span class="keyword">uint32_t</span> outStride = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = allocator.allocate(inWidth, inHeight, inFormat, inLayerCount,</span><br><span class="line">            inUsage, &amp;handle, &amp;outStride, mId,</span><br><span class="line">            <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        mBufferMapper.getTransportSize(handle, &amp;mTransportNumFds, &amp;mTransportNumInts);</span><br><span class="line"></span><br><span class="line">        width = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inWidth);</span><br><span class="line">        height = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inHeight);</span><br><span class="line">        format = inFormat;</span><br><span class="line">        layerCount = inLayerCount;</span><br><span class="line">        usage = inUsage;</span><br><span class="line">        usage_deprecated = <span class="keyword">int</span>(usage);</span><br><span class="line">        stride = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(outStride);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着请求GraphicBufferAllocator 做一个allocate的动作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\libs\ui\GraphicBufferAllocator.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GraphicBufferAllocator::allocate</span><span class="params">(<span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">        PixelFormat format, <span class="keyword">uint32_t</span> layerCount, <span class="keyword">uint64_t</span> usage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">uint32_t</span>* stride,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> <span class="comment">/*graphicBufferId*/</span>, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure to not allocate a N x 0 or 0 x N buffer, since this is</span></span><br><span class="line">    <span class="comment">// allowed from an API stand-point allocate a 1x1 buffer instead.</span></span><br><span class="line">    <span class="keyword">if</span> (!width || !height)</span><br><span class="line">        width = height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bpp = bytesPerPixel(format);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max() / width / height &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bpp)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to allocate (%u x %u) layerCount %u format %d &quot;</span></span><br><span class="line">              <span class="string">&quot;usage %&quot;</span> PRIx64 <span class="string">&quot;: Requesting too large a buffer size&quot;</span>,</span><br><span class="line">              width, height, layerCount, format, usage);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that layerCount is valid.</span></span><br><span class="line">    <span class="keyword">if</span> (layerCount &lt; <span class="number">1</span>)</span><br><span class="line">        layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/72323293, b/72703005): Remove these invalid bits from callers</span></span><br><span class="line">    usage &amp;= ~<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;((<span class="number">1</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> error =</span><br><span class="line">            mAllocator-&gt;allocate(width, height, format, layerCount, usage, <span class="number">1</span>, stride, handle);</span><br><span class="line">    <span class="keyword">size_t</span> bufSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if stride has no meaning or is too large,</span></span><br><span class="line">    <span class="comment">// approximate size with the input width instead</span></span><br><span class="line">    <span class="keyword">if</span> ((*stride) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">size_t</span>&gt;::max() / height / (*stride) &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bpp)) &#123;</span><br><span class="line">        bufSize = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(width) * height * bpp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bufSize = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;((*stride)) * height * bpp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == NO_ERROR) &#123;</span><br><span class="line">        Mutex::Autolock _l(sLock);</span><br><span class="line">        KeyedVector&lt;buffer_handle_t, alloc_rec_t&gt;&amp; list(sAllocList);</span><br><span class="line">        <span class="keyword">alloc_rec_t</span> rec;</span><br><span class="line">        rec.width = width;</span><br><span class="line">        rec.height = height;</span><br><span class="line">        rec.stride = *stride;</span><br><span class="line">        rec.format = format;</span><br><span class="line">        rec.layerCount = layerCount;</span><br><span class="line">        rec.usage = usage;</span><br><span class="line">        rec.size = bufSize;</span><br><span class="line">        rec.requestorName = <span class="built_in">std</span>::move(requestorName);</span><br><span class="line">        <span class="built_in">list</span>.add(*handle, rec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to allocate (%u x %u) layerCount %u format %d &quot;</span></span><br><span class="line">                <span class="string">&quot;usage %&quot;</span> PRIx64 <span class="string">&quot;: %d&quot;</span>,</span><br><span class="line">                width, height, layerCount, format, usage,</span><br><span class="line">                error);</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X:\frameworks\native\libs\ui\Gralloc2.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Gralloc2Allocator::allocate</span><span class="params">(<span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> layerCount, <span class="keyword">uint64_t</span> usage, <span class="keyword">uint32_t</span> bufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span>* outStride, <span class="keyword">buffer_handle_t</span>* outBufferHandles)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    IMapper::BufferDescriptorInfo descriptorInfo = &#123;&#125;;</span><br><span class="line">    descriptorInfo.width = width;</span><br><span class="line">    descriptorInfo.height = height;</span><br><span class="line">    descriptorInfo.layerCount = layerCount;</span><br><span class="line">    descriptorInfo.format = <span class="keyword">static_cast</span>&lt;hardware::graphics::common::V1_1::PixelFormat&gt;(format);</span><br><span class="line">    descriptorInfo.usage = usage;</span><br><span class="line"></span><br><span class="line">    BufferDescriptor descriptor;</span><br><span class="line">    <span class="keyword">status_t</span> error = mMapper.createDescriptor(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;descriptorInfo),</span><br><span class="line">                                              <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;descriptor));</span><br><span class="line">    <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(printTrace &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ALOGD_CALLSTACK(<span class="string">&quot;allocate&quot;</span>);</span><br><span class="line">        printTrace--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = mAllocator-&gt;allocate(descriptor, bufferCount,</span><br><span class="line">                                    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpStride,</span><br><span class="line">                                        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tmpBuffers) &#123;</span><br><span class="line">                                        error = <span class="keyword">static_cast</span>&lt;<span class="keyword">status_t</span>&gt;(tmpError);</span><br><span class="line">                                        <span class="keyword">if</span> (tmpError != Error::NONE) &#123;</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// import buffers</span></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">                                            error = mMapper.importBuffer(tmpBuffers[i],</span><br><span class="line">                                                                         &amp;outBufferHandles[i]);</span><br><span class="line">                                            <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">                                                <span class="keyword">for</span> (<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                                                    mMapper.freeBuffer(outBufferHandles[j]);</span><br><span class="line">                                                    outBufferHandles[j] = <span class="literal">nullptr</span>;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        *outStride = tmpStride;</span><br><span class="line">                                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the kernel driver sees BC_FREE_BUFFER and closes the fds now</span></span><br><span class="line">    hardware::IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ret.isOk()) ? error : <span class="keyword">static_cast</span>&lt;<span class="keyword">status_t</span>&gt;(kTransactionError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看Log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      FILE:LINE</span><br><span class="line">  000000000001f7e0  android::Gralloc2Mapper::importBuffer(android::hardware::hidl_handle const&amp;, native_handle const**) const+112                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;Gralloc2.cpp:180</span><br><span class="line">  v--------------&gt;  operator()&lt;android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; &gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;Gralloc2.cpp:458</span><br><span class="line">  v--------------&gt;  _ZNSt3__18__invokeIRZNK7android17Gralloc2Allocator8allocateEjjijmjPjPPK13native_handleE3$_7JNS1_8hardware8graphics6mapper4V2_05ErrorEjRKNSA_8hidl_vecINSA_11hidl_handleEEEEEEDTclclsr3std3__1E7forwardIT_Efp_Espclsr3std3__1E7forwardIT0_Efp0_EEEOSK_DpOSL_                                                                                                                                                                                                                                                                                                                                                                                                                                   external&#x2F;libcxx&#x2F;include&#x2F;type_traits:4353</span><br><span class="line">  v--------------&gt;  void std::__1::__invoke_void_return_wrapper&lt;void&gt;::__call&lt;android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7&amp;, android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;&gt;(android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7&amp;, android::hardware::graphics::mapper::V2_0::Error&amp;&amp;, unsigned int&amp;&amp;, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)                 external&#x2F;libcxx&#x2F;include&#x2F;__functional_base:349</span><br><span class="line">  v--------------&gt;  std::__1::__function::__alloc_func&lt;android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7, std::__1::allocator&lt;android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7&gt;, void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;::operator()(android::hardware::graphics::mapper::V2_0::Error&amp;&amp;, unsigned int&amp;&amp;, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)  external&#x2F;libcxx&#x2F;include&#x2F;functional:1527</span><br><span class="line">  0000000000020bcc  std::__1::__function::__func&lt;android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7, std::__1::allocator&lt;android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const::$_7&gt;, void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;::operator()(android::hardware::graphics::mapper::V2_0::Error&amp;&amp;, unsigned int&amp;&amp;, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)+116    external&#x2F;libcxx&#x2F;include&#x2F;functional:1651</span><br><span class="line">  v--------------&gt;  std::__1::__function::__value_func&lt;void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;::operator()(android::hardware::graphics::mapper::V2_0::Error&amp;&amp;, unsigned int&amp;&amp;, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;) const                                                                                                                                                                                                                                                                                                                                                       external&#x2F;libcxx&#x2F;include&#x2F;functional:1799</span><br><span class="line">  v--------------&gt;  std::__1::function&lt;void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;::operator()(android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;) const                                                                                                                                                                                                                                                                                                                                                                           external&#x2F;libcxx&#x2F;include&#x2F;functional:2347</span><br><span class="line">  000000000000b9c8  android::hardware::graphics::allocator::V2_0::BpHwAllocator::_hidl_allocate(android::hardware::IInterface*, android::hardware::details::HidlInstrumentor*, android::hardware::hidl_vec&lt;unsigned int&gt; const&amp;, unsigned int, std::__1::function&lt;void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;)+864                                                                                                                                                                                                                                                                                                 out&#x2F;soong&#x2F;.intermediates&#x2F;hardware&#x2F;interfaces&#x2F;graphics&#x2F;allocator&#x2F;2.0&#x2F;android.hardware.graphics.allocator@2.0_genc++&#x2F;gen&#x2F;android&#x2F;hardware&#x2F;graphics&#x2F;allocator&#x2F;2.0&#x2F;AllocatorAll.cpp:295</span><br><span class="line">  000000000000bdac  android::hardware::graphics::allocator::V2_0::BpHwAllocator::allocate(android::hardware::hidl_vec&lt;unsigned int&gt; const&amp;, unsigned int, std::__1::function&lt;void (android::hardware::graphics::mapper::V2_0::Error, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;)+156                                                                                                                                                                                                                                                                                                                                                                                      out&#x2F;soong&#x2F;.intermediates&#x2F;hardware&#x2F;interfaces&#x2F;graphics&#x2F;allocator&#x2F;2.0&#x2F;android.hardware.graphics.allocator@2.0_genc++&#x2F;gen&#x2F;android&#x2F;hardware&#x2F;graphics&#x2F;allocator&#x2F;2.0&#x2F;AllocatorAll.cpp:326</span><br><span class="line">  000000000002045c  android::Gralloc2Allocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, unsigned int, unsigned int*, native_handle const**) const+316                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;Gralloc2.cpp:448</span><br><span class="line">  00000000000243f4  android::GraphicBufferAllocator::allocate(unsigned int, unsigned int, int, unsigned int, unsigned long, native_handle const**, unsigned int*, unsigned long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;)+284                                                                                                                                                                                                                                                                                                                                                                                                                                       frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;GraphicBufferAllocator.cpp:134</span><br><span class="line">  0000000000022234  android::GraphicBuffer::initWithSize(unsigned int, unsigned int, int, unsigned int, unsigned long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;)+212                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;GraphicBuffer.cpp:207</span><br><span class="line">  0000000000022114  android::GraphicBuffer::GraphicBuffer(unsigned int, unsigned int, int, unsigned int, unsigned long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;)+124                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;GraphicBuffer.cpp:92</span><br><span class="line">  0000000000070b50  android::BufferQueueProducer::dequeueBuffer(int*, android::sp&lt;android::Fence&gt;*, unsigned int, unsigned int, int, unsigned long, unsigned long*, android::FrameEventHistoryDelta*)+1576                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;BufferQueueProducer.cpp:515</span><br><span class="line">  000000000007f47c  android::BnGraphicBufferProducer::onTransact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+1300                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;IGraphicBufferProducer.cpp:806</span><br><span class="line">  000000000004c6b8  android::BBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+136                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;Binder.cpp:134</span><br><span class="line">  0000000000058d08  android::IPCThreadState::executeCommand(int)+984                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp:1213</span><br><span class="line">  000000000005887c  android::IPCThreadState::getAndExecuteCommand()+156                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp:514</span><br><span class="line">  0000000000058fc4  android::IPCThreadState::joinThreadPool(bool)+60                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp:594</span><br><span class="line">  000000000007f578  android::PoolThread::threadLoop()+24                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp:67</span><br><span class="line">  00000000000137a4  android::Thread::_threadLoop(void*)+284                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       system&#x2F;core&#x2F;libutils&#x2F;Threads.cpp:746</span><br><span class="line">  00000000000e230c  __pthread_start(void*)+36                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     bionic&#x2F;libc&#x2F;bionic&#x2F;pthread_create.cpp:338</span><br><span class="line">  0000000000083d98  __start_thread+64                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             bionic&#x2F;libc&#x2F;bionic&#x2F;clone.cpp:53</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。这里只有一个buffer，slot为0。</p>
<p>看看Log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-DRM: handle: name&#x3D;0 pfd&#x3D;46</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: [File] : hardware&#x2F;rockchip&#x2F;libgralloc&#x2F;midgard&#x2F;gralloc_drm_rockchip.cpp; [Line] : 1766; [Func] : drm_gem_rockchip_alloc;</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: drm_gem_rockchip_alloc enter, w : 362, h : 1920, format : 0x1, usage : 0x933.</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: [File] : hardware&#x2F;rockchip&#x2F;libgralloc&#x2F;midgard&#x2F;gralloc_drm_rockchip.cpp; [Line] : 2168; [Func] : drm_gem_rockchip_alloc;</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: to ask for cachable buffer for CPU read, usage : 0x933</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: [File] : hardware&#x2F;rockchip&#x2F;libgralloc&#x2F;midgard&#x2F;gralloc_drm_rockchip.cpp; [Line] : 2664; [Func] : rk_drm_adapter_import_dma_buf;</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: imported a dma_buf as a gem_obj with handle 4</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: [File] : hardware&#x2F;rockchip&#x2F;libgralloc&#x2F;midgard&#x2F;gralloc_drm_rockchip.cpp; [Line] : 2375; [Func] : drm_gem_rockchip_alloc;</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: leave, w : 362, h : 1920, format : 0x1,internal_format : 0x1, usage : 0x933. size&#x3D;2826240,pixel_stride&#x3D;368,byte_stride&#x3D;1472</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: [File] : hardware&#x2F;rockchip&#x2F;libgralloc&#x2F;midgard&#x2F;gralloc_drm_rockchip.cpp; [Line] : 2376; [Func] : drm_gem_rockchip_alloc;</span><br><span class="line">10-28 09:41:00.121   179   523 D GRALLOC-ROCKCHIP: leave: prime_fd&#x3D;46,share_attr_fd&#x3D;48</span><br><span class="line">10-28 09:41:00.121   179   523 V BufferQueueProducer: [test#0] dequeueBuffer: returning slot&#x3D;0&#x2F;0 buf&#x3D;0x70f185f180 flags&#x3D;0x1</span><br><span class="line"></span><br><span class="line">10-28 09:41:00.122   179   189 V BufferQueueProducer: [test#0] requestBuffer: slot 0</span><br></pre></td></tr></table></figure>


<h5 id="3-1-1、SurfaceFlinger-test-red填充数据"><a href="#3-1-1、SurfaceFlinger-test-red填充数据" class="headerlink" title="3.1.1、SurfaceFlinger_test_red填充数据"></a>3.1.1、SurfaceFlinger_test_red填充数据</h5><p>我们这里将Layer填充为屏幕三分之一大小的红色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill a region with the specified color.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillBufferColor</span><span class="params">(<span class="keyword">const</span> ANativeWindow_Buffer&amp; buffer, <span class="keyword">const</span> Rect&amp; rect, <span class="keyword">const</span> Color&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> x = rect.left;</span><br><span class="line">    <span class="keyword">int32_t</span> y = rect.top;</span><br><span class="line">    <span class="keyword">int32_t</span> width = rect.right - rect.left;</span><br><span class="line">    <span class="keyword">int32_t</span> height = rect.bottom - rect.top;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        width += x;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        height += y;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x + width &gt; buffer.width) &#123;</span><br><span class="line">        x = <span class="built_in">std</span>::min(x, buffer.width);</span><br><span class="line">        width = buffer.width - x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y + height &gt; buffer.height) &#123;</span><br><span class="line">        y = <span class="built_in">std</span>::min(y, buffer.height);</span><br><span class="line">        height = buffer.height - y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* dst = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(buffer.bits) + (buffer.stride * (y + j) + x) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">            dst[<span class="number">0</span>] = color.r;</span><br><span class="line">            dst[<span class="number">1</span>] = color.g;</span><br><span class="line">            dst[<span class="number">2</span>] = color.b;</span><br><span class="line">            dst[<span class="number">3</span>] = color.a;</span><br><span class="line">            dst += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// anonymous namespace</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillLayerColor</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceControl&gt;&amp; layer, <span class="keyword">const</span> Color&amp; color)</span> </span>&#123;</span><br><span class="line">        ANativeWindow_Buffer buffer;</span><br><span class="line">        ASSERT_NO_FATAL_FAILURE(buffer = getLayerBuffer(layer));</span><br><span class="line">        fillBufferColor(buffer, Rect(<span class="number">0</span>, <span class="number">0</span>, buffer.width, buffer.height), color);</span><br><span class="line">        postLayerBuffer(layer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postLayerBuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceControl&gt;&amp; layer)</span> </span>&#123;</span><br><span class="line">        ASSERT_EQ(NO_ERROR, layer-&gt;getSurface()-&gt;unlockAndPost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wait for the newly posted buffer to be latched</span></span><br><span class="line">        waitForLayerBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="3-1-2、APP提交-unlockAndPost-Buffer的过程"><a href="#3-1-2、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="3.1.2、APP提交(unlockAndPost)Buffer的过程"></a>3.1.2、APP提交(unlockAndPost)Buffer的过程</h5><p> [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                        FILE:LINE</span><br><span class="line">  000000000001ffe4  android::Gralloc2Mapper::unlock(native_handle const*) const+116                                 frameworks/native/libs/ui/Gralloc2.cpp:361</span><br><span class="line">  0000000000025218  android::GraphicBufferMapper::unlockAsync(native_handle const*, int*)+80                        frameworks/native/libs/ui/GraphicBufferMapper.cpp:162</span><br><span class="line">  00000000000bc2f0  android::Surface::unlockAndPost()+64                                                            frameworks/native/libs/gui/Surface.cpp:1907</span><br><span class="line">  000000000001118c  android::LayerTransactionTest::postLayerBuffer(android::sp&lt;android::SurfaceControl&gt; const&amp;)+68  /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  000000000000f310  android::LayerTransactionTest_SetPositionBasic_Test::TestBody()+704                             /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  0000000000017b8c  testing::Test::Run()+668                                                                        /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  00000000000188dc  testing::TestInfo::Run()+676                                                                    /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  0000000000018d70  testing::TestSuite::Run()+272                                                                   /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  0000000000025678  testing::internal::UnitTestImpl::RunAllTests()+1112                                             /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  00000000000251cc  testing::UnitTest::Run()+340                                                                    /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  0000000000012210  main+72                                                                                         /system/bin/SurfaceFlinger_test_red</span><br><span class="line">  000000000007d844  __libc_init+108                                                                                 bionic/libc/bionic/libc_init_dynamic.cpp:136</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10-28 09:41:00.183   884   884 V Surface : Surface::queueBuffer</span><br><span class="line">10-28 09:41:00.183   884   884 V Surface : Surface::queueBuffer making up timestamp: 43112.59 ms</span><br><span class="line">10-28 09:41:00.183   179   523 V BufferQueueProducer: [<span class="built_in">test</span><span class="comment">#0] queueBuffer: slot=0/1 time=43112591811 dataSpace=0 validHdrMetadataTypes=0x0 crop=[0,0,0,0] transform=0 scale=FREEZE</span></span><br><span class="line">10-28 09:41:00.184   179   523 V ConsumerBase: [<span class="built_in">test</span><span class="comment">#0] onFrameAvailable</span></span><br><span class="line">10-28 09:41:00.184   179   523 V ConsumerBase: [<span class="built_in">test</span><span class="comment">#0] actually calling onFrameAvailable</span></span><br><span class="line">10-28 09:41:00.184   179   523 I BufferQueueLayer: zjj.rk3399.SF onFrameAvailable frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp onFrameAvailable 456 </span><br><span class="line">10-28 09:41:00.184   179   523 I BufferLayerConsumer: zjj.rk3399.SF onBufferAvailable frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp onBufferAvailable 506 </span><br><span class="line">10-28 09:41:00.184   179   523 I BufferLayerConsumer: zjj.rk3399.SF Image frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp Image 553 </span><br><span class="line">10-28 09:41:00.184   179   523 V BufferQueueProducer: [<span class="built_in">test</span><span class="comment">#0] addAndGetFrameTimestamps</span></span><br></pre></td></tr></table></figure>

<p>   这里也比较简单，核心也是分两步：<br>       1）解锁图形缓冲区，和前面的lockAsync成对出现；<br>       2）queueBuffer去归还图形缓冲区；<br>        所以我们还是重点分析第二步，查看queueBuffer的实现：<br>       [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。<br>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>       1）从传入的QueueBufferInput ，解析填充一些变量；<br>       2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断；<br>       3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem；<br>       4）将BufferItem塞进mCore的mQueue队列，依照指定规则；<br>       5）然后通知SurfaceFlinger去消费。<br>看看Log：</p>
<h4 id="（四）、通知SF消费合成"><a href="#（四）、通知SF消费合成" class="headerlink" title="（四）、通知SF消费合成"></a>（四）、通知SF消费合成</h4><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。<br>listener最终通过回调，会回到BufferLayer当中，所以最终调用BufferQueueLayer的onFrameAvailable接口，我们看看它的实现：<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueueLayer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ALOGI(<span class="string">&quot;zjj.rk3399.SF onFrameAvailable %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFlinger-&gt;mUseSmart90ForVideo) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> presentTime = item.mIsAutoTimestamp ? <span class="number">0</span> : item.mTimestamp;</span><br><span class="line">            mFlinger-&gt;mScheduler-&gt;addLayerPresentTimeAndHDR(mSchedulerLayerHandle, presentTime,</span><br><span class="line">                                                            item.mHdrMetadata.validTypes != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="comment">// Reset the frame number tracker when we receive the first buffer after</span></span><br><span class="line">        <span class="comment">// a frame number reset</span></span><br><span class="line">        <span class="keyword">if</span> (item.mFrameNumber == <span class="number">1</span>) &#123;</span><br><span class="line">            mLastFrameNumberReceived = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure that callbacks are handled in order</span></span><br><span class="line">        <span class="keyword">while</span> (item.mFrameNumber != mLastFrameNumberReceived + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = mQueueItemCondition.waitRelative(mQueueItemLock, ms2ns(<span class="number">500</span>));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;[%s] Timed out waiting on callback&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mQueueItems.push_back(item);</span><br><span class="line">        mQueuedFrames++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;mInterceptor-&gt;saveBufferUpdate(<span class="keyword">this</span>, item.mGraphicBuffer-&gt;getWidth(),</span><br><span class="line">                                             item.mGraphicBuffer-&gt;getHeight(), item.mFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this layer is orphaned, then we run a fake vsync pulse so that</span></span><br><span class="line">    <span class="comment">// dequeueBuffer doesn&#x27;t block indefinitely.</span></span><br><span class="line">    <span class="keyword">if</span> (isRemovedFromCurrentState()) &#123;</span><br><span class="line">        fakeVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    mConsumer-&gt;onBufferAvailable(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mScheduler-&gt;resetIdleTimer();</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又调用MessageQueue的invalidate函数：<br>[MessageQueue.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>MessageQueue中分发两个消息，一个INVALIDATE，一个REFRESH，SurfaceFlinger对这两个消息的响应过程，就是合成的过程。</p>
<h5 id="4-0、消息INVALIDATE处理"><a href="#4-0、消息INVALIDATE处理" class="headerlink" title="4.0、消息INVALIDATE处理"></a>4.0、消息INVALIDATE处理</h5><p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">// calculate the expected present time once and use the cached</span></span><br><span class="line">            <span class="comment">// value throughout this frame to make sure all layers are</span></span><br><span class="line">            <span class="comment">// seeing this same value.</span></span><br><span class="line">            populateExpectedPresentTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When Backpressure propagation is enabled we want to give a small grace period</span></span><br><span class="line">            <span class="comment">// for the present fence to fire instead of just giving up on this frame to handle cases</span></span><br><span class="line">            <span class="comment">// where present fence is just about to get signaled.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> graceTimeForPresentFenceMs =</span><br><span class="line">                    (mPropagateBackpressure &amp;&amp;</span><br><span class="line">                     (mPropagateBackpressureClientComposition || !mHadClientComposition))</span><br><span class="line">                    ? <span class="number">1</span></span><br><span class="line">                    : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> frameMissed = previousFrameMissed(graceTimeForPresentFenceMs);</span><br><span class="line">            <span class="keyword">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="keyword">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;FrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;HwcFrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;GpuFrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;incrementMissedFrames();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mUseSmart90ForVideo) &#123;</span><br><span class="line">                <span class="comment">// This call is made each time SF wakes up and creates a new frame. It is part</span></span><br><span class="line">                <span class="comment">// of video detection feature.</span></span><br><span class="line">                mScheduler-&gt;updateFpsBasedOnContent();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (performSetActiveConfig()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    signalLayerUpdate();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Now that we&#x27;re going to make it to the handleMessageTransaction()</span></span><br><span class="line">            <span class="comment">// call below it&#x27;s safe to call updateVrFlinger(), which will</span></span><br><span class="line">            <span class="comment">// potentially trigger a display handoff.</span></span><br><span class="line">            updateVrFlinger();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line"></span><br><span class="line">            updateCursorAsync();</span><br><span class="line">            updateInputFlinger();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">                <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">                <span class="comment">// repaint</span></span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在INVALIDATE过程中，主要做以下处理：</p>
<ul>
<li>对丢帧的处理</li>
</ul>
<p>如果丢帧，且mPropagateBackpressure为true，mPropagateBackpressure表示显示给压力了。显示说，太慢了，都丢帧了，给点压力，上层赶紧处理。mPropagateBackpressure是在SurfaceFlinger的构造函数中初始化的，受debug.sf.disable_backpressure属性的控制。</p>
<ul>
<li>更新VR updateVrFlinger</li>
</ul>
<p>这个只有在VR模式下才会起作用，我们这里先不管VR的事。</p>
<ul>
<li>处理Transition</li>
</ul>
<p>Transition的处理，前面我们已经说过，只是当时不清楚是什么时候触发的，现在清楚了。Vsync到来后，触发INVALIDATE消息时先去处理Transition。处理的过程就是前面已经说过的handleMessageTransaction，有需要可以回头去看看。这个过程就是处理应用传过来的各种Transition，需要记住的是在commit Transition时，又个状态的更替，mCurrentState赋值给了mDrawingState。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::commitTransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line">    mDrawingState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;commitChildList();</span><br><span class="line">    &#125;);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以SurfaceFlinger两个状态：<br>mCurrentState状态， 准备数据，应用传过来的数据保存在mCurrentState中。<br>mDrawingState状态，进程合成状态，需要进行合成的数据保存在mDrawingState中。<br>也就是说，每次合成时，先更新一下状态数据。每一层Layer也需要去更新状态数据。</p>
<ul>
<li>处理Invalidate<br>这是一个重要的流程，handleMessageInvalidate函数如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">bool</span> refreshNeeded = handlePageFlip();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF handleMessageInvalidate %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        computeLayerBounds();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.notify(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;getScreenBounds());</span><br><span class="line">        invalidateLayerStack(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.clear();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是调用handlePageFlip，做Page的Flip。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">//ALOGV(&quot;handlePageFlip&quot;);</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF handlePageFlip %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    <span class="keyword">nsecs_t</span> latchTime = systemTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line">    <span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line">    <span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line">    <span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line">    <span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line">    <span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line">    <span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line">    <span class="comment">// Display is now waiting on Layer 1&#x27;s frame, which is behind layer 0&#x27;s</span></span><br><span class="line">    <span class="comment">// second frame. But layer 0&#x27;s second frame could be waiting on display.</span></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;hasReadyFrame()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> expectedPresentTime = getExpectedPresentTime();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;shouldPresentNow(expectedPresentTime)) &#123;</span><br><span class="line">                mLayersWithQueuedFrames.push_back(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ATRACE_NAME(<span class="string">&quot;!layer-&gt;shouldPresentNow()&quot;</span>);</span><br><span class="line">                layer-&gt;useEmptyDamage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.empty()) &#123;</span><br><span class="line">        <span class="comment">// mStateLock is needed for latchBuffer as LayerRejecter::reject()</span></span><br><span class="line">        <span class="comment">// writes to Layer current state. See also b/119481871</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;latchBuffer(visibleRegions, latchTime)) &#123;</span><br><span class="line">                mLayersPendingRefresh.push_back(layer);</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;useSurfaceDamage();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;isBufferLatched()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mLayersWithQueuedFrames，用于标记那些已经有Frame的Layer，这得从Layer的onFrameAvailable说起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueueLayer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ALOGI(<span class="string">&quot;zjj.rk3399.SF onFrameAvailable %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFlinger-&gt;mUseSmart90ForVideo) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> presentTime = item.mIsAutoTimestamp ? <span class="number">0</span> : item.mTimestamp;</span><br><span class="line">            mFlinger-&gt;mScheduler-&gt;addLayerPresentTimeAndHDR(mSchedulerLayerHandle, presentTime,</span><br><span class="line">                                                            item.mHdrMetadata.validTypes != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="comment">// Reset the frame number tracker when we receive the first buffer after</span></span><br><span class="line">        <span class="comment">// a frame number reset</span></span><br><span class="line">        <span class="keyword">if</span> (item.mFrameNumber == <span class="number">1</span>) &#123;</span><br><span class="line">            mLastFrameNumberReceived = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure that callbacks are handled in order</span></span><br><span class="line">        <span class="keyword">while</span> (item.mFrameNumber != mLastFrameNumberReceived + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = mQueueItemCondition.waitRelative(mQueueItemLock, ms2ns(<span class="number">500</span>));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;[%s] Timed out waiting on callback&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mQueueItems.push_back(item);</span><br><span class="line">        mQueuedFrames++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;mInterceptor-&gt;saveBufferUpdate(<span class="keyword">this</span>, item.mGraphicBuffer-&gt;getWidth(),</span><br><span class="line">                                             item.mGraphicBuffer-&gt;getHeight(), item.mFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this layer is orphaned, then we run a fake vsync pulse so that</span></span><br><span class="line">    <span class="comment">// dequeueBuffer doesn&#x27;t block indefinitely.</span></span><br><span class="line">    <span class="keyword">if</span> (isRemovedFromCurrentState()) &#123;</span><br><span class="line">        fakeVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    mConsumer-&gt;onBufferAvailable(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>onFrameAvailable时，先将Buffer的窗口属性保存在mInterceptor中，这里我们暂时不看，记得标记一下。然后对FrameNumber进行处理，一是确保FrameNumber被重置时，重置mLastFrameNumberReceived，二时，确保FrameNumber的顺序。之后，将新过来的BufferItem，push到mQueueItems中，对mQueuedFrames数进行+1。最后才触发SurfaceFlinger进行signalLayerUpdate。<br>回到handlePageFlip。所以，对于触发SurfaceFlinger进行signalLayerUpdate的Layer，hasQueuedFrame为true，是有Queued的Frame的。<br>但是mLayersWithQueuedFrames还要一个条件，shouldPresentNow。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::shouldPresentNow</span><span class="params">(<span class="keyword">const</span> DispSync&amp; dispSync)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSidebandStreamChanged || mAutoRefresh) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mQueueItems.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> timestamp = mQueueItems[<span class="number">0</span>].mTimestamp;</span><br><span class="line">    <span class="keyword">nsecs_t</span> expectedPresent = mConsumer-&gt;computeExpectedPresent(dispSync);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore timestamps more than a second in the future</span></span><br><span class="line">    <span class="keyword">bool</span> isPlausible = timestamp &lt; (expectedPresent + s2ns(<span class="number">1</span>));</span><br><span class="line">    ALOGW_IF(!isPlausible,</span><br><span class="line">             <span class="string">&quot;[%s] Timestamp %&quot;</span> PRId64 <span class="string">&quot; seems implausible &quot;</span></span><br><span class="line">             <span class="string">&quot;relative to expectedPresent %&quot;</span> PRId64,</span><br><span class="line">             mName.<span class="built_in">string</span>(), timestamp, expectedPresent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isDue = timestamp &lt; expectedPresent;</span><br><span class="line">    <span class="keyword">return</span> isDue || !isPlausible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在shouldPresentNow的判断逻辑中，首先根据DispSync，去计算期望显示的时间。再看看Buffer的时间戳和期望显示的时间，如果Buffer的时间还没有到，且和期望显示的时间之间差不到1秒，那么shouldPresentNow成立。该Layer标记为mLayersWithQueuedFrames；否则，Layer使用空的DamageRegion。记住这个<strong>DamageRegion</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::useEmptyDamage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    surfaceDamageRegion.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续handlePageFlip函数分析。</p>
<p>对mLayersWithQueuedFrames标记的Layer进行处理</p>
<p>首先，通过latchBuffer获取Layer的Buffer；再更新Surface的Damage；再通过invalidateLayerStack去刷新脏区域，验证LayerStack。记住LayerStack这个概念。处理这块稍后继续～～～<br>注意这里重新signalLayerUpdate的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有BufferQueue过来，但是还没有到显示时间（mLayersWithQueuedFrames为空），或者没有获取到Buffer。重新触发一次更新～<br>注意handlePageFlip的返回值，有Layer要显示，且获取到Buffer时，才返回true。注意这里的<strong>mVisibleRegionsDirty</strong>，mVisibleRegionsDirty，脏区域，表示可见区域有更新。</p>
<h5 id="4-1、handlePageFlip获取Buffer"><a href="#4-1、handlePageFlip获取Buffer" class="headerlink" title="4.1、handlePageFlip获取Buffer"></a>4.1、handlePageFlip获取Buffer</h5><p>继续前面的Buffer的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions, latchTime))</span></span>;</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    invalidateLayerStack(layer, dirty);</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;isBufferLatched()) &#123;</span><br><span class="line">        newDataLatched = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 Buffer<br>Layer的latchBuffer函数比较长，这里将去获取Producer Queue过来的数据。我们分段来看：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::latchBuffer</span><span class="params">(<span class="keyword">bool</span>&amp; recomputeVisibleRegions, <span class="keyword">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF latchBuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> refreshRequired = latchSidebandStream(recomputeVisibleRegions);</span><br><span class="line">   ....... </span><br><span class="line">    <span class="comment">// we&#x27;ll trigger an update in onPreComposition().</span></span><br><span class="line">    <span class="keyword">if</span> (mRefreshPending) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ....... </span><br><span class="line">    <span class="keyword">if</span> (!fenceHasSignaled()) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;!fenceHasSignaled()&quot;</span>);</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capture the old state of the layer for comparisons later</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> oldOpacity = isOpaque(s);</span><br><span class="line">    sp&lt;GraphicBuffer&gt; oldBuffer = mActiveBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allTransactionsSignaled()) &#123;</span><br><span class="line">        mFlinger-&gt;setTransactionFlags(eTraversalNeeded);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = updateTexImage(recomputeVisibleRegions, latchTime);</span><br><span class="line">    ....... </span><br><span class="line"></span><br><span class="line">    err = updateActiveBuffer();</span><br><span class="line">   ....... </span><br><span class="line">    mBufferLatched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    err = updateFrameNumber(latchTime);</span><br><span class="line">   ....... </span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">true</span>;</span><br><span class="line">    mFrameLatencyNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// the first time we receive a buffer, we need to trigger a</span></span><br><span class="line">        <span class="comment">// geometry invalidation.</span></span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ui::Dataspace dataSpace = getDrawingDataSpace();</span><br><span class="line">    <span class="comment">// translate legacy dataspaces to modern dataspaces</span></span><br><span class="line">    <span class="keyword">switch</span> (dataSpace) &#123;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::SRGB:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_SRGB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::SRGB_LINEAR:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_SRGB_LINEAR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::JFIF:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_JFIF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT601_625:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT601_625;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT601_525:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT601_525;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT709:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT709;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentDataSpace = dataSpace;</span><br><span class="line"></span><br><span class="line">    <span class="function">Rect <span class="title">crop</span><span class="params">(getDrawingCrop())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">uint32_t</span> <span class="title">transform</span><span class="params">(getDrawingTransform())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">uint32_t</span> <span class="title">scalingMode</span><span class="params">(getDrawingScalingMode())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="title">transformToDisplayInverse</span><span class="params">(getTransformToDisplayInverse())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((crop != mCurrentCrop) || (transform != mCurrentTransform) ||</span><br><span class="line">        (scalingMode != mCurrentScalingMode) ||</span><br><span class="line">        (transformToDisplayInverse != mTransformToDisplayInverse)) &#123;</span><br><span class="line">        mCurrentCrop = crop;</span><br><span class="line">        mCurrentTransform = transform;</span><br><span class="line">        mCurrentScalingMode = scalingMode;</span><br><span class="line">        mTransformToDisplayInverse = transformToDisplayInverse;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> bufWidth = mActiveBuffer-&gt;getWidth();</span><br><span class="line">        <span class="keyword">uint32_t</span> bufHeight = mActiveBuffer-&gt;getHeight();</span><br><span class="line">        <span class="keyword">if</span> (bufWidth != <span class="keyword">uint32_t</span>(oldBuffer-&gt;width) || bufHeight != <span class="keyword">uint32_t</span>(oldBuffer-&gt;height)) &#123;</span><br><span class="line">            recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldOpacity != isOpaque(s)) &#123;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any sync points corresponding to the buffer which was just</span></span><br><span class="line">    <span class="comment">// latched</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> point = mLocalSyncPoints.begin();</span><br><span class="line">        <span class="keyword">while</span> (point != mLocalSyncPoints.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(*point)-&gt;frameIsAvailable() || !(*point)-&gt;transactionIsApplied()) &#123;</span><br><span class="line">                <span class="comment">// This sync point must have been added since we started</span></span><br><span class="line">                <span class="comment">// latching. Don&#x27;t drop it yet.</span></span><br><span class="line">                ++point;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((*point)-&gt;getFrameNumber() &lt;= mCurrentFrameNumber) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;Dropping sync point &quot;</span> &lt;&lt; (*point)-&gt;getFrameNumber();</span><br><span class="line">                ATRACE_NAME(ss.str().c_str());</span><br><span class="line">                point = mLocalSyncPoints.erase(point);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateActiveBuffer()更新当前激活buffer。<br>看看Log：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayer: zjj.rk3399.SF latchBuffer frameworks/native/services/surfaceflinger/BufferLayer.cpp latchBuffer <span class="number">629</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayer: zjj.rk3399.SF hasReadyFrame frameworks/native/services/surfaceflinger/BufferLayer.cpp hasReadyFrame <span class="number">795</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferQueueLayer: zjj.rk3399.SF updateTexImage frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp updateTexImage <span class="number">278</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferQueueProducer: [test#<span class="number">0</span>] query: <span class="number">11</span>? <span class="number">0</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] updateTexImage</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayerConsumer: zjj.rk3399.SF updateTexImage frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp updateTexImage <span class="number">108</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayerConsumer: zjj.rk3399.SF acquireBufferLocked frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp acquireBufferLocked <span class="number">218</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V ConsumerBase: [test#<span class="number">0</span>] acquireBufferLocked: -&gt; slot=<span class="number">0</span>/<span class="number">1</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayerConsumer: zjj.rk3399.SF updateAndReleaseLocked frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp updateAndReleaseLocked <span class="number">243</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] updateAndRelease: (slot=<span class="number">-1</span> buf=<span class="number">0x0</span>) -&gt; (slot=<span class="number">0</span> buf=<span class="number">0x70f185f180</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] computeCurrentTransformMatrixLocked</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayerConsumer: zjj.rk3399.SF computeCurrentTransformMatrixLocked frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp computeCurrentTransformMatrixLocked <span class="number">343</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] getFrameNumber</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferQueueLayer: zjj.rk3399.SF updateActiveBuffer frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp updateActiveBuffer <span class="number">383</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayerConsumer: zjj.rk3399.SF getCurrentBuffer frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp getCurrentBuffer <span class="number">402</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferLayer: zjj.rk3399.SF getCompositionLayer frameworks/native/services/surfaceflinger/BufferLayer.cpp getCompositionLayer <span class="number">939</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> I BufferQueueLayer: zjj.rk3399.SF updateFrameNumber frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp updateFrameNumber <span class="number">398</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] getFrameNumber</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">00.211</span>   <span class="number">179</span>   <span class="number">179</span> V BufferLayerConsumer: [test#<span class="number">0</span>] getCurrentDataSpace</span><br></pre></td></tr></table></figure>

<p>接着调用BufferQueueLayer 的 updateTexImage()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\BufferQueueLayer.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueLayer::updateTexImage</span><span class="params">(<span class="keyword">bool</span>&amp; recomputeVisibleRegions, <span class="keyword">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This boolean is used to make sure that SurfaceFlinger&#x27;s shadow copy</span></span><br><span class="line">    <span class="comment">// of the buffer queue isn&#x27;t modified when the buffer queue is returning</span></span><br><span class="line">    <span class="comment">// BufferItem&#x27;s that weren&#x27;t actually queued. This can happen in shared</span></span><br><span class="line">    <span class="comment">// buffer mode.</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF updateTexImage %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> queuedBuffer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> layerID = getSequence();</span><br><span class="line">    <span class="function">LayerRejecter <span class="title">r</span><span class="params">(mDrawingState, getCurrentState(), recomputeVisibleRegions,</span></span></span><br><span class="line"><span class="function"><span class="params">                    getProducerStickyTransform() != <span class="number">0</span>, mName.<span class="built_in">string</span>(), mOverrideScalingMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                    getTransformToDisplayInverse(), mFreezeGeometryUpdates)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> expectedPresentTime = mFlinger-&gt;getExpectedPresentTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRemovedFromCurrentState()) &#123;</span><br><span class="line">        expectedPresentTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// updateTexImage() below might drop the some buffers at the head of the queue if there is a</span></span><br><span class="line">    <span class="comment">// buffer behind them which is timely to be presented. However this buffer may not be signaled</span></span><br><span class="line">    <span class="comment">// yet. The code below makes sure that this wouldn&#x27;t happen by setting maxFrameNumber to the</span></span><br><span class="line">    <span class="comment">// last buffer that was signaled.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> lastSignaledFrameNumber = mLastFrameNumberReceived;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mQueueItems.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> fenceSignaled =</span><br><span class="line">                    mQueueItems[i].mFenceTime-&gt;getSignalTime() != Fence::SIGNAL_TIME_PENDING;</span><br><span class="line">            <span class="keyword">if</span> (!fenceSignaled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastSignaledFrameNumber = mQueueItems[i].mFrameNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> maxFrameNumberToAcquire =</span><br><span class="line">            <span class="built_in">std</span>::min(mLastFrameNumberReceived.load(), lastSignaledFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> updateResult = mConsumer-&gt;updateTexImage(&amp;r, expectedPresentTime, &amp;mAutoRefresh,</span><br><span class="line">                                                      &amp;queuedBuffer, maxFrameNumberToAcquire);</span><br><span class="line">    <span class="keyword">if</span> (updateResult == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">        <span class="comment">// Producer doesn&#x27;t want buffer to be displayed yet.  Signal a</span></span><br><span class="line">        <span class="comment">// layer update so we check again at the next opportunity.</span></span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult == BufferLayerConsumer::BUFFER_REJECTED) &#123;</span><br><span class="line">        <span class="comment">// If the buffer has been rejected, remove it from the shadow queue</span></span><br><span class="line">        <span class="comment">// and return early</span></span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock lock(mQueueItemLock);</span><br><span class="line">            mConsumer-&gt;mergeSurfaceDamage(mQueueItems[<span class="number">0</span>].mSurfaceDamage);</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;removeTimeRecord(layerID, mQueueItems[<span class="number">0</span>].mFrameNumber);</span><br><span class="line">            mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">            mQueuedFrames--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult != NO_ERROR || mUpdateTexImageFailed) &#123;</span><br><span class="line">        <span class="comment">// This can occur if something goes wrong when trying to create the</span></span><br><span class="line">        <span class="comment">// EGLImage for this buffer. If this happens, the buffer has already</span></span><br><span class="line">        <span class="comment">// been released, so we need to clean up the queue and bug out</span></span><br><span class="line">        <span class="comment">// early.</span></span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock lock(mQueueItemLock);</span><br><span class="line">            mQueueItems.clear();</span><br><span class="line">            mQueuedFrames = <span class="number">0</span>;</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;onDestroy(layerID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once we have hit this state, the shadow queue may no longer</span></span><br><span class="line">        <span class="comment">// correctly reflect the incoming BufferQueue&#x27;s contents, so even if</span></span><br><span class="line">        <span class="comment">// updateTexImage starts working, the only safe course of action is</span></span><br><span class="line">        <span class="comment">// to continue to ignore updates.</span></span><br><span class="line">        mUpdateTexImageFailed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">        <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="keyword">auto</span> currentFrameNumber = mConsumer-&gt;getFrameNumber();</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove any stale buffers that have been dropped during</span></span><br><span class="line">        <span class="comment">// updateTexImage</span></span><br><span class="line">        <span class="keyword">while</span> (mQueueItems[<span class="number">0</span>].mFrameNumber != currentFrameNumber) &#123;</span><br><span class="line">            mConsumer-&gt;mergeSurfaceDamage(mQueueItems[<span class="number">0</span>].mSurfaceDamage);</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;removeTimeRecord(layerID, mQueueItems[<span class="number">0</span>].mFrameNumber);</span><br><span class="line">            mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">            mQueuedFrames--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFlinger-&gt;mTimeStats-&gt;setAcquireFence(layerID, currentFrameNumber,</span><br><span class="line">                                              mQueueItems[<span class="number">0</span>].mFenceTime);</span><br><span class="line">        mFlinger-&gt;mTimeStats-&gt;setLatchTime(layerID, currentFrameNumber, latchTime);</span><br><span class="line"></span><br><span class="line">        mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decrement the queued-frames count.  Signal another event if we</span></span><br><span class="line">    <span class="comment">// have more frames pending.</span></span><br><span class="line">    <span class="keyword">if</span> ((queuedBuffer &amp;&amp; mQueuedFrames.fetch_sub(<span class="number">1</span>) &gt; <span class="number">1</span>) || mAutoRefresh) &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看BufferLayerConsumer::updateTexImage</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\BufferLayerConsumer.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="keyword">nsecs_t</span> expectedPresentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">bool</span>* autoRefresh, <span class="keyword">bool</span>* queuedBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    BLC_LOGV(<span class="string">&quot;updateTexImage&quot;</span>);</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF updateTexImage %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        BLC_LOGE(<span class="string">&quot;updateTexImage: BufferLayerConsumer is abandoned!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire the next buffer.</span></span><br><span class="line">    <span class="comment">// In asynchronous mode the list is guaranteed to be one buffer</span></span><br><span class="line">    <span class="comment">// deep, while in synchronous mode we use the oldest buffer.</span></span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, expectedPresentTime, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == BufferQueue::NO_BUFFER_AVAILABLE) &#123;</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">            <span class="comment">// return the error, without logging</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BLC_LOGE(<span class="string">&quot;updateTexImage: acquire failed: %s (%d)&quot;</span>, strerror(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoRefresh) &#123;</span><br><span class="line">        *autoRefresh = item.mAutoRefresh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">        *queuedBuffer = item.mQueuedBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We call the rejecter here, in case the caller has a reason to</span></span><br><span class="line">    <span class="comment">// not accept this buffer.  This is used by SurfaceFlinger to</span></span><br><span class="line">    <span class="comment">// reject buffers which have the wrong size</span></span><br><span class="line">    <span class="keyword">int</span> slot = item.mSlot;</span><br><span class="line">    <span class="keyword">if</span> (rejecter &amp;&amp; rejecter-&gt;reject(mSlots[slot].mGraphicBuffer, item)) &#123;</span><br><span class="line">        releaseBufferLocked(slot, mSlots[slot].mGraphicBuffer);</span><br><span class="line">        <span class="keyword">return</span> BUFFER_REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the previous buffer.</span></span><br><span class="line">    err = updateAndReleaseLocked(item, &amp;mPendingRelease);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mRE.useNativeFenceSync()) &#123;</span><br><span class="line">        <span class="comment">// Bind the new buffer to the GL texture.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Older devices require the &quot;implicit&quot; synchronization provided</span></span><br><span class="line">        <span class="comment">// by glEGLImageTargetTexture2DOES, which this method calls.  Newer</span></span><br><span class="line">        <span class="comment">// devices will either call this in Layer::onDraw, or (if it&#x27;s not</span></span><br><span class="line">        <span class="comment">// a GL-composited layer) not at all.</span></span><br><span class="line">        err = bindTextureImageLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     PendingRelease* pendingRelease)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slot = item.mSlot;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF updateAndReleaseLocked %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    BLC_LOGV(<span class="string">&quot;updateAndRelease: (slot=%d buf=%p) -&gt; (slot=%d buf=%p)&quot;</span>, mCurrentTexture,</span><br><span class="line">             (mCurrentTextureBuffer != <span class="literal">nullptr</span> &amp;&amp; mCurrentTextureBuffer-&gt;graphicBuffer() != <span class="literal">nullptr</span>)</span><br><span class="line">                     ? mCurrentTextureBuffer-&gt;graphicBuffer()-&gt;handle</span><br><span class="line">                     : <span class="number">0</span>,</span><br><span class="line">             slot, mSlots[slot].mGraphicBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hang onto the pointer so that it isn&#x27;t freed in the call to</span></span><br><span class="line">    <span class="comment">// releaseBufferLocked() if we&#x27;re in shared buffer mode and both buffers are</span></span><br><span class="line">    <span class="comment">// the same.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; nextTextureBuffer;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line">        nextTextureBuffer = mImages[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release old buffer</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingRelease == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> status =</span><br><span class="line">                    releaseBufferLocked(mCurrentTexture, mCurrentTextureBuffer-&gt;graphicBuffer());</span><br><span class="line">            <span class="keyword">if</span> (status &lt; NO_ERROR) &#123;</span><br><span class="line">                BLC_LOGE(<span class="string">&quot;updateAndRelease: failed to release buffer: %s (%d)&quot;</span>, strerror(-status),</span><br><span class="line">                         status);</span><br><span class="line">                err = status;</span><br><span class="line">                <span class="comment">// keep going, with error raised [?]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingRelease-&gt;currentTexture = mCurrentTexture;</span><br><span class="line">            pendingRelease-&gt;graphicBuffer = mCurrentTextureBuffer-&gt;graphicBuffer();</span><br><span class="line">            pendingRelease-&gt;isPending = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the BufferLayerConsumer state.</span></span><br><span class="line">    mCurrentTexture = slot;</span><br><span class="line">    mCurrentTextureBuffer = nextTextureBuffer;</span><br><span class="line">    mCurrentCrop = item.mCrop;</span><br><span class="line">    mCurrentTransform = item.mTransform;</span><br><span class="line">    mCurrentScalingMode = item.mScalingMode;</span><br><span class="line">    mCurrentTimestamp = item.mTimestamp;</span><br><span class="line">    mCurrentDataSpace = <span class="keyword">static_cast</span>&lt;ui::Dataspace&gt;(item.mDataSpace);</span><br><span class="line">    mCurrentHdrMetadata = item.mHdrMetadata;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line">    mCurrentFenceTime = item.mFenceTime;</span><br><span class="line">    mCurrentFrameNumber = item.mFrameNumber;</span><br><span class="line">    mCurrentTransformToDisplayInverse = item.mTransformToDisplayInverse;</span><br><span class="line">    mCurrentSurfaceDamage = item.mSurfaceDamage;</span><br><span class="line">    mCurrentApi = item.mApi;</span><br><span class="line"></span><br><span class="line">    computeCurrentTransformMatrixLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::acquireBufferLocked</span><span class="params">(BufferItem* item, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF acquireBufferLocked %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = ConsumerBase::acquireBufferLocked(item, presentWhen, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If item-&gt;mGraphicBuffer is not null, this buffer has not been acquired</span></span><br><span class="line">    <span class="comment">// before, so we need to clean up old references.</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mImages[item-&gt;mSlot] == <span class="literal">nullptr</span> || mImages[item-&gt;mSlot]-&gt;graphicBuffer() == <span class="literal">nullptr</span> ||</span><br><span class="line">            mImages[item-&gt;mSlot]-&gt;graphicBuffer()-&gt;getId() != item-&gt;mGraphicBuffer-&gt;getId()) &#123;</span><br><span class="line">            mImages[item-&gt;mSlot] = <span class="built_in">std</span>::make_shared&lt;Image&gt;(item-&gt;mGraphicBuffer, mRE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::bindTextureImageLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF bindTextureImageLocked %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTextureBuffer != <span class="literal">nullptr</span> &amp;&amp; mCurrentTextureBuffer-&gt;graphicBuffer() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mRE.bindExternalTextureBuffer(mTexName, mCurrentTextureBuffer-&gt;graphicBuffer(),</span><br><span class="line">                                             mCurrentFence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>invalidateLayerStack的处理如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::invalidateLayerStack</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> Layer&gt;&amp; layer, <span class="keyword">const</span> Region&amp; dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;belongsToDisplay(hw-&gt;getLayerStack(), hw-&gt;isPrimary())) &#123;</span><br><span class="line">            hw-&gt;dirtyRegion.orSelf(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>layerStack，Layer的栈，Android支持多个屏幕，layer可以定制化的只显示到某个显示屏幕上。其中就是靠layerStack来实现的。Layer的stack值如果和DisplayDevice的stack值一样，那说明这个layer是属于这个显示屏幕的。<br>INVALIDATE消息处理，基本完成。如果需要刷新，触发刷新的消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\SurfaceFlinger.cpp</span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line"></span><br><span class="line">            updateCursorAsync();</span><br><span class="line">            updateInputFlinger();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">                <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">                <span class="comment">// repaint</span></span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>什么时候需要刷新？</p>
<ul>
<li>有新的Transaction处理</li>
<li>PageFlip时，有Buffer更新！～</li>
<li>有重新合成请求时mRepaintEverything，这是响应HWC的请求时触发的。<br>刷新消息REFRESH处理<br>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[SurfaceFlinger.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF handleMessageRefresh %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = mRepaintEverything.exchange(<span class="literal">false</span>);</span><br><span class="line">    preComposition();</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    calculateWorkingSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        beginFrame(display);</span><br><span class="line">        prepareFrame(display);</span><br><span class="line">        doDebugFlashRegions(display, repaintEverything);</span><br><span class="line">        doComposition(display, repaintEverything);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For rk:</span></span><br><span class="line">    <span class="comment">// Adapt to HWC1,all displays call postFramebuffer after prepareFrame</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        postFramebuffer(display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logLayerStats();</span><br><span class="line"></span><br><span class="line">    postFrame();</span><br><span class="line">    postComposition();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || getHwComposer().hasClientComposition(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.onRefreshed(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleMessageRefresh 函数中，包含了刷新一帧显示数据所有的流程。下面我们分别来进行说明。</p>
<h3 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF preComposition %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    mRefreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;onPreComposition(mRefreshStartTime)) &#123;</span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合成前，先遍历所有需要进行合成的Layer，调Layer的onPreComposition方法。</p>
<p>ColorLayer的onPreComposition，返回值是固定的，为true；BufferLayer的onPreComposition如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="keyword">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF onPreComposition %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.addPreComposition(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> hasReadyFrame();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF hasReadyFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasFrameUpdate() || getSidebandStreamChanged() || getAutoRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构Layer的Stack rebuildLayerStacks<br>现在，我们需要合成显示的Layer数据，都保存在mDrawingState的layersSortedByZ中，且是按照z-order的顺序进行存放。那么rebuild Layer又是做什么呢？</p>
<h3 id="二、rebuildLayerStacks-函数"><a href="#二、rebuildLayerStacks-函数" class="headerlink" title="二、rebuildLayerStacks()函数"></a>二、rebuildLayerStacks()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF rebuildLayerStacks %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayDevice = <span class="built_in">pair</span>.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="keyword">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="keyword">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">//ALOGV(&quot;computeVisibleRegions&quot;);</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF computeVisibleRegions %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.clear();</span><br><span class="line"></span><br><span class="line">    mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// start with the whole surface at its current location</span></span><br><span class="line">        <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// only consider the layers on the given layer stack</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * opaqueRegion: area of a surface that is fully opaque.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * visibleRegion: area of a surface that is visible on screen</span></span><br><span class="line"><span class="comment">         * and not fully transparent. This is essentially the layer&#x27;s</span></span><br><span class="line"><span class="comment">         * footprint minus the opaque regions above it.</span></span><br><span class="line"><span class="comment">         * Areas covered by a translucent surface are considered visible.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * coveredRegion: area of a surface that is covered by all</span></span><br><span class="line"><span class="comment">         * visible regions above it (which includes the translucent areas).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * transparentRegion: area of a surface that is hinted to be completely</span></span><br><span class="line"><span class="comment">         * transparent. This is only used to tell when the layer has no visible</span></span><br><span class="line"><span class="comment">         * non-transparent regions and can be removed from the layer list. It</span></span><br><span class="line"><span class="comment">         * does not affect the visibleRegion of this layer or any layers</span></span><br><span class="line"><span class="comment">         * beneath it. The hint may not be correct if apps don&#x27;t respect the</span></span><br><span class="line"><span class="comment">         * SurfaceView restrictions (which, sadly, some don&#x27;t).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Region transparentRegion;</span><br></pre></td></tr></table></figure>
<p>我们先来看Display的几个关于区域的概念：</p>
<ul>
<li>脏区域 dirtyRegion<br>计算脏区域时，outDirtyRegion先清空～  然后遍历mDrawingState中的Layer，如果Layer不属于Display，那么就返回了，outDirtyRegion为空。</li>
<li>非透明区域 opaqueRegion<br>Surface(Layer)完全不透明的区域<br>可见区域 visibleRegion<br>Layer可以被看见的区域，包括不完全透明的区域。原则上，这就是整个Surface减去非透明区域。</li>
<li>被覆盖区域 coveredRegion<br>Surface被上面的Surface覆盖的区域，包括被透明区域覆盖的区域。</li>
<li>透明区域 transparentRegion<br>Surface完全透明的部分，如果没有可见的非透明区域，这个Layer就可以从Layer列表中删掉。它并不影响该Layer本身或其下方Layer的可见区域大小。这个区域可能不太准，如果App不遵守SurfaceView的限制，可悲的是，确实有不遵守的。</li>
</ul>
<p>回到computeVisibleRegions函数，其是按照z-order进行反序号遍历的，所以从最上面开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// handle hidden surfaces by setting the visible region to empty</span></span><br><span class="line">        <span class="keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> translucent = !layer-&gt;isOpaque(s);</span><br><span class="line">            <span class="function">Rect <span class="title">bounds</span><span class="params">(layer-&gt;getScreenBounds())</span></span>;</span><br><span class="line"></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            ui::Transform tr = layer-&gt;getTransform();</span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// Remove the transparent area from the visible region</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tr.preserveRects()) &#123;</span><br><span class="line">                        <span class="comment">// transform the transparent region</span></span><br><span class="line">                        transparentRegion = tr.transform(layer-&gt;getActiveTransparentRegion(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// transformation too complex, can&#x27;t do the</span></span><br><span class="line">                        <span class="comment">// transparent region optimization.</span></span><br><span class="line">                        transparentRegion.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// compute the opaque region</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int32_t</span> layerOrientation = tr.getOrientation();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;getAlpha() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;getRoundedCornerState().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// the opaque region is the layer&#x27;s footprint</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visibleRegion.isEmpty()) &#123;</span><br><span class="line">            layer-&gt;clearVisibilityRegions();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clip the covered region to the visible region</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update aboveCoveredLayers for next (lower) layer</span></span><br><span class="line">        aboveCoveredLayers.orSelf(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// subtract the opaque region covered by the layers above us</span></span><br><span class="line">        visibleRegion.subtractSelf(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute this layer&#x27;s dirty region</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// we need to invalidate the whole region</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.orSelf(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* compute the exposed region:</span></span><br><span class="line"><span class="comment">             *   the exposed region consists of two components:</span></span><br><span class="line"><span class="comment">             *   1) what&#x27;s VISIBLE now and was COVERED before</span></span><br><span class="line"><span class="comment">             *   2) what&#x27;s EXPOSED now less what was EXPOSED before</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * note that (1) is conservative, we start with the whole</span></span><br><span class="line"><span class="comment">             * visible region but only keep what used to be covered by</span></span><br><span class="line"><span class="comment">             * something -- which mean it may have been exposed.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * (2) handles areas that were not covered by anything but got</span></span><br><span class="line"><span class="comment">             * exposed because of a resize.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line">        dirty.subtractSelf(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// accumulate to the screen dirty region</span></span><br><span class="line">        outDirtyRegion.orSelf(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update aboveOpaqueLayers for next (lower) layer</span></span><br><span class="line">        aboveOpaqueLayers.orSelf(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the visible region in screen space</span></span><br><span class="line">        layer-&gt;setVisibleRegion(visibleRegion);</span><br><span class="line">        layer-&gt;setCoveredRegion(coveredRegion);</span><br><span class="line">        layer-&gt;setVisibleNonTransparentRegion(</span><br><span class="line">                visibleRegion.subtract(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> getTransform 获取 Layer的变换矩阵<br>屏幕有旋转，需要做变换，去适配显示屏幕</p>
<p>回到 computeVisibleRegions函数，计算完可见区域，计算非透明区域，一般情况下，如果layer是非透明的，非透明区域就是可见区域<br>outDirtyRegion 是屏幕的脏区域，它是每个Layer脏区域的合。最后将计算好的区域值设置到Layer中。outOpaqueRegion是屏幕的非透明区域。</p>
<ul>
<li>setVisibleRegion 设置可见区域</li>
<li>setCoveredRegion 设置被覆盖的区域</li>
<li>setVisibleNonTransparentRegion 设置可见的非透明区域，它是可见区域，减去透明区域。</li>
</ul>
<p>回到rebuildLayerStacks函数～ computeVisibleRegions结束后，屏幕的脏区域得到了，每个Layer的可见区域，被覆盖的区域，以及可见非透明区域都计算出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF rebuildLayerStacks %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayDevice = <span class="built_in">pair</span>.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="keyword">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="keyword">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;getCompositionLayer();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;getId();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;getLayerFE();</span><br><span class="line">                    LOG_ALWAYS_FATAL_IF(layerFE.get() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;belongsInOutput(layer-&gt;getLayerStack(),</span><br><span class="line">                                                 layer-&gt;getPrimaryDisplayOnly())) &#123;</span><br><span class="line">                        Region drawRegion(tr.transform(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.andSelf(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.emplace_back(</span><br><span class="line">                                display-&gt;getOrCreateOutputLayer(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.add(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.back()-&gt;editState();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.transform(layer-&gt;visibleRegion.intersect(displayState.viewport));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">// For layers that are being removed from a HWC display,</span></span><br><span class="line">                        <span class="comment">// and that have queued frames, add them to a a list of</span></span><br><span class="line">                        <span class="comment">// released layers so we can properly set a fence.</span></span><br><span class="line">                        <span class="keyword">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;getOutputLayerForLayer(compositionLayer.get()) != <span class="literal">nullptr</span>;</span><br><span class="line">                        <span class="keyword">bool</span> hasQueuedFrames = <span class="built_in">std</span>::find(mLayersWithQueuedFrames.cbegin(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.cend(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.cend();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            layersNeedingFences.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            display-&gt;setOutputLayersOrderedByZ(<span class="built_in">std</span>::move(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;editState().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;editState().dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rebuildLayerStacks函数中对Layer再遍历一次，这次是正序，也就是从下往上。遍历时，主要做了一下处理：</p>
<ul>
<li>计算Layer需要绘制的区域drawRegion，将Layer的可见区域和Display的大小做交集而得到</li>
<li>如果drawRegion不为空，将该Layer加到当前Display的Layer列表中，也是按照z-order进行存放layersSortedByZ。每个Display有自己的layersSortedByZ。</li>
<li>如果之前Layer是可见的，现在不可见，销毁掉hwc Layer。销毁的Layer放到layersNeedingFences中，它虽然不需要releaseFence，但是还是需要fence去释放旧的Buffer。</li>
</ul>
<p>rebuildLayerStacks的最后，将数据更新到Display中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : mDisplays) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            display-&gt;setOutputLayersOrderedByZ(<span class="built_in">std</span>::move(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;editState().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;editState().dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Display中还有一个区域，叫未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</p>
<p>创建Layer栈完成，此时需要进行合成显示的数据已经被更新到每个Display各自的layersSortedByZ中。</p>
<h3 id="三、calculateWorkingSet-函数"><a href="#三、calculateWorkingSet-函数" class="headerlink" title="三、calculateWorkingSet()函数"></a>三、calculateWorkingSet()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立HWC中的Layer列表</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同样需要针对各个Display做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;editState();</span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Z轴顺序依次递增</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。</span></span><br><span class="line">                <span class="comment">// 也就是frontEnd（LayerFECompositionState）中</span></span><br><span class="line">                layer-&gt;getLayerFE().latchCompositionState(layer-&gt;getLayer().editState().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新计算OutputLayer的几何状态</span></span><br><span class="line">                <span class="comment">// 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、</span></span><br><span class="line">                <span class="comment">// 变换窗口裁剪以匹配缓冲区坐标系等等。</span></span><br><span class="line">                layer-&gt;updateCompositionState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Layer更新完毕的几何状态写入HWC</span></span><br><span class="line">                layer-&gt;writeStateToHWC(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每帧的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;getDisplayColorProfile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;setColorTransform(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            pickColorMode(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            display-&gt;setColorMode(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">            layer-&gt;setPerFrameData(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;getSupportedPerFrameMetadata(),</span><br><span class="line">                                   isHdrColorMode(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="keyword">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;getCompositionType(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里建立HWC中的Layer列表：</p>
<p>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC将Layer的mActiveBuffer设置到HWComposer中</p>
<h4 id="3-1、setPerFrameData"><a href="#3-1、setPerFrameData" class="headerlink" title="3.1、setPerFrameData()"></a>3.1、setPerFrameData()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">X:\frameworks\native\services\surfaceflinger\BufferLayer.cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::setPerFrameData</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> ui::Transform&amp; transform, <span class="keyword">const</span> Rect&amp; viewport,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int32_t</span> supportedPerFrameMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> ui::Dataspace targetDataspace)</span> </span>&#123;</span><br><span class="line">    RETURN_IF_NO_HWC_LAYER(displayDevice);</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF setPerFrameData %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply this display&#x27;s projection&#x27;s viewport to the visible region</span></span><br><span class="line">    <span class="comment">// before giving it to the HWC HAL.</span></span><br><span class="line">    Region visible = transform.transform(visibleRegion.intersect(viewport));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> outputLayer = findOutputLayerForDisplay(displayDevice);</span><br><span class="line">    LOG_FATAL_IF(!outputLayer || !outputLayer-&gt;getState().hwc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = (*outputLayer-&gt;getState().hwc).hwcLayer;</span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setVisibleRegion(visible);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set visible region: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        visible.dump(LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">    outputLayer-&gt;editState().visibleRegion = visible;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line"></span><br><span class="line">    error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set surface damage: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        surfaceDamageRegion.dump(LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">    layerCompositionState.surfaceDamage = surfaceDamageRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sideband layers</span></span><br><span class="line">    <span class="keyword">if</span> (layerCompositionState.sidebandStream.get()) &#123;</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::SIDEBAND);</span><br><span class="line">        ALOGV(<span class="string">&quot;[%s] Requesting Sideband composition&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        error = hwcLayer-&gt;setSidebandStream(layerCompositionState.sidebandStream-&gt;handle());</span><br><span class="line">        <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;[%s] Failed to set sideband stream %p: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">                  layerCompositionState.sidebandStream-&gt;handle(), to_string(error).c_str(),</span><br><span class="line">                  <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        &#125;</span><br><span class="line">        layerCompositionState.compositionType = Hwc2::IComposerClient::Composition::SIDEBAND;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Device or Cursor layers</span></span><br><span class="line">    <span class="keyword">if</span> (mPotentialCursor) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;[%s] Requesting Cursor composition&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CURSOR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;[%s] Requesting Device composition&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::DEVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ui::Dataspace dataspace = isColorSpaceAgnostic() &amp;&amp; targetDataspace != ui::Dataspace::UNKNOWN</span><br><span class="line">            ? targetDataspace</span><br><span class="line">            : mCurrentDataSpace;</span><br><span class="line">    error = hwcLayer-&gt;setDataspace(dataspace);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set dataspace %d: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(), dataspace,</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> HdrMetadata&amp; metadata = getDrawingHdrMetadata();</span><br><span class="line">    error = hwcLayer-&gt;setPerFrameMetadata(supportedPerFrameMetadata, metadata);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None &amp;&amp; error != HWC2::Error::Unsupported) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set hdrMetadata: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = hwcLayer-&gt;setColorTransform(getColorTransform());</span><br><span class="line">    <span class="keyword">if</span> (error == HWC2::Error::Unsupported) &#123;</span><br><span class="line">        <span class="comment">// If per layer color transform is not supported, we use GPU composition.</span></span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CLIENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to setColorTransform: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line">    layerCompositionState.dataspace = mCurrentDataSpace;</span><br><span class="line">    layerCompositionState.colorTransform = getColorTransform();</span><br><span class="line">    layerCompositionState.hdrMetadata = metadata;</span><br><span class="line"></span><br><span class="line">    setHwcLayerBuffer(displayDevice);</span><br><span class="line">    <span class="comment">// Use rk ashmem -------</span></span><br><span class="line">    <span class="keyword">if</span>(mActiveBuffer != <span class="literal">nullptr</span>)</span><br><span class="line">        set_handle_layername(mActiveBuffer-&gt;handle, mName.<span class="built_in">string</span>());</span><br><span class="line">    <span class="comment">// Use rk ashmem -------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X:\frameworks\native\services\surfaceflinger\BufferQueueLayer.cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueueLayer::setHwcLayerBuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; display)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF setHwcLayerBuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> outputLayer = findOutputLayerForDisplay(display);</span><br><span class="line">    LOG_FATAL_IF(!outputLayer);</span><br><span class="line">    LOG_FATAL_IF(!outputLayer-&gt;getState.hwc);</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = (*outputLayer-&gt;getState().hwc).hwcLayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> hwcSlot = <span class="number">0</span>;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; hwcBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// INVALID_BUFFER_SLOT is used to identify BufferStateLayers.  Default to 0</span></span><br><span class="line">    <span class="comment">// for BufferQueueLayers</span></span><br><span class="line">    <span class="keyword">int</span> slot = (mActiveBufferSlot == BufferQueue::INVALID_BUFFER_SLOT) ? <span class="number">0</span> : mActiveBufferSlot;</span><br><span class="line">    (*outputLayer-&gt;editState().hwc)</span><br><span class="line">            .hwcBufferCache.getHwcBuffer(slot, mActiveBuffer, &amp;hwcSlot, &amp;hwcBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> acquireFence = mConsumer-&gt;getCurrentFence();</span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setBuffer(hwcSlot, hwcBuffer, acquireFence);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set buffer %p: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(), mActiveBuffer-&gt;handle,</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line">    layerCompositionState.bufferSlot = mActiveBufferSlot;</span><br><span class="line">    layerCompositionState.buffer = mActiveBuffer;</span><br><span class="line">    layerCompositionState.acquireFence = acquireFence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、beginFrame-函数"><a href="#四、beginFrame-函数" class="headerlink" title="四、beginFrame()函数"></a>四、beginFrame()函数</h3><p>开始合成前的准备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有待更新的区域</span></span><br><span class="line">    <span class="keyword">bool</span> dirty = !display-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="comment">// 可见Layer数量是否为0</span></span><br><span class="line">    <span class="keyword">bool</span> empty = displayDevice-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上次合成是否有可见Layer</span></span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过</span></span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> flagPrefix[] = &#123;<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>&gt;(flagPrefix);</span><br><span class="line">    ALOGV_IF(displayDevice-&gt;isVirtual(), <span class="string">&quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;</span>,</span><br><span class="line">             __FUNCTION__, mustRecompose ? <span class="string">&quot;doing&quot;</span> : <span class="string">&quot;skipping&quot;</span>,</span><br><span class="line">             displayDevice-&gt;getDebugName().c_str(), flagPrefix[dirty], flagPrefix[empty],</span><br><span class="line">             flagPrefix[wasEmpty]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类</span></span><br><span class="line">    display-&gt;getRenderSurface()-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;editState().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">RenderSurface::beginFrame</span><span class="params">(<span class="keyword">bool</span> mustRecompose)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF beginFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;beginFrame(mustRecompose);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::beginFrame</span><span class="params">(<span class="keyword">bool</span> <span class="comment">/*mustRecompose*/</span>)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF beginFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、prepareFrame-函数"><a href="#五、prepareFrame-函数" class="headerlink" title="五、prepareFrame()函数"></a>五、prepareFrame()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::prepareFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF prepareFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayState.isEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = display-&gt;getRenderSurface()-&gt;prepareFrame();</span><br><span class="line">    ALOGE_IF(result != NO_ERROR, <span class="string">&quot;prepareFrame failed for %s: %d (%s)&quot;</span>,</span><br><span class="line">             displayDevice-&gt;getDebugName().c_str(), result, strerror(-result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">RenderSurface::prepareFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF prepareFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwc = mCompositionEngine.getHwComposer();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> id = mDisplay.getId();</span><br><span class="line">    <span class="keyword">if</span> (id) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> error = hwc.prepare(*id, mDisplay);</span><br><span class="line">        <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DisplaySurface::CompositionType compositionType;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasClient = hwc.hasClientComposition(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasDevice = hwc.hasDeviceComposition(id);</span><br><span class="line">    <span class="keyword">if</span> (hasClient &amp;&amp; hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_MIXED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasClient) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_GLES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Nothing to do -- when turning the screen off we get a frame like</span></span><br><span class="line">        <span class="comment">// this. Call it a HWC frame since we won&#x27;t be doing any GLES work but</span></span><br><span class="line">        <span class="comment">// will do a prepare/set cycle.</span></span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;prepareFrame(compositionType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::prepareFrame</span><span class="params">(CompositionType <span class="comment">/*compositionType*/</span>)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF prepareFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、doComposition-display-repaintEverything-函数"><a href="#六、doComposition-display-repaintEverything-函数" class="headerlink" title="六、doComposition(display, repaintEverything)函数"></a>六、doComposition(display, repaintEverything)函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="keyword">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF doComposition %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen&#x27;s coordinate space</span></span><br><span class="line">        <span class="keyword">const</span> Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;editState().dirtyRegion.clear();</span><br><span class="line">        display-&gt;getRenderSurface()-&gt;flip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line">    <span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line">    <span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line">    <span class="comment">// 2) There is work to be done (the dirty region isn&#x27;t empty)</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;getId() &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF doDisplayComposition %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGV(&quot;doDisplayComposition&quot;);</span></span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line">    <span class="keyword">if</span> (!doComposeSurfaces(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap buffers (presentation)</span></span><br><span class="line">    display-&gt;getRenderSurface()-&gt;queueBuffer(<span class="built_in">std</span>::move(readyFence));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF doComposeSurfaces %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderEngine = getRenderEngine();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> supportProtectedContent = renderEngine.supportsProtectedContent();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasClientComposition = getHwComposer().hasClientComposition(displayId);</span><br><span class="line">    ATRACE_INT(<span class="string">&quot;hasClientComposition&quot;</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (displayDevice-&gt;isPrimary() &amp;&amp; supportProtectedContent) &#123;</span><br><span class="line">            <span class="keyword">bool</span> needsProtected = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">                <span class="comment">// If the layer is a protected layer, mark protected context is needed.</span></span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isProtected()) &#123;</span><br><span class="line">                    needsProtected = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needsProtected != renderEngine.isProtected()) &#123;</span><br><span class="line">                renderEngine.useProtectedContext(needsProtected);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needsProtected != display-&gt;getRenderSurface()-&gt;isProtected() &amp;&amp;</span><br><span class="line">                needsProtected == renderEngine.isProtected()) &#123;</span><br><span class="line">                display-&gt;getRenderSurface()-&gt;setProtected(needsProtected);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf = display-&gt;getRenderSurface()-&gt;dequeueBuffer(&amp;fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot;</span></span><br><span class="line">                  <span class="string">&quot;client composition for this frame&quot;</span>,</span><br><span class="line">                  displayDevice-&gt;getDisplayName().c_str());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor;</span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="keyword">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.asMatrix4();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>* profile = display-&gt;getDisplayColorProfile();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;hasWideColorGamut()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">                profile-&gt;getHdrCapabilities().getDesiredMaxLuminance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> hasDeviceComposition = getHwComposer().hasDeviceComposition(displayId);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> skipClientColorTransform =</span><br><span class="line">                getHwComposer()</span><br><span class="line">                        .hasDisplayCapability(displayId,</span><br><span class="line">                                              HWC2::DisplayCapability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the global color transform matrix.</span></span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * and then, render the layers targeted at the framebuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;Rendering client layers&quot;</span>);</span><br><span class="line">    <span class="keyword">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        ALOGV(<span class="string">&quot;Layer: %s&quot;</span>, layer-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line">        ALOGV(<span class="string">&quot;  Composition type: %s&quot;</span>, toString(layer-&gt;getCompositionType(displayDevice)).c_str());</span><br><span class="line">        <span class="keyword">if</span> (!clip.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;getCompositionType(displayDevice)) &#123;</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CURSOR:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::DEVICE:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SIDEBAND:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SOLID_COLOR: &#123;</span><br><span class="line">                    LOG_ALWAYS_FATAL_IF(!displayId);</span><br><span class="line">                    <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">state</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (layer-&gt;getClearClientTarget(displayDevice) &amp;&amp; !firstLayer &amp;&amp;</span><br><span class="line">                        layer-&gt;isOpaque(state) &amp;&amp; (layer-&gt;getAlpha() == <span class="number">1.0f</span>) &amp;&amp;</span><br><span class="line">                        layer-&gt;getRoundedCornerState().radius == <span class="number">0.0f</span> &amp;&amp; hasClientComposition) &#123;</span><br><span class="line">                        <span class="comment">// never clear the very first layer since we&#x27;re</span></span><br><span class="line">                        <span class="comment">// guaranteed the FB is already cleared</span></span><br><span class="line">                        renderengine::LayerSettings layerSettings;</span><br><span class="line">                        Region dummyRegion;</span><br><span class="line">                        <span class="keyword">bool</span> prepared =</span><br><span class="line">                                layer-&gt;prepareClientLayer(renderArea, clip, dummyRegion,</span><br><span class="line">                                                          supportProtectedContent, layerSettings);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                            layerSettings.source.buffer.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">                            layerSettings.source.solidColor = half3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                            layerSettings.alpha = half(<span class="number">0.0</span>);</span><br><span class="line">                            layerSettings.disableBlending = <span class="literal">true</span>;</span><br><span class="line">                            clientCompositionLayers.push_back(layerSettings);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="keyword">bool</span> prepared =</span><br><span class="line">                            layer-&gt;prepareClientLayer(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        clientCompositionLayers.push_back(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform some cleanup steps if we used client composition.</span></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        clientCompositionDisplay.clearRegion = clearRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We boost GPU frequency here because there will be color spaces conversion</span></span><br><span class="line">        <span class="comment">// and it&#x27;s expensive. We boost the GPU frequency so that GPU composition can</span></span><br><span class="line">        <span class="comment">// finish in time. We must reset GPU frequency afterwards, because high frequency</span></span><br><span class="line">        <span class="comment">// consumes extra battery.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> expensiveRenderingExpected =</span><br><span class="line">                clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3;</span><br><span class="line">        <span class="keyword">if</span> (expensiveRenderingExpected &amp;&amp; displayId) &#123;</span><br><span class="line">            mPowerAdvisor.setExpensiveRenderingExpected(*displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!debugRegion.isEmpty()) &#123;</span><br><span class="line">            Region::const_iterator it = debugRegion.begin();</span><br><span class="line">            Region::const_iterator end = debugRegion.end();</span><br><span class="line">            <span class="keyword">while</span> (it != end) &#123;</span><br><span class="line">                <span class="keyword">const</span> Rect&amp; rect = *it++;</span><br><span class="line">                renderengine::LayerSettings layerSettings;</span><br><span class="line">                layerSettings.source.buffer.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">                layerSettings.source.solidColor = half3(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">                layerSettings.geometry.boundaries = rect.toFloatRect();</span><br><span class="line">                layerSettings.alpha = half(<span class="number">1.0</span>);</span><br><span class="line">                clientCompositionLayers.push_back(layerSettings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGD_CALLSTACK(<span class="string">&quot;drawLayers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        renderEngine.drawLayers(clientCompositionDisplay, clientCompositionLayers,</span><br><span class="line">                                buf-&gt;getNativeBuffer(), <span class="comment">/*useFramebufferCache=*/</span><span class="literal">true</span>, <span class="built_in">std</span>::move(fd),</span><br><span class="line">                                readyFence);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">        mPowerAdvisor.setExpensiveRenderingExpected(*displayId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-1、RenderSurface-gt-dequeueBuffer-amp-fd"><a href="#6-1、RenderSurface-gt-dequeueBuffer-amp-fd" class="headerlink" title="6.1、RenderSurface()-&gt;dequeueBuffer(&amp;fd)"></a>6.1、RenderSurface()-&gt;dequeueBuffer(&amp;fd)</h4><p>看看Log：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.275</span>   <span class="number">179</span>   <span class="number">179</span> V SurfaceFlinger: hasClientComposition</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.275</span>   <span class="number">179</span>   <span class="number">179</span> I CompositionEngine: zjj.rk3399.SF dequeueBuffer frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp dequeueBuffer <span class="number">166</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.275</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine: queueBuffer</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">00</span> pc <span class="number">000000000011</span>ed98  /system/lib64/libsurfaceflinger.so (android::compositionengine::impl::RenderSurface::dequeueBuffer(android::base::unique_fd_impl&lt;android::base::DefaultCloser&gt;*)+<span class="number">184</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">01</span> pc <span class="number">00000000000e3998</span>  /system/lib64/libsurfaceflinger.so (android::SurfaceFlinger::doComposeSurfaces(android::sp&lt;android::DisplayDevice&gt; <span class="keyword">const</span>&amp;, android::Region <span class="keyword">const</span>&amp;, android::base::unique_fd_impl&lt;android::base::DefaultCloser&gt;*)+<span class="number">1024</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">02</span> pc <span class="number">00000000000e0868</span>  /system/lib64/libsurfaceflinger.so (android::SurfaceFlinger::handleMessageRefresh()+<span class="number">3528</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">03</span> pc <span class="number">00000000000</span>df6bc  /system/lib64/libsurfaceflinger.so (android::SurfaceFlinger::onMessageReceived(<span class="keyword">int</span>)+<span class="number">9484</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">04</span> pc <span class="number">0000000000017</span>dfc  /system/lib64/libutils.so (android::Looper::pollInner(<span class="keyword">int</span>)+<span class="number">332</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">05</span> pc <span class="number">0000000000017</span>c10  /system/lib64/libutils.so (android::Looper::pollOnce(<span class="keyword">int</span>, <span class="keyword">int</span>*, <span class="keyword">int</span>*, <span class="keyword">void</span>**)+<span class="number">56</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">06</span> pc <span class="number">00000000000</span>ced04  /system/lib64/libsurfaceflinger.so (android::impl::MessageQueue::waitMessage()+<span class="number">92</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">07</span> pc <span class="number">00000000000</span>dc69c  /system/lib64/libsurfaceflinger.so (android::SurfaceFlinger::run()+<span class="number">20</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">08</span> pc <span class="number">0000000000003370</span>  /system/bin/surfaceflinger (main+<span class="number">800</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> D CompositionEngine:   #<span class="number">09</span> pc <span class="number">000000000007</span>d844  /apex/com.android.runtime/lib64/bionic/libc.so (__libc_init+<span class="number">108</span>)</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V Surface : Surface::dequeueBuffer</span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V BufferQueueProducer: [FramebufferSurface] dequeueBuffer: w=<span class="number">0</span> h=<span class="number">0</span> format=<span class="number">0x1</span>, usage=<span class="number">0x200</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V BufferQueueProducer: [FramebufferSurface] dequeueBuffer: setting buffer age to <span class="number">1</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V BufferQueueProducer: [FramebufferSurface] dequeueBuffer: returning slot=<span class="number">2</span>/<span class="number">0</span> buf=<span class="number">0x70de65bb40</span> flags=<span class="number">0x1</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V BufferQueueProducer: [FramebufferSurface] requestBuffer: slot <span class="number">2</span></span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.297</span>   <span class="number">179</span>   <span class="number">179</span> V SurfaceFlinger: Rendering client layers</span><br></pre></td></tr></table></figure>

<p>dequeueBuffer用于RenderSurface。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">RenderSurface::dequeueBuffer</span><span class="params">(base::unique_fd* bufferFence)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    ANativeWindowBuffer* buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF dequeueBuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    ALOGD_CALLSTACK(<span class="string">&quot;queueBuffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buffer, &amp;fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;ANativeWindow::dequeueBuffer failed for display [%s] with error: %d&quot;</span>,</span><br><span class="line">              mDisplay.getName().c_str(), result);</span><br><span class="line">        <span class="comment">// Return fast here as we can&#x27;t do much more - any rendering we do</span></span><br><span class="line">        <span class="comment">// now will just be wrong.</span></span><br><span class="line">        <span class="keyword">return</span> mGraphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGW_IF(mGraphicBuffer != <span class="literal">nullptr</span>, <span class="string">&quot;Clobbering a non-null pointer to a buffer [%p].&quot;</span>,</span><br><span class="line">             mGraphicBuffer-&gt;getNativeBuffer()-&gt;handle);</span><br><span class="line">    mGraphicBuffer = GraphicBuffer::from(buffer);</span><br><span class="line"></span><br><span class="line">    *bufferFence = base::unique_fd(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mGraphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2、prepareClientLayer"><a href="#6-2、prepareClientLayer" class="headerlink" title="6.2、prepareClientLayer()"></a>6.2、prepareClientLayer()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::prepareClientLayer</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">const</span> Region&amp; clip,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> useIdentityTransform, Region&amp; clearRegion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> <span class="keyword">bool</span> supportProtectedContent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     renderengine::LayerSettings&amp; layer)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF prepareClientLayer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    Layer::prepareClientLayer(renderArea, clip, useIdentityTransform, clearRegion,</span><br><span class="line">                              supportProtectedContent, layer);</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mActiveBuffer == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// the texture has not been created yet, this Layer has</span></span><br><span class="line">        <span class="comment">// in fact never been drawn into. This happens frequently with</span></span><br><span class="line">        <span class="comment">// SurfaceView because the WindowManager can&#x27;t know when the client</span></span><br><span class="line">        <span class="comment">// has drawn the first time.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is nothing under us, we paint the screen in black, otherwise</span></span><br><span class="line">        <span class="comment">// we just skip this update.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// figure out if there is something below us</span></span><br><span class="line">        Region under;</span><br><span class="line">        <span class="keyword">bool</span> finished = <span class="literal">false</span>;</span><br><span class="line">        mFlinger-&gt;mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (finished || layer == <span class="keyword">static_cast</span>&lt;BufferLayer <span class="keyword">const</span>*&gt;(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                finished = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            under.orSelf(layer-&gt;visibleRegion);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// if not everything below us is covered, we plug the holes!</span></span><br><span class="line">        <span class="function">Region <span class="title">holes</span><span class="params">(clip.subtract(under))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!holes.isEmpty()) &#123;</span><br><span class="line">            clearRegion.orSelf(holes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rk_ext: Deliver to GLESRenderEngine for 10bit to 8bit</span></span><br><span class="line">    layer.source.buffer.currentcrop = mCurrentCrop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> blackOutLayer =</span><br><span class="line">            (isProtected() &amp;&amp; !supportProtectedContent) || (isSecure() &amp;&amp; !renderArea.isSecure());</span><br><span class="line">    <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!blackOutLayer) &#123;</span><br><span class="line">        layer.source.buffer.buffer = mActiveBuffer;</span><br><span class="line">        layer.source.buffer.isOpaque = isOpaque(s);</span><br><span class="line">        layer.source.buffer.fence = mActiveBufferFence;</span><br><span class="line">        layer.source.buffer.textureName = mTextureName;</span><br><span class="line">        layer.source.buffer.usePremultipliedAlpha = getPremultipledAlpha();</span><br><span class="line">        layer.source.buffer.isY410BT2020 = isHdrY410();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> we could be more subtle with isFixedSize()</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> useFiltering = needsFiltering(renderArea.getDisplayDevice()) ||</span><br><span class="line">                renderArea.needsFiltering() || isFixedSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query the texture matrix given our current filtering mode.</span></span><br><span class="line">        <span class="keyword">float</span> textureMatrix[<span class="number">16</span>];</span><br><span class="line">        setFilteringEnabled(useFiltering);</span><br><span class="line">        getDrawingTransformMatrix(textureMatrix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getTransformToDisplayInverse()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * the code below applies the primary display&#x27;s inverse transform to</span></span><br><span class="line"><span class="comment">             * the texture transform</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">uint32_t</span> transform = DisplayDevice::getPrimaryDisplayOrientationTransform();</span><br><span class="line">            mat4 tr = inverseOrientation(transform);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * TODO(b/36727915): This is basically a hack.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Ensure that regardless of the parent transformation,</span></span><br><span class="line"><span class="comment">             * this buffer is always transformed from native display</span></span><br><span class="line"><span class="comment">             * orientation to display orientation. For example, in the case</span></span><br><span class="line"><span class="comment">             * of a camera where the buffer remains in native orientation,</span></span><br><span class="line"><span class="comment">             * we want the pixels to always be upright.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            sp&lt;Layer&gt; p = mDrawingParent.promote();</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> parentTransform = p-&gt;getTransform();</span><br><span class="line">                tr = tr * inverseOrientation(parentTransform.getOrientation());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// and finally apply it to the original texture matrix</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> mat4 <span class="title">texTransform</span><span class="params">(mat4(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>*&gt;(textureMatrix)) * tr)</span></span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(textureMatrix, texTransform.asArray(), <span class="keyword">sizeof</span>(textureMatrix));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Rect win&#123;getBounds()&#125;;</span><br><span class="line">        <span class="keyword">float</span> bufferWidth = getBufferSize(s).getWidth();</span><br><span class="line">        <span class="keyword">float</span> bufferHeight = getBufferSize(s).getHeight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BufferStateLayers can have a &quot;buffer size&quot; of [0, 0, -1, -1] when no display frame has</span></span><br><span class="line">        <span class="comment">// been set and there is no parent layer bounds. In that case, the scale is meaningless so</span></span><br><span class="line">        <span class="comment">// ignore them.</span></span><br><span class="line">        <span class="keyword">if</span> (!getBufferSize(s).isValid()) &#123;</span><br><span class="line">            bufferWidth = <span class="keyword">float</span>(win.right) - <span class="keyword">float</span>(win.left);</span><br><span class="line">            bufferHeight = <span class="keyword">float</span>(win.bottom) - <span class="keyword">float</span>(win.top);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> scaleHeight = (<span class="keyword">float</span>(win.bottom) - <span class="keyword">float</span>(win.top)) / bufferHeight;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> scaleWidth = (<span class="keyword">float</span>(win.right) - <span class="keyword">float</span>(win.left)) / bufferWidth;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> translateY = <span class="keyword">float</span>(win.top) / bufferHeight;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> translateX = <span class="keyword">float</span>(win.left) / bufferWidth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flip y-coordinates because GLConsumer expects OpenGL convention.</span></span><br><span class="line">        mat4 tr = mat4::translate(vec4(<span class="number">.5</span>, <span class="number">.5</span>, <span class="number">0</span>, <span class="number">1</span>)) * mat4::scale(vec4(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>)) *</span><br><span class="line">                mat4::translate(vec4(<span class="number">-.5</span>, <span class="number">-.5</span>, <span class="number">0</span>, <span class="number">1</span>)) *</span><br><span class="line">                mat4::translate(vec4(translateX, translateY, <span class="number">0</span>, <span class="number">1</span>)) *</span><br><span class="line">                mat4::scale(vec4(scaleWidth, scaleHeight, <span class="number">1.0</span>, <span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">        layer.source.buffer.useTextureFiltering = useFiltering;</span><br><span class="line">        layer.source.buffer.textureTransform = mat4(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">float</span>*&gt;(textureMatrix)) * tr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If layer is blacked out, force alpha to 1 so that we draw a black color</span></span><br><span class="line">        <span class="comment">// layer.</span></span><br><span class="line">        layer.source.buffer.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        layer.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Layer::prepareClientLayer</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; <span class="comment">/*renderArea*/</span>, <span class="keyword">const</span> Region&amp; <span class="comment">/*clip*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">bool</span> useIdentityTransform, Region&amp; <span class="comment">/*clearRegion*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="keyword">bool</span> <span class="comment">/*supportProtectedContent*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               renderengine::LayerSettings&amp; layer)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF prepareClientLayer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    FloatRect bounds = getBounds();</span><br><span class="line">    half alpha = getAlpha();</span><br><span class="line">    layer.geometry.boundaries = bounds;</span><br><span class="line">    <span class="keyword">if</span> (useIdentityTransform) &#123;</span><br><span class="line">        layer.geometry.positionTransform = mat4();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ui::Transform transform = getTransform();</span><br><span class="line">        mat4 m;</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">0</span>] = transform[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">1</span>] = transform[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        m[<span class="number">0</span>][<span class="number">3</span>] = transform[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">0</span>] = transform[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">1</span>] = transform[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        m[<span class="number">1</span>][<span class="number">3</span>] = transform[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        m[<span class="number">3</span>][<span class="number">0</span>] = transform[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        m[<span class="number">3</span>][<span class="number">1</span>] = transform[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">        m[<span class="number">3</span>][<span class="number">3</span>] = transform[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        layer.geometry.positionTransform = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasColorTransform()) &#123;</span><br><span class="line">        layer.colorTransform = getColorTransform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> roundedCornerState = getRoundedCornerState();</span><br><span class="line">    layer.geometry.roundedCornersRadius = roundedCornerState.radius;</span><br><span class="line">    layer.geometry.roundedCornersCrop = roundedCornerState.cropRect;</span><br><span class="line"></span><br><span class="line">    layer.alpha = alpha;</span><br><span class="line">    layer.sourceDataspace = mCurrentDataSpace;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-3、drawLayers"><a href="#6-3、drawLayers" class="headerlink" title="6.3、drawLayers()"></a>6.3、drawLayers()</h4><p>使用渲染引擎GLESRenderEngine合成所有Layer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GLESRenderEngine::drawLayers</span><span class="params">(<span class="keyword">const</span> DisplaySettings&amp; display,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LayerSettings&gt;&amp; layers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ANativeWindowBuffer* <span class="keyword">const</span> buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">bool</span> useFramebufferCache, base::unique_fd&amp;&amp; bufferFence,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      base::unique_fd* drawFence)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">if</span> (layers.empty()) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Drawing empty layer stack&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">        ALOGI(<span class="string">&quot;zjj.rk3399.SF drawLayers %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">        <span class="comment">//ALOGD_CALLSTACK(&quot;drawLayers&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MALI_PRODUCT_ID_450 || MALI_PRODUCT_ID_400</span></span><br><span class="line">        <span class="keyword">if</span>(bufferFence.get() &gt;= <span class="number">0</span>)&#123;     <span class="comment">//.RK ext: don&#x27;t use waitFence before solve the problem(eglWaitSyncKHR didn&#x27;t wait release fence) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (bufferFence.get() &gt;= <span class="number">0</span> &amp;&amp; !waitFence(<span class="built_in">std</span>::move(bufferFence))) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;Waiting before draw&quot;</span>);</span><br><span class="line">        sync_wait(bufferFence.get(), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;No output buffer provided. Aborting GPU composition.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BindNativeBufferAsFramebuffer <span class="title">fbo</span><span class="params">(*<span class="keyword">this</span>, buffer, useFramebufferCache)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fbo.getStatus() != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to bind framebuffer! Aborting GPU composition for buffer (%p).&quot;</span>,</span><br><span class="line">              buffer-&gt;handle);</span><br><span class="line">        checkErrors();</span><br><span class="line">        <span class="keyword">return</span> fbo.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the entire buffer, sometimes when we reuse buffers we&#x27;d persist</span></span><br><span class="line">    <span class="comment">// ghost images otherwise.</span></span><br><span class="line">    <span class="comment">// we also require a full transparent framebuffer for overlays. This is</span></span><br><span class="line">    <span class="comment">// probably not quite efficient on all GPUs, since we could filter out</span></span><br><span class="line">    <span class="comment">// opaque layers.</span></span><br><span class="line">    clearWithColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    setViewportAndProjection(display.physicalDisplay, display.clip);</span><br><span class="line"></span><br><span class="line">    setOutputDataSpace(display.outputDataspace);</span><br><span class="line">    setDisplayMaxLuminance(display.maxLuminance);</span><br><span class="line"></span><br><span class="line">    mat4 projectionMatrix = mState.projectionMatrix * display.globalTransform;</span><br><span class="line">    mState.projectionMatrix = projectionMatrix;</span><br><span class="line">    <span class="keyword">if</span> (!display.clearRegion.isEmpty()) &#123;</span><br><span class="line">        glDisable(GL_BLEND);</span><br><span class="line">        fillRegionWithColor(display.clearRegion, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mesh <span class="title">mesh</span><span class="params">(Mesh::TRIANGLE_FAN, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> layer : layers) &#123;</span><br><span class="line">        mState.projectionMatrix = projectionMatrix * layer.geometry.positionTransform;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> FloatRect bounds = layer.geometry.boundaries;</span><br><span class="line">        <span class="function">Mesh::VertexArray&lt;vec2&gt; <span class="title">position</span><span class="params">(mesh.getPositionArray&lt;vec2&gt;())</span></span>;</span><br><span class="line">        position[<span class="number">0</span>] = vec2(bounds.left, bounds.top);</span><br><span class="line">        position[<span class="number">1</span>] = vec2(bounds.left, bounds.bottom);</span><br><span class="line">        position[<span class="number">2</span>] = vec2(bounds.right, bounds.bottom);</span><br><span class="line">        position[<span class="number">3</span>] = vec2(bounds.right, bounds.top);</span><br><span class="line"></span><br><span class="line">        setupLayerCropping(layer, mesh);</span><br><span class="line">        setColorTransform(display.colorTransform * layer.colorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> usePremultipliedAlpha = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> disableTexture = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> isOpaque = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layer.source.buffer.buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            disableTexture = <span class="literal">false</span>;</span><br><span class="line">            isOpaque = layer.source.buffer.isOpaque;</span><br><span class="line"></span><br><span class="line">            sp&lt;GraphicBuffer&gt; gBuf = layer.source.buffer.buffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (RK_NV12_10_TO_NV12_BY_RGA | RK_NV12_10_TO_NV12_BY_NENO | RK_HDR)</span></span><br><span class="line">            <span class="keyword">if</span>(gBuf != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">               gBuf-&gt;getPixelFormat() == HAL_PIXEL_FORMAT_YCrCb_NV12_10 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Rect CurrentCrop(0,0,3840,2160);</span></span><br><span class="line">                <span class="function">Rect <span class="title">CurrentCrop</span><span class="params">(layer.source.buffer.currentcrop)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RK_HDR</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> yuvTexUsage = GraphicBuffer::USAGE_HW_TEXTURE | GRALLOC_USAGE_TO_USE_ARM_P010;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> yuvTexFormat = HAL_PIXEL_FORMAT_YCrCb_NV12_10;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (RK_NV12_10_TO_NV12_BY_NENO | RK_NV12_10_TO_NV12_BY_RGA)</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> yuvTexUsage = GraphicBuffer::USAGE_HW_TEXTURE <span class="comment">/*| HDRUSAGE*/</span>;</span><br><span class="line">                <span class="comment">//GraphicBuffer::USAGE_SW_WRITE_RARELY;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> yuvTexFormat = HAL_PIXEL_FORMAT_YCrCb_NV12;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> yuvcnt;</span><br><span class="line">                <span class="keyword">int</span> yuvIndex ;</span><br><span class="line"></span><br><span class="line">                yuvcnt ++;</span><br><span class="line">                yuvIndex = yuvcnt%<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (RK_HDR | RK_NV12_10_TO_NV12_BY_NENO)</span></span><br><span class="line">                <span class="keyword">int</span> src_l,<span class="keyword">src_t</span>,src_r,src_b,src_stride;</span><br><span class="line">                <span class="keyword">void</span> *src_vaddr;</span><br><span class="line">                <span class="keyword">void</span> *dst_vaddr;</span><br><span class="line">                src_l = CurrentCrop.left;</span><br><span class="line">                <span class="keyword">src_t</span> = CurrentCrop.top;</span><br><span class="line">                src_r = CurrentCrop.right;</span><br><span class="line">                src_b = CurrentCrop.bottom;</span><br><span class="line">                src_stride = gBuf-&gt;getStride();</span><br><span class="line">                <span class="keyword">uint32_t</span> w = src_r - src_l;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> RK_NV12_10_TO_NV12_BY_RGA</span></span><br><span class="line">                <span class="comment">//Since rga cann&#x27;t support scalet to bigger than 4096 limit to 4096</span></span><br><span class="line">                <span class="keyword">uint32_t</span> w = (CurrentCrop.getWidth() + <span class="number">31</span>) &amp; (~<span class="number">31</span>);</span><br><span class="line">                <span class="comment">//ALOGD(&quot;10to8[%s %d] f:%x w:%d gH:%d\n&quot;,__FUNCTION__,__LINE__,gBuf-&gt;getPixelFormat(),w,gBuf-&gt;getHeight());</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">if</span>((yuvTeximg[yuvIndex].yuvTexBuffer != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                   (yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getWidth() != w ||</span><br><span class="line">                    yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getHeight() != gBuf-&gt;getHeight()))</span><br><span class="line">                &#123;</span><br><span class="line">                    yuvTeximg[yuvIndex].yuvTexBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(yuvTeximg[yuvIndex].yuvTexBuffer == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    yuvTeximg[yuvIndex].yuvTexBuffer = <span class="keyword">new</span> GraphicBuffer(w, gBuf-&gt;getHeight(),yuvTexFormat, yuvTexUsage);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (RK_HDR | RK_NV12_10_TO_NV12_BY_NENO)</span></span><br><span class="line">                gBuf-&gt;lock(GRALLOC_USAGE_SW_READ_OFTEN,&amp;src_vaddr);</span><br><span class="line">                yuvTeximg[yuvIndex].yuvTexBuffer-&gt;lock(GRALLOC_USAGE_SW_WRITE_OFTEN,&amp;dst_vaddr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//PRINT_TIME_START</span></span><br><span class="line">                <span class="keyword">if</span>(dso == <span class="literal">NULL</span>)</span><br><span class="line">                    dso = dlopen(RK_XXX_PATH, RTLD_NOW | RTLD_LOCAL);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dso == <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;rk_debug can&#x27;t not find /system/lib64/librockchipxxx.so ! error=%s \n&quot;</span>,</span><br><span class="line">                        dlerror());</span><br><span class="line">                    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RK_HDR</span></span><br><span class="line">                <span class="keyword">if</span>(rockchipxxx == <span class="literal">NULL</span>)</span><br><span class="line">                    rockchipxxx = (__rockchipxxx)dlsym(dso, <span class="string">&quot;_Z11rockchipxxxPhS_iiiii&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(rockchipxxx == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;rk_debug can&#x27;t not find target function in /system/lib64/librockchipxxx.so ! \n&quot;</span>);</span><br><span class="line">                    dlclose(dso);</span><br><span class="line">                    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* align w to 64 */</span></span><br><span class="line">                w = ALIGN(w, <span class="number">64</span>);</span><br><span class="line">                ALOGD(<span class="string">&quot;DEBUG_lb Stride=%d&quot;</span>,yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getStride());</span><br><span class="line">                <span class="keyword">if</span>(w &lt;= yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getStride()/<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    rockchipxxx((u8*)src_vaddr, (u8*)dst_vaddr, w, src_b - <span class="keyword">src_t</span>, src_stride, yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getStride(), <span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    ALOGE(<span class="string">&quot;%s(%d):unsupport resolution for 4k&quot;</span>, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> RK_NV12_10_TO_NV12_BY_NENO</span></span><br><span class="line">                <span class="keyword">if</span>(rockchipxxx3288 == <span class="literal">NULL</span>)</span><br><span class="line">                    rockchipxxx3288 = (__rockchipxxx3288)dlsym(dso, <span class="string">&quot;_Z15rockchipxxx3288PhS_iiiii&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(rockchipxxx3288 == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;rk_debug can&#x27;t not find target function in /system/lib64/librockchipxxx.so ! \n&quot;</span>);</span><br><span class="line">                    dlclose(dso);</span><br><span class="line">                    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                rockchipxxx3288((u8*)src_vaddr, (u8*)dst_vaddr, src_r - src_l, src_b - <span class="keyword">src_t</span>, src_stride, (src_r - src_l), <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="comment">//PRINT_TIME_END(&quot;convert10to16_highbit_arm64_neon&quot;)</span></span><br><span class="line">                ALOGD(<span class="string">&quot;src_vaddr=%p,dst_vaddr=%p,crop_w=%d,crop_h=%d,stride=%f, src_stride=%d,raw_w=%d,raw_h=%d&quot;</span>,</span><br><span class="line">                        src_vaddr, dst_vaddr, src_r - src_l,src_b - <span class="keyword">src_t</span>,</span><br><span class="line">                        (src_r - src_l)*<span class="number">1.25</span>+<span class="number">64</span>,src_stride,gBuf-&gt;getWidth(),gBuf-&gt;getHeight());</span><br><span class="line">                <span class="comment">//dump data</span></span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">char</span> pro_value[PROPERTY_VALUE_MAX];</span><br><span class="line"></span><br><span class="line">                property_get(<span class="string">&quot;sys.dump_out_neon&quot;</span>,pro_value,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">10</span> &amp;&amp; !<span class="built_in">strcmp</span>(pro_value,<span class="string">&quot;true&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> data_name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">sprintf</span>(data_name,<span class="string">&quot;/data/dump/glesdmlayer%d_%d_%d.bin&quot;</span>, i,</span><br><span class="line">                            yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getWidth(),yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getHeight());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RK_HDR</span></span><br><span class="line">                    <span class="keyword">int</span> n = yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getHeight() * yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getStride();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    <span class="keyword">int</span> n = yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getHeight() * yuvTeximg[yuvIndex].yuvTexBuffer-&gt;getStride() * <span class="number">1.5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    ALOGD(<span class="string">&quot;dump %s size=%d&quot;</span>, data_name, n );</span><br><span class="line">                    FILE *fp;</span><br><span class="line">                    <span class="keyword">if</span> ((fp = fopen(data_name, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open output.bin!!!!!\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fwrite(dst_vaddr, n, <span class="number">1</span>, fp);</span><br><span class="line">                    fclose(fp);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> RK_NV12_10_TO_NV12_BY_RGA</span></span><br><span class="line">                rgaCopyBit(gBuf, yuvTeximg[yuvIndex].yuvTexBuffer, CurrentCrop);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                bindExternalTextureBuffer(layer.source.buffer.textureName,</span><br><span class="line">                                yuvTeximg[yuvIndex].yuvTexBuffer, layer.source.buffer.fence);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">            &#123;</span><br><span class="line">                bindExternalTextureBuffer(layer.source.buffer.textureName, gBuf, layer.source.buffer.fence);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            usePremultipliedAlpha = layer.source.buffer.usePremultipliedAlpha;</span><br><span class="line">            <span class="function">Texture <span class="title">texture</span><span class="params">(Texture::TEXTURE_EXTERNAL, layer.source.buffer.textureName)</span></span>;</span><br><span class="line">            mat4 texMatrix = layer.source.buffer.textureTransform;</span><br><span class="line"></span><br><span class="line">            texture.setMatrix(texMatrix.asArray());</span><br><span class="line">            texture.setFiltering(layer.source.buffer.useTextureFiltering);</span><br><span class="line"></span><br><span class="line">            texture.setDimensions(gBuf-&gt;getWidth(), gBuf-&gt;getHeight());</span><br><span class="line">            setSourceY410BT2020(layer.source.buffer.isY410BT2020);</span><br><span class="line"></span><br><span class="line">            renderengine::<span class="function">Mesh::VertexArray&lt;vec2&gt; <span class="title">texCoords</span><span class="params">(mesh.getTexCoordArray&lt;vec2&gt;())</span></span>;</span><br><span class="line">            texCoords[<span class="number">0</span>] = vec2(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            texCoords[<span class="number">1</span>] = vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            texCoords[<span class="number">2</span>] = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            texCoords[<span class="number">3</span>] = vec2(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            setupLayerTexturing(texture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> half3 solidColor = layer.source.solidColor;</span><br><span class="line">        <span class="keyword">const</span> half4 color = half4(solidColor.r, solidColor.g, solidColor.b, layer.alpha);</span><br><span class="line">        <span class="comment">// Buffer sources will have a black solid color ignored in the shader,</span></span><br><span class="line">        <span class="comment">// so in that scenario the solid color passed here is arbitrary.</span></span><br><span class="line">        setupLayerBlending(usePremultipliedAlpha, isOpaque, disableTexture, color,</span><br><span class="line">                           layer.geometry.roundedCornersRadius);</span><br><span class="line">        <span class="keyword">if</span> (layer.disableBlending) &#123;</span><br><span class="line">            glDisable(GL_BLEND);</span><br><span class="line">        &#125;</span><br><span class="line">        setSourceDataSpace(layer.sourceDataspace);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We only want to do a special handling for rounded corners when having rounded corners</span></span><br><span class="line">        <span class="comment">// is the only reason it needs to turn on blending, otherwise, we handle it like the</span></span><br><span class="line">        <span class="comment">// usual way since it needs to turn on blending anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (layer.geometry.roundedCornersRadius &gt; <span class="number">0.0</span> &amp;&amp; color.a &gt;= <span class="number">1.0f</span> &amp;&amp; isOpaque) &#123;</span><br><span class="line">            handleRoundedCorners(display, layer, mesh);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drawMesh(mesh);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cleanup if there&#x27;s a buffer source</span></span><br><span class="line">        <span class="keyword">if</span> (layer.source.buffer.buffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            disableBlending();</span><br><span class="line">            setSourceY410BT2020(<span class="literal">false</span>);</span><br><span class="line">            disableTexturing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawFence != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;zjj.rk3399.SF drawFence %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">        *drawFence = flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If flush failed or we don&#x27;t support native fences, we need to force the</span></span><br><span class="line">    <span class="comment">// gl command stream to be executed.</span></span><br><span class="line">    <span class="keyword">if</span> (drawFence == <span class="literal">nullptr</span> || drawFence-&gt;get() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;zjj.rk3399.SF drawFence %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> success = finish();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Failed to flush RenderEngine commands&quot;</span>);</span><br><span class="line">            checkErrors();</span><br><span class="line">            <span class="comment">// Chances are, something illegal happened (either the caller passed</span></span><br><span class="line">            <span class="comment">// us bad parameters, or we messed up our shader generation).</span></span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkErrors();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看看Log：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.319</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF drawLayers frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp drawLayers <span class="number">1089</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.319</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF getFramebufferForDrawing frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp getFramebufferForDrawing <span class="number">484</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.319</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF setNativeWindowBuffer frameworks/native/libs/renderengine/gl/GLFramebuffer.cpp setNativeWindowBuffer <span class="number">48</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.319</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF createFramebufferImageIfNeeded frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp createFramebufferImageIfNeeded <span class="number">944</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.320</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF bindFrameBuffer frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp bindFrameBuffer <span class="number">883</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.320</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF bindExternalTextureBuffer frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp bindExternalTextureBuffer <span class="number">667</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.320</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF bindExternalTextureImage frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp bindExternalTextureImage <span class="number">648</span> </span><br><span class="line"><span class="number">10</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">54.321</span>   <span class="number">179</span>   <span class="number">179</span> I RenderEngine: zjj.rk3399.SF flush frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp flush <span class="number">503</span></span><br></pre></td></tr></table></figure>
<h4 id="6-4、RenderSurface-gt-queueBuffer"><a href="#6-4、RenderSurface-gt-queueBuffer" class="headerlink" title="6.4、RenderSurface()-&gt;queueBuffer()"></a>6.4、RenderSurface()-&gt;queueBuffer()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">display-&gt;getRenderSurface()-&gt;queueBuffer(<span class="built_in">std</span>::move(readyFence));</span><br><span class="line"></span><br><span class="line">X:\frameworks\native\services\surfaceflinger\CompositionEngine\src\RenderSurface.cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderSurface::queueBuffer</span><span class="params">(base::unique_fd&amp;&amp; readyFence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwc = mCompositionEngine.getHwComposer();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> id = mDisplay.getId();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF queueBuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    ALOGD_CALLSTACK(<span class="string">&quot;queueBuffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hwc.hasClientComposition(id) || hwc.hasFlipClientTargetRequest(id)) &#123;</span><br><span class="line">        <span class="comment">// hasFlipClientTargetRequest could return true even if we haven&#x27;t</span></span><br><span class="line">        <span class="comment">// dequeued a buffer before. Try dequeueing one if we don&#x27;t have a</span></span><br><span class="line">        <span class="comment">// buffer ready.</span></span><br><span class="line">        <span class="keyword">if</span> (mGraphicBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Attempting to queue a client composited buffer without one &quot;</span></span><br><span class="line">                  <span class="string">&quot;previously dequeued for display [%s]. Attempting to dequeue &quot;</span></span><br><span class="line">                  <span class="string">&quot;a scratch buffer now&quot;</span>,</span><br><span class="line">                  mDisplay.getName().c_str());</span><br><span class="line">            <span class="comment">// We shouldn&#x27;t deadlock here, since mGraphicBuffer == nullptr only</span></span><br><span class="line">            <span class="comment">// after a successful call to queueBuffer, or if dequeueBuffer has</span></span><br><span class="line">            <span class="comment">// never been called.</span></span><br><span class="line">            base::unique_fd unused;</span><br><span class="line">            dequeueBuffer(&amp;unused);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mGraphicBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;No buffer is ready for display [%s]&quot;</span>, mDisplay.getName().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result =</span><br><span class="line">                    mNativeWindow-&gt;queueBuffer(mNativeWindow.get(),</span><br><span class="line">                                               mGraphicBuffer-&gt;getNativeBuffer(), dup(readyFence));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Error when queueing buffer for display [%s]: %d&quot;</span>, mDisplay.getName().c_str(),</span><br><span class="line">                      result);</span><br><span class="line">                <span class="comment">// We risk blocking on dequeueBuffer if the primary display failed</span></span><br><span class="line">                <span class="comment">// to queue up its buffer, so crash here.</span></span><br><span class="line">                <span class="keyword">if</span> (!mDisplay.isVirtual()) &#123;</span><br><span class="line">                    LOG_ALWAYS_FATAL(<span class="string">&quot;ANativeWindow::queueBuffer failed with error: %d&quot;</span>, result);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mNativeWindow-&gt;cancelBuffer(mNativeWindow.get(),</span><br><span class="line">                                                mGraphicBuffer-&gt;getNativeBuffer(), dup(readyFence));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = mDisplaySurface-&gt;advanceFrame();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] failed pushing new frame to HWC: %d&quot;</span>, mDisplay.getName().c_str(), result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X:\frameworks\native\services\surfaceflinger\DisplayHardware\FramebufferSurface.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::advanceFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> slot = <span class="number">0</span>;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF advanceFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">acquireFence</span><span class="params">(Fence::NO_FENCE)</span></span>;</span><br><span class="line">    Dataspace dataspace = Dataspace::UNKNOWN;</span><br><span class="line">    <span class="keyword">status_t</span> result = nextBuffer(slot, buf, acquireFence, dataspace);</span><br><span class="line">    mDataSpace = dataspace;</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error latching next FramebufferSurface buffer: %s (%d)&quot;</span>,</span><br><span class="line">                strerror(-result), result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::nextBuffer</span><span class="params">(<span class="keyword">uint32_t</span>&amp; outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,</span></span></span><br><span class="line"><span class="function"><span class="params">        Dataspace&amp; outDataspace)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF nextBuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    ALOGD_CALLSTACK(<span class="string">&quot;nextBuffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == BufferQueue::NO_BUFFER_AVAILABLE) &#123;</span><br><span class="line">        mHwcBufferCache.getHwcBuffer(mCurrentBufferSlot, mCurrentBuffer, &amp;outSlot, &amp;outBuffer);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error acquiring buffer: %s (%d)&quot;</span>, strerror(-err), err);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the BufferQueue has freed and reallocated a buffer in mCurrentSlot</span></span><br><span class="line">    <span class="comment">// then we may have acquired the slot we already own.  If we had released</span></span><br><span class="line">    <span class="comment">// our current buffer before we call acquireBuffer then that release call</span></span><br><span class="line">    <span class="comment">// would have returned STALE_BUFFER_SLOT, and we would have called</span></span><br><span class="line">    <span class="comment">// freeBufferLocked on that slot.  Because the buffer slot has already</span></span><br><span class="line">    <span class="comment">// been overwritten with the new buffer all we have to do is skip the</span></span><br><span class="line">    <span class="comment">// releaseBuffer call and we should be in the same state we&#x27;d be in if we</span></span><br><span class="line">    <span class="comment">// had released the old buffer first.</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;</span><br><span class="line">        item.mSlot != mCurrentBufferSlot) &#123;</span><br><span class="line">        mHasPendingRelease = <span class="literal">true</span>;</span><br><span class="line">        mPreviousBufferSlot = mCurrentBufferSlot;</span><br><span class="line">        mPreviousBuffer = mCurrentBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentBufferSlot = item.mSlot;</span><br><span class="line">    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line"></span><br><span class="line">    outFence = item.mFence;</span><br><span class="line">    mHwcBufferCache.getHwcBuffer(mCurrentBufferSlot, mCurrentBuffer, &amp;outSlot, &amp;outBuffer);</span><br><span class="line">    outDataspace = <span class="keyword">static_cast</span>&lt;Dataspace&gt;(item.mDataSpace);</span><br><span class="line">    <span class="keyword">status_t</span> result = mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error posting framebuffer: %d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、postFramebuffer-display-函数"><a href="#七、postFramebuffer-display-函数" class="headerlink" title="七、postFramebuffer(display)函数"></a>七、postFramebuffer(display)函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFramebuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF postFramebuffer %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">            getHwComposer().presentAndGetReleaseFences(*displayId);</span><br><span class="line">        &#125;</span><br><span class="line">        display-&gt;getRenderSurface()-&gt;onPresentDisplayCompleted();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE;</span><br><span class="line">            <span class="keyword">bool</span> usedClientComposition = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The layer buffer from the previous frame (if any) is released</span></span><br><span class="line">            <span class="comment">// by HWC only when the release fence from this frame (if any) is</span></span><br><span class="line">            <span class="comment">// signaled.  Always get the release fence from HWC first.</span></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getState().hwc) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; hwcState = *layer-&gt;getState().hwc;</span><br><span class="line">                releaseFence =</span><br><span class="line">                        getHwComposer().getLayerReleaseFence(*displayId, hwcState.hwcLayer.get());</span><br><span class="line">                usedClientComposition =</span><br><span class="line">                        hwcState.hwcCompositionType == Hwc2::IComposerClient::Composition::CLIENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the layer was client composited in the previous frame, we</span></span><br><span class="line">            <span class="comment">// need to merge with the previous client target acquire fence.</span></span><br><span class="line">            <span class="comment">// Since we do not track that, always merge with the current</span></span><br><span class="line">            <span class="comment">// client target acquire fence when it is available, even though</span></span><br><span class="line">            <span class="comment">// this is suboptimal.</span></span><br><span class="line">            <span class="keyword">if</span> (usedClientComposition) &#123;</span><br><span class="line">                releaseFence =</span><br><span class="line">                        Fence::merge(<span class="string">&quot;LayerRelease&quot;</span>, releaseFence,</span><br><span class="line">                                     display-&gt;getRenderSurface()-&gt;getClientTargetAcquireFence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;getLayerFE().onLayerDisplayed(releaseFence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;ve got a list of layers needing fences, that are disjoint with</span></span><br><span class="line">        <span class="comment">// display-&gt;getVisibleLayersSortedByZ.  The best we can do is to</span></span><br><span class="line">        <span class="comment">// supply them with the present fence.</span></span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;getLayersNeedingFences().isEmpty()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; presentFence =</span><br><span class="line">                    displayId ? getHwComposer().getPresentFence(*displayId) : Fence::NO_FENCE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getLayersNeedingFences()) &#123;</span><br><span class="line">                layer-&gt;getCompositionLayer()-&gt;getLayerFE()-&gt;onLayerDisplayed(presentFence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">            getHwComposer().clearReleaseFences(*displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X:\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::presentAndGetReleaseFences</span><span class="params">(DisplayId displayId)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    RETURN_IF_INVALID_DISPLAY(displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcDisplay = displayData.hwcDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.validateWasSkipped) &#123;</span><br><span class="line">        <span class="comment">// explicitly flush all pending commands</span></span><br><span class="line">        <span class="keyword">auto</span> error = mHwcDevice-&gt;flushCommands();</span><br><span class="line">        RETURN_IF_HWC_ERROR_FOR(<span class="string">&quot;flushCommands&quot;</span>, error, displayId, UNKNOWN_ERROR);</span><br><span class="line">        RETURN_IF_HWC_ERROR_FOR(<span class="string">&quot;present&quot;</span>, displayData.presentError, displayId, UNKNOWN_ERROR);</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;present(&amp;displayData.lastPresentFence);</span><br><span class="line">    RETURN_IF_HWC_ERROR_FOR(<span class="string">&quot;present&quot;</span>, error, displayId, UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">    error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);</span><br><span class="line">    RETURN_IF_HWC_ERROR_FOR(<span class="string">&quot;getReleaseFences&quot;</span>, error, displayId, UNKNOWN_ERROR);</span><br><span class="line"></span><br><span class="line">    displayData.releaseFences = <span class="built_in">std</span>::move(releaseFences);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X:\frameworks\native\services\surfaceflinger\CompositionEngine\src\RenderSurface.cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderSurface::onPresentDisplayCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplaySurface-&gt;onFrameCommitted();</span><br><span class="line">&#125;</span><br><span class="line">X:\frameworks\native\services\surfaceflinger\DisplayHardware\FramebufferSurface.cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FramebufferSurface::onFrameCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF onFrameCommitted %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    ALOGD_CALLSTACK(<span class="string">&quot;onFrameCommitted&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasPendingRelease) &#123;</span><br><span class="line">        sp&lt;Fence&gt; fence = mHwc.getPresentFence(mDisplayId);</span><br><span class="line">        <span class="keyword">if</span> (fence-&gt;isValid()) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = addReleaseFence(mPreviousBufferSlot,</span><br><span class="line">                    mPreviousBuffer, fence);</span><br><span class="line">            ALOGE_IF(result != NO_ERROR, <span class="string">&quot;onFrameCommitted: failed to add the&quot;</span></span><br><span class="line">                    <span class="string">&quot; fence: %s (%d)&quot;</span>, strerror(-result), result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> result = releaseBufferLocked(mPreviousBufferSlot, mPreviousBuffer);</span><br><span class="line">        ALOGE_IF(result != NO_ERROR, <span class="string">&quot;onFrameCommitted: error releasing buffer:&quot;</span></span><br><span class="line">                <span class="string">&quot; %s (%d)&quot;</span>, strerror(-result), result);</span><br><span class="line"></span><br><span class="line">        mPreviousBuffer.clear();</span><br><span class="line">        mHasPendingRelease = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X:\frameworks\native\libs\gui\ConsumerBase.cpp</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ConsumerBase::releaseBufferLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> slot, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR eglFence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        CB_LOGE(<span class="string">&quot;releaseBufferLocked: ConsumerBase is abandoned!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If consumer no longer tracks this graphicBuffer (we received a new</span></span><br><span class="line">    <span class="comment">// buffer on the same slot), the buffer producer is definitely no longer</span></span><br><span class="line">    <span class="comment">// tracking it.</span></span><br><span class="line">    <span class="keyword">if</span> (!stillTracking(slot, graphicBuffer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CB_LOGV(<span class="string">&quot;releaseBufferLocked: slot=%d/%&quot;</span> PRIu64,</span><br><span class="line">            slot, mSlots[slot].mFrameNumber);</span><br><span class="line">    <span class="keyword">status_t</span> err = mConsumer-&gt;releaseBuffer(slot, mSlots[slot].mFrameNumber,</span><br><span class="line">            display, eglFence, mSlots[slot].mFence);</span><br><span class="line">    <span class="keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) &#123;</span><br><span class="line">        freeBufferLocked(slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrevFinalReleaseFence = mSlots[slot].mFence;</span><br><span class="line">    mSlots[slot].mFence = Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hwcDisplay-&gt;present看看log:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                  FILE:LINE</span><br><span class="line">  000000000009f0a0  HWC2::impl::Display::present(android::sp&lt;android::Fence&gt;*)+144                            frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp:602</span><br><span class="line">  00000000000a79e0  android::impl::HWComposer::presentAndGetReleaseFences(android::DisplayId)+520             frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp:578</span><br><span class="line">  00000000000e2f40  android::SurfaceFlinger::postFramebuffer(android::sp&lt;android::DisplayDevice&gt; const&amp;)+232  frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp:2613</span><br><span class="line">  00000000000e0b9c  android::SurfaceFlinger::handleMessageRefresh()+4348                                      frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp:1886</span><br><span class="line">  00000000000df6bc  android::SurfaceFlinger::onMessageReceived(int)+9484                                      frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp:1834</span><br><span class="line">  0000000000017dfc  android::Looper::pollInner(int)+332                                                       system/core/libutils/Looper.cpp:323</span><br><span class="line">  0000000000017c10  android::Looper::pollOnce(int, int*, int*, void**)+56                                     system/core/libutils/Looper.cpp:205</span><br><span class="line">  v--------------&gt;  android::Looper::pollOnce(int)                                                            system/core/libutils/include/utils/Looper.h:267</span><br><span class="line">  00000000000ced04  android::impl::MessageQueue::waitMessage()+92                                             frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp:120</span><br><span class="line">  v--------------&gt;  android::SurfaceFlinger::waitForEvent()                                                   frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp:1470</span><br><span class="line">  00000000000dc69c  android::SurfaceFlinger::run()+20                                                         frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp:1504</span><br><span class="line">  0000000000003370  main+800                                                                                  frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp:120</span><br><span class="line">  000000000007d844  __libc_init+108                                                                           bionic/libc/bionic/libc_init_dynamic.cpp:136</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          FILE:LINE</span><br><span class="line">  0000000000002440  drm_mod_perform(gralloc_module_t const*, int, ...)+120                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            hardware/rockchip/libgralloc/midgard/gralloc.cpp:95</span><br><span class="line">  v--------------&gt;  android::hwc_get_handle_alreadyStereo(gralloc_module_t const*, native_handle const*)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              hardware/rockchip/hwcomposer/hwc_rockchip.cpp:494</span><br><span class="line">  0000000000060958  android::detect_3d_mode(android::hwc_drm_display*, hwc_display_contents_1*, int)+176                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              hardware/rockchip/hwcomposer/hwc_rockchip.cpp:200</span><br><span class="line">  00000000000536b4  android::hwc_prepare(hwc_composer_device_1*, unsigned long, hwc_display_contents_1**)+12044                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       hardware/rockchip/hwcomposer/hwcomposer.cpp:2564</span><br><span class="line">  00000000000151cc  android::HWC2On1Adapter::prepareAllDisplays()+1156                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                hardware/interfaces/graphics/composer/2.1/utils/hwc2on1adapter/HWC2On1Adapter.cpp:2395</span><br><span class="line">  0000000000014cdc  android::HWC2On1Adapter::Display::validate(unsigned int*, unsigned int*)+92                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       hardware/interfaces/graphics/composer/2.1/utils/hwc2on1adapter/HWC2On1Adapter.cpp:984</span><br><span class="line">  00000000000092f8  android::hardware::graphics::composer::V2_1::passthrough::detail::HwcHalImpl&lt;android::hardware::graphics::composer::V2_1::hal::ComposerHal&gt;::validateDisplay(unsigned long, std::__1::vector&lt;unsigned long, std::__1::allocator&lt;unsigned long&gt; &gt;*, std::__1::vector&lt;android::hardware::graphics::composer::V2_1::IComposerClient::Composition, std::__1::allocator&lt;android::hardware::graphics::composer::V2_1::IComposerClient::Composition&gt; &gt;*, unsigned int*, std::__1::vector&lt;unsigned long, std::__1::allocator&lt;unsigned long&gt; &gt;*, std::__1::vector&lt;unsigned int, std::__1::allocator&lt;unsigned int&gt; &gt;*)+112  hardware/interfaces/graphics/composer/2.1/utils/passthrough/include/composer-passthrough/2.1/HwcHal.h:334</span><br><span class="line">  0000000000011510  android::hardware::graphics::composer::V2_1::hal::ComposerCommandEngine::executePresentOrValidateDisplay(unsigned short)+424                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      hardware/interfaces/graphics/composer/2.1/utils/hal/include/composer-hal/2.1/ComposerCommandEngine.h:300</span><br><span class="line">  0000000000010adc  android::hardware::graphics::composer::V2_1::hal::ComposerCommandEngine::executeCommand(android::hardware::graphics::composer::V2_1::IComposerClient::Command, unsigned short)+1540                                                                                                                                                                                                                                                                                                                                                                                                                               hardware/interfaces/graphics/composer/2.1/utils/hal/include/composer-hal/2.1/ComposerCommandEngine.h:105</span><br><span class="line">  000000000000f168  android::hardware::graphics::composer::V2_1::hal::ComposerCommandEngine::execute(unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;, bool*, unsigned int*, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt;*)+128                                                                                                                                                                                                                                                                                                                                                        hardware/interfaces/graphics/composer/2.1/utils/hal/include/composer-hal/2.1/ComposerCommandEngine.h:64</span><br><span class="line">  000000000000c604  android::hardware::graphics::composer::V2_1::hal::detail::ComposerClientImpl&lt;android::hardware::graphics::composer::V2_1::IComposerClient, android::hardware::graphics::composer::V2_1::hal::ComposerHal&gt;::executeCommands(unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;, std::__1::<span class="keyword">function</span>&lt;void (android::hardware::graphics::composer::V2_1::Error, bool, unsigned int, android::hardware::hidl_vec&lt;android::hardware::hidl_handle&gt; const&amp;)&gt;)+116                                                                                                                           hardware/interfaces/graphics/composer/2.1/utils/hal/include/composer-hal/2.1/ComposerClient.h:305</span><br><span class="line">  00000000000388e4  android::hardware::graphics::composer::V2_1::BnHwComposerClient::_hidl_executeCommands(android::hidl::base::V1_0::BnHwBase*, android::hardware::Parcel const&amp;, android::hardware::Parcel*, std::__1::<span class="keyword">function</span>&lt;void (android::hardware::Parcel&amp;)&gt;)+524                                                                                                                                                                                                                                                                                                                                                             out/soong/.intermediates/hardware/interfaces/graphics/composer/2.1/android.hardware.graphics.composer@2.1_genc++/gen/android/hardware/graphics/composer/2.1/ComposerClientAll.cpp:3710</span><br><span class="line">  0000000000039590  android::hardware::graphics::composer::V2_1::BnHwComposerClient::onTransact(unsigned int, android::hardware::Parcel const&amp;, android::hardware::Parcel*, unsigned int, std::__1::<span class="keyword">function</span>&lt;void (android::hardware::Parcel&amp;)&gt;)+2672                                                                                                                                                                                                                                                                                                                                                                                 out/soong/.intermediates/hardware/interfaces/graphics/composer/2.1/android.hardware.graphics.composer@2.1_genc++/gen/android/hardware/graphics/composer/2.1/ComposerClientAll.cpp:4058</span><br><span class="line">  0000000000096604  android::hardware::BHwBinder::transact(unsigned int, android::hardware::Parcel const&amp;, android::hardware::Parcel*, unsigned int, std::__1::<span class="keyword">function</span>&lt;void (android::hardware::Parcel&amp;)&gt;)+68                                                                                                                                                                                                                                                                                                                                                                                                                        system/libhwbinder/Binder.cpp:116</span><br><span class="line">  v--------------&gt;  android::hardware::IPCThreadState::executeCommand(int)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            system/libhwbinder/IPCThreadState.cpp:1204</span><br><span class="line">  0000000000099fcc  android::hardware::IPCThreadState::getAndExecuteCommand()+1036                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    system/libhwbinder/IPCThreadState.cpp:461</span><br><span class="line">  000000000009b1e0  android::hardware::IPCThreadState::joinThreadPool(bool)+96                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        system/libhwbinder/IPCThreadState.cpp:561</span><br><span class="line">  00000000000a9df0  android::hardware::PoolThread::threadLoop()+24                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    system/libhwbinder/ProcessState.cpp:61</span><br><span class="line">  00000000000137a4  android::Thread::_threadLoop(void*)+284                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           system/core/libutils/Threads.cpp:746</span><br><span class="line">  00000000000e230c  __pthread_start(void*)+36                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         bionic/libc/bionic/pthread_create.cpp:338</span><br><span class="line">  0000000000083d98  __start_thread+64             </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="八、postFrame-函数"><a href="#八、postFrame-函数" class="headerlink" title="八、postFrame()函数"></a>八、postFrame()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// |mStateLock| not needed as we are on the main thread</span></span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF postFrame %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> display = getDefaultDisplayDeviceLocked();</span><br><span class="line">    <span class="keyword">if</span> (display &amp;&amp; getHwComposer().isConnected(*display-&gt;getId())) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> flipCount = display-&gt;getPageFlipCount();</span><br><span class="line">        <span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">            logFrameStats();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、postComposition-函数"><a href="#九、postComposition-函数" class="headerlink" title="九、postComposition()函数"></a>九、postComposition()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGI(<span class="string">&quot;zjj.rk3399.SF postComposition %s %s %d \n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> dequeueReadyTime = systemTime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">        layer-&gt;releasePendingBuffer(dequeueReadyTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// |mStateLock| not needed as we are on the main thread</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> displayDevice = getDefaultDisplayDeviceLocked();</span><br><span class="line"></span><br><span class="line">    getBE().mGlCompositionDoneTimeline.updateSignalTimes();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FenceTime&gt; glCompositionDoneFenceTime;</span><br><span class="line">    <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().hasClientComposition(displayDevice-&gt;getId())) &#123;</span><br><span class="line">        glCompositionDoneFenceTime =</span><br><span class="line">                <span class="built_in">std</span>::make_shared&lt;FenceTime&gt;(displayDevice-&gt;getCompositionDisplay()</span><br><span class="line">                                                    -&gt;getRenderSurface()</span><br><span class="line">                                                    -&gt;getClientTargetAcquireFence());</span><br><span class="line">        getBE().mGlCompositionDoneTimeline.push(glCompositionDoneFenceTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        glCompositionDoneFenceTime = FenceTime::NO_FENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getBE().mDisplayTimeline.updateSignalTimes();</span><br><span class="line">    mPreviousPresentFences[<span class="number">1</span>] = mPreviousPresentFences[<span class="number">0</span>];</span><br><span class="line">    mPreviousPresentFences[<span class="number">0</span>] = displayDevice</span><br><span class="line">            ? getHwComposer().getPresentFence(*displayDevice-&gt;getId())</span><br><span class="line">            : Fence::NO_FENCE;</span><br><span class="line">    <span class="keyword">auto</span> presentFenceTime = <span class="built_in">std</span>::make_shared&lt;FenceTime&gt;(mPreviousPresentFences[<span class="number">0</span>]);</span><br><span class="line">    getBE().mDisplayTimeline.push(presentFenceTime);</span><br><span class="line"></span><br><span class="line">    DisplayStatInfo stats;</span><br><span class="line">    mScheduler-&gt;getDisplayStatInfo(&amp;stats);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We use the mRefreshStartTime which might be sampled a little later than</span></span><br><span class="line">    <span class="comment">// when we started doing work for this frame, but that should be okay</span></span><br><span class="line">    <span class="comment">// since updateCompositorTiming has snapping logic.</span></span><br><span class="line">    updateCompositorTiming(stats, mRefreshStartTime, presentFenceTime);</span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(getBE().mCompositorTimingLock)</span></span>;</span><br><span class="line">        compositorTiming = getBE().mCompositorTiming;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameLatched =</span><br><span class="line">                layer-&gt;onPostComposition(displayDevice-&gt;getId(), glCompositionDoneFenceTime,</span><br><span class="line">                                         presentFenceTime, compositorTiming);</span><br><span class="line">        <span class="keyword">if</span> (frameLatched) &#123;</span><br><span class="line">            recordBufferingStats(layer-&gt;getName().<span class="built_in">string</span>(),</span><br><span class="line">                    layer-&gt;getOccupancyHistory(<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">        mScheduler-&gt;addPresentFence(presentFenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasSyncFramework) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId()) &amp;&amp;</span><br><span class="line">            displayDevice-&gt;isPoweredOn()) &#123;</span><br><span class="line">            mScheduler-&gt;enableHardwareVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAnimCompositionPending) &#123;</span><br><span class="line">        mAnimCompositionPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">            mAnimFrameTracker.setActualPresentFence(</span><br><span class="line">                    <span class="built_in">std</span>::move(presentFenceTime));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId())) &#123;</span><br><span class="line">            <span class="comment">// The HWC doesn&#x27;t support present fences, so use the refresh</span></span><br><span class="line">            <span class="comment">// timestamp instead.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> presentTime =</span><br><span class="line">                    getHwComposer().getRefreshTimestamp(*displayDevice-&gt;getId());</span><br><span class="line">            mAnimFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mAnimFrameTracker.advanceFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimeStats-&gt;incrementTotalFrames();</span><br><span class="line">    <span class="keyword">if</span> (mHadClientComposition) &#123;</span><br><span class="line">        mTimeStats-&gt;incrementClientCompositionFrames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimeStats-&gt;setPresentFenceGlobal(presentFenceTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId()) &amp;&amp;</span><br><span class="line">        !displayDevice-&gt;isPoweredOn()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = systemTime();</span><br><span class="line">    <span class="keyword">if</span> (mHasPoweredOff) &#123;</span><br><span class="line">        mHasPoweredOff = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> elapsedTime = currentTime - getBE().mLastSwapTime;</span><br><span class="line">        <span class="keyword">size_t</span> numPeriods = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(elapsedTime / stats.vsyncPeriod);</span><br><span class="line">        <span class="keyword">if</span> (numPeriods &lt; SurfaceFlingerBE::NUM_BUCKETS - <span class="number">1</span>) &#123;</span><br><span class="line">            getBE().mFrameBuckets[numPeriods] += elapsedTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getBE().mFrameBuckets[SurfaceFlingerBE::NUM_BUCKETS - <span class="number">1</span>] += elapsedTime;</span><br><span class="line">        &#125;</span><br><span class="line">        getBE().mTotalTime += elapsedTime;</span><br><span class="line">    &#125;</span><br><span class="line">    getBE().mLastSwapTime = currentTime;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard <span class="title">lock</span><span class="params">(mTexturePoolMutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mTexturePool.size() &lt; mTexturePoolSize) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> refillCount = mTexturePoolSize - mTexturePool.size();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> offset = mTexturePool.size();</span><br><span class="line">            mTexturePool.resize(mTexturePoolSize);</span><br><span class="line">            getRenderEngine().genTextures(refillCount, mTexturePool.data() + offset);</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;TexturePoolSize&quot;</span>, mTexturePool.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTexturePool.size() &gt; mTexturePoolSize) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> deleteCount = mTexturePool.size() - mTexturePoolSize;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> offset = mTexturePoolSize;</span><br><span class="line">            getRenderEngine().deleteTextures(deleteCount, mTexturePool.data() + offset);</span><br><span class="line">            mTexturePool.resize(mTexturePoolSize);</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;TexturePoolSize&quot;</span>, mTexturePool.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTransactionCompletedThread.addPresentFence(mPreviousPresentFences[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the mStateLock in case SurfaceFlinger is in the middle of applying a transaction.</span></span><br><span class="line">    <span class="comment">// If we do not lock here, a callback could be sent without all of its SurfaceControls and</span></span><br><span class="line">    <span class="comment">// metrics.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mStateLock);</span><br><span class="line">        mTransactionCompletedThread.sendCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mLumaSampling &amp;&amp; mRegionSamplingThread) &#123;</span><br><span class="line">        mRegionSamplingThread-&gt;notifyNewContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even though ATRACE_INT64 already checks if tracing is enabled, it doesn&#x27;t prevent the</span></span><br><span class="line">    <span class="comment">// side-effect of getTotalSize(), so we check that again here</span></span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        ATRACE_INT64(<span class="string">&quot;Total Buffer Size&quot;</span>, GraphicBufferAllocator::get().getTotalSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20210910/">https://zhoujinjian.com/posts/20210910/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20211010/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.29.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 10 Display System源码分析（8）：App（&quot;com.android.testgreen&quot;）界面显示流程源码分析（1）：Activity启动流程分析（Android 10.0 &amp;&amp; Kernel 4.15）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20210810/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer &amp;&amp; Gralloc2 分析（Android 10.0 &amp;&amp; Kernel 4.15）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Native-Surface%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">（一）、Native Surface创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-0-%E3%80%81Native-Surface%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.0 、Native Surface创建步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-SurfaceFlinger%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android SurfaceFlinger内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-0-%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.0 、BufferQueue介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1、生产者Producer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-2%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2、消费者Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA-lock-Buffer-amp-amp-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-0%E3%80%81APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.0、APP申请(lock)Buffer的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1%E3%80%81SurfaceFlinger-test-red%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3.1.1、SurfaceFlinger_test_red填充数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2%E3%80%81APP%E6%8F%90%E4%BA%A4-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.1.2、APP提交(unlockAndPost)Buffer的过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81%E9%80%9A%E7%9F%A5SF%E6%B6%88%E8%B4%B9%E5%90%88%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">（四）、通知SF消费合成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0%E3%80%81%E6%B6%88%E6%81%AFINVALIDATE%E5%A4%84%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">4.0、消息INVALIDATE处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81handlePageFlip%E8%8E%B7%E5%8F%96Buffer"><span class="toc-number">4.2.</span> <span class="toc-text">4.1、handlePageFlip获取Buffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81preComposition-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">一、preComposition()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81rebuildLayerStacks-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">二、rebuildLayerStacks()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81calculateWorkingSet-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">三、calculateWorkingSet()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81setPerFrameData"><span class="toc-number">1.</span> <span class="toc-text">3.1、setPerFrameData()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81beginFrame-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">四、beginFrame()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81prepareFrame-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">五、prepareFrame()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81doComposition-display-repaintEverything-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">六、doComposition(display, repaintEverything)函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E3%80%81RenderSurface-gt-dequeueBuffer-amp-fd"><span class="toc-number">1.</span> <span class="toc-text">6.1、RenderSurface()-&gt;dequeueBuffer(&amp;fd)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E3%80%81prepareClientLayer"><span class="toc-number">2.</span> <span class="toc-text">6.2、prepareClientLayer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E3%80%81drawLayers"><span class="toc-number">3.</span> <span class="toc-text">6.3、drawLayers()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E3%80%81RenderSurface-gt-queueBuffer"><span class="toc-number">4.</span> <span class="toc-text">6.4、RenderSurface()-&gt;queueBuffer()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81postFramebuffer-display-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">七、postFramebuffer(display)函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81postFrame-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">八、postFrame()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81postComposition-%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">九、postComposition()函数</span></a></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>