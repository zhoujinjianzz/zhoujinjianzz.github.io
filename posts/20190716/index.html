<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android P Graphics System（四）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析 | zhoujinjian</title><meta name="keywords" content="Android,Graphics"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。（&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android P Graphics System（四）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190716/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。（&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.39.jpg">
<meta property="article:published_time" content="2019-07-16T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.964Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.39.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190716/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.39.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android P Graphics System（四）：Native Surface创建 &amp;&amp; SurfaceFlinger合成流程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-07-16T01:25:00.000Z" title="发表于 2019-07-16 09:25:00">2019-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.964Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Graphics/">Graphics</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料 Android 9.0 &amp;&amp; Linux（Kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Qualcomm ©Android @Linux 版权所有），谢谢。<br>（==<strong>文章基于 Kernel-3.18</strong>==）&amp;&amp;（==<strong>文章基于 Android 9.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://www.intrinsyc.com/snapdragon-embedded-development-kits/open-q-820-usom-development-kit/">【开发板 Intrinsyc Open-Q™ 820 µSOM Development Kit】</a><br><a target="_blank" rel="noopener" href="https://gitlab.com/zhoujinjianzz/apq8096_la.um.7.5.r1-03100-8x96.0_p_v5.0">【开发板 Android 9.0 &amp;&amp; Linux（Kernel 3.18）源码链接】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，特别感谢！！！</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/f92447ae8445/">（1）【Android P 图形显示系统】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/">（2）【深入剖析Android系统】</a><br><a target="_blank" rel="noopener" href="http://charlesvincent.cc/">（3）【Android Display System】</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/">（4）【Android SurfaceFlinger 学习之路】</a></p>
<hr>
<p>==源码（部分）==：</p>
<blockquote>
<p>SurfaceFlinger</p>
</blockquote>
<ul>
<li>frameworks/native/services/surfaceflinger</li>
</ul>
<hr>
<h4 id="（一）、Native-Surface创建过程"><a href="#（一）、Native-Surface创建过程" class="headerlink" title="（一）、Native Surface创建过程"></a>（一）、Native Surface创建过程</h4><h5 id="1-1-0-、Native-Surface创建步骤"><a href="#1-1-0-、Native-Surface创建步骤" class="headerlink" title="1.1.0 、Native Surface创建步骤"></a>1.1.0 、Native Surface创建步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; client = <span class="keyword">new</span> SurfaceComposerClient();  </span><br><span class="line">sp&lt;SurfaceControl&gt; surfaceControl = client-&gt;createSurface(String8(<span class="string">&quot;new_surface&quot;</span>),  <span class="number">480</span>, <span class="number">854</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);  </span><br><span class="line">sp&lt;Surface&gt; surface = surfaceControl-&gt;getSurface();  </span><br><span class="line">SurfaceComposerClient::openGlobalTransaction();  </span><br><span class="line">surfaceControl-&gt;setLayer(<span class="number">100000</span>);  </span><br><span class="line">SurfaceComposerClient::closeGlobalTransaction();  </span><br><span class="line">ANativeWindow_Buffer outBuffer; </span><br><span class="line">surface-&gt;lock(&amp;outBuffer, <span class="literal">NULL</span>);  </span><br><span class="line"><span class="comment">//填充或绘制图像数据</span></span><br><span class="line"><span class="comment">//fillBufferColor(outBuffer, Rect(0, 0, buffer.width, buffer.height), COLOR::RED)</span></span><br><span class="line">surface-&gt;unlockAndPost();  </span><br></pre></td></tr></table></figure>
<p>下图是Android 7.1.2分析的流程图，大体流程相同，这里就不重新画流程图了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.ask.SurfaceFlinger.createSurface.png" alt="Alt text | center"></p>
<p>[-&gt;SurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">    PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">&quot;SurfaceComposerClient::createSurface error %s&quot;</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。<br>[ISurfaceComposerClient.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[Client.cpp]<br>MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">Client::createSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">status_t</span> <span class="title">getResult</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ALOGD(&quot;createLayer for (%d x %d), name=%s&quot;, w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer:<br>  [-&gt;ISurfaceComposerClient.h]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = <span class="number">0x00000000</span>,</span><br><span class="line">eFXSurfaceDim       = <span class="number">0x00020000</span>,</span><br><span class="line">eFXSurfaceMask      = <span class="number">0x000F0000</span></span><br></pre></td></tr></table></figure>

<p>[-&gt;SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createNormalLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span></span>&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;createNormalLayer() failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。</p>
<h4 id="（二）、Android-SurfaceFlinger内部机制"><a href="#（二）、Android-SurfaceFlinger内部机制" class="headerlink" title="（二）、Android SurfaceFlinger内部机制"></a>（二）、Android SurfaceFlinger内部机制</h4><h5 id="2-1-0-、BufferQueue介绍"><a href="#2-1-0-、BufferQueue介绍" class="headerlink" title="2.1.0 、BufferQueue介绍"></a>2.1.0 、BufferQueue介绍</h5><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。<br>从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.SurfaceFlinger-BufferQueue.png.png" alt="Alt text | center"></p>
<p>先来看一下图中几个状态代表的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure>
<p><strong>FREE :</strong><br>FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue“拥有”。 它转换到DEQUEUED<br>当调用dequeueBuffer时。</p>
<p><strong>DEQUEUED：</strong><br>DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer“拥有”。 它可以转换到QUEUED（通过<br>queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p>
<p><strong>QUEUED：</strong><br>QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续<br>  修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue“拥有”。 它<br>  可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p>
<p><strong>ACQUIRED：</strong><br>ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到<br>获得栅栏fence信号。 BufferSlot由Consumer“拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个<br>分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p>
<p><strong>SHARED：</strong><br> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合，<br>除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p>
<p><strong>简单描述一下状态转换过程：</strong></p>
<p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p>
<p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。 </p>
<p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p>
<p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p>
<h6 id="2-1-1、生产者Producer"><a href="#2-1-1、生产者Producer" class="headerlink" title="2.1.1、生产者Producer"></a>2.1.1、生产者Producer</h6><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.SurfaceFlinger-IGraphicsBufferProducer.png" alt="Alt text | center"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、requestBuffer</strong><br>requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestBuffer requests a new buffer for the given index. The server (i.e.</span></span><br><span class="line"><span class="comment">// the IGraphicBufferProducer implementation) assigns the newly created</span></span><br><span class="line"><span class="comment">// buffer to the given slot index, and the client is expected to mirror the</span></span><br><span class="line"><span class="comment">// slot-&gt;buffer mapping so that it&#x27;s not necessary to transfer a</span></span><br><span class="line"><span class="comment">// GraphicBuffer for every dequeue operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2、dequeueBuffer</strong><br>dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span></span><br><span class="line"><span class="comment">// of the slot is transfered to the client, meaning that the server will not</span></span><br><span class="line"><span class="comment">// use the contents of the buffer associated with that slot.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> usage)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp <GraphicBuffer>（即必须调用requestBuffer）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been dequeued, and the caller</span></span><br><span class="line"><span class="comment">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span></span><br><span class="line"><span class="comment">// requestBuffer).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was dequeued</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously dequeued.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h6 id="2-1-2、消费者Consumer"><a href="#2-1-2、消费者Consumer" class="headerlink" title="2.1.2、消费者Consumer"></a>2.1.2、消费者Consumer</h6><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.SurfaceFlinger-IGraphicsBufferConsumer.png" alt="Alt text | center"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、acquireBuffer</strong><br>acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span></span><br><span class="line"><span class="comment">// the BufferQueue.  If no buffer is pending then it returns</span></span><br><span class="line"><span class="comment">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span></span><br><span class="line"><span class="comment">// information about the buffer is returned in BufferItem.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2、releaseBuffer</strong><br>releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releaseBuffer releases a buffer slot from the consumer back to the</span></span><br><span class="line"><span class="comment">// BufferQueue.  This may be done while the buffer&#x27;s contents are still</span></span><br><span class="line"><span class="comment">// being accessed.  The fence will signal when the buffer is no longer</span></span><br><span class="line"><span class="comment">// in use. frameNumber is used to indentify the exact buffer returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="keyword">int</span> buf, <span class="keyword">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR fence,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<h4 id="（三）、Surface管理图形缓冲区-lock-Buffer-amp-amp-unlockAndPost-Buffer的过程"><a href="#（三）、Surface管理图形缓冲区-lock-Buffer-amp-amp-unlockAndPost-Buffer的过程" class="headerlink" title="（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程"></a>（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程</h4><h5 id="3-1-0、APP申请-lock-Buffer的过程"><a href="#3-1-0、APP申请-lock-Buffer的过程" class="headerlink" title="3.1.0、APP申请(lock)Buffer的过程"></a>3.1.0、APP申请(lock)Buffer的过程</h5><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。<br>[-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">&quot;dequeueBuffer failed (%s)&quot;</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backBufferSlot</span><span class="params">(getSlotFromBufferLocked(backBuffer.get()))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">copyback</span><span class="params">(oldDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can&#x27;t copy-back anything, modify the user&#x27;s dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有：<br>       1）调用connect函数完成一些初始化；<br>       2）调用dequeueBuffer函数，申请图形缓冲区；<br>       3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。<br>       [-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt;&amp; <span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p>
<h5 id="3-1-1、APP提交-unlockAndPost-Buffer的过程"><a href="#3-1-1、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="3.1.1、APP提交(unlockAndPost)Buffer的过程"></a>3.1.1、APP提交(unlockAndPost)Buffer的过程</h5><p>Surface绘制完毕后，unlockCanvasAndPost操作。<br>[-&gt;android_view_Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   这里也比较简单，核心也是分两步：<br>       1）解锁图形缓冲区，和前面的lockAsync成对出现；<br>       2）queueBuffer去归还图形缓冲区；<br>        所以我们还是重点分析第二步，查看queueBuffer的实现：<br>       [-&gt;Surface.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。<br>[-&gt;BufferQueueProducer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>       1）从传入的QueueBufferInput ，解析填充一些变量；<br>       2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断；<br>       3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem；<br>       4）将BufferItem塞进mCore的mQueue队列，依照指定规则；<br>       5）然后通知SurfaceFlinger去消费。</p>
<h4 id="（四）、通知SF消费合成"><a href="#（四）、通知SF消费合成" class="headerlink" title="（四）、通知SF消费合成"></a>（四）、通知SF消费合成</h4><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。<br>listener最终通过回调，会回到BufferLayer当中，所以最终调用BufferLayer的onFrameAvailable接口，我们看看它的实现：<br>[Layer.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ......</span><br><span class="line">        mQueueItems.push_back(item);</span><br><span class="line">        android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用MessageQueue的invalidate函数：<br>[MessageQueue.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.Vsync-surfaceflinger.init.png" alt="Alt text | center"></p>
<p>MessageQueue中分发两个消息，一个INVALIDATE，一个REFRESH，SurfaceFlinger对这两个消息的响应过程，就是合成的过程。</p>
<h5 id="4-0、消息INVALIDATE处理"><a href="#4-0、消息INVALIDATE处理" class="headerlink" title="4.0、消息INVALIDATE处理"></a>4.0、消息INVALIDATE处理</h5><p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                    mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                    (mPreviousPresentFence-&gt;getSignalTime() ==</span><br><span class="line">                            Fence::SIGNAL_TIME_PENDING);</span><br><span class="line">            ATRACE_INT(<span class="string">&quot;FrameMissed&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">            <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">                signalLayerUpdate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            updateVrFlinger();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在INVALIDATE过程中，主要做以下处理：</p>
<ul>
<li>对丢帧的处理</li>
</ul>
<p>如果丢帧，且mPropagateBackpressure为true，mPropagateBackpressure表示显示给压力了。显示说，太慢了，都丢帧了，给点压力，上层赶紧处理。mPropagateBackpressure是在SurfaceFlinger的构造函数中初始化的，受debug.sf.disable_backpressure属性的控制。</p>
<ul>
<li>更新VR updateVrFlinger</li>
</ul>
<p>这个只有在VR模式下才会起作用，我们这里先不管VR的事。</p>
<ul>
<li>处理Transition</li>
</ul>
<p>Transition的处理，前面我们已经说过，只是当时不清楚是什么时候触发的，现在清楚了。Vsync到来后，触发INVALIDATE消息时先去处理Transition。处理的过程就是前面已经说过的handleMessageTransaction，有需要可以回头去看看。这个过程就是处理应用传过来的各种Transition，需要记住的是在commit Transition时，又个状态的更替，mCurrentState赋值给了mDrawingState。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::commitTransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line">    mDrawingState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;commitChildList();</span><br><span class="line">    &#125;);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以SurfaceFlinger两个状态：<br>mCurrentState状态， 准备数据，应用传过来的数据保存在mCurrentState中。<br>mDrawingState状态，进程合成状态，需要进行合成的数据保存在mDrawingState中。<br>也就是说，每次合成时，先更新一下状态数据。每一层Layer也需要去更新状态数据。</p>
<ul>
<li>处理Invalidate<br>这是一个重要的流程，handleMessageInvalidate函数如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">return</span> handlePageFlip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是调用handlePageFlip，做Page的Flip。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;handlePageFlip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> latchTime = systemTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">                mLayersWithQueuedFrames.push_back(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                layer-&gt;useEmptyDamage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions, latchTime))</span></span>;</span><br><span class="line">        layer-&gt;useSurfaceDamage();</span><br><span class="line">        invalidateLayerStack(layer, dirty);</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;isBufferLatched()) &#123;</span><br><span class="line">            newDataLatched = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mLayersWithQueuedFrames，用于标记那些已经有Frame的Layer，这得从Layer的onFrameAvailable说起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        mFlinger-&gt;mInterceptor.saveBufferUpdate(<span class="keyword">this</span>, item.mGraphicBuffer-&gt;getWidth(),</span><br><span class="line">                                                item.mGraphicBuffer-&gt;getHeight(),</span><br><span class="line">                                                item.mFrameNumber);</span><br><span class="line">        <span class="comment">// Reset the frame number tracker when we receive the first buffer after</span></span><br><span class="line">        <span class="comment">// a frame number reset</span></span><br><span class="line">        <span class="keyword">if</span> (item.mFrameNumber == <span class="number">1</span>) &#123;</span><br><span class="line">            mLastFrameNumberReceived = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure that callbacks are handled in order</span></span><br><span class="line">        <span class="keyword">while</span> (item.mFrameNumber != mLastFrameNumberReceived + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = mQueueItemCondition.waitRelative(mQueueItemLock,</span><br><span class="line">                                                               ms2ns(<span class="number">500</span>));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;[%s] Timed out waiting on callback&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mQueueItems.push_back(item);</span><br><span class="line">        android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onFrameAvailable时，先将Buffer的窗口属性保存在mInterceptor中，这里我们暂时不看，记得标记一下。然后对FrameNumber进行处理，一是确保FrameNumber被重置时，重置mLastFrameNumberReceived，二时，确保FrameNumber的顺序。之后，将新过来的BufferItem，push到mQueueItems中，对mQueuedFrames数进行+1。最后才触发SurfaceFlinger进行signalLayerUpdate。<br>回到handlePageFlip。所以，对于触发SurfaceFlinger进行signalLayerUpdate的Layer，hasQueuedFrame为true，是有Queued的Frame的。<br>但是mLayersWithQueuedFrames还要一个条件，shouldPresentNow。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::shouldPresentNow</span><span class="params">(<span class="keyword">const</span> DispSync&amp; dispSync)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSidebandStreamChanged || mAutoRefresh) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mQueueItems.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> timestamp = mQueueItems[<span class="number">0</span>].mTimestamp;</span><br><span class="line">    <span class="keyword">nsecs_t</span> expectedPresent = mConsumer-&gt;computeExpectedPresent(dispSync);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore timestamps more than a second in the future</span></span><br><span class="line">    <span class="keyword">bool</span> isPlausible = timestamp &lt; (expectedPresent + s2ns(<span class="number">1</span>));</span><br><span class="line">    ALOGW_IF(!isPlausible,</span><br><span class="line">             <span class="string">&quot;[%s] Timestamp %&quot;</span> PRId64 <span class="string">&quot; seems implausible &quot;</span></span><br><span class="line">             <span class="string">&quot;relative to expectedPresent %&quot;</span> PRId64,</span><br><span class="line">             mName.<span class="built_in">string</span>(), timestamp, expectedPresent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isDue = timestamp &lt; expectedPresent;</span><br><span class="line">    <span class="keyword">return</span> isDue || !isPlausible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在shouldPresentNow的判断逻辑中，首先根据DispSync，去计算期望显示的时间。再看看Buffer的时间戳和期望显示的时间，如果Buffer的时间还没有到，且和期望显示的时间之间差不到1秒，那么shouldPresentNow成立。该Layer标记为mLayersWithQueuedFrames；否则，Layer使用空的DamageRegion。记住这个<strong>DamageRegion</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::useEmptyDamage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    surfaceDamageRegion.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续handlePageFlip函数分析。</p>
<p>对mLayersWithQueuedFrames标记的Layer进行处理</p>
<p>首先，通过latchBuffer获取Layer的Buffer；再更新Surface的Damage；再通过invalidateLayerStack去刷新脏区域，验证LayerStack。记住LayerStack这个概念。处理这块稍后继续～～～<br>注意这里重新signalLayerUpdate的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有BufferQueue过来，但是还没有到显示时间（mLayersWithQueuedFrames为空），或者没有获取到Buffer。重新触发一次更新～<br>注意handlePageFlip的返回值，有Layer要显示，且获取到Buffer时，才返回true。注意这里的<strong>mVisibleRegionsDirty</strong>，mVisibleRegionsDirty，脏区域，表示可见区域有更新。</p>
<h5 id="4-1、handlePageFlip获取Buffer"><a href="#4-1、handlePageFlip获取Buffer" class="headerlink" title="4.1、handlePageFlip获取Buffer"></a>4.1、handlePageFlip获取Buffer</h5><p>继续前面的Buffer的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">dirty</span><span class="params">(layer-&gt;latchBuffer(visibleRegions, latchTime))</span></span>;</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    invalidateLayerStack(layer, dirty);</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;isBufferLatched()) &#123;</span><br><span class="line">        newDataLatched = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 Buffer<br>Layer的latchBuffer函数比较长，这里将去获取Producer Queue过来的数据。我们分段来看：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">BufferLayer::latchBuffer</span><span class="params">(<span class="keyword">bool</span>&amp; recomputeVisibleRegions, <span class="keyword">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (android_atomic_acquire_cas(<span class="literal">true</span>, <span class="literal">false</span>, &amp;mSidebandStreamChanged) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mSidebandStreamChanged was true</span></span><br><span class="line">        mSidebandStream = mConsumer-&gt;getSidebandStream();</span><br><span class="line">        <span class="comment">// replicated in LayerBE until FE/BE is ready to be synchronized</span></span><br><span class="line">        getBE().compositionInfo.hwc.sidebandStream = mSidebandStream;</span><br><span class="line">        <span class="keyword">if</span> (getBE().compositionInfo.hwc.sidebandStream != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            setTransactionFlags(eTransactionNeeded);</span><br><span class="line">            mFlinger-&gt;setTransactionFlags(eTraversalNeeded);</span><br><span class="line">        &#125;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> getTransform().transform(Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<p>android_atomic_acquire_cas是比较-设置的原子操纵函数，如果变量第三个参数和第一个相等，那么将第二个参数赋值给第三个参数，成功返回0。mSidebandStreamChanged为true，说明Sideband流改变了，这里处理后，就返回了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    Region outDirtyRegion;</span><br><span class="line">    ... ... <span class="comment">// 如果条件不满足，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> oldOpacity = isOpaque(s);</span><br><span class="line">    sp&lt;GraphicBuffer&gt; oldBuffer = getBE().compositionInfo.mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allTransactionsSignaled()) &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">        <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>oldBuffer，前一帧的Buffer～<br>allTransactionsSignaled，确保所有的Fence都已经Signal出来。记住这个点，Fence相关的知识。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> queuedBuffer = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">LayerRejecter <span class="title">r</span><span class="params">(mDrawingState, getCurrentState(), recomputeVisibleRegions,</span></span></span><br><span class="line"><span class="function"><span class="params">                    getProducerStickyTransform() != <span class="number">0</span>, mName.<span class="built_in">string</span>(),</span></span></span><br><span class="line"><span class="function"><span class="params">                    mOverrideScalingMode, mFreezeGeometryUpdates)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> updateResult =</span><br><span class="line">            mConsumer-&gt;updateTexImage(&amp;r, mFlinger-&gt;mPrimaryDispSync,</span><br><span class="line">                                                    &amp;mAutoRefresh, &amp;queuedBuffer,</span><br><span class="line">                                                    mLastFrameNumberReceived);</span><br><span class="line">    <span class="keyword">if</span> (updateResult == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">        <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult == BufferLayerConsumer::BUFFER_REJECTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock lock(mQueueItemLock);</span><br><span class="line">            mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">            android_atomic_dec(&amp;mQueuedFrames);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult != NO_ERROR || mUpdateTexImageFailed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock lock(mQueueItemLock);</span><br><span class="line">            mQueueItems.clear();</span><br><span class="line">            android_atomic_and(<span class="number">0</span>, &amp;mQueuedFrames);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUpdateTexImageFailed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>LayerRejecter顾名思义，用以决定是否拒绝这个Layer。updateTexImage 很关键，这里去获取的Buffer，将通过acquireBuffer函数去请求Buffer。前面我们已经说过BufferQueue的acquireBuffer流程。<br>updateTexImage有多种返回结果：<br>PRESENT_LATER：稍后显示，暂时不显示，触发SurfaceFlinger重新刷新signalLayerUpdate。<br>BUFFER_REJECTED： Buffer被Reject掉，这一帧数据将不再被显示，从mQueueItems中去掉这一帧的Buffer，mQueuedFrames也-1。<br>更新失败或出错：处理和BUFFER_REJECTED类似。<br>updateTexImage的流程稍后再看，我们将这个函数读完。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line"><span class="comment">// Autolock scope</span></span><br><span class="line"><span class="keyword">auto</span> currentFrameNumber = mConsumer-&gt;getFrameNumber();</span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删掉updateTexImage中已经被丢弃的Buffer</span></span><br><span class="line">  <span class="keyword">while</span> (mQueueItems[<span class="number">0</span>].mFrameNumber != currentFrameNumber) &#123;</span><br><span class="line">      mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">      android_atomic_dec(&amp;mQueuedFrames);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((queuedBuffer &amp;&amp; android_atomic_dec(&amp;mQueuedFrames) &gt; <span class="number">1</span>) ||</span><br><span class="line">mAutoRefresh) &#123;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果获取Buffer后，队列中还有其他的Buffer，触发SurfaceFlinger去再做一次刷新signalLayerUpdate，在下一个Vsync再处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// update the active buffer</span></span><br><span class="line">    getBE().compositionInfo.mBuffer =</span><br><span class="line">            mConsumer-&gt;getCurrentBuffer(&amp;getBE().compositionInfo.mBufferSlot);</span><br><span class="line">    <span class="comment">// replicated in LayerBE until FE/BE is ready to be synchronized</span></span><br><span class="line">    mActiveBuffer = getBE().compositionInfo.mBuffer;</span><br><span class="line">    <span class="keyword">if</span> (getBE().compositionInfo.mBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// this can only happen if the very first buffer was rejected.</span></span><br><span class="line">        <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更新Active的Buffer，mActiveBuffer就是我们这次合成，该Layer的数据。如果没有获取到，返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">... ...</span><br><span class="line">mBufferLatched = <span class="literal">true</span>;</span><br><span class="line">mPreviousFrameNumber = mCurrentFrameNumber;</span><br><span class="line">mCurrentFrameNumber = mConsumer-&gt;getFrameNumber();</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">mFrameEventHistory.addLatch(mCurrentFrameNumber, latchTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mFrameEventHistory，记录Frame的历史，Producer和Consumer对Frame的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">true</span>;</span><br><span class="line">    mFrameLatencyNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// the first time we receive a buffer, we need to trigger a</span></span><br><span class="line">        <span class="comment">// geometry invalidation.</span></span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setDataSpace(mConsumer-&gt;getCurrentDataSpace());</span><br><span class="line"></span><br><span class="line">    <span class="function">Rect <span class="title">crop</span><span class="params">(mConsumer-&gt;getCurrentCrop())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">uint32_t</span> <span class="title">transform</span><span class="params">(mConsumer-&gt;getCurrentTransform())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">uint32_t</span> <span class="title">scalingMode</span><span class="params">(mConsumer-&gt;getCurrentScalingMode())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((crop != mCurrentCrop) ||</span><br><span class="line">        (transform != mCurrentTransform) ||</span><br><span class="line">        (scalingMode != mCurrentScalingMode)) &#123;</span><br><span class="line">        mCurrentCrop = crop;</span><br><span class="line">        mCurrentTransform = transform;</span><br><span class="line">        mCurrentScalingMode = scalingMode;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> bufWidth = getBE().compositionInfo.mBuffer-&gt;getWidth();</span><br><span class="line">        <span class="keyword">uint32_t</span> bufHeight = getBE().compositionInfo.mBuffer-&gt;getHeight();</span><br><span class="line">        <span class="keyword">if</span> (bufWidth != <span class="keyword">uint32_t</span>(oldBuffer-&gt;width) ||</span><br><span class="line">            bufHeight != <span class="keyword">uint32_t</span>(oldBuffer-&gt;height)) &#123;</span><br><span class="line">            recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurrentOpacity = getOpacityForFormat(getBE().compositionInfo.mBuffer-&gt;format);</span><br><span class="line">    <span class="keyword">if</span> (oldOpacity != isOpaque(s)) &#123;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是根据新的Buffer的属性，和上一帧Buffer的的数据，做比较，看看是否需要重新去计算可见区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/BufferLayer.cpp</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> point = mLocalSyncPoints.begin();</span><br><span class="line">        <span class="keyword">while</span> (point != mLocalSyncPoints.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(*point)-&gt;frameIsAvailable() || !(*point)-&gt;transactionIsApplied()) &#123;</span><br><span class="line">                <span class="comment">// This sync point must have been added since we started</span></span><br><span class="line">                <span class="comment">// latching. Don&#x27;t drop it yet.</span></span><br><span class="line">                ++point;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((*point)-&gt;getFrameNumber() &lt;= mCurrentFrameNumber) &#123;</span><br><span class="line">                point = mLocalSyncPoints.erase(point);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> postedRegion should be dirty &amp; bounds</span></span><br><span class="line">    <span class="function">Region <span class="title">dirtyRegion</span><span class="params">(Rect(s.active.w, s.active.h))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transform the dirty region to window-manager space</span></span><br><span class="line">    outDirtyRegion = (getTransform().transform(dirtyRegion));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outDirtyRegion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，是对SyncPoint进行处理，新latch的buffer相关的Syncpoint都删掉。返回的是outDirtyRegion，对dirtyRegion做了transform变换后的区域大小。<br>我们再回过头看updateTexImage，updateTexImage函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="keyword">const</span> DispSync&amp; dispSync,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">bool</span>* autoRefresh, <span class="keyword">bool</span>* queuedBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, computeExpectedPresent(dispSync), maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == BufferQueue::NO_BUFFER_AVAILABLE) &#123;</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">            <span class="comment">// return the error, without logging</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BLC_LOGE(<span class="string">&quot;updateTexImage: acquire failed: %s (%d)&quot;</span>, strerror(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (autoRefresh) &#123;</span><br><span class="line">        *autoRefresh = item.mAutoRefresh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">        *queuedBuffer = item.mQueuedBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slot = item.mSlot;</span><br><span class="line">    <span class="keyword">if</span> (rejecter &amp;&amp; rejecter-&gt;reject(mSlots[slot].mGraphicBuffer, item)) &#123;</span><br><span class="line">        releaseBufferLocked(slot, mSlots[slot].mGraphicBuffer);</span><br><span class="line">        <span class="keyword">return</span> BUFFER_REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the previous buffer.</span></span><br><span class="line">    err = updateAndReleaseLocked(item, &amp;mPendingRelease);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SyncFeatures::getInstance().useNativeFenceSync()) &#123;</span><br><span class="line">        err = bindTextureImageLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateTexImage过程大致如下：<br>1.拿到一块Buffer，从BufferQueue中，acquireBufferLocked</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::acquireBufferLocked</span><span class="params">(BufferItem* item, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = ConsumerBase::acquireBufferLocked(item, presentWhen, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If item-&gt;mGraphicBuffer is not null, this buffer has not been acquired</span></span><br><span class="line">    <span class="comment">// before, so any prior EglImage created is using a stale buffer. This</span></span><br><span class="line">    <span class="comment">// replaces any old EglImage with a new one (using the new buffer).</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mImages[item-&gt;mSlot] = <span class="keyword">new</span> Image(item-&gt;mGraphicBuffer, mRE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireBufferLocked通过父类，ConsumerBase的acquireBufferLocked函数去获取Buffer，如果Buffer不为空，创建 Eglimage。<br>在ConsumerBase的acquireBufferLocked中，正式通过BufferQueue的BufferQueueConsumer去acquireBuffer。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> presentWhen, <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        CB_LOGE(<span class="string">&quot;acquireBufferLocked: ConsumerBase is abandoned!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            freeBufferLocked(item-&gt;mSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;</span><br><span class="line">    mSlots[item-&gt;mSlot].mFence = item-&gt;mFence;</span><br><span class="line"></span><br><span class="line">    CB_LOGV(<span class="string">&quot;acquireBufferLocked: -&gt; slot=%d/%&quot;</span> PRIu64,</span><br><span class="line">            item-&gt;mSlot, item-&gt;mFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireBuffer的流程前面已经说过，拿到Buffer后，将Buffer保存在mSlots[item-&gt;mSlot].mGraphicBuffer中。同时更新mFrameNumber和mFence。<br>2.检测Buffer可用不，不可用就Reject掉，rejecter-&gt;reject<br>相关的逻辑在类LayerRejecter中：</p>
<ul>
<li>frameworks/native/services/surfaceflinger/LayerRejecter.cpp</li>
</ul>
<p>代码这里就不贴了，在reject逻辑中，其一是判断释放需要重新计算可见区域mRecomputeVisibleRegions；其二，看看Buffer的属性和状态描述中的属性释放吻合，不一直就reject掉；</p>
<p>3.更新Buffer，释放上一个Buffer，updateAndReleaseLocked</p>
<p>updateAndReleaseLocked函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     PendingRelease* pendingRelease)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slot = item.mSlot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do whatever sync ops we need to do before releasing the old slot.</span></span><br><span class="line">    <span class="keyword">if</span> (slot != mCurrentTexture) &#123;</span><br><span class="line">        err = syncForReleaseLocked();</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// Release the buffer we just acquired.  It&#x27;s not safe to</span></span><br><span class="line">            <span class="comment">// release the old buffer, so instead we just drop the new frame.</span></span><br><span class="line">            <span class="comment">// As we are still under lock since acquireBuffer, it is safe to</span></span><br><span class="line">            <span class="comment">// release by slot.</span></span><br><span class="line">            releaseBufferLocked(slot, mSlots[slot].mGraphicBuffer);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BLC_LOGV(<span class="string">&quot;updateAndRelease: (slot=%d buf=%p) -&gt; (slot=%d buf=%p)&quot;</span>, mCurrentTexture,</span><br><span class="line">             mCurrentTextureImage != <span class="literal">NULL</span> ? mCurrentTextureImage-&gt;graphicBufferHandle() : <span class="number">0</span>, slot,</span><br><span class="line">             mSlots[slot].mGraphicBuffer-&gt;handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hang onto the pointer so that it isn&#x27;t freed in the call to</span></span><br><span class="line">    <span class="comment">// releaseBufferLocked() if we&#x27;re in shared buffer mode and both buffers are</span></span><br><span class="line">    <span class="comment">// the same.</span></span><br><span class="line">    sp&lt;Image&gt; nextTextureImage = mImages[slot];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release old buffer</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingRelease == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> status =</span><br><span class="line">                    releaseBufferLocked(mCurrentTexture, mCurrentTextureImage-&gt;graphicBuffer());</span><br><span class="line">            <span class="keyword">if</span> (status &lt; NO_ERROR) &#123;</span><br><span class="line">                BLC_LOGE(<span class="string">&quot;updateAndRelease: failed to release buffer: %s (%d)&quot;</span>, strerror(-status),</span><br><span class="line">                         status);</span><br><span class="line">                err = status;</span><br><span class="line">                <span class="comment">// keep going, with error raised [?]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingRelease-&gt;currentTexture = mCurrentTexture;</span><br><span class="line">            pendingRelease-&gt;graphicBuffer = mCurrentTextureImage-&gt;graphicBuffer();</span><br><span class="line">            pendingRelease-&gt;isPending = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the BufferLayerConsumer state.</span></span><br><span class="line">    mCurrentTexture = slot;</span><br><span class="line">    mCurrentTextureImage = nextTextureImage;</span><br><span class="line">    mCurrentCrop = item.mCrop;</span><br><span class="line">    mCurrentTransform = item.mTransform;</span><br><span class="line">    mCurrentScalingMode = item.mScalingMode;</span><br><span class="line">    mCurrentTimestamp = item.mTimestamp;</span><br><span class="line">    mCurrentDataSpace = item.mDataSpace;</span><br><span class="line">    mCurrentHdrMetadata = item.mHdrMetadata;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line">    mCurrentFenceTime = item.mFenceTime;</span><br><span class="line">    mCurrentFrameNumber = item.mFrameNumber;</span><br><span class="line">    mCurrentTransformToDisplayInverse = item.mTransformToDisplayInverse;</span><br><span class="line">    mCurrentSurfaceDamage = item.mSurfaceDamage;</span><br><span class="line"></span><br><span class="line">    computeCurrentTransformMatrixLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数中，处理Fence相关的逻辑比较多，后续我们将用专门的章节来讲述Android中Fence同步机制，这里先不要太关注它。该函数中主要作用如下：</p>
<ul>
<li>syncForReleaseLocked，mCurrentTexture是上一个Buffer的序号slot，我们需要给旧Buffer设置ReleaseFence。</li>
<li>releaseBufferLocked，release掉旧的Buffer，先加到mPendingRelease中，待合成完成后release掉Pending的Buffer。</li>
<li>更新BufferLayerConsumer的状态，Buffer的属性都保存到mCurrent**定义的属性中。</li>
</ul>
<p>到此updateTexImage函数完成。<br>latchBuffer中，再通过getCurrentBuffer去获取Consumer中已经更了Buffer。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">BufferLayerConsumer::getCurrentBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outSlot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *outSlot = mCurrentTexture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (mCurrentTextureImage == <span class="literal">nullptr</span>) ? <span class="literal">NULL</span> : mCurrentTextureImage-&gt;graphicBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCurrentTextureImage，也是按照slot从mImages中获取的，前面acquireBuffer时，Buffer根据slot保存在mImages中。<br>到此，Layer中已经获取到Buffer的数据。需要注意的是，这不是对单个的Layer，而是所有的mLayersWithQueuedFrames都会走上面的流程，而每个Layer有自己的BufferLayerConsumer和BufferQueue。<br>我们先来看看看这里遇到的几个类间的相互关系：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.Layer.Buffer.png" alt="Alt text | center"><br>还算比较清晰吧～这里我们只关心Buffer从哪儿来，到哪儿去就行了</p>
<p>拿到Buffer后，更新Layer的Damage，useSurfaceDamage，Damage表示Layer的那些区域被破坏了，被破坏的区域需要重新合成显示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Region&amp; <span class="title">BufferLayerConsumer::getSurfaceDamage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCurrentSurfaceDamage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>surfaceDamage就前面updateTexture时一起更新的mCurrentSurfaceDamage。</p>
<p>invalidateLayerStack的处理如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::invalidateLayerStack</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> Layer&gt;&amp; layer, <span class="keyword">const</span> Region&amp; dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;belongsToDisplay(hw-&gt;getLayerStack(), hw-&gt;isPrimary())) &#123;</span><br><span class="line">            hw-&gt;dirtyRegion.orSelf(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>layerStack，Layer的栈，Android支持多个屏幕，layer可以定制化的只显示到某个显示屏幕上。其中就是靠layerStack来实现的。Layer的stack值如果和DisplayDevice的stack值一样，那说明这个layer是属于这个显示屏幕的。<br>INVALIDATE消息处理，基本完成。如果需要刷新，触发刷新的消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">    signalRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候需要刷新？</p>
<ul>
<li>有新的Transaction处理</li>
<li>PageFlip时，有Buffer更新！～</li>
<li>有重新合成请求时mRepaintEverything，这是响应HWC的请求时触发的。<br>刷新消息REFRESH处理<br>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数<br>[SurfaceFlinger.cpp]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    preComposition(refreshStartTime);</span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    setUpHWComposer();</span><br><span class="line">    doDebugFlashRegions();</span><br><span class="line">    doTracing(<span class="string">&quot;handleRefresh&quot;</span>);</span><br><span class="line">    doComposition();</span><br><span class="line">    postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">    mPreviousPresentFence = getBE().mHwc-&gt;getPresentFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        mHadClientComposition = mHadClientComposition ||</span><br><span class="line">                getBE().mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handleMessageRefresh 函数中，包含了刷新一帧显示数据所有的流程。下面我们分别来进行说明。</p>
<h5 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">(<span class="keyword">nsecs_t</span> refreshStartTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;preComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;onPreComposition(refreshStartTime)) &#123;</span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合成前，先遍历所有需要进行合成的Layer，调Layer的onPreComposition方法。</p>
<p>ColorLayer的onPreComposition，返回值是固定的，为true；BufferLayer的onPreComposition如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="keyword">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.addPreComposition(mCurrentFrameNumber,</span><br><span class="line">                                             refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged ||</span><br><span class="line">            mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onPreComposition中主要作用为：</p>
<ul>
<li>mFrameEventHistory记录PreComposition事件</li>
<li>判断是否需要再触发SurfaceFlinger继续接受Vsync进行合成<br>这3中情况需要：如果mQueuedFrames的值大于0，说明这个时候BufferQueue中还有Buffer，之前我们在acquireBuffer的时候，已经做了-1操纵；SidebandStream改变；或者是自动刷新模式。</li>
</ul>
<p>如果需要再触发SurfaceFlinger工作，调signalLayerUpdate函数。<br>重构Layer的Stack rebuildLayerStacks<br>现在，我们需要合成显示的Layer数据，都保存在mDrawingState的layersSortedByZ中，且是按照z-order的顺序进行存放。那么rebuild Layer又是做什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;rebuildLayerStacks&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">displayDevice</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Transform&amp; <span class="title">tr</span><span class="params">(displayDevice-&gt;getTransform())</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(displayDevice-&gt;getBounds())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.subtractSelf(</span><br><span class="line">                    tr.transform(opaqueRegion));</span><br><span class="line">            displayDevice-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rebuild Layer的前提是存在脏区域，mVisibleRegionsDirty为true。invalidateHwcGeometry重置mGeometryInvalid标记，这个标识后面会用到。<br>Android支持多个屏幕，每个屏幕的显示数据并不是完全一样的，每个Display是分开合成的；也就是说，layersSortedByZ中的layer需要根据显示屏的特性，分别进行合成，合成后的数据，送给各自的显示屏。<br>mDisplays是当前系统中的显示屏，isDisplayOn判断屏幕是否是打开的。主屏幕是默认支持的，处于打开状态。<br>computeVisibleRegions，计算可见区域。Layer中有很多个区域，不太好理解。computeVisibleRegions函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;computeVisibleRegions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.clear();</span><br><span class="line"></span><br><span class="line">    mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// start with the whole surface at its current location</span></span><br><span class="line">        <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// only consider the layers on the given layer stack</span></span><br><span class="line">        <span class="keyword">if</span> (!layer-&gt;belongsToDisplay(displayDevice-&gt;getLayerStack(), displayDevice-&gt;isPrimary()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        Region transparentRegion;</span><br></pre></td></tr></table></figure>
<p>我们先来看Display的几个关于区域的概念：</p>
<ul>
<li>脏区域 dirtyRegion<br>计算脏区域时，outDirtyRegion先清空～  然后遍历mDrawingState中的Layer，如果Layer不属于Display，那么就返回了，outDirtyRegion为空。</li>
<li>非透明区域 opaqueRegion<br>Surface(Layer)完全不透明的区域<br>可见区域 visibleRegion<br>Layer可以被看见的区域，包括不完全透明的区域。原则上，这就是整个Surface减去非透明区域。</li>
<li>被覆盖区域 coveredRegion<br>Surface被上面的Surface覆盖的区域，包括被透明区域覆盖的区域。</li>
<li>透明区域 transparentRegion<br>Surface完全透明的部分，如果没有可见的非透明区域，这个Layer就可以从Layer列表中删掉。它并不影响该Layer本身或其下方Layer的可见区域大小。这个区域可能不太准，如果App不遵守SurfaceView的限制，可悲的是，确实有不遵守的。</li>
</ul>
<p>回到computeVisibleRegions函数，其是按照z-order进行反序号遍历的，所以从最上面开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// handle hidden surfaces by setting the visible region to empty</span></span><br><span class="line">        <span class="keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> translucent = !layer-&gt;isOpaque(s);</span><br><span class="line">            <span class="function">Rect <span class="title">bounds</span><span class="params">(layer-&gt;computeScreenBounds())</span></span>;</span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            Transform tr = layer-&gt;getTransform();</span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 将完全透明区域从可见区域中删掉</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tr.preserveRects()) &#123;</span><br><span class="line">                        <span class="comment">// transform 透明区域</span></span><br><span class="line">                        transparentRegion = tr.transform(s.activeTransparentRegion);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 太复杂了，做不了优化</span></span><br><span class="line">                        transparentRegion.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// compute the opaque region</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int32_t</span> layerOrientation = tr.getOrientation();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;getAlpha() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// the opaque region is the layer&#x27;s footprint</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里用到Layer的几个函数：</p>
<ul>
<li>isOpaque 说明Layer是非透明的Layer，这个是上层应用设置的，注意，我们这里说的应用不只说App，也包括Android的Framework，是泛指。</li>
<li>computeScreenBounds 计算Layer的在屏幕上的大小<br>computeScreenBounds函数如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rect <span class="title">Layer::computeScreenBounds</span><span class="params">(<span class="keyword">bool</span> reduceTransparentRegion)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    <span class="function">Rect <span class="title">win</span><span class="params">(s.active.w, s.active.h)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.crop.isEmpty()) &#123;</span><br><span class="line">        win.intersect(s.crop, &amp;win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Transform t = getTransform();</span><br><span class="line">    win = t.transform(win);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.finalCrop.isEmpty()) &#123;</span><br><span class="line">        win.intersect(s.finalCrop, &amp;win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; p = mDrawingParent.promote();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Rect bounds = p-&gt;computeScreenBounds(<span class="literal">false</span>);</span><br><span class="line">        bounds.intersect(win, &amp;win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reduceTransparentRegion) &#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> screenTransparentRegion = t.transform(s.activeTransparentRegion);</span><br><span class="line">        win = reduce(win, screenTransparentRegion);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s.active.w和s.active.h，是Layer本身的大小，用win表示。<br>crop是Layer的源剪截区域，由上层设置，表示该Layer只截取crop的区域进行合成显示，这个区域可以能比win大，也可能比win小，所以要和win做一个交集运算，截取两个区域重复的部分。<br>finalCrop和crop类似，只是这里的finalCrop是处理win做了变换后的，最终的区域。finalCrop也是上层设置的。<br>Layer本身的crop处理完后，还要和父Layer的区域做一个交集运算，子Layer不让超过父Layer的大小？<br>默认的需要减掉透明区域的，reduceTransparentRegion默认参数为true。<br>computeScreenBounds的返回值，就是Layer可见区域的大小，visibleRegion区域后续还会被裁剪。</p>
<ul>
<li>getTransform 获取 Layer的变换矩阵<br>屏幕有旋转，需要做变换，去适配显示屏幕</li>
</ul>
<p>回到 computeVisibleRegions函数，计算完可见区域，计算非透明区域，一般情况下，如果layer是非透明的，非透明区域就是可见区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// 遍历时，第一层时，aboveCoveredLayers为空，coveredRegion也是为空，最上面一层是没有被覆盖的，当然为空。</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新aboveCoveredLayers，该层之下的Layer都被该层Layer覆盖，所以这里和可见区域做一个或操纵，最下面的区域被覆盖的越大</span></span><br><span class="line">        aboveCoveredLayers.orSelf(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可见区域要减掉该层之上的非透明区域。</span></span><br><span class="line">        visibleRegion.subtractSelf(aboveOpaqueLayers);</span><br></pre></td></tr></table></figure>
<p>上面部分的逻辑，都注释在代码中。继续看～</p>
<p>下面是计算Layer的脏区域：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// compute this layer&#x27;s dirty region</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// we need to invalidate the whole region</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.orSelf(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line">        dirty.subtractSelf(aboveOpaqueLayers);</span><br></pre></td></tr></table></figure>
<p>contentDirty表示Layer的可见区域被修改了，这个是需要和layer的visibleRegion做一个与运算。确保可见的区域都能被刷新到。如果contentDirty没有被修改，开始计算暴露出来的区域 exposedRegion。exposedRegion包含两部分，之前被覆盖的区域，现在暴露了，直接暴露的区域，现在也是暴露的区域。dirty的区域，就是暴露的区域，再除去上面非透明的区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// accumulate to the screen dirty region</span></span><br><span class="line">        outDirtyRegion.orSelf(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新之上非透明的区域，下面的Layer计算时会用到</span></span><br><span class="line">        aboveOpaqueLayers.orSelf(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the visible region in screen space</span></span><br><span class="line">        layer-&gt;setVisibleRegion(visibleRegion);</span><br><span class="line">        layer-&gt;setCoveredRegion(coveredRegion);</span><br><span class="line">        layer-&gt;setVisibleNonTransparentRegion(</span><br><span class="line">                visibleRegion.subtract(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outDirtyRegion是屏幕的脏区域，它是每个Layer脏区域的合。最后将计算好的区域值设置到Layer中。outOpaqueRegion是屏幕的非透明区域。</p>
<ul>
<li>setVisibleRegion 设置可见区域</li>
<li>setCoveredRegion 设置被覆盖的区域</li>
<li>setVisibleNonTransparentRegion 设置可见的非透明区域，它是可见区域，减去透明区域。</li>
</ul>
<p>回到rebuildLayerStacks函数～ computeVisibleRegions结束后，屏幕的脏区域得到了，每个Layer的可见区域，被覆盖的区域，以及可见非透明区域都计算出来了。</p>
<h4 id="二、rebuildLayerStacks函数"><a href="#二、rebuildLayerStacks函数" class="headerlink" title="二、rebuildLayerStacks函数"></a>二、rebuildLayerStacks函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> hwcLayerDestroyed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (layer-&gt;belongsToDisplay(displayDevice-&gt;getLayerStack(),</span><br><span class="line">                                displayDevice-&gt;isPrimary())) &#123;</span><br><span class="line">                        Region drawRegion(tr.transform(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.andSelf(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            layersSortedByZ.add(layer);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hwcLayerDestroyed = layer-&gt;destroyHwcLayer(</span><br><span class="line">                                    displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        hwcLayerDestroyed = layer-&gt;destroyHwcLayer(</span><br><span class="line">                                displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hwcLayerDestroyed) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> found = <span class="built_in">std</span>::find(mLayersWithQueuedFrames.cbegin(),</span><br><span class="line">                                mLayersWithQueuedFrames.cend(), layer);</span><br><span class="line">                        <span class="keyword">if</span> (found != mLayersWithQueuedFrames.cend()) &#123;</span><br><span class="line">                            layersNeedingFences.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rebuildLayerStacks函数中对Layer再遍历一次，这次是正序，也就是从下往上。遍历时，主要做了一下处理：</p>
<ul>
<li>计算Layer需要绘制的区域drawRegion，将Layer的可见区域和Display的大小做交集而得到</li>
<li>如果drawRegion不为空，将该Layer加到当前Display的Layer列表中，也是按照z-order进行存放layersSortedByZ。每个Display有自己的layersSortedByZ。</li>
<li>如果之前Layer是可见的，现在不可见，销毁掉hwc Layer。销毁的Layer放到layersNeedingFences中，它虽然不需要releaseFence，但是还是需要fence去释放旧的Buffer。</li>
</ul>
<p>rebuildLayerStacks的最后，将数据更新到Display中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            displayDevice-&gt;undefinedRegion.subtractSelf(</span><br><span class="line">                    tr.transform(opaqueRegion));</span><br><span class="line">            displayDevice-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Display中还有一个区域，叫未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</p>
<p>创建Layer栈完成，此时需要进行合成显示的数据已经被更新到每个Display各自的layersSortedByZ中。</p>
<h5 id="三、配置硬件合成-setUpHWComposer"><a href="#三、配置硬件合成-setUpHWComposer" class="headerlink" title="三、配置硬件合成 setUpHWComposer"></a>三、配置硬件合成 setUpHWComposer</h5><p>回到handleMessageRefresh，继续看Refresh消息的处理。此时需要进行合成显示的数据，在rebuildLayerStacks时，已经被更新到每个Display各自的layersSortedByZ中。Layer栈创建完成后，进行HWC 合成的设置。<br>setUpHWComposer的代码比较长，我们分段看，在setUpHWComposer中，主要做了以下几件事：</p>
<h5 id="1-DisplayDevice-beginFrame"><a href="#1-DisplayDevice-beginFrame" class="headerlink" title="1.DisplayDevice beginFrame"></a>1.DisplayDevice beginFrame</h5><p>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setUpHWComposer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">        <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  判断是否需要重新合成</span></span><br><span class="line">        <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">            mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Android对每一块显示屏的处理都是分开的。这里主要是调Display的beginFrame函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">DisplayDevice::beginFrame</span><span class="params">(<span class="keyword">bool</span> mustRecompose)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;beginFrame(mustRecompose);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mDisplaySurface根据屏幕有所不同。<br>主显和外显用的FramebufferSurface，需显示用的VirtualDisplaySurface，我们这里先不关虚显。<br>status_t FramebufferSurface::beginFrame(bool /<em>mustRecompose</em>/) {<br>    return NO_ERROR;<br>}</p>
<p>FramebufferSurface在beginFrame是每一做什么过多的处理。<br>回到setUpHWComposer函数</p>
<h5 id="2-创建工作列表"><a href="#2-创建工作列表" class="headerlink" title="2.创建工作列表"></a>2.创建工作列表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setUpHWComposer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            <span class="function">sp&lt;<span class="keyword">const</span> DisplayDevice&gt; <span class="title">displayDevice</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (hwcId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Vector&lt;sp&lt;Layer&gt;&gt;&amp; <span class="title">currentLayers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        displayDevice-&gt;getVisibleLayersSortedByZ())</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; currentLayers.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; layer = currentLayers[i];</span><br><span class="line">                    <span class="keyword">if</span> (!layer-&gt;hasHwcLayer(hwcId)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!layer-&gt;createHwcLayer(getBE().mHwc.get(), hwcId)) &#123;</span><br><span class="line">                            layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layer-&gt;setGeometry(displayDevice, i);</span><br><span class="line">                    <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                        layer-&gt;forceClientComposition(hwcId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对每个Display中的每个Layer创建对应的HWC Layer，注意hwcId，只是对hwcId大于零的Layer才会创建HWC Layer。Layer的createHwcLayer函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Layer::createHwcLayer</span><span class="params">(HWComposer* hwc, <span class="keyword">int32_t</span> hwcId)</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(getBE().mHwcLayers.count(hwcId) != <span class="number">0</span>,</span><br><span class="line">                        <span class="string">&quot;Already have a layer for hwcId %d&quot;</span>, hwcId);</span><br><span class="line">    HWC2::Layer* layer = hwc-&gt;createLayer(hwcId);</span><br><span class="line">    <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LayerBE::HWCInfo&amp; hwcInfo = getBE().mHwcLayers[hwcId];</span><br><span class="line">    hwcInfo.hwc = hwc;</span><br><span class="line">    hwcInfo.layer = layer;</span><br><span class="line">    layer-&gt;setLayerDestroyedListener(</span><br><span class="line">            [<span class="keyword">this</span>, hwcId](HWC2::Layer* <span class="comment">/*layer*/</span>) &#123; getBE().mHwcLayers.erase(hwcId); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据hwcId来创建，也就是说，HWC上层（SurfaceFlinger）的每个Layer，都会为每个Display创建一个HWC Layer。HWComposer 根据hwcId找对HWC2的Display，再通过具体的HWC2::Dispaly去创建自己的HWC Layer；<br>Layer通过HWComposer来创建，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWC2::Layer* <span class="title">HWComposer::createLayer</span><span class="params">(<span class="keyword">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidDisplay(displayId)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to create layer on invalid display %d&quot;</span>, displayId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> display = mDisplayData[displayId].hwcDisplay;</span><br><span class="line">    HWC2::Layer* layer;</span><br><span class="line">    <span class="keyword">auto</span> error = display-&gt;createLayer(&amp;layer);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to create layer on display %d: %s (%d)&quot;</span>, displayId,</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建HWC Layer的实现，最终是在Vendor实现的HAL中来完成的。对应的HWC2command为HWC2_FUNCTION_CREATE_LAYER。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">HwcHal::createLayer</span><span class="params">(Display display, Layer* outLayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> err = mDispatch.createLayer(mDevice, display, outLayer);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Error&gt;(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的HWC Layer在HWC2::Dispaly中也保存了一个引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp</span><br><span class="line"></span><br><span class="line"><span class="function">Error <span class="title">Display::createLayer</span><span class="params">(Layer** outLayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!outLayer) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error::BadParameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">hwc2_layer_t</span> layerId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> intError = mComposer.createLayer(mId, &amp;layerId);</span><br><span class="line">    <span class="keyword">auto</span> error = <span class="keyword">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    <span class="keyword">if</span> (error != Error::None) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> layer = <span class="built_in">std</span>::make_unique&lt;Layer&gt;(</span><br><span class="line">            mComposer, mCapabilities, mId, layerId);</span><br><span class="line">    *outLayer = layer.get();</span><br><span class="line">    mLayers.emplace(layerId, <span class="built_in">std</span>::move(layer));</span><br><span class="line">    <span class="keyword">return</span> Error::None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果hwclayer没有创建成功，那么这一层Layer就强制用Client方式合成forceClientComposition。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::forceClientComposition</span><span class="params">(<span class="keyword">int32_t</span> hwcId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBE().mHwcLayers.count(hwcId) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;forceClientComposition: no HWC layer found (%d)&quot;</span>, hwcId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getBE().mHwcLayers[hwcId].forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果是Disable掉HWC合成，或者调试Region，也强制用Client方式合成：<br>mDebugDisableHWC || mDebugRegion</p>
<p>这两个调试方式可以在系统设置，开发者选项中进行设置。<br>创建完hwcLayer后，设置Layer的几何尺寸：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::setGeometry</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice, <span class="keyword">uint32_t</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ... ... <span class="comment">//注意，我们这里的数据都是来源于DrawingState</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (!isOpaque(s) || getAlpha() != <span class="number">1.0f</span>) &#123;</span><br><span class="line">        blendMode =</span><br><span class="line">                mPremultipliedAlpha ? HWC2::BlendMode::Premultiplied : HWC2::BlendMode::Coverage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setBlendMode(blendMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算displayFrame</span></span><br><span class="line">    Rect frame&#123;t.transform(computeBounds(activeTransparentRegion))&#125;;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Transform&amp; <span class="title">tr</span><span class="params">(displayDevice-&gt;getTransform())</span></span>;</span><br><span class="line">    Rect transformedFrame = tr.transform(frame);</span><br><span class="line">    error = hwcLayer-&gt;setDisplayFrame(transformedFrame);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算sourceCrop</span></span><br><span class="line">    FloatRect sourceCrop = computeCrop(displayDevice);</span><br><span class="line">    error = hwcLayer-&gt;setSourceCrop(sourceCrop);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Alpha</span></span><br><span class="line">    <span class="keyword">float</span> alpha = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(getAlpha());</span><br><span class="line">    error = hwcLayer-&gt;setPlaneAlpha(alpha);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置z-order</span></span><br><span class="line">    error = hwcLayer-&gt;setZOrder(z);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type = s.type;</span><br><span class="line">    <span class="keyword">int</span> appId = s.appId;</span><br><span class="line">    sp&lt;Layer&gt; parent = mDrawingParent.promote();</span><br><span class="line">    <span class="keyword">if</span> (parent.get()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; parentState = parent-&gt;getDrawingState();</span><br><span class="line">        type = parentState.type;</span><br><span class="line">        appId = parentState.appId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Layer的信息</span></span><br><span class="line">    error = hwcLayer-&gt;setInfo(type, appId);</span><br><span class="line">    ALOGE_IF(error != HWC2::Error::None, <span class="string">&quot;[%s] Failed to set info (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置transform</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> orientation = transform.getOrientation();</span><br><span class="line">    <span class="keyword">if</span> (orientation &amp; Transform::ROT_INVALID) &#123;</span><br><span class="line">        <span class="comment">// we can only handle simple transformation</span></span><br><span class="line">        hwcInfo.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> transform = <span class="keyword">static_cast</span>&lt;HWC2::Transform&gt;(orientation);</span><br><span class="line">        <span class="keyword">auto</span> error = hwcLayer-&gt;setTransform(transform);</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们这里的数据都是来源于DrawingState，setGeometry函数中，主要做了以下几件事：</p>
<ul>
<li>确认HWCLayer的混合模式<br>混合模式，是两个Layer直接的混合方式，主要下面的几种：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Blend modes, settable per layer */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    HWC2_BLEND_MODE_INVALID = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc */</span></span><br><span class="line">    HWC2_BLEND_MODE_NONE = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc + colorDst * (1 - alphaSrc) */</span></span><br><span class="line">    HWC2_BLEND_MODE_PREMULTIPLIED = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc * alphaSrc + colorDst * (1 - alphaSrc) */</span></span><br><span class="line">    HWC2_BLEND_MODE_COVERAGE = <span class="number">3</span>,</span><br><span class="line">&#125; <span class="keyword">hwc2_blend_mode_t</span>;</span><br></pre></td></tr></table></figure>
<p>HWC2_BLEND_MODE_NONE，不混合，源是什么样，输出就是什么样的。<br>HWC2_BLEND_MODE_PREMULTIPLIED，预乘，Dst需要做Alpha的处理。<br>HWC2_BLEND_MODE_COVERAGE，覆盖方式，源和Dst都需要做Alpha的处理。</p>
<ul>
<li>计算displayFrame并设置给hwcLayer<br>displayFrame通过transform转换过的</li>
<li>计算sourceCrop并设置给hwcLayer<br>sourceCrop是上层传下来的，再和Dispaly，其他Layer的属性进行计算。</li>
<li>设置Alpha值</li>
<li>设置z-Order</li>
<li>设置Layer的信息<br>type和appId是Android Framework层创建SurfaceControl时设置的，可以搜搜”new SurfaceControl”就出来了。type是类型，比如ScreenshotSurface，Background等；appId是应用的进程号。</li>
<li>设置变换信息transform</li>
</ul>
<p>Layer信息的设置，是通过CommandBuffer的读写来完成的，比如，设置混合模式，最终是调的HwcHal的setLayerBlendMode方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">HwcHal::setLayerBlendMode</span><span class="params">(Display display, Layer layer, <span class="keyword">int32_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> err = mDispatch.setLayerBlendMode(mDevice, display, layer, mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Error&gt;(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到setUpHWComposer函数</p>
<h5 id="3-设置每层Layer的Frame数据"><a href="#3-设置每层Layer的Frame数据" class="headerlink" title="3.设置每层Layer的Frame数据"></a>3.设置每层Layer的Frame数据</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setUpHWComposer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ... ...</span><br><span class="line">    mat4 colorMatrix = mColorMatrix * computeSaturationMatrix() * mDaltonizer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line"></span><br><span class="line">        ... ... <span class="comment">// 设置每个Dispaly的颜色矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (colorMatrix != mPreviousColorMatrix) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = getBE().mHwc-&gt;setColorTransform(hwcId, colorMatrix);</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getForceClientComposition(hwcId)) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;[%s] Requesting Client composition&quot;</span>, layer-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line">                layer-&gt;setCompositionType(hwcId, HWC2::Composition::Client);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;setPerFrameData(displayDevice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasWideColorDisplay) &#123;</span><br><span class="line">            android_color_mode newColorMode;</span><br><span class="line">            android_dataspace newDataSpace = HAL_DATASPACE_V0_SRGB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">                newDataSpace = bestTargetDataSpace(layer-&gt;getDataSpace(), newDataSpace);</span><br><span class="line">                ALOGV(<span class="string">&quot;layer: %s, dataspace: %s (%#x), newDataSpace: %s (%#x)&quot;</span>,</span><br><span class="line">                      layer-&gt;getName().<span class="built_in">string</span>(), dataspaceDetails(layer-&gt;getDataSpace()).c_str(),</span><br><span class="line">                      layer-&gt;getDataSpace(), dataspaceDetails(newDataSpace).c_str(), newDataSpace);</span><br><span class="line">            &#125;</span><br><span class="line">            newColorMode = pickColorMode(newDataSpace);</span><br><span class="line"></span><br><span class="line">            setActiveColorModeInternal(displayDevice, newColorMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPreviousColorMatrix = colorMatrix;</span><br></pre></td></tr></table></figure>
<p>设置Frame数据时，主要做了以下几件事：</p>
<ul>
<li>设置每个Dispaly的颜色矩阵<br>可以在开发这选项中设置，模拟颜色空间。其支持的transform主要有：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    HAL_COLOR_TRANSFORM_IDENTITY = <span class="number">0</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX = <span class="number">1</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_VALUE_INVERSE = <span class="number">2</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_GRAYSCALE = <span class="number">3</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_PROTANOPIA = <span class="number">4</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_DEUTERANOPIA = <span class="number">5</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_TRITANOPIA = <span class="number">6</span>,</span><br><span class="line">&#125; <span class="keyword">android_color_transform_t</span>;</span><br></pre></td></tr></table></figure>

<p>colorTransform主要是用以做颜色变换，以模拟或帮助色盲患者等。</p>
<ul>
<li>设置每一层Layer的显示数据<br>setPerFrameData BufferLayer和ColorLayer的实现不一样。ColorLayer 的逻辑比较简单：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ColorLayer::setPerFrameData</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// 设置可见区域</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setVisibleRegion(visible);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制定合成方式</span></span><br><span class="line">    setCompositionType(hwcId, HWC2::Composition::SolidColor);</span><br><span class="line"></span><br><span class="line">    half4 color = getColor();</span><br><span class="line">    <span class="comment">// 设置颜色</span></span><br><span class="line">    error = hwcLayer-&gt;setColor(&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.r)),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.g)),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.b)), <span class="number">255</span>&#125;);</span><br><span class="line">    ... ...<span class="comment">// 去掉变换矩阵</span></span><br><span class="line">    error = hwcLayer-&gt;setTransform(HWC2::Transform::None);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ColorLayer，主要有4个操纵：设置可见区域，这个前面已经就算好了，但是这里要确保它在Dispaly的视窗里；指定合成方式，默认采用SolidColor方式合成；设置颜色，指定该Layer的颜色，RGBA的格式，Alpha默认为255，全透；最后，ColorLayer不需要transform，去掉。<br>BufferLayer的setPerFrameData处理如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::setPerFrameData</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置可见区域</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = hwcInfo.layer;</span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setVisibleRegion(visible);</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">//设置Damage区域</span></span><br><span class="line">    error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sideband layers处理，默认合成类型为Sideband</span></span><br><span class="line">    <span class="keyword">if</span> (getBE().compositionInfo.hwc.sidebandStream.get()) &#123;</span><br><span class="line">        setCompositionType(hwcId, HWC2::Composition::Sideband);</span><br><span class="line">        <span class="comment">// 制定Sideband流</span></span><br><span class="line">        error = hwcLayer-&gt;setSidebandStream(getBE().compositionInfo.hwc.sidebandStream-&gt;handle());</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// Sideband layers处理完成后直接返回了。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是Cursor Layer，合成类似为Cursor，其他为Device</span></span><br><span class="line">    <span class="keyword">if</span> (mPotentialCursor) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;[%s] Requesting Cursor composition&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(hwcId, HWC2::Composition::Cursor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;[%s] Requesting Device composition&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(hwcId, HWC2::Composition::Device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据空间dataspace</span></span><br><span class="line">    error = hwcLayer-&gt;setDataspace(mCurrentState.dataSpace);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set dataspace %d: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(), mCurrentState.dataSpace,</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取GraphicBuffer</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hwcSlot = <span class="number">0</span>;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; hwcBuffer;</span><br><span class="line">    hwcInfo.bufferCache.getHwcBuffer(getBE().compositionInfo.mBufferSlot,</span><br><span class="line">                                     getBE().compositionInfo.mBuffer, &amp;hwcSlot, &amp;hwcBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Fence</span></span><br><span class="line">    <span class="keyword">auto</span> acquireFence = mConsumer-&gt;getCurrentFence();</span><br><span class="line">    <span class="comment">// 设置Buffer</span></span><br><span class="line">    error = hwcLayer-&gt;setBuffer(hwcSlot, hwcBuffer, acquireFence);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] Failed to set buffer %p: %s (%d)&quot;</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">              getBE().compositionInfo.mBuffer-&gt;handle, to_string(error).c_str(),</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BufferLayer的处理比ColorLayer多，Sideband，Cursor和其他的UI图层都属于BufferLayer，每种类型Layer处理不台一样。这里比较难的是Fence的处理。Buffer也只是将Buffer的handle传给底层的HWC，并没有传Buffer里面的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Composer::setLayerBuffer</span><span class="params">(Display display, Layer layer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> slot, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer, <span class="keyword">int</span> acquireFence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mWriter.selectDisplay(display);</span><br><span class="line">    mWriter.selectLayer(layer);</span><br><span class="line">    <span class="keyword">if</span> (mIsUsingVrComposer &amp;&amp; buffer.get()) &#123;</span><br><span class="line">        ... ...<span class="comment">//VR</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* handle = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (buffer.get()) &#123;</span><br><span class="line">        handle = buffer-&gt;getNativeBuffer()-&gt;handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWriter.setLayerBuffer(slot, handle, acquireFence);</span><br><span class="line">    <span class="keyword">return</span> Error::NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，每层Layer的数据，要么的Buffer，要么是固定的颜色。在处理每一层的数据时，还要处理widecolor。首先通过bestTargetDataSpace找到每层Layer的最佳DataSpace，然后再通过pickColorMode选取颜色模式，最后通过setActiveColorModeInternal函数设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::setActiveColorModeInternal</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">android_color_mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> type = hw-&gt;getDisplayType();</span><br><span class="line">    <span class="keyword">android_color_mode_t</span> currentMode = hw-&gt;getActiveColorMode();</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    hw-&gt;setActiveColorMode(mode);</span><br><span class="line">    getHwComposer().setActiveColorMode(type, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到setUpHWComposer函数</p>
<h5 id="4-prepareFrame准备数据"><a href="#4-prepareFrame准备数据" class="headerlink" title="4.prepareFrame准备数据"></a>4.prepareFrame准备数据</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.HW2_present.png" alt="Alt text | center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> result = displayDevice-&gt;prepareFrame(*getBE().mHwc);</span><br><span class="line">        ALOGE_IF(result != NO_ERROR, <span class="string">&quot;prepareFrame for display %zd failed:&quot;</span></span><br><span class="line">                <span class="string">&quot; %d (%s)&quot;</span>, displayId, result, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Prepare流程，现在写的有点隐晦，以前都是直接在SurfaceFlinger中调的Prepare。现在通过DisplayDevice来完成，调用每个DisplayDevice的prepareFrame。</p>
<p>prepareFrame函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">DisplayDevice::prepareFrame</span><span class="params">(HWComposer&amp; hwc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> error = hwc.prepare(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DisplaySurface::CompositionType compositionType;</span><br><span class="line">    <span class="keyword">bool</span> hasClient = hwc.hasClientComposition(mHwcDisplayId);</span><br><span class="line">    <span class="keyword">bool</span> hasDevice = hwc.hasDeviceComposition(mHwcDisplayId);</span><br><span class="line">    <span class="keyword">if</span> (hasClient &amp;&amp; hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_MIXED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasClient) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_GLES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Nothing to do -- when turning the screen off we get a frame like</span></span><br><span class="line">        <span class="comment">// this. Call it a HWC frame since we won&#x27;t be doing any GLES work but</span></span><br><span class="line">        <span class="comment">// will do a prepare/set cycle.</span></span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;prepareFrame(compositionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置Layer数据时，已经指定每一层的合成方式，但是那是SurfaceFlinger的一厢情愿，还得看HWC接受不接受。HWComposer的prepare函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::prepare</span><span class="params">(DisplayDevice&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mDisplayLock);</span><br><span class="line">    <span class="keyword">auto</span> displayId = displayDevice.getHwcDisplayId();</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcDisplay = displayData.hwcDisplay;</span><br><span class="line">    <span class="keyword">if</span> (!hwcDisplay-&gt;isConnected()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (!displayData.hasClientComposition) &#123;</span><br><span class="line">        sp&lt;android::Fence&gt; outPresentFence;</span><br><span class="line">        <span class="keyword">uint32_t</span> state = UINT32_MAX;</span><br><span class="line">        error = hwcDisplay-&gt;presentOrValidate(&amp;numTypes, &amp;numRequests, &amp;outPresentFence , &amp;state);</span><br><span class="line">        <span class="keyword">if</span> (error != HWC2::Error::None &amp;&amp; error != HWC2::Error::HasChanges) &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;skipValidate: Failed to Present or Validate&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">1</span>) &#123; <span class="comment">//Present Succeeded.</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">            error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);</span><br><span class="line">            displayData.releaseFences = <span class="built_in">std</span>::move(releaseFences);</span><br><span class="line">            displayData.lastPresentFence = outPresentFence;</span><br><span class="line">            displayData.validateWasSkipped = <span class="literal">true</span>;</span><br><span class="line">            displayData.presentError = error;</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Present failed but Validate ran.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error = hwcDisplay-&gt;validate(&amp;numTypes, &amp;numRequests);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, HWC2::Composition&gt; changedTypes;</span><br><span class="line">    changedTypes.reserve(numTypes);</span><br><span class="line">    error = hwcDisplay-&gt;getChangedCompositionTypes(&amp;changedTypes);</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    displayData.displayRequests = <span class="keyword">static_cast</span>&lt;HWC2::DisplayRequest&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, HWC2::LayerRequest&gt; layerRequests;</span><br><span class="line">    layerRequests.reserve(numRequests);</span><br><span class="line">    error = hwcDisplay-&gt;getRequests(&amp;displayData.displayRequests,</span><br><span class="line">            &amp;layerRequests);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;prepare: getRequests failed on display %d: %s (%d)&quot;</span>, displayId,</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayData.hasClientComposition = <span class="literal">false</span>;</span><br><span class="line">    displayData.hasDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice.getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> hwcLayer = layer-&gt;getHwcLayer(displayId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changedTypes.count(hwcLayer) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We pass false so we only update our state and don&#x27;t call back</span></span><br><span class="line">            <span class="comment">// into the HWC device</span></span><br><span class="line">            validateChange(layer-&gt;getCompositionType(displayId),</span><br><span class="line">                    changedTypes[hwcLayer]);</span><br><span class="line">            layer-&gt;setCompositionType(displayId, changedTypes[hwcLayer], <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (layer-&gt;getCompositionType(displayId)) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layerRequests.count(hwcLayer) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                layerRequests[hwcLayer] ==</span><br><span class="line">                        HWC2::LayerRequest::ClearClientTarget) &#123;</span><br><span class="line">            layer-&gt;setClearClientTarget(displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (layerRequests.count(hwcLayer) != <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;prepare: Unknown layer request: %s&quot;</span>,</span><br><span class="line">                        to_string(layerRequests[hwcLayer]).c_str());</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;setClearClientTarget(displayId, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = hwcDisplay-&gt;acceptChanges();</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepare流程如下：</p>
<ul>
<li>首先尝试Prepare和Present一次处理完成<br>如果SurfaceFlinger没有指定得有Client端合成hasClientComposition为false，首先通过presentOrValidate接口尝试直接present，如果HWC不能直接显示，再执行validate操纵，这时的流程和validate是类似的。如果成功，那么此次数据就显示了，不用再 继续后续的处理。</li>
<li>validate刷新</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp</span><br><span class="line"><span class="function">Error <span class="title">Display::validate</span><span class="params">(<span class="keyword">uint32_t</span>* outNumTypes, <span class="keyword">uint32_t</span>* outNumRequests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> numTypes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> numRequests = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> intError = mComposer.validateDisplay(mId, &amp;numTypes, &amp;numRequests);</span><br><span class="line">    <span class="keyword">auto</span> error = <span class="keyword">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    <span class="keyword">if</span> (error != Error::None &amp;&amp; error != Error::HasChanges) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *outNumTypes = numTypes;</span><br><span class="line">    *outNumRequests = numRequests;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Composer的 validateDisplay 函数，和其他Composer的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Composer::validateDisplay</span><span class="params">(Display display, <span class="keyword">uint32_t</span>* outNumTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span>* outNumRequests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mWriter.selectDisplay(display);</span><br><span class="line">    mWriter.validateDisplay();</span><br><span class="line"></span><br><span class="line">    Error error = execute();</span><br><span class="line">    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReader.hasChanges(display, outNumTypes, outNumRequests);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Error::NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>validateDisplay 也是通过CommandWriter写Buffer的方式调用到HWC中的，但是这里多了一个execute函数。其实，validateDisplay之前的通过，Buffer命令的调用，都还没有真正的调到HWC中，只是将命令写到了Buffer中。这里的execute才真正的调用，这里将触发HWC的服务端去解析Buffer命令，再分别去调HWC中对应的实现函数。<br>比如设置 z-order的解析如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ComposerClient::CommandReader::parseSetLayerZOrder(<span class="keyword">uint16_t</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length != CommandWriterBase::kSetLayerZOrderLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> err = mHal.setLayerZOrder(mDisplay, mLayer, read());</span><br><span class="line">    <span class="keyword">if</span> (err != Error::NONE) &#123;</span><br><span class="line">        mWriter.setError(getCommandLoc(), err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>获取HWC的validate结果<br>如果SurfaceFlinger指定的合成方式HWC不能处理，通过getChangedCompositionTypes函数获取到HWC对合成方式的修改，保存在 changedTypes 中。获取LayerRequest，保存在layerRequests中。layerRequests和changedTypes都是以HWC2::Layer作为key的map。</li>
<li>修改合成方式<br>如果合成方式HWC不接受，SurfaceFlinger中修改根据HWC的反馈进行修改，也就是changedTypes中的Layer进行修改。修改的函数为setCompositionType，注意这里的callIntoHwc参数为false。</li>
<li>响应layerRequests<br>layerRequests主要是决定是否需要清楚Client端的Target，也就是Client的合成结果，留意clearClientTarget，看看后续的流程是怎么处理的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::setClearClientTarget</span><span class="params">(<span class="keyword">int32_t</span> hwcId, <span class="keyword">bool</span> clear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBE().mHwcLayers.count(hwcId) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;setClearClientTarget called without a valid HWC layer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getBE().mHwcLayers[hwcId].clearClientTarget = clear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后接受修改<br>通过HWC，SurfaceFlinger接受修改。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Display::acceptChanges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> intError = mComposer.acceptDisplayChanges(mId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.SurfaceFlinger_HWC_negotiation_design.png" alt="Alt text | center"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.SurfaceFlinger_HWC_negotiation.png" alt="Alt text | center"></p>
<p>到此setUpHWComposer结束，此时，我们需要显示的数据已经送到HWC，且每一层Layer的合成方式已经确定。如果是HWC能支持更新和显示同时完成，那么此时数据已经开始显示。<br>回到handleMessageRefresh函数，接下来是doDebugFlashRegions。doDebugFlashRegions只是一个debug的功能，其目前就是更新的区域不停的闪烁，收mDebugRegion的控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDebugFlashRegions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// is debugging enabled</span></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(!mDebugRegion))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的doTracing也是一个debug的辅助功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doTracing</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* where)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ATRACE_NAME(where);</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mTracing.isEnabled())) &#123;</span><br><span class="line">        mTracing.traceLayers(where, dumpProtoInfo(LayerVector::StateSet::Drawing));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、合成处理-doComposition"><a href="#四、合成处理-doComposition" class="headerlink" title="四、合成处理 doComposition"></a>四、合成处理 doComposition</h5><p>如果present和validate没有一起完成，那么此时我们需要显示的数据已经送到HWC，且每一层Layer的合成方式已经确定。接下来的合成处理流程在doComposition中完成。</p>
<p>doComposition函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">&quot;doComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; <span class="title">hw</span><span class="params">(mDisplays[dpy])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">// transform the dirty region into this screen&#x27;s coordinate space</span></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Region <span class="title">dirtyRegion</span><span class="params">(hw-&gt;getDirtyRegion(repaintEverything))</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">            doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">            hw-&gt;dirtyRegion.clear();</span><br><span class="line">            hw-&gt;flip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合成处理也是每个Display各自 进行的，合成处理主要步骤如下：</p>
<h5 id="1-获取脏区域"><a href="#1-获取脏区域" class="headerlink" title="1.获取脏区域"></a>1.获取脏区域</h5><p>在前面重构Layer时，Display的脏区域dirtyRegion已经计算出来。如果是重画，mRepaintEverything为true，那么脏区域就是整个屏幕的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Region <span class="title">DisplayDevice::getDirtyRegion</span><span class="params">(<span class="keyword">bool</span> repaintEverything)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Region dirty;</span><br><span class="line">    <span class="keyword">if</span> (repaintEverything) &#123;</span><br><span class="line">        dirty.<span class="built_in">set</span>(getBounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Transform&amp; planeTransform(mGlobalTransform);</span><br><span class="line">        dirty = planeTransform.transform(<span class="keyword">this</span>-&gt;dirtyRegion);</span><br><span class="line">        dirty.andSelf(getBounds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-Display合成处理"><a href="#2-Display合成处理" class="headerlink" title="2.Display合成处理"></a>2.Display合成处理</h5><p>doDisplayComposition函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Region&amp; inDirtyRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 需要HWC处理，或者脏区域不为空</span></span><br><span class="line">    <span class="keyword">bool</span> isHwcDisplay = displayDevice-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!doComposeSurfaces(displayDevice)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap buffers (presentation)</span></span><br><span class="line">    displayDevice-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合成操纵主要在doComposeSurfaces函数中完成，合成方式，主要就两种，一种Client端用GPU合成；另外一种，Device端合成，用的是HWC硬件。doComposeSurfaces主要是处理Client端合成，Client通过RenderEngine用GPU来进行合成。<br>doComposeSurfaces 函数如下，我们分段看：</p>
<h5 id="RenderEngine-的初始化"><a href="#RenderEngine-的初始化" class="headerlink" title="RenderEngine 的初始化"></a>RenderEngine 的初始化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">bounds</span><span class="params">(displayDevice-&gt;bounds())</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line"></span><br><span class="line">    mat4 oldColorMatrix;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> applyColorMatrix = !getBE().mHwc-&gt;hasDeviceComposition(hwcId) &amp;&amp;</span><br><span class="line">            !getBE().mHwc-&gt;hasCapability(HWC2::Capability::SkipClientColorTransform);</span><br><span class="line">    <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">        mat4 colorMatrix = mColorMatrix * mDaltonizer();</span><br><span class="line">        oldColorMatrix = getRenderEngine().setupColorTransform(colorMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasClientComposition = getBE().mHwc-&gt;hasClientComposition(hwcId);</span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        getBE().mRenderEngine-&gt;setWideColor(</span><br><span class="line">                displayDevice-&gt;getWideColorSupport() &amp;&amp; !mForceNativeColorMode);</span><br><span class="line">        getBE().mRenderEngine-&gt;setColorMode(mForceNativeColorMode ?</span><br><span class="line">                HAL_COLOR_MODE_NATIVE : displayDevice-&gt;getActiveColorMode());</span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;makeCurrent()) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> hasDeviceComposition = getBE().mHwc-&gt;hasDeviceComposition(hwcId);</span><br><span class="line">        <span class="keyword">if</span> (hasDeviceComposition) &#123;</span><br><span class="line">            getBE().mRenderEngine-&gt;clearWithColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> Region letterbox(bounds.subtract(displayDevice-&gt;getScissor()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compute the area to clear</span></span><br><span class="line">            <span class="function">Region <span class="title">region</span><span class="params">(displayDevice-&gt;undefinedRegion.merge(letterbox))</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// screen is already cleared here</span></span><br><span class="line">            <span class="keyword">if</span> (!region.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// can happen with SurfaceView</span></span><br><span class="line">                drawWormhole(displayDevice, region);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (displayDevice-&gt;getDisplayType() != DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">const</span> Rect&amp; <span class="title">bounds</span><span class="params">(displayDevice-&gt;getBounds())</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Rect&amp; <span class="title">scissor</span><span class="params">(displayDevice-&gt;getScissor())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (scissor != bounds) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">uint32_t</span> height = displayDevice-&gt;getHeight();</span><br><span class="line">                getBE().mRenderEngine-&gt;setScissor(scissor.left, height - scissor.bottom,</span><br><span class="line">                        scissor.getWidth(), scissor.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>RenderEngine的初始化包括：</p>
<ul>
<li>指定颜色矩阵 setupColorTransform</li>
<li>指定是否用WideColor setWideColor</li>
<li>指定颜色模式 setColorMode</li>
<li>设置FBTarget Surface，视窗，投影矩阵等</li>
<li>这个过程在DisplayDevice的makeCurrent中完成：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DisplayDevice::makeCurrent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = mFlinger-&gt;getRenderEngine().setCurrentSurface(mSurface);</span><br><span class="line">    setViewportAndProjection();</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>FBTarget 处理背景<br>如果是混合模式，也就是hasClientComposition和hasDeviceComposition，先清掉FBTarget背景。一般情况，合成很少采用这种方式。基本都是通过drawWormhole将屏幕填充为RGBA_0000。</li>
<li>设置剪切区 setScissor<br>对于非主屏，通过setScissor设置Display的剪切区</li>
</ul>
<p>到此，初始化完成～</p>
<h5 id="将Client端的Layer渲染到FBTarget"><a href="#将Client端的Layer渲染到FBTarget" class="headerlink" title="将Client端的Layer渲染到FBTarget"></a>将Client端的Layer渲染到FBTarget</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Transform&amp; displayTransform = displayDevice-&gt;getTransform();</span><br><span class="line">    <span class="keyword">if</span> (hwcId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// hwcId &gt;=0 我们使用HWC</span></span><br><span class="line">        <span class="keyword">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">const</span> Region <span class="title">clip</span><span class="params">(bounds.intersect(</span></span></span><br><span class="line"><span class="function"><span class="params">                    displayTransform.transform(layer-&gt;visibleRegion)))</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!clip.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (layer-&gt;getCompositionType(hwcId)) &#123;</span><br><span class="line">                    <span class="keyword">case</span> HWC2::Composition::Cursor:</span><br><span class="line">                    <span class="keyword">case</span> HWC2::Composition::Device:</span><br><span class="line">                    <span class="keyword">case</span> HWC2::Composition::Sideband:</span><br><span class="line">                    <span class="keyword">case</span> HWC2::Composition::SolidColor: &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">state</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">                        <span class="keyword">if</span> (layer-&gt;getClearClientTarget(hwcId) &amp;&amp; !firstLayer &amp;&amp;</span><br><span class="line">                                layer-&gt;isOpaque(state) &amp;&amp; (state.color.a == <span class="number">1.0f</span>)</span><br><span class="line">                                &amp;&amp; hasClientComposition) &#123;</span><br><span class="line">                            <span class="comment">// never clear the very first layer since we&#x27;re</span></span><br><span class="line">                            <span class="comment">// guaranteed the FB is already cleared</span></span><br><span class="line">                            layer-&gt;clearWithOpenGL(renderArea);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> HWC2::Composition::Client: &#123;</span><br><span class="line">                        layer-&gt;draw(renderArea, clip);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            firstLayer = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we&#x27;re not using h/w composer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Region clip(bounds.intersect(</span><br><span class="line">                    displayTransform.transform(layer-&gt;visibleRegion)));</span><br><span class="line">            <span class="keyword">if</span> (!clip.isEmpty()) &#123;</span><br><span class="line">                layer-&gt;draw(renderArea, clip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">        getRenderEngine().setupColorTransform(oldColorMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable scissor at the end of the frame</span></span><br><span class="line">    getBE().mRenderEngine-&gt;disableScissor();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hwcId &gt;= 0说明我们用到了HWC，大多数情况都会走到这里。对于很多VirtualDisplay的情况，hwcId为-1。<br>用到hwc时，首先计算每一层Layer的可见区域在Display中的区域clip，如果Layer是Client合成，那么直接调layer-&gt;draw，将Layer中clip区域绘制到FBTarget上。如果不是Client合成，但是有其他Layer是Client合成时，需要将Layer在 FBTarget中对应的区域清理掉clearWithOpenGL，清理掉的区域HWC合成。最终，FBTarget的内容和HWC中的内容再合成为最后的显示数据。<br>没有用到hwc时，直接调layer-&gt;draw，将Layer中clip区域绘制到FBTarget上。<br>到此，doComposeSurfaces完成，这里主要是处理和Client端合成相关的流程～</p>
<h5 id="3-Display-交换Buffer"><a href="#3-Display-交换Buffer" class="headerlink" title="3.Display 交换Buffer"></a>3.Display 交换Buffer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDevice::swapBuffers</span><span class="params">(HWComposer&amp; hwc)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hwc.hasClientComposition(mHwcDisplayId)) &#123;</span><br><span class="line">        mSurface.swapBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = mDisplaySurface-&gt;advanceFrame();</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;[%s] failed pushing new frame to HWC: %d&quot;</span>,</span><br><span class="line">                mDisplayName.<span class="built_in">string</span>(), result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有Client合成，调eglSwapBuffers交换Buffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Surface::swapBuffers</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!eglSwapBuffers(mEGLDisplay, mEGLSurface)) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mDisplaySurface的advanceFrame方法，虚显用的VirtualDisplaySurface，非虚显用的FramebufferSurface。advanceFrame获取 FBTarget 的数据，我们看非虚显：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::advanceFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> slot = <span class="number">0</span>;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">acquireFence</span><span class="params">(Fence::NO_FENCE)</span></span>;</span><br><span class="line">    <span class="keyword">android_dataspace_t</span> dataspace = HAL_DATASPACE_UNKNOWN;</span><br><span class="line">    <span class="keyword">status_t</span> result = nextBuffer(slot, buf, acquireFence, dataspace);</span><br><span class="line">    mDataSpace = dataspace;</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;error latching next FramebufferSurface buffer: %s (%d)&quot;</span>,</span><br><span class="line">                strerror(-result), result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要在nextBuffer函数中完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::nextBuffer</span><span class="params">(<span class="keyword">uint32_t</span>&amp; outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">android_dataspace_t</span>&amp; outDataspace)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, <span class="number">0</span>);</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">if</span> (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;</span><br><span class="line">        item.mSlot != mCurrentBufferSlot) &#123;</span><br><span class="line">        mHasPendingRelease = <span class="literal">true</span>;</span><br><span class="line">        mPreviousBufferSlot = mCurrentBufferSlot;</span><br><span class="line">        mPreviousBuffer = mCurrentBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentBufferSlot = item.mSlot;</span><br><span class="line">    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line"></span><br><span class="line">    outFence = item.mFence;</span><br><span class="line">    mHwcBufferCache.getHwcBuffer(mCurrentBufferSlot, mCurrentBuffer,</span><br><span class="line">            &amp;outSlot, &amp;outBuffer);</span><br><span class="line">    outDataspace = item.mDataSpace;</span><br><span class="line">    <span class="keyword">status_t</span> result =</span><br><span class="line">            mHwc.setClientTarget(mDisplayType, outSlot, outFence, outBuffer, outDataspace);</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nextBuffer函数中：</p>
<ul>
<li>获取一个Buffer<br>如果是Client合成，swapBuffer时，将调用queueBuffer，queue到FrameBufferSurface的BufferQueue中。这里的acquireBufferLocked 将从BufferQueue中获取一个Buffer。</li>
<li>替换Buffer<br>当前Buffer的序号mCurrentBufferSlot，当前Buffer mCurrentBuffer，对应的Fence mCurrentFence；如果新获取到的Buffer不一样，释放旧的。Buffer都被cache到mHwcBufferCache中。</li>
<li>将 FBTarget 设置给HWC<br>关键代码mHwc.setClientTarget。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::setClientTarget</span><span class="params">(<span class="keyword">int32_t</span> displayId, <span class="keyword">uint32_t</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; target,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">android_dataspace_t</span> dataspace)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcDisplay = mDisplayData[displayId].hwcDisplay;</span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;setClientTarget(slot, target, acquireFence, dataspace);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Failed to set client target for display %d: %s (%d)&quot;</span>, displayId,</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FBTarget 也是通过Command Buffer的方式传到HWC中的。在hwc1.x的版本中，在创建工作列表时也为FBTarget创建了一个Layer，HWC2版本直接传递FBTarget。<br>回到doComposition函数中，DisplayDevice的flip函数，将记录flip的次数mPageFlipCount。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDevice::flip</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mFlinger-&gt;getRenderEngine().checkErrors();</span><br><span class="line">    mPageFlipCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-提交Framebuffer"><a href="#4-提交Framebuffer" class="headerlink" title="4.提交Framebuffer"></a>4.提交Framebuffer</h5><p>到此，我们显示的数据成什么样了？需要Client合成的，已经合成完了，合成后的结果FBTarget已传给HWC。需要Device合成的数据之前也提交给HWC了。但是数据还没有最终合成显示出来。postFramebuffer 函数就是告诉HWC开始做最后的合成了。</p>
<h5 id="五、postFramebuffer-函数"><a href="#五、postFramebuffer-函数" class="headerlink" title="五、postFramebuffer()函数"></a>五、postFramebuffer()函数</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.HW2_postframebuffer.png" alt="Alt text | center"><br>可以看到，这就跟前面的分析衔接起来了。<br><a href="https://zhoujinjian.com/posts/20190708/">Android P Graphics System（三）：Qualcomm HWC2（Hardware Composer 2.0 ）分析</a><br>postFramebuffer函数如下：<br>[SurfaceFlinger.cpp]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFramebuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> hwcId = displayDevice-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (hwcId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            getBE().mHwc-&gt;presentAndGetReleaseFences(hwcId);</span><br><span class="line">        &#125;</span><br><span class="line">        displayDevice-&gt;onSwapBuffersCompleted();</span><br><span class="line">        displayDevice-&gt;makeCurrent();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hwcLayer = layer-&gt;getHwcLayer(hwcId);</span><br><span class="line">            sp&lt;Fence&gt; releaseFence = getBE().mHwc-&gt;getLayerReleaseFence(hwcId, hwcLayer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getCompositionType(hwcId) == HWC2::Composition::Client) &#123;</span><br><span class="line">                releaseFence = Fence::merge(<span class="string">&quot;LayerRelease&quot;</span>, releaseFence,</span><br><span class="line">                        displayDevice-&gt;getClientTargetAcquireFence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;onLayerDisplayed(releaseFence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;getLayersNeedingFences().isEmpty()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; presentFence = getBE().mHwc-&gt;getPresentFence(hwcId);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getLayersNeedingFences()) &#123;</span><br><span class="line">                layer-&gt;onLayerDisplayed(presentFence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hwcId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            getBE().mHwc-&gt;clearReleaseFences(hwcId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">    mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// |mStateLock| not needed as we are on the main thread</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDeviceLocked()-&gt;getPageFlipCount();</span><br><span class="line">    <span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">        logFrameStats();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postFramebuffer的流程如下：</p>
<p>通过presentAndGetReleaseFences显示获取releaseFence</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::presentAndGetReleaseFences</span><span class="params">(<span class="keyword">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcDisplay = displayData.hwcDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.validateWasSkipped) &#123;</span><br><span class="line">        <span class="comment">// explicitly flush all pending commands</span></span><br><span class="line">        <span class="keyword">auto</span> error = mHwcDevice-&gt;flushCommands();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;present(&amp;displayData.lastPresentFence);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">    error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    displayData.releaseFences = <span class="built_in">std</span>::move(releaseFences);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果之前Prepare过程中，presentOrValidate成功，validateWasSkipped为 true，那么直接刷掉command Buffer中的命令，让你执行。就没有后续的处理了，presentOrValidate成功，是没有Client合成的，也就没有所谓的FBTarget。<br>如果之前presentOrValidate没有成功，很有可能是需要Client端做合成的，也就是present没有完成，那么这里需要走present的流程。<br>present操纵也是先写到Command Buffer中。最后调的execute。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Composer::presentDisplay</span><span class="params">(Display display, <span class="keyword">int</span>* outPresentFence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mWriter.selectDisplay(display);</span><br><span class="line">    mWriter.presentDisplay();</span><br><span class="line"></span><br><span class="line">    Error error = execute();</span><br><span class="line">    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReader.takePresentFence(display, outPresentFence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Error::NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置FBTarget时，只是写到Buffer中，execute时，设置FBTarget的操纵才一起生效，设置到了Server端。Server再进行最后的合成。<br>present完成后，通过getReleaseFences获取releaseFence，保存在displayData中。注意这里的release是每个Layer的release fence，这是8.0之前的版本没有的流程，之前的releasefence只有一个，所以Layer只有一个。而present时的lastPresentFence就是FBTarget的releasefence。<br>回到postFramebuffer函数。</p>
<ul>
<li>DisplayDevice处理FBTarget<br>释放上一帧的Buffer</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDevice::onSwapBuffersCompleted</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    mDisplaySurface-&gt;onFrameCommitted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要在onFrameCommitted函数中完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FramebufferSurface::onFrameCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHasPendingRelease) &#123;</span><br><span class="line">        sp&lt;Fence&gt; fence = mHwc.getPresentFence(mDisplayType);</span><br><span class="line">        <span class="keyword">if</span> (fence-&gt;isValid()) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = addReleaseFence(mPreviousBufferSlot,</span><br><span class="line">                    mPreviousBuffer, fence);</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> result = releaseBufferLocked(mPreviousBufferSlot, mPreviousBuffer);</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        mPreviousBuffer.clear();</span><br><span class="line">        mHasPendingRelease = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeCurrent为新的合成做准备</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DisplayDevice::makeCurrent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = mFlinger-&gt;getRenderEngine().setCurrentSurface(mSurface);</span><br><span class="line">    setViewportAndProjection();</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>给每一层Layer设置releaseFence</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onLayerDisplayed</span><span class="params">(<span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>&#123;</span><br><span class="line">    mConsumer-&gt;setReleaseFence(releaseFence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Layer需要Fence，给它presentFence，也就是FBTarget的Fence。最后清除HWComposer的mDisplayData中的releaseFence，因为他们已经传给Layer去了。</p>
<p>到此合成处理结束～</p>
<h5 id="六、合成后处理-postComposition"><a href="#六、合成后处理-postComposition" class="headerlink" title="六、合成后处理 postComposition"></a>六、合成后处理 postComposition</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postComposition</span><span class="params">(<span class="keyword">nsecs_t</span> refreshStartTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> dequeueReadyTime = systemTime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">        layer-&gt;releasePendingBuffer(dequeueReadyTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Timeline</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录Buffer状态</span></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameLatched = layer-&gt;onPostComposition(glCompositionDoneFenceTime,</span><br><span class="line">                presentFenceTime, compositorTiming);</span><br><span class="line">        <span class="keyword">if</span> (frameLatched) &#123;</span><br><span class="line">            recordBufferingStats(layer-&gt;getName().<span class="built_in">string</span>(),</span><br><span class="line">                    layer-&gt;getOccupancyHistory(<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vsync的同步</span></span><br><span class="line">    <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPrimaryDispSync.addPresentFence(presentFenceTime)) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasSyncFramework) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            enableHardwareVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画合成处理</span></span><br><span class="line">    <span class="keyword">if</span> (mAnimCompositionPending) &#123;</span><br><span class="line">        mAnimCompositionPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">            mAnimFrameTracker.setActualPresentFence(</span><br><span class="line">                    <span class="built_in">std</span>::move(presentFenceTime));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The HWC doesn&#x27;t support present fences, so use the refresh</span></span><br><span class="line">            <span class="comment">// timestamp instead.</span></span><br><span class="line">            <span class="keyword">nsecs_t</span> presentTime =</span><br><span class="line">                    getBE().mHwc-&gt;getRefreshTimestamp(HWC_DISPLAY_PRIMARY);</span><br><span class="line">            mAnimFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mAnimFrameTracker.advanceFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中主要做了下列几件事：</p>
<ul>
<li>释放待释放的Buffer<br>这一帧合成完成后，将被替代的Buffer释放掉～</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::releasePendingBuffer</span><span class="params">(<span class="keyword">nsecs_t</span> dequeueReadyTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mConsumer-&gt;releasePendingBuffer()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> releaseFenceTime =</span><br><span class="line">            <span class="built_in">std</span>::make_shared&lt;FenceTime&gt;(mConsumer-&gt;getPrevFinalReleaseFence());</span><br><span class="line">    mReleaseTimeline.updateSignalTimes();</span><br><span class="line">    mReleaseTimeline.push(releaseFenceTime);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mPreviousFrameNumber != <span class="number">0</span>) &#123;</span><br><span class="line">        mFrameEventHistory.addRelease(mPreviousFrameNumber, dequeueReadyTime,</span><br><span class="line">                                      <span class="built_in">std</span>::move(releaseFenceTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>处理Timeline</p>
</li>
<li><p>记录Buffer状态</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::recordBufferingStats</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* layerName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OccupancyTracker::Segment&gt;&amp;&amp; history)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(getBE().mBufferingStatsMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; stats = getBE().mBufferingStats[layerName];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; segment : history) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!segment.usedThirdBuffer) &#123;</span><br><span class="line">            stats.twoBufferTime += segment.totalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (segment.occupancyAverage &lt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">            stats.doubleBufferedTime += segment.totalTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (segment.occupancyAverage &lt; <span class="number">2.0f</span>) &#123;</span><br><span class="line">            stats.tripleBufferedTime += segment.totalTime;</span><br><span class="line">        &#125;</span><br><span class="line">        ++stats.numSegments;</span><br><span class="line">        stats.totalTime += segment.totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Vsync的同步<br>平常我们用的Vsync都是mPrimaryDispSync分发出来的，并不是每一次都是从底层硬件上报的，所以mPrimaryDispSync需要和- - 底层的硬件Vsync保持同步</li>
<li>动画合成处理</li>
<li>处理时间的记录</li>
</ul>
<p>到此一次合成处理完成，REFRESH处理完成。下一个Vsync到来时，新的一次合成又将开始。</p>
<h4 id="五-、Client合成"><a href="#五-、Client合成" class="headerlink" title="(五)、Client合成"></a>(五)、Client合成</h4><p>硬件HWC合成是Vendor实现的，各个Vendor不一样。而Client合成是Android自带的，我们接下来就来看看Android的Client端的合成。<br>Client端合成，本质是采用GPU进程合成，SurfaceFlinger中封装了RenderEngine进行具体的实现，相关的代码在如下位置：</p>
<blockquote>
<p>frameworks/native/services/surfaceflinger/RenderEngine<br>我们来看看看相关的类：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/display.system/Android.PG4.RenderEngine.png" alt="Alt text | center"></p>
</blockquote>
<ul>
<li>RenderEngine 是对GPU渲染的封装，包括了 EGLDisplay，EGLContext， EGLConfig，EGLSurface。注意每个Display的EGLSurface不是同一个，各自有各自的EGLSurface。</li>
<li>GLES20RenderEngine 继承RenderEngine，是GELS的2.0版本实现。其Program采用ProgramCache进行cache。状态用Description进描述。</li>
<li>每个BufferLayer 都有专门的Texture进行纹理的描述，GLES20RenderEngine 支持纹理贴图。合成时，将GraphicBuffer转换为纹理，进行混合。</li>
</ul>
<p>下面我们来看具体的流程，Client端GPU合成相关的流程如下：</p>
<h5 id="1-创建-RenderEngine"><a href="#1-创建-RenderEngine" class="headerlink" title="1.创建 RenderEngine"></a>1.创建 RenderEngine</h5><p>RenderEngine 是在SurfaceFlinger初始化时，创建的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    getBE().mRenderEngine = RenderEngine::create(HAL_PIXEL_FORMAT_RGBA_8888,</span><br><span class="line">            hasWideColorDisplay ? RenderEngine::WIDE_COLOR_SUPPORT : <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>create函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RenderEngine&gt; <span class="title">RenderEngine::create</span><span class="params">(<span class="keyword">int</span> hwcFormat, <span class="keyword">uint32_t</span> featureFlags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化EGLDisplay</span></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="keyword">if</span> (!eglInitialize(display, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;failed to initialize EGL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLExtensions处理</span></span><br><span class="line"></span><br><span class="line">    EGLint renderableType = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (config == EGL_NO_CONFIG) &#123;</span><br><span class="line">        renderableType = EGL_OPENGL_ES2_BIT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!eglGetConfigAttrib(display, config, EGL_RENDERABLE_TYPE, &amp;renderableType)) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;can&#x27;t query EGLConfig RENDERABLE_TYPE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    EGLint contextClientVersion = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (renderableType &amp; EGL_OPENGL_ES2_BIT) &#123;</span><br><span class="line">        contextClientVersion = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (renderableType &amp; EGL_OPENGL_ES_BIT) &#123;</span><br><span class="line">        contextClientVersion = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;no supported EGL_RENDERABLE_TYPEs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Attributes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EGLint&gt; contextAttributes;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EGLContext</span></span><br><span class="line">    EGLContext ctxt = eglCreateContext(display, config, <span class="literal">NULL</span>, contextAttributes.data());</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PBuffer</span></span><br><span class="line">    EGLint attribs[] = &#123;EGL_WIDTH, <span class="number">1</span>, EGL_HEIGHT, <span class="number">1</span>, EGL_NONE, EGL_NONE&#125;;</span><br><span class="line">    EGLSurface dummy = eglCreatePbufferSurface(display, dummyConfig, attribs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    EGLBoolean success = eglMakeCurrent(display, dummy, dummy, ctxt);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!success, <span class="string">&quot;can&#x27;t make dummy pbuffer current&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RenderEngine&gt; engine;</span><br><span class="line">    <span class="keyword">switch</span> (version) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">case</span> GLES_VERSION_3_0:</span><br><span class="line">            engine = <span class="built_in">std</span>::make_unique&lt;GLES20RenderEngine&gt;(featureFlags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置EGL信息</span></span><br><span class="line">    engine-&gt;setEGLHandles(display, config, ctxt);</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</span><br><span class="line">    eglDestroySurface(display, dummy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderEngine的初始化过程，就是GPU渲染初始化的过程，做过OpenGL编程的同学来说，小case。其大概的流程如下：</p>
<ul>
<li>创建 EGLDisplay<br>eglGetDisplay</li>
<li>初始化 EGLDisplay<br>eglInitialize</li>
<li>选择 EGLConfig<br>chooseEglConfig</li>
<li>获取renderableType<br>eglGetConfigAttrib</li>
<li>初始化Context属性<br>contextAttributes</li>
<li>创建EGLContext<br>eglCreateContext</li>
<li>创建 PBuffer<br>eglCreatePbufferSurface</li>
<li>MakeCurrent<br>eglMakeCurrent这是为虚拟的PBuffercheck状态。</li>
<li>创建RenderEngine<br>这里，目前值支持GELS2.0，对应的Render GLES20RenderEngine</li>
<li>设置设置EGL信息<br>将创建的EGL对象设置到我们创建的GLES20RenderEngine中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderEngine::setEGLHandles</span><span class="params">(EGLDisplay display, EGLConfig config, EGLContext ctxt)</span> </span>&#123;</span><br><span class="line">    mEGLDisplay = display;</span><br><span class="line">    mEGLConfig = config;</span><br><span class="line">    mEGLContext = ctxt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-创建Surface-FBTarget"><a href="#2-创建Surface-FBTarget" class="headerlink" title="2.创建Surface FBTarget"></a>2.创建Surface FBTarget</h5><p>在RenderEngine创建时，初始化了EGLDisplaym，EGLConfig，EGLContext。这些都是所有Display共用的，但是Surface每个Display的是自己的。<br>在DisplayDevice创建时，创建对应的Surface</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">isplayDevice::DisplayDevice(</span><br><span class="line">       ... ...</span><br><span class="line">      mSurface&#123;flinger-&gt;getRenderEngine()&#125;,</span><br><span class="line">      ... ...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">    Surface* surface;</span><br><span class="line">    mNativeWindow = surface = <span class="keyword">new</span> Surface(producer, <span class="literal">false</span>);</span><br><span class="line">    ANativeWindow* <span class="keyword">const</span> window = mNativeWindow.get();</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">    mSurface.setCritical(mType == DisplayDevice::DISPLAY_PRIMARY);</span><br><span class="line">    mSurface.setAsync(mType &gt;= DisplayDevice::DISPLAY_VIRTUAL);</span><br><span class="line">    mSurface.setNativeWindow(window);</span><br><span class="line">    mDisplayWidth = mSurface.queryWidth();</span><br><span class="line">    mDisplayHeight = mSurface.queryHeight();</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useTripleFramebuffer) &#123;</span><br><span class="line">        surface-&gt;allocateBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意mSurface.setNativeWindow，通过ANativeWindow，Surface就和DisplayDevice的BufferQueue建立了联系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Surface::setNativeWindow</span><span class="params">(ANativeWindow* window)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEGLSurface != EGL_NO_SURFACE) &#123;</span><br><span class="line">        eglDestroySurface(mEGLDisplay, mEGLSurface);</span><br><span class="line">        mEGLSurface = EGL_NO_SURFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindow = window;</span><br><span class="line">    <span class="keyword">if</span> (mWindow) &#123;</span><br><span class="line">        mEGLSurface = eglCreateWindowSurface(mEGLDisplay, mEGLConfig, mWindow, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的EGLSurface mEGLSurface和nativewindow mWindow 关联。这个GPU就可以通过nativewindow，从BufferQueue中dequeue Buffer进行渲染，swapBuffer时，也queue到Bufferqueu中。这里的ANativeWindow，本质就是 FBTarget。</p>
<h5 id="3-创建Texture"><a href="#3-创建Texture" class="headerlink" title="3.创建Texture"></a>3.创建Texture</h5><p>BufferLayer创建时，创建Texture：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferLayer::BufferLayer(SurfaceFlinger* flinger, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">                         <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">      : Layer(flinger, client, name, w, h, flags),</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">    mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过glGenTextures函数创建Texture。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderEngine::genTextures</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">uint32_t</span>* names)</span> </span>&#123;</span><br><span class="line">    glGenTextures(count, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>且在创建BufferLayerConsumer时，传到了Consumer中，对应的值为mTexName。</p>
<p>glGenTextures生成的Texture，在BufferLayer中，保存在mTexture中。</p>
<h5 id="4-开始合成-doComposeSurfaces"><a href="#4-开始合成-doComposeSurfaces" class="headerlink" title="4.开始合成 doComposeSurfaces"></a>4.开始合成 doComposeSurfaces</h5><p>合成是在SurfaceFlinger的doComposeSurfaces中进的，首先先makeCurrent。每个Display有自己的Surface，所以，每个Display做具体合成时，需要给RenderEngine指定Surface，视窗，投影矩阵等，告诉RenderEngine合成到哪个Surface上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DisplayDevice::makeCurrent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = mFlinger-&gt;getRenderEngine().setCurrentSurface(mSurface);</span><br><span class="line">    setViewportAndProjection();</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setCurrentSurface函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderEngine::setCurrentSurface</span><span class="params">(<span class="keyword">const</span> RE::Surface&amp; surface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    EGLSurface eglSurface = surface.getEGLSurface();</span><br><span class="line">    <span class="keyword">if</span> (eglSurface != eglGetCurrentSurface(EGL_DRAW)) &#123;</span><br><span class="line">        success = eglMakeCurrent(mEGLDisplay, eglSurface, eglSurface, mEGLContext) == EGL_TRUE;</span><br><span class="line">        <span class="keyword">if</span> (success &amp;&amp; surface.getAsync()) &#123;</span><br><span class="line">            eglSwapInterval(mEGLDisplay, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GPU不支持多线程，所以需要通过eglMakeCurrent切换GPU的工作线程，eglMakeCurrent后，GPU将处理我们当前线程的OpenGL绘图操纵。</p>
<h5 id="5-Layer的合成"><a href="#5-Layer的合成" class="headerlink" title="5.Layer的合成"></a>5.Layer的合成</h5><p>合成时，每个Display的每个Layer都合成到Display对应的Surface上。主要是在Layer的draw方法中完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::draw</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">const</span> Region&amp; clip)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    onDraw(renderArea, clip, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BufferLayer和ColorLayer实现各自的onDraw方法。我们先来看BufferLayer，BufferLayer比较复杂。</p>
<p>BufferLayer的合成onDraw处理流程如下：</p>
<ul>
<li>绑定Texture</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onDraw</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">const</span> Region&amp; clip,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> useIdentityTransform)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(getBE().compositionInfo.mBuffer == <span class="number">0</span>)) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定Texture</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mConsumer-&gt;bindTextureImage();</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::bindTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> bindTextureImageLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定Texture主要在bindTextureImageLocked中完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::bindTextureImageLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRE.checkErrors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT &amp;&amp; mCurrentTextureImage == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Rect&amp; imageCrop = canUseImageCrop(mCurrentCrop) ? mCurrentCrop : Rect::EMPTY_RECT;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCurrentTextureImage-&gt;createIfNeeded(imageCrop);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRE.bindExternalTextureImage(mTexName, mCurrentTextureImage-&gt;image());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doFenceWaitLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCurrentTextureImage是合成开始时，acquireBuffer时更新的。通过createIfNeeded创建Image。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferLayerConsumer::Image::createIfNeeded(<span class="keyword">const</span> Rect&amp; imageCrop) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> cropWidth = imageCrop.width();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> cropHeight = imageCrop.height();</span><br><span class="line">    <span class="keyword">if</span> (mCreated &amp;&amp; mCropWidth == cropWidth &amp;&amp; mCropHeight == cropHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCreated = mImage.setNativeWindowBuffer(mGraphicBuffer-&gt;getNativeBuffer(),</span><br><span class="line">                                            mGraphicBuffer-&gt;getUsage() &amp; GRALLOC_USAGE_PROTECTED,</span><br><span class="line">                                            cropWidth, cropHeight);</span><br><span class="line">    <span class="keyword">if</span> (mCreated) &#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCreated ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image的创建在setNativeWindowBuffer函数中完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Image::setNativeWindowBuffer</span><span class="params">(ANativeWindowBuffer* buffer, <span class="keyword">bool</span> isProtected, <span class="keyword">int32_t</span> cropWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int32_t</span> cropHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEGLImage != EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">        ... <span class="comment">//release pre mEGLImage</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EGLint&gt; attrs = buildAttributeList(isProtected, cropWidth, cropHeight);</span><br><span class="line">        mEGLImage = eglCreateImageKHR(mEGLDisplay, EGL_NO_CONTEXT, EGL_NATIVE_BUFFER_ANDROID,</span><br><span class="line">                                      <span class="keyword">static_cast</span>&lt;EGLClientBuffer&gt;(buffer), attrs.data());</span><br><span class="line">        <span class="keyword">if</span> (mEGLImage == EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;failed to create EGLImage: %#x&quot;</span>, eglGetError());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setNativeWindowBuffer时，先释放掉旧的mEGLImage。再创建新的mEGLImage。注意eglCreateImageKHR的参数。这里的buffer就是我们acquireBuffer时，获取到的GraphicBuffer。eglCreateImageKHR函数根据GraphicBuffer创建了一个mEGLImage。<br>回到bindTextureImageLocked函数，创建的EglImage通过bindExternalTextureImage函数绑定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderEngine::bindExternalTextureImage</span><span class="params">(<span class="keyword">uint32_t</span> texName, <span class="keyword">const</span> RE::Image&amp; image)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> GLenum target = GL_TEXTURE_EXTERNAL_OES;</span><br><span class="line"></span><br><span class="line">    glBindTexture(target, texName);</span><br><span class="line">    <span class="keyword">if</span> (image.getEGLImage() != EGL_NO_IMAGE_KHR) &#123;</span><br><span class="line">        glEGLImageTargetTexture2DOES(target, <span class="keyword">static_cast</span>&lt;GLeglImageOES&gt;(image.getEGLImage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终通过glEGLImageTargetTexture2DOES函数，将创建的EglImage和Texture mTexName进行绑定。这样我们的Layer数据就送到了GPU进行处理。<br>回到onDraw方法：</p>
<ul>
<li>DRM处理<br>如果是受保护的内容，或者是Secure的内容想显示在非安全的Display上，都是不允许的。这个时候，相关的区域显示为黑色</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLES20RenderEngine::setupLayerBlackedOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, mProtectedTexName);</span><br><span class="line">    <span class="function">Texture <span class="title">texture</span><span class="params">(Texture::TEXTURE_2D, mProtectedTexName)</span></span>;</span><br><span class="line">    texture.setDimensions(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// <span class="doctag">FIXME:</span> we should get that from somewhere</span></span><br><span class="line">    mState.setTexture(texture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取textureMatrix</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onDraw</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">const</span> Region&amp; clip,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">bool</span> useIdentityTransform)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">bool</span> blackOutLayer = isProtected() || (isSecure() &amp;&amp; !renderArea.isSecure());</span><br><span class="line"></span><br><span class="line">    <span class="function">RenderEngine&amp; <span class="title">engine</span><span class="params">(mFlinger-&gt;getRenderEngine())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!blackOutLayer) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> useFiltering = getFiltering() || needsFiltering(renderArea) || isFixedSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query the texture matrix given our current filtering mode.</span></span><br><span class="line">        <span class="keyword">float</span> textureMatrix[<span class="number">16</span>];</span><br><span class="line">        mConsumer-&gt;setFilteringEnabled(useFiltering);</span><br><span class="line">        mConsumer-&gt;getTransformMatrix(textureMatrix);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getTransformToDisplayInverse()) &#123;</span><br><span class="line">            <span class="comment">// 处理Inverse翻转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set things up for texturing.</span></span><br><span class="line">        mTexture.setDimensions(getBE().compositionInfo.mBuffer-&gt;getWidth(),</span><br><span class="line">                               getBE().compositionInfo.mBuffer-&gt;getHeight());</span><br><span class="line">        mTexture.setFiltering(useFiltering);</span><br><span class="line">        mTexture.setMatrix(textureMatrix);</span><br><span class="line"></span><br><span class="line">        engine.setupLayerTexturing(mTexture);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        engine.setupLayerBlackedOut();</span><br><span class="line">    &#125;</span><br><span class="line">    drawWithOpenGL(renderArea, useIdentityTransform);</span><br><span class="line">    engine.disableTexturing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>textureMatrix是在GLConsumer::computeTransformMatrix中计算的，感兴趣的可以去看看。</p>
<ul>
<li>用OpenGL绘制<br>主要通过drawWithOpenGL函数完成：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::drawWithOpenGL</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">bool</span> useIdentityTransform)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//计算区域边界，获取Mesh</span></span><br><span class="line">    computeGeometry(renderArea, getBE().mMesh, useIdentityTransform);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Rect bounds&#123;computeBounds()&#125;; <span class="comment">// Rounds from FloatRect</span></span><br><span class="line"></span><br><span class="line">    Transform t = getTransform();</span><br><span class="line">    Rect win = bounds;</span><br><span class="line">    <span class="keyword">if</span> (!s.finalCrop.isEmpty()) &#123;</span><br><span class="line">         ... ... <span class="comment">//处理finalCrop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> left = <span class="keyword">float</span>(win.left) / <span class="keyword">float</span>(s.active.w);</span><br><span class="line">    <span class="keyword">float</span> top = <span class="keyword">float</span>(win.top) / <span class="keyword">float</span>(s.active.h);</span><br><span class="line">    <span class="keyword">float</span> right = <span class="keyword">float</span>(win.right) / <span class="keyword">float</span>(s.active.w);</span><br><span class="line">    <span class="keyword">float</span> bottom = <span class="keyword">float</span>(win.bottom) / <span class="keyword">float</span>(s.active.h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算Texture的坐标顶点</span></span><br><span class="line">    <span class="function">Mesh::VertexArray&lt;vec2&gt; <span class="title">texCoords</span><span class="params">(getBE().mMesh.getTexCoordArray&lt;vec2&gt;())</span></span>;</span><br><span class="line">    texCoords[<span class="number">0</span>] = vec2(left, <span class="number">1.0f</span> - top);</span><br><span class="line">    texCoords[<span class="number">1</span>] = vec2(left, <span class="number">1.0f</span> - bottom);</span><br><span class="line">    texCoords[<span class="number">2</span>] = vec2(right, <span class="number">1.0f</span> - bottom);</span><br><span class="line">    texCoords[<span class="number">3</span>] = vec2(right, <span class="number">1.0f</span> - top);</span><br><span class="line"></span><br><span class="line">    <span class="function">RenderEngine&amp; <span class="title">engine</span><span class="params">(mFlinger-&gt;getRenderEngine())</span></span>;</span><br><span class="line">    engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(s), <span class="literal">false</span> <span class="comment">/* disableTexture */</span>,</span><br><span class="line">                              getColor());</span><br><span class="line">    engine.setSourceDataSpace(mCurrentState.dataSpace);</span><br><span class="line">    engine.drawMesh(getBE().mMesh);</span><br><span class="line">    engine.disableBlending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setupLayerBlending处理Alpha的Blend：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLES20RenderEngine::setupLayerBlending</span><span class="params">(<span class="keyword">bool</span> premultipliedAlpha, <span class="keyword">bool</span> opaque,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">bool</span> disableTexture, <span class="keyword">const</span> half4&amp; color)</span> </span>&#123;</span><br><span class="line">    mState.setPremultipliedAlpha(premultipliedAlpha);</span><br><span class="line">    mState.setOpaque(opaque);</span><br><span class="line">    mState.setColor(color);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disableTexture) &#123;</span><br><span class="line">        mState.disableTexture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (color.a &lt; <span class="number">1.0f</span> || !opaque) &#123;</span><br><span class="line">        glEnable(GL_BLEND);</span><br><span class="line">        glBlendFunc(premultipliedAlpha ? GL_ONE : GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        glDisable(GL_BLEND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>drawMesh绘制内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLES20RenderEngine::drawMesh</span><span class="params">(<span class="keyword">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.getTexCoordsSize()) &#123;</span><br><span class="line">        glEnableVertexAttribArray(Program::texCoords);</span><br><span class="line">        glVertexAttribPointer(Program::texCoords, mesh.getTexCoordsSize(), GL_FLOAT, GL_FALSE,</span><br><span class="line">                              mesh.getByteStride(), mesh.getTexCoords());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(Program::position, mesh.getVertexSize(), GL_FLOAT, GL_FALSE,</span><br><span class="line">                          mesh.getByteStride(), mesh.getPositions());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usesWideColor()) &#123;</span><br><span class="line">        Description wideColorState = mState;</span><br><span class="line">        <span class="keyword">if</span> (mDataSpace != HAL_DATASPACE_DISPLAY_P3) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">        ProgramCache::getInstance().useProgram(wideColorState);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(mesh.getPrimitive(), <span class="number">0</span>, mesh.getVertexCount());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outputDebugPPMs) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ProgramCache::getInstance().useProgram(mState);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(mesh.getPrimitive(), <span class="number">0</span>, mesh.getVertexCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mesh.getTexCoordsSize()) &#123;</span><br><span class="line">        glDisableVertexAttribArray(Program::texCoords);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>glDrawArrays绘制～</p>
<p>所有Layer都绘制完成后，swapBuffer</p>
<h5 id="6-交换Buffer"><a href="#6-交换Buffer" class="headerlink" title="6.交换Buffer"></a>6.交换Buffer</h5><p>Surface交换Buffer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Surface::swapBuffers</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!eglSwapBuffers(mEGLDisplay, mEGLSurface)) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eglSwapBuffers 将交换GPU处理的Buffer，处理完的Buffer，也就是包含Layer合成数据后的Buffer将被queue到BufferQueue中。<br>前面已经说过advanceFrame时，将acquireBuffer，通过setClientTarget给HWC设置Client端的合成结果，传给底层进行显示。<br>以上就是Client端的合成处理。</p>
<h4 id="六-、参考资料-特别感谢-："><a href="#六-、参考资料-特别感谢-：" class="headerlink" title="(六)、参考资料(特别感谢)："></a>(六)、参考资料(特别感谢)：</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/f92447ae8445/">（1）【Android P 图形显示系统】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/">（2）【深入剖析Android系统】</a><br><a target="_blank" rel="noopener" href="http://charlesvincent.cc/">（3）【Android Display System】</a><br><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/">（4）【Android SurfaceFlinger 学习之路】</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190716/">https://zhoujinjian.com/posts/20190716/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.39.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190724/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.40.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android P Graphics System（五）：GraphicBuffer和Gralloc分析（转载）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190708/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.38.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android P Graphics System（三）：Qualcomm HWC2（Hardware Composer 2.0 ）分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Native-Surface%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">（一）、Native Surface创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-0-%E3%80%81Native-Surface%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.0 、Native Surface创建步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-SurfaceFlinger%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android SurfaceFlinger内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-0-%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.0 、BufferQueue介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1、生产者Producer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-2%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2、消费者Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Surface%E7%AE%A1%E7%90%86%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA-lock-Buffer-amp-amp-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">（三）、Surface管理图形缓冲区- (lock) Buffer &amp;&amp; (unlockAndPost) Buffer的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-0%E3%80%81APP%E7%94%B3%E8%AF%B7-lock-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.0、APP申请(lock)Buffer的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1%E3%80%81APP%E6%8F%90%E4%BA%A4-unlockAndPost-Buffer%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">3.1.1、APP提交(unlockAndPost)Buffer的过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81%E9%80%9A%E7%9F%A5SF%E6%B6%88%E8%B4%B9%E5%90%88%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">（四）、通知SF消费合成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-0%E3%80%81%E6%B6%88%E6%81%AFINVALIDATE%E5%A4%84%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">4.0、消息INVALIDATE处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81handlePageFlip%E8%8E%B7%E5%8F%96Buffer"><span class="toc-number">4.2.</span> <span class="toc-text">4.1、handlePageFlip获取Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81preComposition-%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">一、preComposition()函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81rebuildLayerStacks%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">二、rebuildLayerStacks函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E7%A1%AC%E4%BB%B6%E5%90%88%E6%88%90-setUpHWComposer"><span class="toc-number">5.1.</span> <span class="toc-text">三、配置硬件合成 setUpHWComposer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-DisplayDevice-beginFrame"><span class="toc-number">5.2.</span> <span class="toc-text">1.DisplayDevice beginFrame</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">2.创建工作列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E6%AF%8F%E5%B1%82Layer%E7%9A%84Frame%E6%95%B0%E6%8D%AE"><span class="toc-number">5.4.</span> <span class="toc-text">3.设置每层Layer的Frame数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-prepareFrame%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="toc-number">5.5.</span> <span class="toc-text">4.prepareFrame准备数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%88%E6%88%90%E5%A4%84%E7%90%86-doComposition"><span class="toc-number">5.6.</span> <span class="toc-text">四、合成处理 doComposition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E8%84%8F%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.7.</span> <span class="toc-text">1.获取脏区域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Display%E5%90%88%E6%88%90%E5%A4%84%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">2.Display合成处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RenderEngine-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.9.</span> <span class="toc-text">RenderEngine 的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86Client%E7%AB%AF%E7%9A%84Layer%E6%B8%B2%E6%9F%93%E5%88%B0FBTarget"><span class="toc-number">5.10.</span> <span class="toc-text">将Client端的Layer渲染到FBTarget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Display-%E4%BA%A4%E6%8D%A2Buffer"><span class="toc-number">5.11.</span> <span class="toc-text">3.Display 交换Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8F%90%E4%BA%A4Framebuffer"><span class="toc-number">5.12.</span> <span class="toc-text">4.提交Framebuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81postFramebuffer-%E5%87%BD%E6%95%B0"><span class="toc-number">5.13.</span> <span class="toc-text">五、postFramebuffer()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%90%88%E6%88%90%E5%90%8E%E5%A4%84%E7%90%86-postComposition"><span class="toc-number">5.14.</span> <span class="toc-text">六、合成后处理 postComposition</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94-%E3%80%81Client%E5%90%88%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">(五)、Client合成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA-RenderEngine"><span class="toc-number">6.1.</span> <span class="toc-text">1.创建 RenderEngine</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BASurface-FBTarget"><span class="toc-number">6.2.</span> <span class="toc-text">2.创建Surface FBTarget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BATexture"><span class="toc-number">6.3.</span> <span class="toc-text">3.创建Texture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BC%80%E5%A7%8B%E5%90%88%E6%88%90-doComposeSurfaces"><span class="toc-number">6.4.</span> <span class="toc-text">4.开始合成 doComposeSurfaces</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Layer%E7%9A%84%E5%90%88%E6%88%90"><span class="toc-number">6.5.</span> <span class="toc-text">5.Layer的合成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BA%A4%E6%8D%A2Buffer"><span class="toc-number">6.6.</span> <span class="toc-text">6.交换Buffer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD-%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2-%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">(六)、参考资料(特别感谢)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>