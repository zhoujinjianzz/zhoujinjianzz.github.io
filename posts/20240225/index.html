<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序 | zhoujinjian</title><meta name="keywords" content="Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">
<meta property="og:url" content="https://zhoujinjian.com/posts/20240225/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg">
<meta property="article:published_time" content="2024-02-24T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.940Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20240225/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.940Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Kernel-4.19</strong>==）&amp;&amp;（==<strong>文章基于 Android 11.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://shop.allnetchina.cn/collections/frontpage/products/rock-pi-4-model-b-board-only-2-4-5ghz-wlan-bluetooth-5-0">【开发板 RockPi4bPlusV1.6】</a></p>
<p><a href="">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）源码链接】</a>：（repo init -u <a target="_blank" rel="noopener" href="https://github.com/radxa/manifests.git">https://github.com/radxa/manifests.git</a> -b Android11_Radxa_rk11.1 -m rockchip-r-release.xml）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.radxa.com/Rockpi4/rockpi-android11">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）编译指南】</a></p>
<p>正是由于前人（各位大神）的分析和总结，帮助我节约了大量的时间和精力，特别感谢，由于不喜欢图片水印，去除了水印，敬请谅解！！！</p>
<p>本文转自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17778173.html">Rockchip RK3399 - DRM HDMI驱动程序 </a>，如有侵权，请联系删除。</p>
<hr>
<p>开发板 ：<code>ROCK Pi 4B+</code>开发板<br><code>eMMC</code> ：<code>32GB</code><br><code>LPDDR4</code> ：<code>4GB</code><br>显示屏 ：<code>7</code>英寸<code>HDMI</code>接口显示屏<br><code>u-boot</code> ：<code>2017.09</code><br><code>linux</code> ：<code>4.19</code>  </p>
<hr>
<p>在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17686403.html">《<code>Rockchip RK3399 - DRM</code>驱动程序》</a>我们已经介绍过了，<code>RK3399</code>有两个<code>VOP</code>，均可以支持<code>HDMI</code>、<code>eDP</code>、<code>DP</code>、<code>MIPI DSI0</code>、<code>MIPI DSI1</code>显示接口，本节我们选择<code>HDMI</code>作为分析的对象。</p>
<p>在《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17778171.html"><code>Rockchip RK3399 - DRM HDMI</code>介绍</a>》我们已经对<code>HDMI</code>协议进行了详细的介绍，本节我们选择<code>DRM HDMI</code>驱动程序作为分析的对象。</p>
<p>这里我们介绍一下<code>Rochchip DRM</code>驱动中与<code>hdmi</code>相关的实现，具体实现文件：</p>
<ul>
<li><code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>；</li>
<li><code>drivers/gpu/drm/rockchip/inno_hdmi.c</code>；</li>
<li><code>drivers/gpu/drm/bridge/synopsys/</code>；</li>
</ul>
<p>由于<code>Rockchip</code>采用了<code>Synopsys</code>的<code>DesignWare HDMI IP</code>解决方案，因此<code>hdmi</code>驱动的核心实现是位于<code>drivers/gpu/drm/bridge/synopsys/</code>目录下的，而<code>Rockchip</code>仅仅是对其进行一层封装。</p>
<p>在介绍<code>hdmi</code>驱动之前，我们首先思考一个问题，假设我们自己是一个画家，现在我手里有一个笔、还有一张纸，然后我打算在纸上绘画一个卡通人物，接下来我们会怎么做呢？</p>
<ul>
<li><p>首先我们需要对我们绘画使用的纸的尺寸有一个了解；</p>
<ul>
<li>如果是<code>A3</code>上的图纸，那么我就会在大脑里构思一个<code>A3</code>大小的卡通人物；</li>
<li>如果是<code>A4</code>，那么我就会在大脑里构思一个<code>A4</code>大小的卡通人物；</li>
<li>总之我们的目的是要让卡通人物占满整张纸；</li>
</ul>
</li>
<li><p>接下来我们就会使用不同颜色的画笔开始在纸上绘画了，而我们的绘画过程呢，就是将大脑中构思的卡通人物按照从左到右、从上到下一笔一笔的勾勒出来；</p>
</li>
</ul>
<p>同样的，类比到<code>DRM</code>显示子系统中；</p>
<ul>
<li><code>hdmi</code>显示器等价于绘画的纸：<code>LCD</code>驱动器会将接收到的数据在显示器上显示出来；</li>
<li><code>RK3399 crtc</code>等价于画笔：<code>crtc</code>从<code>framebuffer</code>中读取待显示的图像，并按照响应的格式输出给<code>encoder</code>；<ul>
<li>对于<code>crtc</code>来说，其承担了各种时序参数配置的重任；</li>
<li><code>encoder</code>实际上就是进行的编码工作，对于<code>HDMI</code>来说来用的就是<code>TMDS</code>协议，经过编码之后的数据就可以通过<code>HDMI</code>线缆输出到<code>HDMI</code>显示器了；这个输出的过程就类似于我们绘画的过程：从左到右、从上到下；</li>
</ul>
</li>
<li><code>framebuffer</code>等价于大脑中构思的卡通人物：<code>framebuffer</code>就是一块驱动和应用层都能访问的内存，这块内存中描述了使用的显示器的分辨率、色彩描述(<code>RGB24</code> ,<code>I420</code> ,<code>YUUV</code>等等）、以及要真正要显示的内容所在的虚拟地址（通过<code>GEM</code>分配物理内存）；</li>
</ul>
<h3 id="一、设备树配置"><a href="#一、设备树配置" class="headerlink" title="一、设备树配置"></a>一、设备树配置</h3><h4 id="1-1-hdmi设备节点"><a href="#1-1-hdmi设备节点" class="headerlink" title="1.1 hdmi设备节点"></a>1.1 <code>hdmi</code>设备节点</h4><p>设备节点<code>vopb</code>下的子节点<code>vopb_out_hdmi</code>通过<code>hdmi_in_vopb</code>（由<code>remote-endpoint</code>属性指定）和<code>hdmi</code>显示接口组成一个连接通路；</p>
<p>设备节点<code>vopl</code>下的子节点<code>vopl_out_hdmi</code>通过<code>hdmi_in_vopl</code>（由<code>remote-endpoint</code>属性指定）和<code>hdmi</code>显示接口组成一个连接通路；</p>
<p><code>hdmi</code>设备节点定义在<code>arch/arm64/boot/dts/rockchip/rk3399.dtsi</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">hdmi: hdmi@ff940000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-dw-hdmi&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xff940000</span> <span class="number">0x0</span> <span class="number">0x20000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">23</span> IRQ_TYPE_LEVEL_HIGH <span class="number">0</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru PCLK_HDMI_CTRL&gt;,</span><br><span class="line">                 &lt;&amp;cru SCLK_HDMI_SFR&gt;,</span><br><span class="line">                 &lt;&amp;cru SCLK_HDMI_CEC&gt;,</span><br><span class="line">                 &lt;&amp;cru PCLK_VIO_GRF&gt;,</span><br><span class="line">                 &lt;&amp;cru PLL_VPLL&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;iahb&quot;</span>, <span class="string">&quot;isfr&quot;</span>, <span class="string">&quot;cec&quot;</span>, <span class="string">&quot;grf&quot;</span>, <span class="string">&quot;ref&quot;</span>;</span><br><span class="line">        power-domains = &lt;&amp;power RK3399_PD_HDCP&gt;;</span><br><span class="line">        reg-io-width = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">        rockchip,grf = &lt;&amp;grf&gt;;</span><br><span class="line">        <span class="meta">#sound-dai-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ports &#123;</span><br><span class="line">                hdmi_in: port &#123;</span><br><span class="line">                        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">                        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">                        hdmi_in_vopb: endpoint@<span class="number">0</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                                remote-endpoint = &lt;&amp;vopb_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        hdmi_in_vopl: endpoint@<span class="number">1</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">                                remote-endpoint = &lt;&amp;vopl_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>子节点<code>ports</code>：包含2个<code>input endpoint</code>，分别连接到<code>vopl</code>和<code>vopb</code>；也就是在<code>rk3399</code>上，<code>hdmi</code>可以和<code>vopl</code>（只支持 2K）、<code>vopb</code>（支持 4K）连接；</li>
</ul>
<p>因此可以得到有2条通路：</p>
<ul>
<li><code>vopb_out_hdmi</code> —&gt; <code>hdmi_in_vopb</code>；</li>
<li><code>vopl_out_hdmi</code> —&gt; <code>hdmi_in_vopl</code>；</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>两个<code>vop</code>可以分别与两个显示接口绑定（一个显示接口只能和一个<code>vop</code>绑定），且可以相互交换：</li>
<li>⼀个显⽰接口在同⼀个时刻只能和⼀个<code>vop</code>连接，所以在具体的板级配置中，需要设备树中把要使⽤的通路打开，把不使⽤的通路设置为<code>disabled</code>状态。</li>
</ul>
<h4 id="1-2-启用hdmi"><a href="#1-2-启用hdmi" class="headerlink" title="1.2 启用hdmi"></a>1.2 启用<code>hdmi</code></h4><p>如果我们希望<code>hdmi</code>连接在<code>vopb</code>上，则需要在<code>arch/arm64/boot/dts/rockchip/rk3399-evb.dts</code>中为以下节点新增属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c7 &#123;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 使能显示子系统</span><br><span class="line">&amp;display_subsystem &#123;</span><br><span class="line">         status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 使能vopb</span><br><span class="line">&amp;vopb &#123;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;vopb_mmu &#123;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"># 使能hdmi</span><br><span class="line">&amp;hdmi &#123;     </span><br><span class="line">        ddc-i2c-bus = &lt;&amp;i2c7&gt;;</span><br><span class="line">        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">        pinctrl<span class="number">-0</span> = &lt;&amp;hdmi_cec&gt;;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># hdmi绑定到vopb</span></span><br><span class="line">&amp;hdmi_in_vopb&#123;</span><br><span class="line">        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># 禁止hdmi绑定到vopl</span><br><span class="line">&amp;hdmi_in_vopl&#123;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、Platform驱动"><a href="#二、Platform驱动" class="headerlink" title="二、Platform驱动"></a>二、<code>Platform</code>驱动</h3><h4 id="2-1-模块入口函数"><a href="#2-1-模块入口函数" class="headerlink" title="2.1 模块入口函数"></a>2.1 模块入口函数</h4><p>在<code>rockchip_drm_init</code>函数中调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">rockchip_drm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drm_firmware_drivers_only())</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据配置来决定是否添加xxx_xxx_driver到数组rockchip_sub_drivers</span></span><br><span class="line">        num_rockchip_sub_drivers = <span class="number">0</span>;</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(dw_hdmi_rockchip_pltfm_driver,CONFIG_ROCKCHIP_DW_HDMI);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 注册多个platform driver    </span></span><br><span class="line">        ret = platform_register_drivers(rockchip_sub_drivers,</span><br><span class="line">                                        num_rockchip_sub_drivers);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册rockchip_drm_platform_driver</span></span><br><span class="line">        ret = platform_driver_register(&amp;rockchip_drm_platform_driver);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_unreg_drivers;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD_ROCKCHIP_SUB_DRIVER(dw_hdmi_rockchip_pltfm_driver,CONFIG_ROCKCHIP_DW_HDMI);</span><br></pre></td></tr></table></figure>

<p>会将<code>vop_platform_driver</code>保存到<code>rockchip_sub_drivers</code>数组中。</p>
<p>并调用<code>platform_register_drivers</code>遍历<code>rockchip_sub_drivers</code>数组，多次调用<code>platform_driver_register</code>注册<code>platform driver</code>。</p>
<h4 id="2-2-dw-hdmi-rockchip-pltfm-driver"><a href="#2-2-dw-hdmi-rockchip-pltfm-driver" class="headerlink" title="2.2 dw_hdmi_rockchip_pltfm_driver"></a>2.2 <code>dw_hdmi_rockchip_pltfm_driver</code></h4><p><code>dw_hdmi_rockchip_pltfm_driver</code>定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">dw_hdmi_rockchip_pltfm_driver</span> = &#123;</span></span><br><span class="line">        .probe  = dw_hdmi_rockchip_probe,</span><br><span class="line">        .remove = dw_hdmi_rockchip_remove,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;dwhdmi-rockchip&quot;</span>,</span><br><span class="line">                .pm = &amp;dw_hdmi_rockchip_pm,</span><br><span class="line">                .of_match_table = dw_hdmi_rockchip_dt_ids, <span class="comment">// 用于设备树匹配</span></span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-of-match-table"><a href="#2-2-1-of-match-table" class="headerlink" title="2.2.1 of_match_table"></a>2.2.1 <code>of_match_table</code></h5><p>其中<code>of_match_table</code>用于设备树匹配，匹配设备树中<code>compatible = &quot;rockchip,rk3399-dw-hdmi&quot;</code>的设备节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_plat_data</span> <span class="title">rk3399_hdmi_drv_data</span> = &#123;</span></span><br><span class="line">        .mode_valid = dw_hdmi_rockchip_mode_valid,</span><br><span class="line">        .mpll_cfg   = rockchip_mpll_cfg,</span><br><span class="line">        .cur_ctr    = rockchip_cur_ctr,</span><br><span class="line">        .phy_config = rockchip_phy_config,</span><br><span class="line">        .phy_data = &amp;rk3399_chip_data,</span><br><span class="line">        .use_drm_infoframe = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">dw_hdmi_rockchip_dt_ids</span>[] = &#123;</span></span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,rk3228-dw-hdmi&quot;</span>,</span><br><span class="line">          .data = &amp;rk3228_hdmi_drv_data</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,rk3288-dw-hdmi&quot;</span>,</span><br><span class="line">          .data = &amp;rk3288_hdmi_drv_data</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,rk3328-dw-hdmi&quot;</span>,</span><br><span class="line">          .data = &amp;rk3328_hdmi_drv_data</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,rk3399-dw-hdmi&quot;</span>,</span><br><span class="line">          .data = &amp;rk3399_hdmi_drv_data</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,rk3568-dw-hdmi&quot;</span>,</span><br><span class="line">          .data = &amp;rk3568_hdmi_drv_data</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-dw-hdmi-rockchip-probe"><a href="#2-2-2-dw-hdmi-rockchip-probe" class="headerlink" title="2.2.2 dw_hdmi_rockchip_probe"></a>2.2.2 <code>dw_hdmi_rockchip_probe</code></h5><p>在<code>platform</code>总线设备驱动模型中，我们知道当内核中有<code>platform</code>设备和<code>platform</code>驱动匹配，会调用到<code>platform_driver</code>里的成员<code>.probe</code>，在这里就是<code>dw_hdmi_rockchip_probe</code>函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">component_ops</span> <span class="title">dw_hdmi_rockchip_ops</span> = &#123;</span></span><br><span class="line">        .bind   = dw_hdmi_rockchip_bind,</span><br><span class="line">        .unbind = dw_hdmi_rockchip_unbind,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_rockchip_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component_add(&amp;pdev-&gt;dev, &amp;dw_hdmi_rockchip_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码很简单，就是为设备<code>pdev-&gt;dev</code>向系统注册一个<code>component</code>，其中组件可执行的初始化操作被设置为了<code>dw_hdmi_rockchip_ops</code>，我们需要重点关注<code>bind</code>函数的实现，这个我们单独小节介绍。</p>
<h3 id="三、HDMI数据结构"><a href="#三、HDMI数据结构" class="headerlink" title="三、HDMI数据结构"></a>三、<code>HDMI</code>数据结构</h3><p><code>hdmi</code>相关的数据结构分为两部分：</p>
<ul>
<li>由<code>DesignWare hdmi</code>相关驱动定义：比如<code>struct dw_hdmi</code>、<code>struct dw_hdmi_plat_data</code>；</li>
<li>由<code>Rochchip hdmi</code>相关驱动定义：比如<code>struct rockchip_hdmi</code>，<code>struct rockchip_hdmi_chip_data</code>；</li>
</ul>
<h4 id="3-1-DesignWare-hdmi"><a href="#3-1-DesignWare-hdmi" class="headerlink" title="3.1 DesignWare hdmi"></a>3.1 <code>DesignWare hdmi</code></h4><h5 id="3-1-1-struct-dw-hdmi"><a href="#3-1-1-struct-dw-hdmi" class="headerlink" title="3.1.1 struct dw_hdmi"></a>3.1.1 <code>struct dw_hdmi</code></h5><p><code>struct dw_hdmi</code>定义在<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> <span class="title">connector</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge</span> <span class="title">bridge</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge</span> *<span class="title">next_bridge</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> version;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">audio</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">cec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">isfr_clk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">iahb_clk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">cec_clk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_i2c</span> *<span class="title">i2c</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hdmi_data_info</span> <span class="title">hdmi_data</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_plat_data</span> *<span class="title">plat_data</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> vic;</span><br><span class="line"></span><br><span class="line">        u8 edid[HDMI_EDID_LEN];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_phy_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">                <span class="keyword">void</span> *data;</span><br><span class="line">                <span class="keyword">bool</span> enabled;</span><br><span class="line">        &#125; phy;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> <span class="title">previous_mode</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">ddc</span>;</span></span><br><span class="line">        <span class="keyword">void</span> __iomem *regs;</span><br><span class="line">        <span class="keyword">bool</span> sink_is_hdmi;</span><br><span class="line">        <span class="keyword">bool</span> sink_has_audio;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">unwedge_state</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>             <span class="comment">/* for state below and previous_mode */</span></span><br><span class="line">        <span class="keyword">enum</span> drm_connector_force force; <span class="comment">/* mutex-protected force state */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">curr_conn</span>;</span><span class="comment">/* current connector (only valid when !disabled) */</span></span><br><span class="line">        <span class="keyword">bool</span> disabled;                  <span class="comment">/* DRM has disabled our bridge */</span></span><br><span class="line">        <span class="keyword">bool</span> bridge_is_on;              <span class="comment">/* indicates the bridge is on */</span></span><br><span class="line">        <span class="keyword">bool</span> rxsense;                   <span class="comment">/* rxsense state */</span></span><br><span class="line">        u8 phy_mask;                    <span class="comment">/* desired phy int mask settings */</span></span><br><span class="line">        u8 mc_clkdis;                   <span class="comment">/* clock disable register */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">spinlock_t</span> audio_lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">audio_mutex</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sample_non_pcm;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sample_width;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> sample_rate;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> channels;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_cts;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_n;</span><br><span class="line">        <span class="keyword">bool</span> audio_enable;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> reg_shift;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regm</span>;</span></span><br><span class="line">        <span class="keyword">void</span> (*enable_audio)(struct dw_hdmi *hdmi);</span><br><span class="line">        <span class="keyword">void</span> (*disable_audio)(struct dw_hdmi *hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">cec_notifier_mutex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cec_notifier</span> *<span class="title">cec_notifier</span>;</span></span><br><span class="line"></span><br><span class="line">        hdmi_codec_plugged_cb plugged_cb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">codec_dev</span>;</span></span><br><span class="line">        <span class="keyword">enum</span> drm_connector_status last_connector_result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>connector</code>：连接器；</li>
<li><code>bridge</code>：桥接设备，一般用于注册encoder后面另外再接的转换芯片；</li>
<li><code>audio</code>：音频<code>platform device</code>；</li>
<li><code>cec</code>：<code>CEC platform device</code>；</li>
<li><code>dev</code>：<code>hdmi</code>设备；</li>
<li><code>isfr_clk</code>、<code>iahb_clk</code>、<code>cec_clk</code>：<code>hdmi</code>相关的时钟；</li>
<li><code>plat_data</code>：<code>dw hdmi</code>平台数据；</li>
<li><code>ddc</code>：存储<code>DDC</code>通道使用的<code>I2C</code>总线适配器；</li>
<li><code>edid</code>：存放<code>edid</code>信息；</li>
<li><code>regs</code>：<code>hdmi</code>相关寄存器基址的虚拟地址；</li>
<li><code>pinctrl</code>、<code>default_state</code>、<code>unwedge_state</code>：引脚状态配置信息；</li>
<li><code>reg_shift</code>：寄存器地址偏移；</li>
<li><code>sample_width</code>：音频采样位数；</li>
<li><code>sample_rate</code>：音频采样率；</li>
<li><code>channels</code>：通道数；</li>
<li><code>regm</code>：寄存器映射，用于通过<code>regmap</code>模型访问<code>hdmi</code>相关寄存器；</li>
<li><code>enable_audio</code>：启用音频回调函数；</li>
<li><code>disable_audio</code>：禁用音频回调函数；</li>
</ul>
<h5 id="3-1-2-struct-dw-hdmi-plat-data"><a href="#3-1-2-struct-dw-hdmi-plat-data" class="headerlink" title="3.1.2 struct dw_hdmi_plat_data"></a>3.1.2 <code>struct dw_hdmi_plat_data</code></h5><p><code>struct dw_hdmi_plat_data</code>定义在<code>include/drm/bridge/dw_hdmi.h</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_plat_data</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regm</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> output_port;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> input_bus_encoding;</span><br><span class="line">        <span class="keyword">bool</span> use_drm_infoframe;</span><br><span class="line">        <span class="keyword">bool</span> ycbcr_420_allowed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Private data passed to all the .mode_valid() and .configure_phy()</span></span><br><span class="line"><span class="comment">         * callback functions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Platform-specific mode validation (optional). */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_mode_status</span> <span class="params">(*mode_valid)</span><span class="params">(struct dw_hdmi *hdmi, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> struct drm_display_info *info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> struct drm_display_mode *mode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Platform-specific audio enable/disable (optional) */</span></span><br><span class="line">        <span class="keyword">void</span> (*enable_audio)(struct dw_hdmi *hdmi, <span class="keyword">int</span> channel,</span><br><span class="line">                             <span class="keyword">int</span> width, <span class="keyword">int</span> rate, <span class="keyword">int</span> non_pcm);</span><br><span class="line">        <span class="keyword">void</span> (*disable_audio)(struct dw_hdmi *hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Vendor PHY support */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_phy_ops</span> *<span class="title">phy_ops</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *phy_name;</span><br><span class="line">        <span class="keyword">void</span> *phy_data;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> phy_force_vendor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Synopsys PHY support */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> *<span class="title">mpll_cfg</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_curr_ctrl</span> *<span class="title">cur_ctr</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_phy_config</span> *<span class="title">phy_config</span>;</span></span><br><span class="line">        <span class="keyword">int</span> (*configure_phy)(struct dw_hdmi *hdmi, <span class="keyword">void</span> *data,</span><br><span class="line">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> mpixelclock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> disable_cec : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(1) 结构体<code>struct dw_hdmi_mpll_config</code>定义在如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> mpixelclock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                u16 cpce;</span><br><span class="line">                u16 gmp;</span><br><span class="line">        &#125; res[DW_HDMI_RES_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各项参数说明如下：</p>
<ul>
<li><code>mpixelclock</code>：像素时钟；</li>
<li><code>cpce</code>：<code>OPMODE_PLLCFG</code>寄存器值；</li>
<li><code>gmp</code>：<code>PLLGMPCTRL</code>寄存器值；</li>
</ul>
<h5 id="3-1-3-struct-edid"><a href="#3-1-3-struct-edid" class="headerlink" title="3.1.3 struct edid"></a>3.1.3 <code>struct edid</code></h5><p><code>linux</code>使用<code>struct edid</code>描述<code>edid</code>主块信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edid</span> &#123;</span></span><br><span class="line">        u8 header[<span class="number">8</span>];   <span class="comment">// 0x00~0x07</span></span><br><span class="line">        <span class="comment">/* Vendor &amp; product info */</span></span><br><span class="line">        u8 mfg_id[<span class="number">2</span>];   <span class="comment">// 0x08~0x09</span></span><br><span class="line">        u8 prod_code[<span class="number">2</span>]; <span class="comment">// 0x0A~0x0B</span></span><br><span class="line">        u32 serial; <span class="comment">/* <span class="doctag">FIXME:</span> byte order,0x0C~0X0F */</span></span><br><span class="line">        u8 mfg_week;  <span class="comment">// 0X10</span></span><br><span class="line">        u8 mfg_year;  <span class="comment">// 0x11</span></span><br><span class="line">        <span class="comment">/* EDID version */</span></span><br><span class="line">        u8 version;  <span class="comment">// 0x12</span></span><br><span class="line">        u8 revision; <span class="comment">// 0x13 </span></span><br><span class="line">        <span class="comment">/* Display info: */</span></span><br><span class="line">        u8 input;     <span class="comment">// 0x14</span></span><br><span class="line">        u8 width_cm;  <span class="comment">// 0x15</span></span><br><span class="line">        u8 height_cm; <span class="comment">// 0x16 </span></span><br><span class="line">        u8 gamma;     <span class="comment">// 0x17</span></span><br><span class="line">        u8 features;  <span class="comment">// 0x18</span></span><br><span class="line">        <span class="comment">/* Color characteristics */</span></span><br><span class="line">        u8 red_green_lo;   <span class="comment">// 0x19</span></span><br><span class="line">        u8 blue_white_lo;  <span class="comment">// 0x1A</span></span><br><span class="line">        u8 red_x;      <span class="comment">// 0x1B</span></span><br><span class="line">        u8 red_y;      <span class="comment">// 0x1c</span></span><br><span class="line">        u8 green_x;    <span class="comment">// 0x1D</span></span><br><span class="line">        u8 green_y;    <span class="comment">// 0x1E</span></span><br><span class="line">        u8 blue_x;     <span class="comment">// 0x1F</span></span><br><span class="line">        u8 blue_y;     <span class="comment">// 0x20</span></span><br><span class="line">        u8 white_x;    <span class="comment">// 0x21   </span></span><br><span class="line">        u8 white_y;    <span class="comment">// 0x22 </span></span><br><span class="line">        <span class="comment">/* Est. timings and mfg rsvd timings*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">est_timings</span> <span class="title">established_timings</span>;</span>   <span class="comment">// 0x23~0x25</span></span><br><span class="line">        <span class="comment">/* Standard timings 1-8*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">std_timing</span> <span class="title">standard_timings</span>[8];</span>    <span class="comment">// 0x26~0X35  </span></span><br><span class="line">        <span class="comment">/* Detailing timings 1-4 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_timing</span> <span class="title">detailed_timings</span>[4];</span> <span class="comment">// 0X36~0X7D</span></span><br><span class="line">        <span class="comment">/* Number of 128 byte ext. blocks */</span></span><br><span class="line">        u8 extensions;  <span class="comment">// 0x7E</span></span><br><span class="line">        <span class="comment">/* Checksum */</span></span><br><span class="line">        u8 checksum;    <span class="comment">// 0X7F</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>该数据结构保存<code>edit</code>主块128字节的信息，具体参考《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17778171.html"><code>Rockchip RK3399 - DRM HDMI介绍</code></a>》。</p>
<h5 id="3-1-4-struct-est-timings"><a href="#3-1-4-struct-est-timings" class="headerlink" title="3.1.4 struct est_timings"></a>3.1.4 <code>struct est_timings</code></h5><p><code>edid</code>的<code>Established Timings</code>信息在<code>linux</code>中使用<code>struct est_timings</code>表示；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">est_timings</span> &#123;</span></span><br><span class="line">        u8 t1;</span><br><span class="line">        u8 t2;</span><br><span class="line">        u8 mfg_rsvd;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-struct-std-timing"><a href="#3-1-5-struct-std-timing" class="headerlink" title="3.1.5 struct std_timing"></a>3.1.5 <code>struct std_timing</code></h5><p><code>edid</code>的<code>Standard Timings</code>信息在<code>linux</code>中使用<code>struct std_timing</code>表示；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 00=16:10, 01=4:3, 10=5:4, 11=16:9 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDID_TIMING_ASPECT_SHIFT 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDID_TIMING_ASPECT_MASK  (0x3 &lt;&lt; EDID_TIMING_ASPECT_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* need to add 60 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDID_TIMING_VFREQ_SHIFT  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDID_TIMING_VFREQ_MASK   (0x3f &lt;&lt; EDID_TIMING_VFREQ_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std_timing</span> &#123;</span></span><br><span class="line">        u8 hsize; <span class="comment">/* need to multiply by 8 then add 248 */</span></span><br><span class="line">        u8 vfreq_aspect;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<h5 id="3-1-6-struct-detailed-timing"><a href="#3-1-6-struct-detailed-timing" class="headerlink" title="3.1.6 struct detailed_timing"></a>3.1.6 <code>struct detailed_timing</code></h5><p><code>edid</code>中的<code>Detailed Timings</code>，它分为4个块（<code>Block</code>），每个块占用18个字节，一共72个字节。</p>
<p>每个块既可以是一个时序说明（<code>Timing Descriptor</code>）也可以是一个显示器描述符（<code>Monitor Descriptor</code>）。</p>
<p><code>struct detailed_timing</code>就是用来描述每一个<code>Detailed Timing</code>，定义在<code>include/drm/drm_edid.h</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">detailed_timing</span> &#123;</span></span><br><span class="line">        __le16 pixel_clock; <span class="comment">/* need to multiply by 10 KHz */</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">detailed_pixel_timing</span> <span class="title">pixel_data</span>;</span>  <span class="comment">// Timing Descriptor</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">detailed_non_pixel</span> <span class="title">other_data</span>;</span>  <span class="comment">// Monitor Descriptor</span></span><br><span class="line">        &#125; __attribute__((packed)) data;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是<code>pixel_clock</code>，如果<code>edid</code>信息中存放的值为<code>0xBCD3</code> =<code>48339</code>，在<code>drm_mode_detailed</code>函数中<code>pixel_clock</code>的值会被赋值为<code>48339*10=483390</code>；</p>
<p>实际像素时钟频率为 <code>48339*10000=483390000Hz</code>，<code>TMDS</code>时钟频率为<code>483390000Hz*10=4833900KHz</code> 所以<code>pixel_clock</code>的单位为<code>10kHZ</code>；</p>
<p>(1) <code>struct detailed_pixel_timing</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If detailed data is pixel timing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">detailed_pixel_timing</span> &#123;</span></span><br><span class="line">        u8 hactive_lo;</span><br><span class="line">        u8 hblank_lo;</span><br><span class="line">        u8 hactive_hblank_hi;</span><br><span class="line">        u8 vactive_lo;</span><br><span class="line">        u8 vblank_lo;</span><br><span class="line">        u8 vactive_vblank_hi;</span><br><span class="line">        u8 hsync_offset_lo;</span><br><span class="line">        u8 hsync_pulse_width_lo;</span><br><span class="line">        u8 vsync_offset_pulse_width_lo;</span><br><span class="line">        u8 hsync_vsync_offset_pulse_width_hi;</span><br><span class="line">        u8 width_mm_lo;</span><br><span class="line">        u8 height_mm_lo;</span><br><span class="line">        u8 width_height_mm_hi;</span><br><span class="line">        u8 hborder;</span><br><span class="line">        u8 vborder;</span><br><span class="line">        u8 misc;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>(2) <code>struct detailed_non_pixel</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">detailed_non_pixel</span> &#123;</span></span><br><span class="line">        u8 pad1; <span class="comment">/* 值为0，标识该block被使用 */</span></span><br><span class="line">        u8 type; <span class="comment">/* ff=serial, fe=string, fd=monitor range, fc=monitor name</span></span><br><span class="line"><span class="comment">                    fb=color point data, fa=standard timing data,</span></span><br><span class="line"><span class="comment">                    f9=undefined, f8=mfg. reserved */</span></span><br><span class="line">        u8 pad2;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">detailed_data_string</span> <span class="title">str</span>;</span> </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">detailed_data_monitor_range</span> <span class="title">range</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">detailed_data_wpindex</span> <span class="title">color</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">std_timing</span> <span class="title">timings</span>[6];</span>  <span class="comment">// type=EDID_DETAIL_STD_MODES=0xfa时生效</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">cvt_timing</span> <span class="title">cvt</span>[4];</span> <span class="comment">// type=EDID_DETAIL_CVT_3BYTE=0xf8时生效</span></span><br><span class="line">        &#125; __attribute__((packed)) data;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Rockchip-hdmi"><a href="#3-2-Rockchip-hdmi" class="headerlink" title="3.2 Rockchip hdmi"></a>3.2 <code>Rockchip hdmi</code></h4><h5 id="3-2-1-struct-rockchip-hdmi"><a href="#3-2-1-struct-rockchip-hdmi" class="headerlink" title="3.2.1 struct rockchip_hdmi"></a>3.2.1 <code>struct rockchip_hdmi</code></h5><p><code>struct rockchip_hdmi</code>定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>，这是<code>Rockchip</code>平台定义的<code>hdmi</code>结构体，其对<code>struct dw_hdmi</code>进行了扩充，用于表示<code>Rockchip</code>平台上的<code>hdmi</code>设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_hdmi</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regmap</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_encoder</span> <span class="title">encoder</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_hdmi_chip_data</span> *<span class="title">chip_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">ref_clk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">grf_clk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">avdd_0v9</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">avdd_1v8</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">phy</span> *<span class="title">phy</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>dev</code>：指向设备的<code>struct device *dev</code>指针；</li>
<li><code>regmap</code>：指向寄存器映射的<code>struct regmap *regmap</code>指针；</li>
<li><code>encoder</code>：指向<code>Rockchip</code>平台定义的<code>encoder</code>指针；</li>
<li><code>chip_data</code>：指向<code>Rockchip</code>平台定义的<code>hdmi data</code>指针；</li>
<li><code>ref_clk</code>：<code>ref</code>时钟；</li>
<li><code>grf_clk</code>：<code>grf</code>时钟；</li>
<li><code>avdd_0v9</code>：<code>0.9V</code>稳压器；</li>
<li><code>avdd_1v8</code>：<code>1.8V</code>稳压器；</li>
<li><code>phy</code>：指向<code>HDMI PHY</code>的<code>struct phy *phy</code>指针；</li>
</ul>
<h5 id="3-2-2-struct-rockchip-hdmi-chip-data"><a href="#3-2-2-struct-rockchip-hdmi-chip-data" class="headerlink" title="3.2.2 struct rockchip_hdmi_chip_data"></a>3.2.2 <code>struct rockchip_hdmi_chip_data</code></h5><p><code>struct rockchip_hdmi_chip_data</code>定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>，用于描述不同型号的<code>Rockchip</code>芯片的<code>HDMI</code>接口配置信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct rockchip_hdmi_chip_data - splite the grf setting of kind of chips</span></span><br><span class="line"><span class="comment"> * @lcdsel_grf_reg: grf register offset of lcdc select</span></span><br><span class="line"><span class="comment"> * @lcdsel_big: reg value of selecting vop big for HDMI</span></span><br><span class="line"><span class="comment"> * @lcdsel_lit: reg value of selecting vop little for HDMI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_hdmi_chip_data</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span>     lcdsel_grf_reg;</span><br><span class="line">        u32     lcdsel_big;</span><br><span class="line">        u32     lcdsel_lit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>lcdsel_grf_reg</code>：表示<code>GRF</code>寄存器中<code>LCD</code>控制器选择寄存器的偏移量，该寄存器用于选择使用哪个<code>vop</code>进行<code>HDMI</code>输出；</li>
<li><code>u32 lcdsel_big</code>：表示在<code>GRF</code>寄存器中<code>lcdsel_grf_reg</code>偏移位置处设置的值，用于选择<code>vopb</code>进行<code>HDMI</code>输出；</li>
<li><code>u32 lcdsel_lit</code>：表示在<code>GRF</code>寄存器中<code>lcdsel_grf_reg</code>偏移位置处设置的值，用于选择<code>vopl</code>进行<code>HDMI</code>输出。</li>
</ul>
<h5 id="3-2-3-struct-rockchip-encoder"><a href="#3-2-3-struct-rockchip-encoder" class="headerlink" title="3.2.3 struct rockchip_encoder"></a>3.2.3 <code>struct rockchip_encoder</code></h5><p><code>struct rockchip_encoder</code>定义在<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.h</code>，这是<code>Rockchip</code>平台定义的<code>encoder</code>结构体，用于表示<code>Rockchip</code>平台上的编码器设备。其对<code>struct drm_encoder</code>进行了扩充；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_encoder</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> crtc_endpoint_id;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> <span class="title">encoder</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>crtc_endpoint_id</code>：表示<code>crtc</code>端点的<code>ID</code>，用于标识该编码器设备连接到哪个<code>vop</code>；</li>
<li><code>drm_encoder encoder</code>：表示<code>DRM encoder</code>的相关信息；</li>
</ul>
<h3 id="四、dw-hdmi-rockchip-bind"><a href="#四、dw-hdmi-rockchip-bind" class="headerlink" title="四、dw_hdmi_rockchip_bind"></a>四、<code>dw_hdmi_rockchip_bind</code></h3><p><code>dw_hdmi_rockchip_bind</code>函数定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>，该函数的代码虽然看着那么多，实际上主要就做了以下几件事；</p>
<ul>
<li>解析<code>hdmi</code>设备节点，涉及到<code>clocks</code> 、<code>rockchip,grf</code>、<code>avdd-0v9</code>、<code>avdd-1v8</code>、以及<code>endpoint</code>子节点；</li>
<li>初始化<code>encoder</code>；</li>
<li>构造<code>dw_hdmi_bind</code>函数需要的参数，尤其是第三个参数<code>rk3399_hdmi_drv_data</code>，最后调用<code>dw_hdmi_bind</code>进入到<code>DesignWare hdmi</code>驱动；</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_rockchip_bind</span><span class="params">(struct device *dev, struct device *master,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">to_platform_device</span>(<span class="title">dev</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_plat_data</span> *<span class="title">plat_data</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">drm</span> = <span class="title">data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *<span class="title">encoder</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_hdmi</span> *<span class="title">hdmi</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pdev-&gt;dev.of_node)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态分配内存，指向struct rockchip_hdmi</span></span><br><span class="line">        hdmi = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*hdmi), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!hdmi)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据设备的设备节点和匹配表进行匹配，并返回匹配项</span></span><br><span class="line">        match = of_match_node(dw_hdmi_rockchip_dt_ids, pdev-&gt;dev.of_node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配内存，指向一个struct dw_hdmi_plat_data，并复制rk3399_hdmi_drv_data数据</span></span><br><span class="line">        plat_data = devm_kmemdup(&amp;pdev-&gt;dev, match-&gt;data,</span><br><span class="line">                                             <span class="keyword">sizeof</span>(*plat_data), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!plat_data)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置device设备</span></span><br><span class="line">        hdmi-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 设置数据</span></span><br><span class="line">        hdmi-&gt;chip_data = plat_data-&gt;phy_data;</span><br><span class="line">        plat_data-&gt;phy_data = hdmi;</span><br><span class="line">        encoder = &amp;hdmi-&gt;encoder.encoder;</span><br><span class="line"></span><br><span class="line">        encoder-&gt;possible_crtcs = drm_of_find_possible_crtcs(drm, dev-&gt;of_node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取设备节点hdmi子节点hdmi_in_vopb的属性remote-endpoint指定vopb_out_hdmi节点的reg的值，用来初始化encoder-&gt;crtc_endpoint_id</span></span><br><span class="line">        rockchip_drm_encoder_set_crtc_endpoint_id(&amp;hdmi-&gt;encoder,</span><br><span class="line">                                                  dev-&gt;of_node, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we failed to find the CRTC(s) which this encoder is</span></span><br><span class="line"><span class="comment">         * supposed to be connected to, it&#x27;s because the CRTC has</span></span><br><span class="line"><span class="comment">         * not been registered yet.  Defer probing, and hope that</span></span><br><span class="line"><span class="comment">         * the required CRTC is added later.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;possible_crtcs == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析hdmi设备节点，比如clocks 、rockchip,grf、avdd-0v9、avdd-1v8等属性；</span></span><br><span class="line">        ret = rockchip_hdmi_parse_dt(hdmi);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">                        DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;Unable to parse OF data\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找并获取一个可选的 PHY（物理层设备）的引用</span></span><br><span class="line">        hdmi-&gt;phy = devm_phy_optional_get(dev, <span class="string">&quot;hdmi&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;phy)) &#123;</span><br><span class="line">                ret = PTR_ERR(hdmi-&gt;phy);</span><br><span class="line">                <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">                        DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;failed to get phy\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使能AVDD_0V9电源</span></span><br><span class="line">        ret = regulator_enable(hdmi-&gt;avdd_0v9);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;failed to enable avdd0v9: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_avdd_0v9;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使能AVDD_1V8电源</span></span><br><span class="line">        ret = regulator_enable(hdmi-&gt;avdd_1v8);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;failed to enable avdd1v8: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_avdd_1v8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备和使能时钟</span></span><br><span class="line">        ret = clk_prepare_enable(hdmi-&gt;ref_clk);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;Failed to enable HDMI reference clock: %d\n&quot;</span>,</span><br><span class="line">                              ret);</span><br><span class="line">                <span class="keyword">goto</span> err_clk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (hdmi-&gt;chip_data == &amp;rk3568_chip_data) &#123;</span><br><span class="line">                regmap_write(hdmi-&gt;regmap, RK3568_GRF_VO_CON1,</span><br><span class="line">                             HIWORD_UPDATE(RK3568_HDMI_SDAIN_MSK |</span><br><span class="line">                                           RK3568_HDMI_SCLIN_MSK,</span><br><span class="line">                                           RK3568_HDMI_SDAIN_MSK |</span><br><span class="line">                                           RK3568_HDMI_SCLIN_MSK));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置encoder的辅助函数helper_private为dw_hdmi_rockchip_encoder_helper_funcs</span></span><br><span class="line">        drm_encoder_helper_add(encoder, &amp;dw_hdmi_rockchip_encoder_helper_funcs);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// encoder初始化</span></span><br><span class="line">        drm_simple_encoder_init(drm, encoder, DRM_MODE_ENCODER_TMDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置驱动私有数据 pdev-&gt;dev.driver_data = hdmi</span></span><br><span class="line">        platform_set_drvdata(pdev, hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化HDMI接口</span></span><br><span class="line">        hdmi-&gt;hdmi = dw_hdmi_bind(pdev, encoder, plat_data);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If dw_hdmi_bind() fails we&#x27;ll never call dw_hdmi_unbind(),</span></span><br><span class="line"><span class="comment">         * which would have called the encoder cleanup.  Do it manually.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;hdmi)) &#123;</span><br><span class="line">                ret = PTR_ERR(hdmi-&gt;hdmi);</span><br><span class="line">                <span class="keyword">goto</span> err_bind;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bind:</span><br><span class="line">        drm_encoder_cleanup(encoder);</span><br><span class="line">        clk_disable_unprepare(hdmi-&gt;ref_clk);</span><br><span class="line">err_clk:</span><br><span class="line">        regulator_disable(hdmi-&gt;avdd_1v8);</span><br><span class="line">err_avdd_1v8:</span><br><span class="line">        regulator_disable(hdmi-&gt;avdd_0v9);</span><br><span class="line">err_avdd_0v9:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-drm-of-find-possible-crtcs"><a href="#4-1-drm-of-find-possible-crtcs" class="headerlink" title="4.1 drm_of_find_possible_crtcs"></a>4.1 <code>drm_of_find_possible_crtcs</code></h4><p><code>drm_of_find_possible_crtcs</code>定义在<code>drivers/gpu/drm/drm_of.c</code>；这个函数的作用是基于设备树中的信息，确定特定<code>encoder</code>端口可能连接的<code>CRTCs</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_of_find_possible_crtcs - find the possible CRTCs for an encoder port</span></span><br><span class="line"><span class="comment"> * @dev: DRM device</span></span><br><span class="line"><span class="comment"> * @port: encoder port to scan for endpoints</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Scan all endpoints attached to a port, locate their attached CRTCs,</span></span><br><span class="line"><span class="comment"> * and generate the DRM mask of CRTCs which may be attached to this</span></span><br><span class="line"><span class="comment"> * encoder.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See Documentation/devicetree/bindings/graph.txt for the bindings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">drm_of_find_possible_crtcs</span><span class="params">(struct drm_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    struct device_node *port)</span> <span class="comment">// hdmi设备节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">remote_port</span>, *<span class="title">ep</span>;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> possible_crtcs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历port结点下的每个endpoint节点，即hdmi_in_vopb、hdmi_in_vopl设备节点</span></span><br><span class="line">        for_each_endpoint_of_node(port, ep) &#123;</span><br><span class="line">                <span class="comment">// 获取hdmi_in_vopb节点remote-endpoint属性指定的设备节点vopb_out_hdmi</span></span><br><span class="line">                remote_port = of_graph_get_remote_port(ep);</span><br><span class="line">                <span class="comment">// 无效节点，进入</span></span><br><span class="line">                <span class="keyword">if</span> (!remote_port) &#123;</span><br><span class="line">                        of_node_put(ep);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下文介绍</span></span><br><span class="line">                possible_crtcs |= drm_of_crtc_port_mask(dev, remote_port);</span><br><span class="line"></span><br><span class="line">                of_node_put(remote_port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> possible_crtcs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>hdmi</code>节点为例，其有两个<code>endpoint</code>子节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hdmi: hdmi@ff940000 &#123;</span><br><span class="line">        ......</span><br><span class="line">        ports &#123;</span><br><span class="line">                hdmi_in: port &#123;                   </span><br><span class="line">                        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">                        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">                        hdmi_in_vopb: endpoint@<span class="number">0</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">0</span>&gt;;        </span><br><span class="line">                                remote-endpoint = &lt;&amp;vopb_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        hdmi_in_vopl: endpoint@<span class="number">1</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">                                remote-endpoint = &lt;&amp;vopl_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一次遍历时，<code>drm_of_crtc_port_mask</code>参数一传入的是<code>drm</code>设备，参数二传入的是<code>vopb_out_hdmi</code>设备节点。</p>
<p><code>drm_of_crtc_port_mask</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DOC: overview</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A set of helper functions to aid DRM drivers in parsing standard DT</span></span><br><span class="line"><span class="comment"> * properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_of_crtc_port_mask - find the mask of a registered CRTC by port OF node</span></span><br><span class="line"><span class="comment"> * @dev: DRM device</span></span><br><span class="line"><span class="comment"> * @port: port OF node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a port OF node, return the possible mask of the corresponding</span></span><br><span class="line"><span class="comment"> * CRTC within a device&#x27;s list of CRTCs.  Returns zero if not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">drm_of_crtc_port_mask</span><span class="params">(struct drm_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct device_node *port)</span> <span class="comment">// vopb_out_hdmi设备节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_crtc</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// list_for_each_entry(tmp, &amp;(dev)-&gt;mode_config.crtc_list, head)，遍历crtc链表，赋值给tmp</span></span><br><span class="line">        <span class="comment">// 因此这里会依次遍历到vopb、vopl对应的crtc，其中vopb对应的crtc-&gt;port被设置为vopb_out设备节点</span></span><br><span class="line">        drm_for_each_crtc(tmp, dev) &#123;   </span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;port == port) <span class="comment">// 两次循环都不匹配</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; index;</span><br><span class="line"></span><br><span class="line">                index++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-rockchip-drm-encoder-set-crtc-endpoint-id"><a href="#4-2-rockchip-drm-encoder-set-crtc-endpoint-id" class="headerlink" title="4.2 rockchip_drm_encoder_set_crtc_endpoint_id"></a>4.2 <code>rockchip_drm_encoder_set_crtc_endpoint_id</code></h4><p><code>rockchip_drm_encoder_set_crtc_endpoint_id</code>定义在<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</code>；函数第二个传入的是<code>hdmi</code>设备节点，第三个参数<code>port</code>传入0，第四个参数<code>reg</code>同样传入0。</p>
<p>这段代码首先获取<code>hdmi</code>设备节点下<code>reg</code>为0的<code>endpoint</code>设备节点，然后获取该节点<code>remote-endpoint</code>属性指定的设备节点的<code>reg</code>属性的值，并将其赋值给<code>rkencoder-&gt;crtc_endpoint_id</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the endpoint id of the remote endpoint of the given encoder. This</span></span><br><span class="line"><span class="comment"> * information is used by the VOP2 driver to identify the encoder.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @rkencoder: The encoder to get the remote endpoint id from</span></span><br><span class="line"><span class="comment"> * @np: The encoder device node</span></span><br><span class="line"><span class="comment"> * @port: The number of the port leading to the VOP2</span></span><br><span class="line"><span class="comment"> * @reg: The endpoint number leading to the VOP2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rockchip_drm_encoder_set_crtc_endpoint_id</span><span class="params">(struct rockchip_encoder *rkencoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              struct device_node *np, <span class="keyword">int</span> port, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">of_endpoint</span> <span class="title">ep</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">en</span>, *<span class="title">ren</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过遍历父设备节点的所有子节点（端点节点）来查找符合指定port=0和reg=0的端点节点，这里返回的是hdmi_in_vopb设备节点</span></span><br><span class="line">        en = of_graph_get_endpoint_by_regs(np, port, reg);</span><br><span class="line">        <span class="keyword">if</span> (!en)</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取en设备节点remote-endpoin属性指定的设备节点，即vopb_out_hdmi设备节点</span></span><br><span class="line">        ren = of_graph_get_remote_endpoint(en);</span><br><span class="line">        <span class="keyword">if</span> (!ren)</span><br><span class="line">                <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析vopb_out_hdmi设备节点的属性，并将解析结果存储到ep</span></span><br><span class="line">        ret = of_graph_parse_endpoint(ren, &amp;ep);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">// 由于vopb_out_hdmi设备节点的reg属性=2，所以此处赋值为2</span></span><br><span class="line">        rkencoder-&gt;crtc_endpoint_id = ep.id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-of-graph-get-endpoint-by-regs"><a href="#4-2-1-of-graph-get-endpoint-by-regs" class="headerlink" title="4.2.1 of_graph_get_endpoint_by_regs"></a>4.2.1 <code>of_graph_get_endpoint_by_regs</code></h5><p><code>of_graph_get_endpoint_by_regs</code>定义在<code>drivers/of/property.c</code>，其作用就是通过遍历父设备节点的所有子节点（端点节点）来查找符合指定 <code>port_reg</code> 和 <code>reg</code> 标识符的端点节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_graph_get_endpoint_by_regs() - get endpoint node of specific identifiers</span></span><br><span class="line"><span class="comment"> * @parent: pointer to the parent device node</span></span><br><span class="line"><span class="comment"> * @port_reg: identifier (value of reg property) of the parent port node</span></span><br><span class="line"><span class="comment"> * @reg: identifier (value of reg property) of the endpoint node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: An &#x27;endpoint&#x27; node pointer which is identified by reg and at the same</span></span><br><span class="line"><span class="comment"> * is the child of a port node identified by port_reg. reg and port_reg are</span></span><br><span class="line"><span class="comment"> * ignored when they are -1. Use of_node_put() on the pointer when done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct device_node *<span class="title">of_graph_get_endpoint_by_regs</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct device_node *parent, <span class="keyword">int</span> port_reg, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">of_endpoint</span> <span class="title">endpoint</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="comment">// 遍历parent结点下的每个endpoint结点</span></span><br><span class="line">        for_each_endpoint_of_node(parent, node) &#123;</span><br><span class="line">                <span class="comment">// 解析端点的信息，并将结果存储在endpoint</span></span><br><span class="line">                of_graph_parse_endpoint(node, &amp;endpoint);</span><br><span class="line">                <span class="comment">// 对比传入的port_reg和reg参数与当前端点节点的属性值，如果匹配则返回该端点节点的指针</span></span><br><span class="line">                <span class="keyword">if</span> (((port_reg == <span class="number">-1</span>) || (endpoint.port == port_reg)) &amp;&amp;</span><br><span class="line">                        ((reg == <span class="number">-1</span>) || (endpoint.id == reg)))</span><br><span class="line">                        <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们的<code>hdmi</code>节点，当调用<code>of_graph_get_endpoint_by_regs(np,0,0)</code>返回的就是<code>hdmi_in_vopb</code>设备节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hdmi: hdmi@ff940000 &#123;</span><br><span class="line">        ......</span><br><span class="line">        ports &#123;</span><br><span class="line">                hdmi_in: port &#123;                     #  属性reg的值赋值给endpoint.port，不存在赋值为<span class="number">0</span></span><br><span class="line">                        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">                        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">                        hdmi_in_vopb: endpoint@<span class="number">0</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">0</span>&gt;;            # 属性reg的值赋值给endpoint.id</span><br><span class="line">                                remote-endpoint = &lt;&amp;vopb_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        hdmi_in_vopl: endpoint@<span class="number">1</span> &#123;</span><br><span class="line">                                reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">                                remote-endpoint = &lt;&amp;vopl_out_hdmi&gt;;</span><br><span class="line">                        &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-of-graph-get-remote-endpoint"><a href="#4-2-2-of-graph-get-remote-endpoint" class="headerlink" title="4.2.2 of_graph_get_remote_endpoint"></a>4.2.2 <code>of_graph_get_remote_endpoint</code></h5><p><code>of_graph_get_remote_endpoint</code>定义在<code>drivers/of/property.c</code>，其作用就是获取与指定本地端点相关联的远程端点节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_graph_get_remote_endpoint() - get remote endpoint node</span></span><br><span class="line"><span class="comment"> * @node: pointer to a local endpoint device_node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: Remote endpoint node associated with remote endpoint node linked</span></span><br><span class="line"><span class="comment"> *         to @node. Use of_node_put() on it when done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct device_node *<span class="title">of_graph_get_remote_endpoint</span><span class="params">(<span class="keyword">const</span> struct device_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* Get remote endpoint node. */</span></span><br><span class="line">        <span class="keyword">return</span> of_parse_phandle(node, <span class="string">&quot;remote-endpoint&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>hdmi_in_vopb</code>设备节点为例，该返回返回<code>remote-endpoin</code>属性指定的设备节点，即<code>vopb_out_hdmi</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdmi_in_vopb: endpoint@<span class="number">0</span> &#123;</span><br><span class="line">    reg = &lt;<span class="number">0</span>&gt;;       </span><br><span class="line">    remote-endpoint = &lt;&amp;vopb_out_hdmi&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-of-graph-parse-endpoint"><a href="#4-2-3-of-graph-parse-endpoint" class="headerlink" title="4.2.3 of_graph_parse_endpoint"></a>4.2.3 <code>of_graph_parse_endpoint</code></h5><p><code>of_graph_parse_endpoint</code>定义在<code>drivers/of/property.c</code>，函数的作用是解析端点节点<code>node</code>的属性，并将解析结果存储到 <code>endpoint</code>中；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_graph_parse_endpoint() - parse common endpoint node properties</span></span><br><span class="line"><span class="comment"> * @node: pointer to endpoint device_node</span></span><br><span class="line"><span class="comment"> * @endpoint: pointer to the OF endpoint data structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller should hold a reference to @node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_graph_parse_endpoint</span><span class="params">(<span class="keyword">const</span> struct device_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct of_endpoint *endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// endpoint的父结点是port结点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">port_node</span> = <span class="title">of_get_parent</span>(<span class="title">node</span>);</span></span><br><span class="line"></span><br><span class="line">        WARN_ONCE(!port_node, <span class="string">&quot;%s(): endpoint %pOF has no parent node\n&quot;</span>,</span><br><span class="line">                  __func__, node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充0</span></span><br><span class="line">        <span class="built_in">memset</span>(endpoint, <span class="number">0</span>, <span class="keyword">sizeof</span>(*endpoint));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置endpoint所属的port节点</span></span><br><span class="line">        endpoint-&gt;local_node = node;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * It doesn&#x27;t matter whether the two calls below succeed.</span></span><br><span class="line"><span class="comment">         * If they don&#x27;t then the default value 0 is used.         </span></span><br><span class="line"><span class="comment">         * port结点下的reg属性值是endpoint-&gt;port值</span></span><br><span class="line"><span class="comment">         * endpoint节点reg属性值是endpoint-&gt;id值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        of_property_read_u32(port_node, <span class="string">&quot;reg&quot;</span>, &amp;endpoint-&gt;port);</span><br><span class="line">        of_property_read_u32(node, <span class="string">&quot;reg&quot;</span>, &amp;endpoint-&gt;id);</span><br><span class="line"></span><br><span class="line">        of_node_put(port_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以<code>vopb_out_hdmi</code>设备节点为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vopb_out_hdmi: endpoint@<span class="number">2</span> &#123;</span><br><span class="line">    reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    remote-endpoint = &lt;&amp;hdmi_in_vopb&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经过<code>of_graph_parse_endpoint</code>函数处理后：</p>
<ul>
<li><code>endpoint-&gt;id = 2</code>；</li>
<li><code>endpoint-&gt;port= 0</code>；</li>
</ul>
<h4 id="4-3-rockchip-hdmi-parse-dt"><a href="#4-3-rockchip-hdmi-parse-dt" class="headerlink" title="4.3 rockchip_hdmi_parse_dt"></a>4.3 <code>rockchip_hdmi_parse_dt</code></h4><p><code>rockchip_hdmi_parse_dt</code>定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>，这段代码主要是在解析<code>hdmi</code>设备节点；比如<code>clocks</code> 、<code>rockchip,grf</code>、<code>avdd-xxx</code>等属性；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rockchip_hdmi_parse_dt</span><span class="params">(struct rockchip_hdmi *hdmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> = <span class="title">hdmi</span>-&gt;<span class="title">dev</span>-&gt;<span class="title">of_node</span>;</span></span><br><span class="line">        <span class="comment">// 根据设备树节点中的rockchip,grf属性获取与GRF相关的寄存器映射  rockchip,grf = &lt;&amp;grf&gt;;</span></span><br><span class="line">        hdmi-&gt;regmap = syscon_regmap_lookup_by_phandle(np, <span class="string">&quot;rockchip,grf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;regmap)) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;Unable to get rockchip,grf\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(hdmi-&gt;regmap);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取ref时钟  &lt;&amp;cru PLL_VPLL&gt;</span></span><br><span class="line">        hdmi-&gt;ref_clk = devm_clk_get_optional(hdmi-&gt;dev, <span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果获取失败，则尝试获取vpll时钟</span></span><br><span class="line">        <span class="keyword">if</span> (!hdmi-&gt;ref_clk)</span><br><span class="line">                hdmi-&gt;ref_clk = devm_clk_get_optional(hdmi-&gt;dev, <span class="string">&quot;vpll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deferred error</span></span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(hdmi-&gt;ref_clk) == -EPROBE_DEFER) &#123;</span><br><span class="line">                <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(hdmi-&gt;ref_clk)) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;failed to get reference clock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(hdmi-&gt;ref_clk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取grf相关的时钟 &lt;&amp;cru PCLK_VIO_GRF&gt;</span></span><br><span class="line">        hdmi-&gt;grf_clk = devm_clk_get(hdmi-&gt;dev, <span class="string">&quot;grf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(hdmi-&gt;grf_clk) == -ENOENT) &#123;</span><br><span class="line">                hdmi-&gt;grf_clk = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PTR_ERR(hdmi-&gt;grf_clk) == -EPROBE_DEFER) &#123;</span><br><span class="line">                <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(hdmi-&gt;grf_clk)) &#123;</span><br><span class="line">                DRM_DEV_ERROR(hdmi-&gt;dev, <span class="string">&quot;failed to get grf clock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(hdmi-&gt;grf_clk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取0.9v稳压器 </span></span><br><span class="line">        hdmi-&gt;avdd_0v9 = devm_regulator_get(hdmi-&gt;dev, <span class="string">&quot;avdd-0v9&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;avdd_0v9))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(hdmi-&gt;avdd_0v9);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取1.8v稳压器 </span></span><br><span class="line">        hdmi-&gt;avdd_1v8 = devm_regulator_get(hdmi-&gt;dev, <span class="string">&quot;avdd-1v8&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;avdd_1v8))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(hdmi-&gt;avdd_1v8);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-devm-regulator-get"><a href="#4-3-1-devm-regulator-get" class="headerlink" title="4.3.1 devm_regulator_get"></a>4.3.1 <code>devm_regulator_get</code></h5><p><code>devm_regulator_get</code>定义在<code>drivers/regulator/devres.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *_<span class="title">devm_regulator_get</span>(<span class="title">struct</span> <span class="title">device</span> *<span class="title">dev</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">id</span>,</span></span><br><span class="line"><span class="class">                                             <span class="title">int</span> <span class="title">get_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> **<span class="title">ptr</span>, *<span class="title">regulator</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为设备分配资源</span></span><br><span class="line">        ptr = devres_alloc(devm_regulator_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!ptr)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找指定名称的regulator，如果找不到对应名字的 regulator，那么就返回 dummy regulator，并且在 kernel log 中输出相关 warning 信息</span></span><br><span class="line">        regulator = _regulator_get(dev, id, get_type);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(regulator)) &#123;</span><br><span class="line">                *ptr = regulator;</span><br><span class="line">                <span class="comment">// 将资源添加到设备的资源链表上。释放资源时，遍历设备资源管理链表，然后调用资源注册的释放函数</span></span><br><span class="line">                devres_add(dev, ptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                devres_free(ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regulator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_regulator_get - Resource managed regulator_get()</span></span><br><span class="line"><span class="comment"> * @dev: device to supply</span></span><br><span class="line"><span class="comment"> * @id:  supply name or regulator ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Managed regulator_get(). Regulators returned from this function are</span></span><br><span class="line"><span class="comment"> * automatically regulator_put() on driver detach. See regulator_get() for more</span></span><br><span class="line"><span class="comment"> * information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct regulator *<span class="title">devm_regulator_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _devm_regulator_get(dev, id, NORMAL_GET);  <span class="comment">// NORMAL_GET值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内部又调用了<code>_regulator_get</code>，定义在<code>drivers/regulator/core.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Internal regulator request function */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *_<span class="title">regulator_get</span>(<span class="title">struct</span> <span class="title">device</span> *<span class="title">dev</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">id</span>, // 以<span class="title">avdd</span>-0<span class="title">v9</span>为例</span></span><br><span class="line"><span class="class">                                 <span class="title">enum</span> <span class="title">regulator_get_type</span> <span class="title">get_type</span>) // 传入0</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator_dev</span> *<span class="title">rdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_link</span> *<span class="title">link</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 &gt;= 3 不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (get_type &gt;= MAX_GET_TYPE) &#123;</span><br><span class="line">                dev_err(dev, <span class="string">&quot;invalid type %d in %s\n&quot;</span>, get_type, __func__);</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;get() with no identifier\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先通过设备树的方式去查找rdev，如果没有找到，在通过regulator_map_list查找rdev，regulator_map_list在regulator_rdev注册的时候初始化的</span></span><br><span class="line">        rdev = regulator_dev_lookup(dev, id);</span><br><span class="line">        <span class="comment">// 找不到 进入</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(rdev)) &#123;</span><br><span class="line">                ret = PTR_ERR(rdev);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If regulator_dev_lookup() fails with error other</span></span><br><span class="line"><span class="comment">                 * than -ENODEV our job here is done, we simply return it.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (ret != -ENODEV)</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!have_full_constraints()) &#123;</span><br><span class="line">                        dev_warn(dev,</span><br><span class="line">                                 <span class="string">&quot;incomplete constraints, dummy supplies not allowed\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (get_type) &#123;                       </span><br><span class="line">                <span class="keyword">case</span> NORMAL_GET:   <span class="comment">// 进入，返回一个dummy regulator</span></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Assume that a regulator is physically present and</span></span><br><span class="line"><span class="comment">                         * enabled, even if it isn&#x27;t hooked up, and just</span></span><br><span class="line"><span class="comment">                         * provide a dummy.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        dev_warn(dev, <span class="string">&quot;supply %s not found, using dummy regulator\n&quot;</span>, id);</span><br><span class="line">                        rdev = dummy_regulator_rdev;</span><br><span class="line">                        get_device(&amp;rdev-&gt;dev);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> EXCLUSIVE_GET:</span><br><span class="line">                        dev_warn(dev,</span><br><span class="line">                                 <span class="string">&quot;dummy supplies not allowed for exclusive requests\n&quot;</span>);</span><br><span class="line">                        fallthrough;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rdev-&gt;exclusive) &#123;</span><br><span class="line">                regulator = ERR_PTR(-EPERM);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get_type == EXCLUSIVE_GET &amp;&amp; rdev-&gt;open_count) &#123;</span><br><span class="line">                regulator = ERR_PTR(-EBUSY);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;regulator_list_mutex);</span><br><span class="line">        ret = (rdev-&gt;coupling_desc.n_resolved != rdev-&gt;coupling_desc.n_coupled);</span><br><span class="line">        mutex_unlock(&amp;regulator_list_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                regulator = ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = regulator_resolve_supply(rdev);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                regulator = ERR_PTR(ret);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!try_module_get(rdev-&gt;owner)) &#123;</span><br><span class="line">                regulator = ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到则调用create_regulator创建regulator</span></span><br><span class="line">        regulator = create_regulator(rdev, dev, id);</span><br><span class="line">        <span class="keyword">if</span> (regulator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                regulator = ERR_PTR(-ENOMEM);</span><br><span class="line">                module_put(rdev-&gt;owner);</span><br><span class="line">                put_device(&amp;rdev-&gt;dev);</span><br><span class="line">                <span class="keyword">return</span> regulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rdev-&gt;open_count++;</span><br><span class="line">        <span class="keyword">if</span> (get_type == EXCLUSIVE_GET) &#123;</span><br><span class="line">                rdev-&gt;exclusive = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                ret = _regulator_is_enabled(rdev);</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        rdev-&gt;use_count = <span class="number">1</span>;</span><br><span class="line">                        regulator-&gt;enable_count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        rdev-&gt;use_count = <span class="number">0</span>;</span><br><span class="line">                        regulator-&gt;enable_count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link = device_link_add(dev, &amp;rdev-&gt;dev, DL_FLAG_STATELESS);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR_OR_NULL(link))</span><br><span class="line">                regulator-&gt;device_link = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regulator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>devm_regulator_get(hdmi-&gt;dev, &quot;avdd-0v9&quot;)</code>为例，该函数会调用<code>regulator_dev_lookup</code>查找<code>regulator</code>；</p>
<ul>
<li>首先通过设备树的方式去查找<code>rdev</code>，即在<code>hdmi</code>设备节点中查找<code>avdd-0v9-supply</code>属性指定的<code>regulator</code>设备节点；</li>
<li>如果没有找到，在通过<code>regulator_map_list</code>查找<code>rdev</code>，<code>regulator_map_list</code>在<code>regulator_rdev</code>注册的时候初始化的；</li>
</ul>
<p>如果找不到将返回<code>dummy regulator</code>，并输入警告信息。</p>
<p>由于我们并没有在<code>hdmi</code>设备节点中定义<code>avdd-0v9-supply</code>属性，同时也没有在设备树定义<code>regulator-name = &quot;avdd-0v9&quot;</code>的<code>regulator_rdev</code>，因此 我们内核在启动时会输入如下警告信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[    1.475048] dwhdmi-rockchip ff940000.hdmi: supply avdd-0v9 not found, using dummy regulator</span><br><span class="line">[    1.484573] dwhdmi-rockchip ff940000.hdmi: supply avdd-1v8 not found, using dummy regulator</span><br></pre></td></tr></table></figure>

<h4 id="4-4-devm-phy-optional-get"><a href="#4-4-devm-phy-optional-get" class="headerlink" title="4.4 devm_phy_optional_get"></a>4.4 <code>devm_phy_optional_get</code></h4><p><code>devm_phy_optional_get</code>定义在<code>drivers/phy/phy-core.c</code>，它用于查找并获取一个可选的<code>PHY</code>（物理层设备）的引用；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_phy_optional_get() - lookup and obtain a reference to an optional phy.</span></span><br><span class="line"><span class="comment"> * @dev: device that requests this phy</span></span><br><span class="line"><span class="comment"> * @string: the phy name as given in the dt data or phy device name</span></span><br><span class="line"><span class="comment"> * for non-dt case</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Gets the phy using phy_get(), and associates a device with it using</span></span><br><span class="line"><span class="comment"> * devres. On driver detach, release function is invoked on the devres</span></span><br><span class="line"><span class="comment"> * data, then, devres data is freed. This differs to devm_phy_get() in</span></span><br><span class="line"><span class="comment"> * that if the phy does not exist, it is not considered an error and</span></span><br><span class="line"><span class="comment"> * -ENODEV will not be returned. Instead the NULL phy is returned,</span></span><br><span class="line"><span class="comment"> * which can be passed to all other phy consumer calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct phy *<span class="title">devm_phy_optional_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 获取PHY</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">phy</span> *<span class="title">phy</span> = <span class="title">devm_phy_get</span>(<span class="title">dev</span>, <span class="title">string</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(phy) == -ENODEV)</span><br><span class="line">                phy = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> phy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-regulator-enable"><a href="#4-5-regulator-enable" class="headerlink" title="4.5 regulator_enable"></a>4.5 <code>regulator_enable</code></h4><p><code>regulator_enable</code>定义在<code>drivers/regulator/core.c</code>，用于使能<code>regulator</code>输出；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * regulator_enable - enable regulator output</span></span><br><span class="line"><span class="comment"> * @regulator: regulator source</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Request that the regulator be enabled with the regulator output at</span></span><br><span class="line"><span class="comment"> * the predefined voltage or current value.  Calls to regulator_enable()</span></span><br><span class="line"><span class="comment"> * must be balanced with calls to regulator_disable().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> the output value can be set by other drivers, boot loader or may be</span></span><br><span class="line"><span class="comment"> * hardwired in the regulator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">regulator_enable</span><span class="params">(struct regulator *regulator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">regulator_dev</span> *<span class="title">rdev</span> = <span class="title">regulator</span>-&gt;<span class="title">rdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ww_acquire_ctx</span> <span class="title">ww_ctx</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        regulator_lock_dependent(rdev, &amp;ww_ctx);</span><br><span class="line">        ret = _regulator_enable(regulator);</span><br><span class="line">        regulator_unlock_dependent(rdev, &amp;ww_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-6-dw-hdmi-bind"><a href="#4-6-dw-hdmi-bind" class="headerlink" title="4.6 dw_hdmi_bind"></a>4.6 <code>dw_hdmi_bind</code></h4><p><code>dw_hdmi_bind</code>定义在<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Bind/unbind API, used from platforms based on the component framework.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct dw_hdmi *<span class="title">dw_hdmi_bind</span><span class="params">(struct platform_device *pdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                             struct drm_encoder *encoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> struct dw_hdmi_plat_data *plat_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dw hdmi探测</span></span><br><span class="line">        hdmi = dw_hdmi_probe(pdev, plat_data);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi))</span><br><span class="line">                <span class="keyword">return</span> hdmi;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ret = drm_bridge_attach(encoder, &amp;hdmi-&gt;bridge, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                dw_hdmi_remove(hdmi);</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hdmi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该函数时，第一个参数传入<code>hdmi</code>设备节点对应的<code>platform device</code>，第二个参数传入<code>drm encoder</code>，第三个参数传入<code>rk3399_hdmi_drv_data</code>；<code>rk3399_hdmi_drv_data</code>定义在<code>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_plat_data</span> <span class="title">rk3399_hdmi_drv_data</span> = &#123;</span></span><br><span class="line">        .mode_valid = dw_hdmi_rockchip_mode_valid,  <span class="comment">// 用于校验显示模式是否有效</span></span><br><span class="line">        .mpll_cfg   = rockchip_mpll_cfg,</span><br><span class="line">        .cur_ctr    = rockchip_cur_ctr,</span><br><span class="line">        .phy_config = rockchip_phy_config,</span><br><span class="line">        .phy_data = &amp;rk3399_chip_data,</span><br><span class="line">        .use_drm_infoframe = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>rockchip_mpll_cfg</code>、<code>rockchip_cur_ctr</code>、<code>rockchip_phy_config</code>中存放的都是<code>HDMI PHY</code>配置参数，会被<code>hdmi_phy_configure_dwc_hdmi_3d_tx</code>函数使用，用于配置<code>DWC HDMI 3D TX PHY</code>的物理层（<code>PHY</code>），该函数位于<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>；</p>
<ul>
<li>首先从提供的<code>plat_data</code>结构中获取<code>mpll_config</code>、<code>curr_ctrl</code>和<code>phy_config</code>的指针。</li>
<li>然后，它通过遍历<code>mpll_config</code>、<code>curr_ctrl</code>和<code>phy_config</code>数组，找到与给定<code>mpixelclock</code>（像素时钟频率）匹配的配置条目。一旦找到匹配的条目，就会使用<code>dw_hdmi_phy_i2c_write</code>函数将对应的配置值写入<code>HDMI PHY</code>寄存器中；</li>
<li>在最后一部分，代码还覆盖并禁用了时钟终端，并将特定的值写入了相应的<code>PHY</code>寄存器；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PHY configuration function for the DWC HDMI 3D TX PHY. Based on the available</span></span><br><span class="line"><span class="comment"> * information the DWC MHL PHY has the same register layout and is thus also</span></span><br><span class="line"><span class="comment"> * supported by this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hdmi_phy_configure_dwc_hdmi_3d_tx</span><span class="params">(struct dw_hdmi *hdmi,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct dw_hdmi_plat_data *pdata,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">long</span> mpixelclock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> *<span class="title">mpll_config</span> = <span class="title">pdata</span>-&gt;<span class="title">mpll_cfg</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_curr_ctrl</span> *<span class="title">curr_ctrl</span> = <span class="title">pdata</span>-&gt;<span class="title">cur_ctr</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_phy_config</span> *<span class="title">phy_config</span> = <span class="title">pdata</span>-&gt;<span class="title">phy_config</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* TOFIX Will need 420 specific PHY configuration tables */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* PLL/MPLL Cfg - always match on final entry */</span></span><br><span class="line">        <span class="keyword">for</span> (; mpll_config-&gt;mpixelclock != ~<span class="number">0U</span>L; mpll_config++)</span><br><span class="line">                <span class="keyword">if</span> (mpixelclock &lt;= mpll_config-&gt;mpixelclock)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; curr_ctrl-&gt;mpixelclock != ~<span class="number">0U</span>L; curr_ctrl++)</span><br><span class="line">                <span class="keyword">if</span> (mpixelclock &lt;= curr_ctrl-&gt;mpixelclock)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; phy_config-&gt;mpixelclock != ~<span class="number">0U</span>L; phy_config++)</span><br><span class="line">                <span class="keyword">if</span> (mpixelclock &lt;= phy_config-&gt;mpixelclock)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mpll_config-&gt;mpixelclock == ~<span class="number">0U</span>L ||</span><br><span class="line">            curr_ctrl-&gt;mpixelclock == ~<span class="number">0U</span>L ||</span><br><span class="line">            phy_config-&gt;mpixelclock == ~<span class="number">0U</span>L)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, mpll_config-&gt;res[<span class="number">0</span>].cpce,</span><br><span class="line">                              HDMI_3D_TX_PHY_CPCE_CTRL);</span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, mpll_config-&gt;res[<span class="number">0</span>].gmp,</span><br><span class="line">                              HDMI_3D_TX_PHY_GMPCTRL);</span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, curr_ctrl-&gt;curr[<span class="number">0</span>],</span><br><span class="line">                              HDMI_3D_TX_PHY_CURRCTRL);</span><br><span class="line"></span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, <span class="number">0</span>, HDMI_3D_TX_PHY_PLLPHBYCTRL);</span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK,</span><br><span class="line">                              HDMI_3D_TX_PHY_MSM_CTRL);</span><br><span class="line"></span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, phy_config-&gt;term, HDMI_3D_TX_PHY_TXTERM);</span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, phy_config-&gt;sym_ctr,</span><br><span class="line">                              HDMI_3D_TX_PHY_CKSYMTXCTRL);</span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, phy_config-&gt;vlev_ctr,</span><br><span class="line">                              HDMI_3D_TX_PHY_VLEVCTRL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Override and disable clock termination. */</span></span><br><span class="line">        dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE,</span><br><span class="line">                              HDMI_3D_TX_PHY_CKCALCTRL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-6-1-dw-hdmi-rockchip-mode-valid"><a href="#4-6-1-dw-hdmi-rockchip-mode-valid" class="headerlink" title="4.6.1 dw_hdmi_rockchip_mode_valid"></a>4.6.1 <code>dw_hdmi_rockchip_mode_valid</code></h5><p><code>dw_hdmi_rockchip_mode_valid</code>函数用于校验显示模式是否有效；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">enum</span> drm_mode_status</span><br><span class="line">dw_hdmi_rockchip_mode_valid(struct dw_hdmi *hdmi, <span class="keyword">void</span> *data,</span><br><span class="line">                            <span class="keyword">const</span> struct drm_display_info *info,</span><br><span class="line">                            <span class="keyword">const</span> struct drm_display_mode *mode)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> *<span class="title">mpll_cfg</span> = <span class="title">rockchip_mpll_cfg</span>;</span></span><br><span class="line">        <span class="keyword">int</span> pclk = mode-&gt;clock * <span class="number">1000</span>;    <span class="comment">// 计算得到像素时钟频率</span></span><br><span class="line">        <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">// 遍历mpll_cfg像素时钟，查找匹配的时钟</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; mpll_cfg[i].mpixelclock != (~<span class="number">0U</span>L); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pclk == mpll_cfg[i].mpixelclock) &#123;</span><br><span class="line">                        valid = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (valid) ? MODE_OK : MODE_BAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-6-2-rockchip-mpll-cfg"><a href="#4-6-2-rockchip-mpll-cfg" class="headerlink" title="4.6.2 rockchip_mpll_cfg"></a>4.6.2 <code>rockchip_mpll_cfg</code></h5><p><code>rockchip_mpll_cfg</code>保存的是<code>RK3399</code>的 <code>HDMI-PHY-PLL</code>配置，用于配置<code>HDMI_3D_TX_PHY_CPCE_CTRL</code>、<code>HDMI_3D_TX_PHY_GMPCTRL</code>寄存器；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> <span class="title">rockchip_mpll_cfg</span>[] = &#123;</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="number">27000000</span>, &#123;</span><br><span class="line">                        &#123; <span class="number">0x00b3</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2153</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x40f3</span>, <span class="number">0x0000</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">36000000</span>, &#123;    <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：800x600@56Hz  640x480@85Hz；适用于edid_est_modes中定义的显示模式：800x600@56Hz                  </span></span><br><span class="line">                        &#123; <span class="number">0x00b3</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2153</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x40f3</span>, <span class="number">0x0000</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">40000000</span>, &#123;    <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：800x600@60Hz；适用于edid_est_modes中定义的显示模式：800x600@60Hz                  </span></span><br><span class="line">                        &#123; <span class="number">0x00b3</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2153</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x40f3</span>, <span class="number">0x0000</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">54000000</span>, &#123;</span><br><span class="line">                        &#123; <span class="number">0x0072</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2142</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x40a2</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">65000000</span>, &#123;    <span class="comment">// 适用于edid_est_modes中定义的显示模式：1024x768@70Hz       </span></span><br><span class="line">                        &#123; <span class="number">0x0072</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2142</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x40a2</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">66000000</span>, &#123;  </span><br><span class="line">                        &#123; <span class="number">0x013e</span>, <span class="number">0x0003</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x217e</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4061</span>, <span class="number">0x0002</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">74250000</span>, &#123;   <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1280x720@60Hz</span></span><br><span class="line">                        &#123; <span class="number">0x0072</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2145</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4061</span>, <span class="number">0x0002</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">83500000</span>, &#123;   <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1280x800@60Hz</span></span><br><span class="line">                        &#123; <span class="number">0x0072</span>, <span class="number">0x0001</span>&#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">108000000</span>, &#123;   <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1600x900@60Hz 1280x1024@60Hz 1152x864@75Hz 1280x960@60Hz；适用于edid_est_modes中定义的显示模式：1152x864@75Hz                 </span></span><br><span class="line">                        &#123; <span class="number">0x0051</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2145</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4061</span>, <span class="number">0x0002</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">106500000</span>, &#123;   <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1440x900@60Hz、1280x800@75Hz</span></span><br><span class="line">                        &#123; <span class="number">0x0051</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2145</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4061</span>, <span class="number">0x0002</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">146250000</span>, &#123;     <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1680x1050@60Hz  1280x800@120Hz RB</span></span><br><span class="line">                        &#123; <span class="number">0x0051</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x2145</span>, <span class="number">0x0002</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4061</span>, <span class="number">0x0002</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">148500000</span>, &#123;       <span class="comment">// 适用于drm_dmt_modes中定义的预定义的标准显示模式：1920x1080@60Hz  1280x960@85Hz </span></span><br><span class="line">                        &#123; <span class="number">0x0051</span>, <span class="number">0x0003</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x214c</span>, <span class="number">0x0003</span>&#125;,</span><br><span class="line">                        &#123; <span class="number">0x4064</span>, <span class="number">0x0003</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                ~<span class="number">0U</span>L, &#123;</span><br><span class="line">                        &#123; <span class="number">0x00a0</span>, <span class="number">0x000a</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0x2001</span>, <span class="number">0x000f</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0x4002</span>, <span class="number">0x000f</span> &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体<code>dw_hdmi_mpll_config</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_mpll_config</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mpixelclock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u16 cpce;</span><br><span class="line">        u16 gmp;</span><br><span class="line">    &#125; res[DW_HDMI_RES_MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各项参数说明如下：</p>
<ul>
<li><code>mpixelclock</code> ：像素时钟频率；</li>
<li><code>cpce</code>：<code>OPMODE_PLLCFG</code>寄存器值；</li>
<li><code>gmp</code>：<code>PLLGMPCTRL</code>寄存器值；</li>
</ul>
<p>以<code>rockchip_mpll_cfg</code>中的第一项配置为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">27000000</span>, &#123;</span><br><span class="line">        &#123; <span class="number">0x00b3</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">        &#123; <span class="number">0x2153</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">        &#123; <span class="number">0x40f3</span>, <span class="number">0x0000</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>27000000</code>表示像素时钟为<code>27000000</code>及以下的分辨率适用该项配置， <code>&#123;0x00b3, 0x0000 &#125;</code> 、 <code>&#123; 0x2153, 0x0000 &#125;</code> 、 <code>&#123; 0x40f3, 0x0000 &#125;</code> 三项依次对应色深为 <code>8 BIT</code>、<code>10BIT</code>、<code>12 BIT</code>（目前<code>Rockchip</code>方案实际只支持<code>8/10 bit</code>两种模式） 情况下使用的配置。<br>由于参数的取值需要查阅<code>PHY</code>的<code>datasheet</code>获取，若需要新增<code>HDMI-PHY-PLL</code>配置，可以向<code>FAE</code>提出所需的像素时钟。然后根据上述的规则，将新增的配置添加到<code>rockchip_mpll_cfg</code>中。</p>
<h5 id="4-6-3-rockchip-cur-ctr"><a href="#4-6-3-rockchip-cur-ctr" class="headerlink" title="4.6.3 rockchip_cur_ctr"></a>4.6.3 <code>rockchip_cur_ctr</code></h5><p>具体作用不晓得，用于配置<code>HDMI_3D_TX_PHY_CURRCTRL</code>寄存器；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_curr_ctrl</span> <span class="title">rockchip_cur_ctr</span>[] = &#123;</span></span><br><span class="line">        <span class="comment">/*      pixelclk    bpp8    bpp10   bpp12 */</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="number">40000000</span>,  &#123; <span class="number">0x0018</span>, <span class="number">0x0018</span>, <span class="number">0x0018</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">65000000</span>,  &#123; <span class="number">0x0028</span>, <span class="number">0x0028</span>, <span class="number">0x0028</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">66000000</span>,  &#123; <span class="number">0x0038</span>, <span class="number">0x0038</span>, <span class="number">0x0038</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">74250000</span>,  &#123; <span class="number">0x0028</span>, <span class="number">0x0038</span>, <span class="number">0x0038</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">83500000</span>,  &#123; <span class="number">0x0028</span>, <span class="number">0x0038</span>, <span class="number">0x0038</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">146250000</span>, &#123; <span class="number">0x0038</span>, <span class="number">0x0038</span>, <span class="number">0x0038</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                <span class="number">148500000</span>, &#123; <span class="number">0x0000</span>, <span class="number">0x0038</span>, <span class="number">0x0038</span> &#125;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                ~<span class="number">0U</span>L,      &#123; <span class="number">0x0000</span>, <span class="number">0x0000</span>, <span class="number">0x0000</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数和<code>rockchip_mpll_cfg</code>类似，比如<code>40000000</code>表示像素时钟为<code>40000000</code>及以下的分辨率适用该项配置。</p>
<h5 id="4-6-4-rockchip-phy-config"><a href="#4-6-4-rockchip-phy-config" class="headerlink" title="4.6.4 rockchip_phy_config"></a>4.6.4 <code>rockchip_phy_config</code></h5><p>具体作用不晓得，用于配置<code>HDMI_3D_TX_PHY_TXTERM</code>、<code>HDMI_3D_TX_PHY_CKSYMTXCTRL</code>、<code>HDMI_3D_TX_PHY_VLEVCTRL</code>寄存器；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_phy_config</span> <span class="title">rockchip_phy_config</span>[] = &#123;</span></span><br><span class="line">        <span class="comment">/*pixelclk   symbol   term   vlev*/</span></span><br><span class="line">        &#123; <span class="number">74250000</span>,  <span class="number">0x8009</span>, <span class="number">0x0004</span>, <span class="number">0x0272</span>&#125;,</span><br><span class="line">        &#123; <span class="number">148500000</span>, <span class="number">0x802b</span>, <span class="number">0x0004</span>, <span class="number">0x028d</span>&#125;,</span><br><span class="line">        &#123; <span class="number">297000000</span>, <span class="number">0x8039</span>, <span class="number">0x0005</span>, <span class="number">0x028d</span>&#125;,</span><br><span class="line">        &#123; ~<span class="number">0U</span>L,      <span class="number">0x0000</span>, <span class="number">0x0000</span>, <span class="number">0x0000</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个参数和<code>rockchip_mpll_cfg</code>类似，比如<code>74250000</code>表示像素时钟为<code>74250000</code>及以下的分辨率适用该项配置。</p>
<h5 id="4-6-5-rk3399-chip-data"><a href="#4-6-5-rk3399-chip-data" class="headerlink" title="4.6.5 rk3399_chip_data"></a>4.6.5 <code>rk3399_chip_data</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RK3399_GRF_SOC_CON20            0x6250</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RK3399_HDMI_LCDC_SEL            BIT(6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIWORD_UPDATE(val, mask)        (val | (mask) &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_hdmi_chip_data</span> <span class="title">rk3399_chip_data</span> = &#123;</span></span><br><span class="line">        .lcdsel_grf_reg = RK3399_GRF_SOC_CON20,</span><br><span class="line">        .lcdsel_big = HIWORD_UPDATE(<span class="number">0</span>, RK3399_HDMI_LCDC_SEL),</span><br><span class="line">        .lcdsel_lit = HIWORD_UPDATE(RK3399_HDMI_LCDC_SEL, RK3399_HDMI_LCDC_SEL),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、dw-hdmi-probe"><a href="#五、dw-hdmi-probe" class="headerlink" title="五、dw_hdmi_probe"></a>五、<code>dw_hdmi_probe</code></h3><p><code>dw_hdmi_probe</code>函数可以看做是<code>DesignWare hdmi</code>驱动的入口函数，从这里开始就告别了<code>Rockchip hdmi</code>驱动相关的内容，正式进入<code>DesignWare hdmi</code>的源码分析中；<code>dw_hdmi_probe</code>函数定义在<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dw_hdmi *<span class="title">dw_hdmi_probe</span><span class="params">(struct platform_device *pdev,  <span class="comment">// 传入hdmi设备节点所属的platform device</span></span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> struct dw_hdmi_plat_data *plat_data)</span> <span class="comment">// 传入rk3399_hdmi_drv_data</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">pdev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> = <span class="title">dev</span>-&gt;<span class="title">of_node</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_info</span> <span class="title">pdevinfo</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">ddc_node</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_cec_data</span> <span class="title">cec</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">iores</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">int</span> irq;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        u32 val = <span class="number">1</span>;</span><br><span class="line">        u8 prod_id0;</span><br><span class="line">        u8 prod_id1;</span><br><span class="line">        u8 config0;</span><br><span class="line">        u8 config3;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 动态分配内存，指向struct dw_hdmi，并进行成员的初始化</span></span><br><span class="line">        hdmi = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*hdmi), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!hdmi)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        hdmi-&gt;plat_data = plat_data;</span><br><span class="line">        hdmi-&gt;dev = dev;</span><br><span class="line">        hdmi-&gt;sample_rate = <span class="number">48000</span>;</span><br><span class="line">        hdmi-&gt;channels = <span class="number">2</span>;</span><br><span class="line">        hdmi-&gt;disabled = <span class="literal">true</span>;</span><br><span class="line">        hdmi-&gt;rxsense = <span class="literal">true</span>;</span><br><span class="line">        hdmi-&gt;phy_mask = (u8)~(HDMI_PHY_HPD | HDMI_PHY_RX_SENSE);</span><br><span class="line">        hdmi-&gt;mc_clkdis = <span class="number">0x7f</span>;</span><br><span class="line">        hdmi-&gt;last_connector_result = connector_status_disconnected;</span><br><span class="line"></span><br><span class="line">        mutex_init(&amp;hdmi-&gt;mutex);</span><br><span class="line">        mutex_init(&amp;hdmi-&gt;audio_mutex);</span><br><span class="line">        mutex_init(&amp;hdmi-&gt;cec_notifier_mutex);</span><br><span class="line">        spin_lock_init(&amp;hdmi-&gt;audio_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析hdmi设备节点，初始化hdmi成员</span></span><br><span class="line">        ret = dw_hdmi_parse_dt(hdmi);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取ddc-i2c-bus设备节点  ddc-i2c-bus = &lt;&amp;i2c7&gt;</span></span><br><span class="line">        ddc_node = of_parse_phandle(np, <span class="string">&quot;ddc-i2c-bus&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ddc_node) &#123;</span><br><span class="line">                <span class="comment">// 获取i2c总线适配器</span></span><br><span class="line">                hdmi-&gt;ddc = of_get_i2c_adapter_by_node(ddc_node);</span><br><span class="line">                of_node_put(ddc_node);</span><br><span class="line">                <span class="keyword">if</span> (!hdmi-&gt;ddc) &#123;</span><br><span class="line">                        dev_dbg(hdmi-&gt;dev, <span class="string">&quot;failed to read ddc node\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(-EPROBE_DEFER);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dev_dbg(hdmi-&gt;dev, <span class="string">&quot;no ddc property found\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 4. 为HDMI相关寄存器注册regmap，采用regmap模型访问HDMI相关寄存器</span></span><br><span class="line">        <span class="keyword">if</span> (!plat_data-&gt;regm) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_config</span> *<span class="title">reg_config</span>;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取hdmi设备节点reg-io-width属性，描述hdmi相关寄存器位宽  reg-io-width = &lt;4&gt;</span></span><br><span class="line">                of_property_read_u32(np, <span class="string">&quot;reg-io-width&quot;</span>, &amp;val);</span><br><span class="line">                <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                        <span class="comment">// regmap 配置信息</span></span><br><span class="line">                        reg_config = &amp;hdmi_regmap_32bit_config;</span><br><span class="line">                        hdmi-&gt;reg_shift = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        reg_config = &amp;hdmi_regmap_8bit_config;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        dev_err(dev, <span class="string">&quot;reg-io-width must be 1 or 4\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取第一个内存资源，即reg = &lt;0x0 0xff940000 0x0 0x20000&gt; HDMI相关寄存器基地址</span></span><br><span class="line">                iores = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">                hdmi-&gt;regs = devm_ioremap_resource(dev, iores);</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(hdmi-&gt;regs)) &#123;</span><br><span class="line">                        ret = PTR_ERR(hdmi-&gt;regs);</span><br><span class="line">                        <span class="keyword">goto</span> err_res;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为内存映射I/O注册regmap </span></span><br><span class="line">                hdmi-&gt;regm = devm_regmap_init_mmio(dev, hdmi-&gt;regs, reg_config);</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(hdmi-&gt;regm)) &#123;</span><br><span class="line">                        dev_err(dev, <span class="string">&quot;Failed to configure regmap\n&quot;</span>);</span><br><span class="line">                        ret = PTR_ERR(hdmi-&gt;regm);</span><br><span class="line">                        <span class="keyword">goto</span> err_res;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hdmi-&gt;regm = plat_data-&gt;regm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据时钟名称isfr获取时钟，设备节点属性clock-names、clocks，指定了名字为isfr对应的时钟为&lt;&amp;cru SCLK_HDMI_SFR&gt;</span></span><br><span class="line">        hdmi-&gt;isfr_clk = devm_clk_get(hdmi-&gt;dev, <span class="string">&quot;isfr&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;isfr_clk)) &#123;</span><br><span class="line">                ret = PTR_ERR(hdmi-&gt;isfr_clk);</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Unable to get HDMI isfr clk: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 准备和使能时钟</span></span><br><span class="line">        ret = clk_prepare_enable(hdmi-&gt;isfr_clk);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Cannot enable HDMI isfr clock: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 根据时钟名称iahb获取时钟，设备节点属性clock-names、clocks，指定了名字为iahb对应的时钟为&lt;&amp;cru PCLK_HDMI_CTRL&gt;</span></span><br><span class="line">        hdmi-&gt;iahb_clk = devm_clk_get(hdmi-&gt;dev, <span class="string">&quot;iahb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;iahb_clk)) &#123;</span><br><span class="line">                ret = PTR_ERR(hdmi-&gt;iahb_clk);</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Unable to get HDMI iahb clk: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_isfr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备和使能时钟</span></span><br><span class="line">        ret = clk_prepare_enable(hdmi-&gt;iahb_clk);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Cannot enable HDMI iahb clock: %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">goto</span> err_isfr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据时钟名称cec获取时钟，设备节点属性clock-names、clocks，指定了名字为cec对应的时钟为&lt;&amp;cru SCLK_HDMI_CEC&gt;</span></span><br><span class="line">        hdmi-&gt;cec_clk = devm_clk_get(hdmi-&gt;dev, <span class="string">&quot;cec&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(hdmi-&gt;cec_clk) == -ENOENT) &#123;</span><br><span class="line">                hdmi-&gt;cec_clk = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(hdmi-&gt;cec_clk)) &#123;</span><br><span class="line">                ret = PTR_ERR(hdmi-&gt;cec_clk);</span><br><span class="line">                <span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">                        dev_err(hdmi-&gt;dev, <span class="string">&quot;Cannot get HDMI cec clock: %d\n&quot;</span>,</span><br><span class="line">                                ret);</span><br><span class="line"></span><br><span class="line">                hdmi-&gt;cec_clk = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">goto</span> err_iahb;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 准备和使能时钟</span></span><br><span class="line">                ret = clk_prepare_enable(hdmi-&gt;cec_clk);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        dev_err(hdmi-&gt;dev, <span class="string">&quot;Cannot enable HDMI cec clock: %d\n&quot;</span>,</span><br><span class="line">                                ret);</span><br><span class="line">                        <span class="keyword">goto</span> err_iahb;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Product and revision IDs, 获取产品和版本标识信息 */</span></span><br><span class="line">        hdmi-&gt;version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                      | (hdmi_readb(hdmi, HDMI_REVISION_ID) &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        prod_id0 = hdmi_readb(hdmi, HDMI_PRODUCT_ID0);</span><br><span class="line">        prod_id1 = hdmi_readb(hdmi, HDMI_PRODUCT_ID1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发现不支持的HDMI控制器类型，则会打印错误信息并返回-ENODEV错误</span></span><br><span class="line">        <span class="keyword">if</span> (prod_id0 != HDMI_PRODUCT_ID0_HDMI_TX ||</span><br><span class="line">            (prod_id1 &amp; ~HDMI_PRODUCT_ID1_HDCP) != HDMI_PRODUCT_ID1_HDMI_TX) &#123;</span><br><span class="line">                dev_err(dev, <span class="string">&quot;Unsupported HDMI controller (%04x:%02x:%02x)\n&quot;</span>,</span><br><span class="line">                        hdmi-&gt;version, prod_id0, prod_id1);</span><br><span class="line">                ret = -ENODEV;</span><br><span class="line">                <span class="keyword">goto</span> err_iahb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 检测HDMI的物理层接口</span></span><br><span class="line">        ret = dw_hdmi_detect_phy(hdmi);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> err_iahb;</span><br><span class="line"></span><br><span class="line">        dev_info(dev, <span class="string">&quot;Detected HDMI TX controller v%x.%03x %s HDCP (%s)\n&quot;</span>,</span><br><span class="line">                 hdmi-&gt;version &gt;&gt; <span class="number">12</span>, hdmi-&gt;version &amp; <span class="number">0xfff</span>,</span><br><span class="line">                 prod_id1 &amp; HDMI_PRODUCT_ID1_HDCP ? <span class="string">&quot;with&quot;</span> : <span class="string">&quot;without&quot;</span>,</span><br><span class="line">                 hdmi-&gt;phy.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. HDMI硬件初始化</span></span><br><span class="line">        dw_hdmi_init_hw(hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 获取第1个IRQ编号 interrupts = &lt;GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH 0&gt;</span></span><br><span class="line">        irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = irq;</span><br><span class="line">                <span class="keyword">goto</span> err_iahb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 申请中断，中断处理函数设置为dw_hdmi_hardirq，中断线程化的处理函数设置为dw_hdmi_irq</span></span><br><span class="line">        ret = devm_request_threaded_irq(dev, irq, dw_hdmi_hardirq,</span><br><span class="line">                                        dw_hdmi_irq, IRQF_SHARED,</span><br><span class="line">                                        dev_name(dev), hdmi);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_iahb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * To prevent overflows in HDMI_IH_FC_STAT2, set the clk regenerator</span></span><br><span class="line"><span class="comment">         * N and cts values before enabling phy</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        hdmi_init_clk_regenerator(hdmi);</span><br><span class="line">        <span class="comment">/* If DDC bus is not specified, try to register HDMI I2C bus，不会进入 */</span></span><br><span class="line">        <span class="keyword">if</span> (!hdmi-&gt;ddc) &#123;</span><br><span class="line">                <span class="comment">/* Look for (optional) stuff related to unwedging */</span></span><br><span class="line">                hdmi-&gt;pinctrl = devm_pinctrl_get(dev);</span><br><span class="line">                <span class="keyword">if</span> (!IS_ERR(hdmi-&gt;pinctrl)) &#123;</span><br><span class="line">                        hdmi-&gt;unwedge_state =</span><br><span class="line">                                pinctrl_lookup_state(hdmi-&gt;pinctrl, <span class="string">&quot;unwedge&quot;</span>);</span><br><span class="line">                        hdmi-&gt;default_state =</span><br><span class="line">                                pinctrl_lookup_state(hdmi-&gt;pinctrl, <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(hdmi-&gt;default_state) ||</span><br><span class="line">                            IS_ERR(hdmi-&gt;unwedge_state)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!IS_ERR(hdmi-&gt;unwedge_state))</span><br><span class="line">                                        dev_warn(dev,</span><br><span class="line">                                                 <span class="string">&quot;Unwedge requires default pinctrl\n&quot;</span>);</span><br><span class="line">                                hdmi-&gt;default_state = <span class="literal">NULL</span>;</span><br><span class="line">                                hdmi-&gt;unwedge_state = <span class="literal">NULL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                hdmi-&gt;ddc = dw_hdmi_i2c_adapter(hdmi);</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(hdmi-&gt;ddc))</span><br><span class="line">                        hdmi-&gt;ddc = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化桥接设备</span></span><br><span class="line">        hdmi-&gt;bridge.driver_private = hdmi;</span><br><span class="line">        hdmi-&gt;bridge.funcs = &amp;dw_hdmi_bridge_funcs;</span><br><span class="line">        hdmi-&gt;bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID</span><br><span class="line">                         | DRM_BRIDGE_OP_HPD;</span><br><span class="line">        hdmi-&gt;bridge.interlace_allowed = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">        hdmi-&gt;bridge.of_node = pdev-&gt;dev.of_node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;pdevinfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(pdevinfo));</span><br><span class="line">        pdevinfo.parent = dev;</span><br><span class="line">        pdevinfo.id = PLATFORM_DEVID_AUTO;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这看起来应该是获取HDMI的配置信息，具体是啥咱也不知道</span></span><br><span class="line">        config0 = hdmi_readb(hdmi, HDMI_CONFIG0_ID);</span><br><span class="line">        config3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  AHB DMA音频？</span></span><br><span class="line">        <span class="keyword">if</span> (iores &amp;&amp; config3 &amp; HDMI_CONFIG3_AHBAUDDMA) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi_audio_data</span> <span class="title">audio</span>;</span></span><br><span class="line"></span><br><span class="line">                audio.phys = iores-&gt;start;</span><br><span class="line">                audio.base = hdmi-&gt;regs;</span><br><span class="line">                audio.irq = irq;</span><br><span class="line">                audio.hdmi = hdmi;</span><br><span class="line">                audio.get_eld = hdmi_audio_get_eld;</span><br><span class="line">                hdmi-&gt;enable_audio = dw_hdmi_ahb_audio_enable;</span><br><span class="line">                hdmi-&gt;disable_audio = dw_hdmi_ahb_audio_disable;</span><br><span class="line"></span><br><span class="line">                pdevinfo.name = <span class="string">&quot;dw-hdmi-ahb-audio&quot;</span>;</span><br><span class="line">                pdevinfo.data = &amp;audio;</span><br><span class="line">                pdevinfo.size_data = <span class="keyword">sizeof</span>(audio);</span><br><span class="line">                pdevinfo.dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">                hdmi-&gt;audio = platform_device_register_full(&amp;pdevinfo);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config0 &amp; HDMI_CONFIG0_I2S) &#123;  <span class="comment">//  I2S音频？</span></span><br><span class="line">                struct dw_hdmi_i2s_audio_data audio;</span><br><span class="line"></span><br><span class="line">                audio.hdmi      = hdmi;</span><br><span class="line">                audio.get_eld   = hdmi_audio_get_eld;</span><br><span class="line">                audio.write     = hdmi_writeb;</span><br><span class="line">                audio.read      = hdmi_readb;</span><br><span class="line">                hdmi-&gt;enable_audio = dw_hdmi_i2s_audio_enable;</span><br><span class="line">                hdmi-&gt;disable_audio = dw_hdmi_i2s_audio_disable;</span><br><span class="line"></span><br><span class="line">                pdevinfo.name = <span class="string">&quot;dw-hdmi-i2s-audio&quot;</span>;</span><br><span class="line">                pdevinfo.data = &amp;audio;</span><br><span class="line">                pdevinfo.size_data = <span class="keyword">sizeof</span>(audio);</span><br><span class="line">                pdevinfo.dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">                hdmi-&gt;audio = platform_device_register_full(&amp;pdevinfo);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iores &amp;&amp; config3 &amp; HDMI_CONFIG3_GPAUD) &#123; <span class="comment">// GP Audiou音频</span></span><br><span class="line">                struct dw_hdmi_audio_data audio;</span><br><span class="line"></span><br><span class="line">                audio.phys = iores-&gt;start;</span><br><span class="line">                audio.base = hdmi-&gt;regs;</span><br><span class="line">                audio.irq = irq;</span><br><span class="line">                audio.hdmi = hdmi;</span><br><span class="line">                audio.get_eld = hdmi_audio_get_eld;</span><br><span class="line"></span><br><span class="line">                hdmi-&gt;enable_audio = dw_hdmi_gp_audio_enable;</span><br><span class="line">                hdmi-&gt;disable_audio = dw_hdmi_gp_audio_disable;</span><br><span class="line"></span><br><span class="line">                pdevinfo.name = <span class="string">&quot;dw-hdmi-gp-audio&quot;</span>;</span><br><span class="line">                pdevinfo.id = PLATFORM_DEVID_NONE;</span><br><span class="line">                pdevinfo.data = &amp;audio;</span><br><span class="line">                pdevinfo.size_data = <span class="keyword">sizeof</span>(audio);</span><br><span class="line">                pdevinfo.dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</span><br><span class="line">                hdmi-&gt;audio = platform_device_register_full(&amp;pdevinfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有禁用CEC，并且HDMI控制器支持CEC</span></span><br><span class="line">        <span class="keyword">if</span> (!plat_data-&gt;disable_cec &amp;&amp; (config0 &amp; HDMI_CONFIG0_CEC)) &#123;</span><br><span class="line">                cec.hdmi = hdmi;</span><br><span class="line">                cec.ops = &amp;dw_hdmi_cec_ops;</span><br><span class="line">                cec.irq = irq;</span><br><span class="line"></span><br><span class="line">                pdevinfo.name = <span class="string">&quot;dw-hdmi-cec&quot;</span>;</span><br><span class="line">                pdevinfo.data = &amp;cec;</span><br><span class="line">                pdevinfo.size_data = <span class="keyword">sizeof</span>(cec);</span><br><span class="line">                pdevinfo.dma_mask = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                hdmi-&gt;cec = platform_device_register_full(&amp;pdevinfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前桥接设备到全局链表`bridge_list中</span></span><br><span class="line">        drm_bridge_add(&amp;hdmi-&gt;bridge);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hdmi;</span><br><span class="line"></span><br><span class="line">err_iahb:</span><br><span class="line">        clk_disable_unprepare(hdmi-&gt;iahb_clk);</span><br><span class="line">        clk_disable_unprepare(hdmi-&gt;cec_clk);</span><br><span class="line">err_isfr:</span><br><span class="line">        clk_disable_unprepare(hdmi-&gt;isfr_clk);</span><br><span class="line">err_res:</span><br><span class="line">        i2c_put_adapter(hdmi-&gt;ddc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的长度一眼望过去令人窒息。我们也不用去一一解读这段代码干了什么，我们只关注我们想了解的东西，比如与<code>edid</code>相关的内容，以及<code>connector</code>初始化相关的内容；</p>
<ul>
<li>动态分配<code>struct dw_hdmi</code>对象，并进行<code>hdmi</code>成员的初始化；</li>
<li>调用<code>dw_hdmi_parse_dt</code>解析<code>hdmi</code>设备节点，初始化<code>hdmi</code>成员；实际上由于没有指定<code>hdmi-&gt;plat_data-&gt;output_port</code>所以这个函数会直接返回；</li>
<li>如果指定了<code>ddc-i2c-bus</code>属性，则 获取<code>i2c</code>总线适配器；</li>
<li>为<code>HDMI</code>相关寄存器注册<code>regmap</code>，采用<code>regmap</code>模型访问<code>hdmi</code>相关寄存器；</li>
<li>获取并使能时钟<code>isfr_clk</code> 、<code>iahb_clk</code> 、<code>cec_clk</code> ；</li>
<li>调用<code>dw_hdmi_detect_phy</code>检测<code>hdmi</code>的物理层接口；</li>
<li>调用<code>dw_hdmi_init_hw</code>进行<code>HDMI</code>硬件初始化；</li>
<li>注册中断<code>interrupts = &lt;GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH 0&gt;</code>，中断处理函数设置为<code>dw_hdmi_hardirq</code>，中断线程化的处理函数设置为<code>dw_hdmi_irq</code>；</li>
<li>初始化桥接设备，设置回调<code>funcs</code>为<code>dw_hdmi_bridge_funcs</code>；</li>
<li>调用<code>drm_bridge_add</code>添加<code>hdmi</code>桥接设备；</li>
</ul>
<h4 id="5-1-dw-hdmi-parse-dt"><a href="#5-1-dw-hdmi-parse-dt" class="headerlink" title="5.1 dw_hdmi_parse_dt"></a>5.1 <code>dw_hdmi_parse_dt</code></h4><p><code>dw_hdmi_parse_dt</code>函数用于解析<code>hdmi</code>设备节点，初始化<code>hdmi</code>成员；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_parse_dt</span><span class="params">(struct dw_hdmi *hdmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">remote</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!hdmi-&gt;plat_data-&gt;output_port)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过遍历父设备节点的所有子节点（端点节点）来查找符合指定port_reg=0的端点节点，这里返回的是hdmi_in_vopb设备节点</span></span><br><span class="line">        endpoint = of_graph_get_endpoint_by_regs(hdmi-&gt;dev-&gt;of_node,</span><br><span class="line">                                                 hdmi-&gt;plat_data-&gt;output_port,</span><br><span class="line">                                                 <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!endpoint) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * On platforms whose bindings don&#x27;t make the output port</span></span><br><span class="line"><span class="comment">                 * mandatory (such as Rockchip) the plat_data-&gt;output_port</span></span><br><span class="line"><span class="comment">                 * field isn&#x27;t set, so it&#x27;s safe to make this a fatal error.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Missing endpoint in port@%u\n&quot;</span>,</span><br><span class="line">                        hdmi-&gt;plat_data-&gt;output_port);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先获取endpoint设备节点remote-endpoin属性指定的设备节点，即vopb_out_hdmi设备节点，并向上查找父设备节点，直至找到vopb设备节点</span></span><br><span class="line">        remote = of_graph_get_remote_port_parent(endpoint);</span><br><span class="line">        of_node_put(endpoint);</span><br><span class="line">        <span class="keyword">if</span> (!remote) &#123;</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;Endpoint in port@%u unconnected\n&quot;</span>,</span><br><span class="line">                        hdmi-&gt;plat_data-&gt;output_port);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断这个设备节点是否处于启用状态 即status = &quot;ok&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!of_device_is_available(remote)) &#123;</span><br><span class="line">                dev_err(hdmi-&gt;dev, <span class="string">&quot;port@%u remote device is disabled\n&quot;</span>,</span><br><span class="line">                        hdmi-&gt;plat_data-&gt;output_port);</span><br><span class="line">                of_node_put(remote);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  find the bridge corresponding to the device node in the global bridge list bridge_list</span></span><br><span class="line">        hdmi-&gt;next_bridge = of_drm_find_bridge(remote);</span><br><span class="line">        of_node_put(remote);</span><br><span class="line">        <span class="keyword">if</span> (!hdmi-&gt;next_bridge)</span><br><span class="line">                <span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>of_drm_find_bridge</code>定义在<code>drivers/gpu/drm/drm_bridge.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_drm_find_bridge - find the bridge corresponding to the device node in</span></span><br><span class="line"><span class="comment"> *                      the global bridge list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @np: device node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * drm_bridge control struct on success, NULL on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct drm_bridge *<span class="title">of_drm_find_bridge</span><span class="params">(struct device_node *np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge</span> *<span class="title">bridge</span>;</span></span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;bridge_lock);</span><br><span class="line"></span><br><span class="line">        list_for_each_entry(bridge, &amp;bridge_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bridge-&gt;of_node == np) &#123;</span><br><span class="line">                        mutex_unlock(&amp;bridge_lock);</span><br><span class="line">                        <span class="keyword">return</span> bridge;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;bridge_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-dw-hdmi-init-hw"><a href="#5-2-dw-hdmi-init-hw" class="headerlink" title="5.2 dw_hdmi_init_hw"></a>5.2 <code>dw_hdmi_init_hw</code></h4><p><code>dw_hdmi_init_hw</code>函数用于初始化<code>I2C</code>控制器；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dw_hdmi_init_hw</span><span class="params">(struct dw_hdmi *hdmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        initialize_hdmi_ih_mutes(hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reset HDMI DDC I2C master controller and mute I2CM interrupts.</span></span><br><span class="line"><span class="comment">         * Even if we are using a separate i2c adapter doing this doesn&#x27;t</span></span><br><span class="line"><span class="comment">         * hurt.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dw_hdmi_i2c_init(hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了，则执行</span></span><br><span class="line">        <span class="keyword">if</span> (hdmi-&gt;phy.ops-&gt;setup_hpd)</span><br><span class="line">                hdmi-&gt;phy.ops-&gt;setup_hpd(hdmi, hdmi-&gt;phy.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-dw-hdmi-hardirq"><a href="#5-3-dw-hdmi-hardirq" class="headerlink" title="5.3 dw_hdmi_hardirq"></a>5.3 <code>dw_hdmi_hardirq</code></h4><p><code>dw_hdmi_hardirq</code>为中断处理函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">dw_hdmi_hardirq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span> = <span class="title">dev_id</span>;</span></span><br><span class="line">        u8 intr_stat;</span><br><span class="line">        <span class="keyword">irqreturn_t</span> ret = IRQ_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (hdmi-&gt;i2c)</span><br><span class="line">                ret = dw_hdmi_i2c_irq(hdmi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取寄存器HDMI_IH_PHY_STAT0的值</span></span><br><span class="line">        intr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);</span><br><span class="line">        <span class="keyword">if</span> (intr_stat) &#123;</span><br><span class="line">                <span class="comment">// 向寄存器HDMI_IH_MUTE_PHY_STAT0写入值</span></span><br><span class="line">                hdmi_writeb(hdmi, ~<span class="number">0</span>, HDMI_IH_MUTE_PHY_STAT0);</span><br><span class="line">                <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-1-hdmi-readb"><a href="#5-3-1-hdmi-readb" class="headerlink" title="5.3.1 hdmi_readb"></a>5.3.1 <code>hdmi_readb</code></h5><p><code>hdmi_readb</code>实际上是对<code>regmap_read</code>进行了又一层的包装，用于实现对<code>RK3399 hdmi</code>相关寄存器进行读操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">hdmi_readb</span><span class="params">(struct dw_hdmi *hdmi, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        regmap_read(hdmi-&gt;regm, offset &lt;&lt; hdmi-&gt;reg_shift, &amp;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-hdmi-writeb"><a href="#5-3-2-hdmi-writeb" class="headerlink" title="5.3.2 hdmi_writeb"></a>5.3.2 <code>hdmi_writeb</code></h5><p><code>hdmi_writeb</code>实际上是对<code>regmap_write</code>进行了又一层的包装，用于实现对<code>RK3399 hdmi</code>相关寄存器进行写操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hdmi_writeb</span><span class="params">(struct dw_hdmi *hdmi, u8 val, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        regmap_write(hdmi-&gt;regm, offset &lt;&lt; hdmi-&gt;reg_shift, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-dw-hdmi-bridge-funcs-重点"><a href="#5-4-dw-hdmi-bridge-funcs-重点" class="headerlink" title="5.4 dw_hdmi_bridge_funcs(重点)"></a>5.4 <code>dw_hdmi_bridge_funcs</code>(重点)</h4><p><code>dw_hdmi_bridge_funcs</code>定义了<code>bridge</code>的控制函数，位于<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>文件；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_funcs</span> <span class="title">dw_hdmi_bridge_funcs</span> = &#123;</span></span><br><span class="line">        .atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,</span><br><span class="line">        .atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,</span><br><span class="line">        .atomic_reset = drm_atomic_helper_bridge_reset,</span><br><span class="line">        .attach = dw_hdmi_bridge_attach,    <span class="comment">// 桥接设备连接到encoder时被调用</span></span><br><span class="line">        .detach = dw_hdmi_bridge_detach,</span><br><span class="line">        .atomic_check = dw_hdmi_bridge_atomic_check,</span><br><span class="line">        .atomic_get_output_bus_fmts = dw_hdmi_bridge_atomic_get_output_bus_fmts,</span><br><span class="line">        .atomic_get_input_bus_fmts = dw_hdmi_bridge_atomic_get_input_bus_fmts,</span><br><span class="line">        .atomic_enable = dw_hdmi_bridge_atomic_enable,</span><br><span class="line">        .atomic_disable = dw_hdmi_bridge_atomic_disable,</span><br><span class="line">        .mode_set = dw_hdmi_bridge_mode_set,</span><br><span class="line">        .mode_valid = dw_hdmi_bridge_mode_valid,  <span class="comment">// 用于校验显示模式是否有效，最终调用dw_hdmi_rockchip_mode_valid</span></span><br><span class="line">        .detect = dw_hdmi_bridge_detect,</span><br><span class="line">        .get_edid = dw_hdmi_bridge_get_edid,  <span class="comment">// 用于获取edid信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>attach</code>：回调函数在桥接设备连接到<code>encoder</code>时被调用；</li>
<li><code>detach</code>：回调函数在桥接设备从<code>encoder</code>断开时被调用；</li>
<li><code>mode_valid</code>：用于校验显示模式是否有效，最终调用<code>dw_hdmi_plat_data</code> 的成员<code>mode_valid</code> ，也就是<code>dw_hdmi_rockchip_mode_valid</code>函数；</li>
<li><code>get_edid</code>：用于读取连接显示器的<code>edid</code>数据的首选方法。如果桥接设备支持读取<code>edid</code>的话，应当实现这个回调函数，并不实现 <code>get_modes</code> 回调；</li>
</ul>
<h5 id="5-4-1-dw-hdmi-bridge-attach"><a href="#5-4-1-dw-hdmi-bridge-attach" class="headerlink" title="5.4.1 dw_hdmi_bridge_attach"></a>5.4.1 <code>dw_hdmi_bridge_attach</code></h5><p>对于<code>briget</code>而言，<code>dw_hdmi_bridge_attach</code>函数用于将<code>bridge</code>与<code>connector</code>（即<code>hdmi</code>设备）连接起来；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_bridge_attach</span><span class="params">(struct drm_bridge *bridge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">enum</span> drm_bridge_attach_flags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span> = <span class="title">bridge</span>-&gt;<span class="title">driver_private</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DRM_BRIDGE_ATTACH_NO_CONNECTOR)</span><br><span class="line">                <span class="keyword">return</span> drm_bridge_attach(bridge-&gt;encoder, hdmi-&gt;next_bridge,</span><br><span class="line">                                         bridge, flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dw_hdmi_connector_create(hdmi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>dw_hdmi_connector_create</code>函数用于初始化 <code>connector</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_connector_create</span><span class="params">(struct dw_hdmi *hdmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span> = &amp;<span class="title">hdmi</span>-&gt;<span class="title">connector</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cec_connector_info</span> <span class="title">conn_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cec_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hdmi-&gt;version &gt;= <span class="number">0x200a</span>)</span><br><span class="line">                connector-&gt;ycbcr_420_allowed =</span><br><span class="line">                        hdmi-&gt;plat_data-&gt;ycbcr_420_allowed;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                connector-&gt;ycbcr_420_allowed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        connector-&gt;interlace_allowed = <span class="number">1</span>;</span><br><span class="line">        connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置connector的辅助函数helper_private为dw_hdmi_connector_helper_funcs</span></span><br><span class="line">        drm_connector_helper_add(connector, &amp;dw_hdmi_connector_helper_funcs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connector初始化, connector的控制函数func设置为dw_hdmi_connector_funcs</span></span><br><span class="line">        drm_connector_init_with_ddc(hdmi-&gt;bridge.dev, connector,</span><br><span class="line">                                    &amp;dw_hdmi_connector_funcs,</span><br><span class="line">                                    DRM_MODE_CONNECTOR_HDMIA,</span><br><span class="line">                                    hdmi-&gt;ddc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * drm_connector_attach_max_bpc_property() requires the</span></span><br><span class="line"><span class="comment">         * connector to have a state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        drm_atomic_helper_connector_reset(connector);</span><br><span class="line"></span><br><span class="line">        drm_connector_attach_max_bpc_property(connector, <span class="number">8</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hdmi-&gt;version &gt;= <span class="number">0x200a</span> &amp;&amp; hdmi-&gt;plat_data-&gt;use_drm_infoframe)</span><br><span class="line">                drm_connector_attach_hdr_output_metadata_property(connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connector-&gt;possible_encoders |= drm_encoder_mask(encoder);</span></span><br><span class="line">        drm_connector_attach_encoder(connector, hdmi-&gt;bridge.encoder);</span><br><span class="line"></span><br><span class="line">        cec_fill_conn_info_from_drm(&amp;conn_info, connector);</span><br><span class="line"></span><br><span class="line">        notifier = cec_notifier_conn_register(hdmi-&gt;dev, <span class="literal">NULL</span>, &amp;conn_info);</span><br><span class="line">        <span class="keyword">if</span> (!notifier)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;hdmi-&gt;cec_notifier_mutex);</span><br><span class="line">        hdmi-&gt;cec_notifier = notifier;</span><br><span class="line">        mutex_unlock(&amp;hdmi-&gt;cec_notifier_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）<code>connector</code>的辅助函数<code>helper_private</code>为<code>dw_hdmi_connector_helper_funcs</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_helper_funcs</span> <span class="title">dw_hdmi_connector_helper_funcs</span> = &#123;</span></span><br><span class="line">        .get_modes = dw_hdmi_connector_get_modes,</span><br><span class="line">        .atomic_check = dw_hdmi_connector_atomic_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>get_modes</code>用于通过<code>DDC</code>探探测的所有显示模式，并将其添加到<code>connector</code>的 <code>probed_modes</code> 链表中。</p>
<p>（2）<code>connector</code>的控制函数<code>func</code>设置为<code>dw_hdmi_connector_funcs</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_funcs</span> <span class="title">dw_hdmi_connector_funcs</span> = &#123;</span></span><br><span class="line">        .fill_modes = drm_helper_probe_single_connector_modes,</span><br><span class="line">        .detect = dw_hdmi_connector_detect,</span><br><span class="line">        .destroy = drm_connector_cleanup,</span><br><span class="line">        .force = dw_hdmi_connector_force,</span><br><span class="line">        .reset = drm_atomic_helper_connector_reset,</span><br><span class="line">        .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,</span><br><span class="line">        .atomic_destroy_state = drm_atomic_helper_connector_destroy_state,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>fill_modes</code>中指定的<code>drm_helper_probe_single_connector_modes</code>函数用于检测并筛选出所有有效的显示模式。该函数旨在作为使用<code>CRTC</code>辅助函数进行输出模式过滤和检测的驱动程序的<code>drm_connector_funcs.fill_modes</code>函数的通用实现。基本过程如下：</p>
<ul>
<li><p>将<code>connector</code>的<code>modes</code>链表中的所有显示模式标记为过时；</p>
</li>
<li><p>使用<code>drm_mode_probed_add</code>将新显示模式添加到<code>connector</code>的<code>probed_modes</code>链表中，新显示模式的状态初始值为<code>OK</code>。显示模式从单个来源按照以下优先顺序添加；</p>
<ul>
<li><code>drm_connector_helper_funcs.get_modes</code>回调函数（<code>drm_helper_probe_get_modes</code>）；</li>
<li>如果<code>connector</code>状态为<code>connected</code>并且<code>drm_helper_probe_get_modes</code>未获取到显示模式，则自动添加标准的<code>VESA DMT</code>显示模式，最高分辨率为<code>1024x768</code>（<code>drm_add_modes_noedid</code>）；</li>
</ul>
</li>
<li><p>通过内核命令行指定的显示模式将与之前的探测结果一起添加（<code>drm_helper_probe_add_cmdline_mode</code>），这些模显示模式是使用<code>VESA GTF</code>/<code>CVT</code>算法生成的；</p>
</li>
<li><p>将显示模式从<code>probed_modes</code>链表移动到<code>modes</code>链表中，潜在的重复模式将被合并在一起（<code>drm_connector_list_update</code>）；此步骤完成后，<code>probed_modes</code>链表将再次为空；</p>
</li>
<li><p><code>modes</code>列表中的任何非过时显示模式都要进行验证，并更新显示模式的状态；</p>
<ul>
<li><code>drm_mode_validate_basic</code>执行基本的合法性检查；</li>
<li><code>drm_mode_validate_size</code>过滤掉大于<code>maxX</code>和<code>maxY</code>（如果有指定）的模式；</li>
<li><code>drm_mode_validate_flag</code>根据基本连接器能力（允许交错，允许双扫描，允许立体）检查模式；</li>
<li>可选的<code>drm_connector_helper_funcs.mode_valid</code>或<code>drm_connector_helper_funcs.mode_valid_ctx</code>辅助函数可以执行驱动程序和/或显示器特定的检查；</li>
<li>可选的<code>drm_crtc_helper_funcs.mode_valid</code>，<code>drm_bridge_funcs.mode_valid</code>（会调用<code>dw_hdmi_bridge_mode_valid</code>函数进行校验）和<code>drm_encoder_helper_funcs.mode_valid</code>辅助函数可以执行驱动程序和/或源特定的检查，这些辅助函数也由<code>modeset</code>/<code>atomic</code>辅助函数执行；</li>
</ul>
</li>
<li><p>从<code>connector</code>的<code>modes</code>链表中去除任何状态不为<code>OK</code>的模式，同时输出调试消息指示模式被拒绝的原因（<code>drm_mode_prune_invalid</code>）。</p>
</li>
</ul>
<p>这里我们简单说一下<code>drm_xxx_helper_funcs</code>和<code>drm_xxx_funcs</code>的区别；</p>
<p><code>drm_connector_funcs</code>是应用层进行<code>drm ioctl</code>操作是的最终入口，对于大多数的<code>SoC</code>厂商来说，他们的<code>drm_xxx_funcs</code>操作流程基本相同，仅仅是在寄存器配置上存在差异，因此开发者将那些通用的操作流程封装了<code>helper</code>函数，而将那些厂商差异化的代码放到了<code>drm_xxx_helper_funcs</code>中去，由<code>SoC</code>厂商自己实现。</p>
<p>比如<code>dw_hdmi_connector_funcs</code>中的<code>fill_modes</code>、<code>reset</code>、<code>atomic_duplicate_state</code>等都是使用的通用的<code>helper</code>函数，他们定义在<code>drivers/gpu/drm/drm_probe_helper.c</code>、<code>drivers/gpu/drm/drm_atomic_state_helper.c</code>等文件中：这些<code>helper</code>函数内部实现一般就是回调<code>dw_hdmi_connector_helper_funcs</code>中的相应方法。</p>
<h5 id="5-4-2-dw-hdmi-bridge-get-edid"><a href="#5-4-2-dw-hdmi-bridge-get-edid" class="headerlink" title="5.4.2 dw_hdmi_bridge_get_edid"></a>5.4.2 <code>dw_hdmi_bridge_get_edid</code></h5><p><code>dw_hdmi_bridge_get_edid</code>用于获取<code>edid</code>信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct edid *<span class="title">dw_hdmi_bridge_get_edid</span><span class="params">(struct drm_bridge *bridge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            struct drm_connector *connector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span> = <span class="title">bridge</span>-&gt;<span class="title">driver_private</span>;</span></span><br><span class="line">        <span class="comment">// 获取edid信息</span></span><br><span class="line">        <span class="keyword">return</span> dw_hdmi_get_edid(hdmi, connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-分析小结"><a href="#5-4-3-分析小结" class="headerlink" title="5.4.3 分析小结"></a>5.4.3 分析小结</h5><p>经过分析我们发现无论是<code>bridget</code>的<code>funcs</code>中的<code>get_edid</code>还是<code>connector</code>的<code>helper_private</code>中<code>get_modes</code>都会调用<code>dw_hdmi_get_edid</code>获取连接器的<code>edid</code>信息;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bridget的funcs被设置为dw_hdmi_bridge_funcs</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_funcs</span> <span class="title">dw_hdmi_bridge_funcs</span> = &#123;</span></span><br><span class="line">     .get_edid = dw_hdmi_bridge_get_edid,            </span><br><span class="line">     ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dw_hdmi_bridge_get_edid(bridge,connector)</span><br><span class="line">    dw_hdmi_get_edid(hdmi, connector)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// connector的helper_private被设置为dw_hdmi_connector_helper_funcs</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_helper_funcs</span> <span class="title">dw_hdmi_connector_helper_funcs</span> = &#123;</span></span><br><span class="line">        .get_modes = dw_hdmi_connector_get_modes,</span><br><span class="line">        ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dw_hdmi_connector_get_modes(connector)</span><br><span class="line">    dw_hdmi_get_edid(hdmi, connector)</span><br></pre></td></tr></table></figure>

<h4 id="5-5-drm-bridge-add"><a href="#5-5-drm-bridge-add" class="headerlink" title="5.5 drm_bridge_add"></a>5.5 <code>drm_bridge_add</code></h4><p><code>drm_bridge_add</code>函数定义在<code>drivers/gpu/drm/drm_bridge.c</code>，用于将当前桥接设备到全局链表<code>bridge_list</code>中；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_bridge_add - add the given bridge to the global bridge list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @bridge: bridge control structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drm_bridge_add</span><span class="params">(struct drm_bridge *bridge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        mutex_init(&amp;bridge-&gt;hpd_mutex);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;bridge_lock);</span><br><span class="line">        list_add_tail(&amp;bridge-&gt;<span class="built_in">list</span>, &amp;bridge_list);</span><br><span class="line">        mutex_unlock(&amp;bridge_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、drm-add-edid-modes"><a href="#六、drm-add-edid-modes" class="headerlink" title="六、drm_add_edid_modes"></a>六、<code>drm_add_edid_modes</code></h3><p><code>struct drm_connector_helper_funcs</code>的<code>get_modes</code>用于通过<code>DDC</code>探测到<code>connector</code>的所有显示模式，并将其添加到<code>connector</code>的 <code>probed_modes</code> 链表中，这些模式还没有经过筛选和过滤；</p>
<p>需要注意的是：在探测阶段，系统可能会探测到一些暂时不可用或不推荐的显示模式，这些模式会先被存储在 <code>probed_modes</code> 中。之后，这些模式可能会经过进一步的处理和筛选，最终加入到 <code>modes</code> 中成为最终可用的显示模式列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_helper_funcs</span> <span class="title">dw_hdmi_connector_helper_funcs</span> = &#123;</span></span><br><span class="line">        .get_modes = dw_hdmi_connector_get_modes,</span><br><span class="line">        .atomic_check = dw_hdmi_connector_atomic_check,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>dw_hdmi_connector_get_modes</code>主要包括两步：</p>
<ul>
<li>通过<code>dw_hdmi_get_edid</code>获取<code>connector</code>的<code>edid</code>信息；</li>
<li>通过<code>drm_add_edid_modes</code>函数解析<code>edid</code>信息，并将其转换为显示模式，添加到<code>connector</code>的 <code>probed_modes</code> 链表；</li>
</ul>
<p><code>dw_hdmi_connector_get_modes</code>函数位于<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dw_hdmi_connector_get_modes</span><span class="params">(struct drm_connector *connector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dw_hdmi</span> *<span class="title">hdmi</span> = <span class="title">container_of</span>(<span class="title">connector</span>, <span class="title">struct</span> <span class="title">dw_hdmi</span>,</span></span><br><span class="line"><span class="class">                                             <span class="title">connector</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *<span class="title">edid</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取connector的edid信息</span></span><br><span class="line">        edid = dw_hdmi_get_edid(hdmi, connector);</span><br><span class="line">        <span class="keyword">if</span> (!edid)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 更新连接器edid属性</span></span><br><span class="line">        drm_connector_update_edid_property(connector, edid);</span><br><span class="line">        cec_notifier_set_phys_addr_from_edid(hdmi-&gt;cec_notifier, edid);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 解析edid中的显示模式并添加到connector的probed_modes链表</span></span><br><span class="line">        ret = drm_add_edid_modes(connector, edid);</span><br><span class="line">        kfree(edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-dw-hdmi-get-edid"><a href="#6-1-dw-hdmi-get-edid" class="headerlink" title="6.1 dw_hdmi_get_edid"></a>6.1 <code>dw_hdmi_get_edid</code></h4><p><code>dw_hdmi_get_edid</code>定义在<code>drivers/gpu/drm/bridge/synopsys/dw-hdmi.c</code>，用于获取<code>connector</code>的<code>edid</code>信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct edid *<span class="title">dw_hdmi_get_edid</span><span class="params">(struct dw_hdmi *hdmi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     struct drm_connector *connector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *<span class="title">edid</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hdmi-&gt;ddc)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过I2C通信获取edid信息</span></span><br><span class="line">        edid = drm_get_edid(connector, hdmi-&gt;ddc);</span><br><span class="line">        <span class="keyword">if</span> (!edid) &#123;</span><br><span class="line">                dev_dbg(hdmi-&gt;dev, <span class="string">&quot;failed to get edid\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dev_dbg(hdmi-&gt;dev, <span class="string">&quot;got edid: width[%d] x height[%d]\n&quot;</span>,</span><br><span class="line">                edid-&gt;width_cm, edid-&gt;height_cm);</span><br><span class="line"></span><br><span class="line">        hdmi-&gt;sink_is_hdmi = drm_detect_hdmi_monitor(edid);</span><br><span class="line">        hdmi-&gt;sink_has_audio = drm_detect_monitor_audio(edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> edid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>drm_get_edid</code>函数位于<code>drivers/gpu/drm/drm_edid.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_get_edid - get EDID data, if available</span></span><br><span class="line"><span class="comment"> * @connector: connector we&#x27;re probing</span></span><br><span class="line"><span class="comment"> * @adapter: I2C adapter to use for DDC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Poke the given I2C channel to grab EDID data if possible.  If found,</span></span><br><span class="line"><span class="comment"> * attach it to the connector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: Pointer to valid EDID or NULL if we couldn&#x27;t find any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct edid *<span class="title">drm_get_edid</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                          struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *<span class="title">edid</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connector-&gt;force == DRM_FORCE_OFF)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connector-&gt;force == DRM_FORCE_UNSPECIFIED &amp;&amp; !drm_probe_ddc(adapter))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用drm_do_probe_ddc_edid函数实现通过I2C总线读取edid信息，有兴趣可以看一下i2c_transfer，I2C从设备地址为0x50</span></span><br><span class="line">        edid = _drm_do_get_edid(connector, drm_do_probe_ddc_edid, adapter, <span class="literal">NULL</span>);</span><br><span class="line">        drm_connector_update_edid_property(connector, edid);</span><br><span class="line">        <span class="keyword">return</span> edid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-drm-add-edid-modes"><a href="#6-2-drm-add-edid-modes" class="headerlink" title="6.2 drm_add_edid_modes"></a>6.2 <code>drm_add_edid_modes</code></h4><p><code>drm_add_edid_modes</code>函数用于解析<code>edid</code>信息，并将其转换为显示模式，添加到<code>connector</code>的 <code>probed_modes</code> 链表。</p>
<p>在这之前，我们需要大概了解一下<code>CVT</code>/<code>GTF</code>/<code>DMT</code>，因此后面在分析代码讲解如何解析<code>edid</code>并将其转换为显示模式的时候会有所涉及。<code>CVT</code>（<code>Coordinated Video Timing</code>）、<code>GTF</code>（<code>Generalized Timing Formula</code>）和<code>DMT</code>（<code>Display Monitor Timings</code>）是三种不同的显示器时序规范。它们在计算和定义显示模式参数方面有所不同；</p>
<ul>
<li><code>DMT</code>（<code>Display Monitor Timings</code>）：<code>DMT</code>是由<code>VESA</code>（<code>Video Electronics Standards Association</code>）定义的一组标准显示模式参数。<code>DMT</code>规范列出了一些预定义的显示模式，包括常见的分辨率、刷新率和时序参数。这些参数在不同的显示设备上是通用的，可以提供简单的配置和兼容性。<code>linux</code>内核中将标准显示模式存放在数组<code>drm_dmt_modes</code>，位于<code>drivers/gpu/drm/drm_edid.c</code>文件；</li>
<li><code>GTF</code>（<code>GeneralizedTimingFormula</code>）：<code>GTF</code>是一种更高级的算法，它可以生成更灵活的显示模式。<code>GTF</code>算法基于显示器的物理特性和电信号时序的数学模型，通过计算参数来生成显示模式。<code>GTF</code>算法允许更精细的控制，可以生成几乎任意分辨率、刷新率和纵横比的显示模式；内核实现函数有：<code>drm_gtf_mode</code>、<code>drm_gtf2_mode</code>，定义在<code>drivers/gpu/drm/drm_modes.c</code>；</li>
<li><code>CVT</code>（<code>CoordinatedVideoTiming</code>）：<code>CVT</code>是一种改进的显示模式计算方法，用于在不同的显示设备上创建更准确的显示模式。<code>CVT</code>算法考虑了显示器的特性、带宽和可见性要求，以生成更准确的时序参数。<code>CVT</code>模式具有更高的精度和可调节性，可以提供更好的显示效果；内核实现函数<code>drm_cvt_mode</code>定义在<code>drivers/gpu/drm/drm_modes.c</code>；</li>
</ul>
<p>总结来说，<code>DMT</code>是一组预定义的标准模式，<code>GTF</code>允许生成更灵活的自定义模式，而<code>CVT</code>通过考虑更多因素生成更准确的显示模式。选择使用哪种时序规范取决于具体的需求和显示设备的兼容性。</p>
<p><code>drm_add_edid_modes</code>其实现位于<code>drivers/gpu/drm/drm_edid.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_add_edid_modes - add modes from EDID data, if available</span></span><br><span class="line"><span class="comment"> * @connector: connector we&#x27;re probing</span></span><br><span class="line"><span class="comment"> * @edid: EDID data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Add the specified modes to the connector&#x27;s mode list. Also fills out the</span></span><br><span class="line"><span class="comment"> * &amp;drm_display_info structure and ELD in @connector with any information which</span></span><br><span class="line"><span class="comment"> * can be derived from the edid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is deprecated. Use drm_edid_connector_add_modes() instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The number of modes added or 0 if we couldn&#x27;t find any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_add_edid_modes</span><span class="params">(struct drm_connector *connector, struct edid *edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_edid</span> _<span class="title">drm_edid</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_edid</span> *<span class="title">drm_edid</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// edid有效性校验</span></span><br><span class="line">        <span class="keyword">if</span> (edid &amp;&amp; !drm_edid_is_valid(edid)) &#123;</span><br><span class="line">                drm_warn(connector-&gt;dev, <span class="string">&quot;[CONNECTOR:%d:%s] EDID invalid.\n&quot;</span>,</span><br><span class="line">                         connector-&gt;base.id, connector-&gt;name);</span><br><span class="line">                edid = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drm_edid = drm_edid_legacy_init(&amp;_drm_edid, edid);</span><br><span class="line"></span><br><span class="line">        update_display_info(connector, drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _drm_edid_connector_add_modes(connector, drm_edid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先检查<code>edid</code>数据的有效性，然后使用提供的<code>edid</code>数据初始化 <code>drm_edid</code> 结构，接着更新显示信息，最后调用 <code>_drm_edid_connector_add_modes</code> 函数来添加模式。</p>
<h5 id="6-2-1-drm-edid-legacy-init"><a href="#6-2-1-drm-edid-legacy-init" class="headerlink" title="6.2.1 drm_edid_legacy_init"></a>6.2.1 <code>drm_edid_legacy_init</code></h5><p><code>drm_edid_legacy_init</code>函数仅仅是用来初始化 <code>drm_edid</code> 结构体。它接受两个参数：<code>drm_edid</code> 和 <code>edid</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initializer helper for legacy interfaces, where we have no choice but to</span></span><br><span class="line"><span class="comment"> * trust edid size. Not for general purpose use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct drm_edid *<span class="title">drm_edid_legacy_init</span><span class="params">(struct drm_edid *drm_edid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">const</span> struct edid *edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!edid)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(drm_edid, <span class="number">0</span>, <span class="keyword">sizeof</span>(*drm_edid));</span><br><span class="line"></span><br><span class="line">        drm_edid-&gt;edid = edid;</span><br><span class="line">        <span class="comment">// 计算edid数据的大小</span></span><br><span class="line">        drm_edid-&gt;size = edid_size(edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> drm_edid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-update-display-info"><a href="#6-2-2-update-display-info" class="headerlink" title="6.2.2 update_display_info"></a>6.2.2 <code>update_display_info</code></h5><p><code>update_display_info</code>用于更新<code>HDMI</code>显示设备的显示信息(即<code>connector-&gt;display_info</code>)，该函数接收两个参数，第一个是<code>connector</code>，第二个参数为<code>edid</code>信息；下面是我使用的一款<code>HDMI</code>显示器的<code>edid</code>信息；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">                0   1   2   3   4   5   6   7   8   9   </span><br><span class="line">        000  |  00  FF  FF  FF  FF  FF  FF  00  35  34</span><br><span class="line">        010  |  00  00  01  01  01  01  00  20  01  03</span><br><span class="line">        020  |  81  00  00  78  EE  8C  75  A9  54  45</span><br><span class="line">        030  |  98  22  1E  50  54  2F  CF  00  71  40</span><br><span class="line">        040  |  81  C0  81  80  95  00  A9  C0  B3  00</span><br><span class="line">        050  |  D1  C0  D1  00  D3  BC  00  A0  A0  A0</span><br><span class="line">        060  |  29  50  30  20  35  00  B9  88  21  00</span><br><span class="line">        070  |  00  1A  56  5E  00  A0  A0  A0  29  50</span><br><span class="line">        080  |  30  20  35  00  B9  88  21  00  00  1A</span><br><span class="line">        090  |  67  E2  00  A0  A0  A0  29  50  30  20</span><br><span class="line">        100  |  35  00  B9  88  21  00  00  1A  00  00</span><br><span class="line">        110  |  00  FC  00  4D  45  49  54  49  41  4E</span><br><span class="line">        120  |  48  41  4F  0A  20  20  01  0B</span><br><span class="line"></span><br><span class="line">(8-9)        ID Manufacture Name : MIT</span><br><span class="line">(10-11)      ID Product Code     : 0000</span><br><span class="line">(12-15)      ID Serial Number    : N/A</span><br><span class="line">(16)         Week of Manufacture : 0</span><br><span class="line">(17)         Year of Manufacture : 2022</span><br><span class="line"></span><br><span class="line">(18)         EDID Version Number : 1</span><br><span class="line">(19)         EDID Revision Number: 3</span><br><span class="line"></span><br><span class="line">(20)         Video Input Definition : Digital</span><br><span class="line">            DFP 1.x Compatible</span><br><span class="line"></span><br><span class="line">(21)         Maximum Horizontal Image Size: 0 cm</span><br><span class="line">(22)         Maximum Vertical Image Size  : 0 cm</span><br><span class="line">(23)         Display Gamma                : 2.20</span><br><span class="line">(24)         Power Management and Supported Feature(s):</span><br><span class="line">            Standby, Suspend, Active Off/Very Low Power, RGB Color, sRGB, Preferred Timing Mode</span><br><span class="line"></span><br><span class="line">(25-34)      Color Characteristics</span><br><span class="line">            Red Chromaticity   :  Rx = 0.658  Ry = 0.328</span><br><span class="line">            Green Chromaticity :  Gx = 0.269  Gy = 0.594</span><br><span class="line">            Blue Chromaticity  :  Bx = 0.134  By = 0.120</span><br><span class="line">            Default White Point:  Wx = 0.313  Wy = 0.329</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">(126-127)    Extension Flag and Checksum</span><br><span class="line"></span><br><span class="line">            Extension Block(s)  : 1      # 表明有扩展块</span><br><span class="line">            Checksum Value      : 11</span><br><span class="line">    ___________________________________________________________________</span><br><span class="line"></span><br><span class="line">    Block 1 ( CEA-861 Extension Block), Bytes 128 - 255,  128  BYTES OF EDID CODE:</span><br><span class="line"></span><br><span class="line">                0   1   2   3   4   5   6   7   8   9   </span><br><span class="line">        128  |  02  03  3A  F2  4F  04  05  10  13  14</span><br><span class="line">        138  |  1F  6C  6C  6C  27  6C  6C  6C  4B  4C</span><br><span class="line">        148  |  E2  00  D5  E3  05  C0  00  23  09  7F</span><br><span class="line">        158  |  07  83  01  00  00  67  03  0C  00  10</span><br><span class="line">        168  |  00  38  78  E6  06  05  01  69  69  4F</span><br><span class="line">        178  |  67  D8  5D  C4  01  76  C0  00  02  3A</span><br><span class="line">        188  |  80  18  71  38  2D  40  58  2C  25  00</span><br><span class="line">        198  |  58  C3  10  00  00  1E  D4  BC  00  A0</span><br><span class="line">        208  |  A0  A0  29  50  30  20  35  00  B9  88</span><br><span class="line">        218  |  21  00  00  1E  98  E2  00  A0  A0  A0</span><br><span class="line">        228  |  29  50  30  20  35  00  B9  88  21  00</span><br><span class="line">        238  |  00  1E  00  00  00  00  00  00  00  00</span><br><span class="line">        248  |  00  00  00  00  00  00  00  C4</span><br><span class="line"></span><br><span class="line">(128-130)    Extension Header</span><br><span class="line"></span><br><span class="line">            Revision Number    :    3</span><br><span class="line">            DTD Starting Offset:    58</span><br><span class="line"></span><br><span class="line">(131)        Display Support</span><br><span class="line"></span><br><span class="line">            DTV Underscan, Basic Audio, YCbCr 4:4:4, YCbCr 4:2:2</span><br><span class="line">            Number of Native Formats: 2</span><br><span class="line"></span><br><span class="line">(132-147)    Video Data Block</span><br><span class="line"></span><br><span class="line">            1280x720p @ 59.94/60Hz - HDTV (16:9, 1:1)</span><br><span class="line">            1920x1080i @ 59.94/60Hz - HDTV (16:9, 1:1)</span><br><span class="line">            1920x1080p @ 59.94/60Hz - HDTV (16:9, 1:1)</span><br><span class="line">            1280x720p  @ 50Hz - HDTV  (16:9, 1:1)</span><br><span class="line">            1920x1080i @ 50Hz - HDTV (16:9, 1:1)</span><br><span class="line">            1920x1080p @ 50Hz - HDTV (16:9, 1:1)</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            1920x1080i (1250 total) - HDTV 50Hz (16:9, 1:1)</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line">            Reserved for the Future</span><br><span class="line"></span><br><span class="line">(148-150)    Video Capability Data Block (VCDB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(151-154)    Colorimetry Data Block</span><br></pre></td></tr></table></figure>

<p><code>update_display_info</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_display_info</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> *<span class="title">info</span> = &amp;<span class="title">connector</span>-&gt;<span class="title">display_info</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *<span class="title">edid</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复位info各个成员的值 </span></span><br><span class="line">        drm_reset_display_info(connector);</span><br><span class="line">        clear_eld(connector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!drm_edid)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        edid = drm_edid-&gt;edid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从edit中获取面板ID（由制造商名称、产品代码构成的一个u32类型），然后根据面板ID到edid_quirk_list列表匹配来获取相应的quirk标志；比如我使用的一款HDMI显示器的面板ID就在edid_quirk_list中不到匹配项，所以quirks设置为0</span></span><br><span class="line">        info-&gt;quirks = edid_get_quirks(drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从edid中获取最大水平图像尺寸   0x15H</span></span><br><span class="line">        info-&gt;width_mm = edid-&gt;width_cm * <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//  从edid中获取最大垂直图像尺寸  0x16H</span></span><br><span class="line">        info-&gt;height_mm = edid-&gt;height_cm * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于edit revision版本号小于4，该函数直接返回</span></span><br><span class="line">        drm_get_monitor_range(connector, drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (edid-&gt;revision &lt; <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是模拟信号，进入</span></span><br><span class="line">        <span class="keyword">if</span> (!(edid-&gt;input &amp; DRM_EDID_INPUT_DIGITAL))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置HDMI的颜色格式</span></span><br><span class="line">        info-&gt;color_formats |= DRM_COLOR_FORMAT_RGB444;</span><br><span class="line">        <span class="comment">// 解析EDID扩展块（CEA-861D）</span></span><br><span class="line">        drm_parse_cea_ext(connector, drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Digital sink with &quot;DFP 1.x compliant TMDS&quot; according to EDID 1.3?</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For such displays, the DFP spec 1.0, section 3.10 &quot;EDID support&quot;</span></span><br><span class="line"><span class="comment">         * tells us to assume 8 bpc color depth if the EDID doesn&#x27;t have</span></span><br><span class="line"><span class="comment">         * extensions which tell otherwise.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;bpc == <span class="number">0</span> &amp;&amp; edid-&gt;revision == <span class="number">3</span> &amp;&amp;</span><br><span class="line">            edid-&gt;input &amp; DRM_EDID_DIGITAL_DFP_1_X) &#123;  <span class="comment">// 进入  DRM_EDID_DIGITAL_DFP_1_X = 1&lt;&lt;0</span></span><br><span class="line">                info-&gt;bpc = <span class="number">8</span>;</span><br><span class="line">                drm_dbg_kms(connector-&gt;dev,</span><br><span class="line">                            <span class="string">&quot;[CONNECTOR:%d:%s] Assigning DFP sink color depth as %d bpc.\n&quot;</span>,</span><br><span class="line">                            connector-&gt;base.id, connector-&gt;name, info-&gt;bpc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only defined for 1.4 with digital displays，对于EDID 1.4以下版本跳转到out */</span></span><br><span class="line">        <span class="keyword">if</span> (edid-&gt;revision &lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (edid-&gt;input &amp; DRM_EDID_DIGITAL_DEPTH_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_6:</span><br><span class="line">                info-&gt;bpc = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_8:</span><br><span class="line">                info-&gt;bpc = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_10:</span><br><span class="line">                info-&gt;bpc = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_12:</span><br><span class="line">                info-&gt;bpc = <span class="number">12</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_14:</span><br><span class="line">                info-&gt;bpc = <span class="number">14</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_16:</span><br><span class="line">                info-&gt;bpc = <span class="number">16</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DRM_EDID_DIGITAL_DEPTH_UNDEF:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                info-&gt;bpc = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drm_dbg_kms(connector-&gt;dev,</span><br><span class="line">                    <span class="string">&quot;[CONNECTOR:%d:%s] Assigning EDID-1.4 digital sink color depth as %d bpc.\n&quot;</span>,</span><br><span class="line">                    connector-&gt;base.id, connector-&gt;name, info-&gt;bpc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (edid-&gt;features &amp; DRM_EDID_FEATURE_RGB_YCRCB444)</span><br><span class="line">                info-&gt;color_formats |= DRM_COLOR_FORMAT_YCBCR444;</span><br><span class="line">        <span class="keyword">if</span> (edid-&gt;features &amp; DRM_EDID_FEATURE_RGB_YCRCB422)</span><br><span class="line">                info-&gt;color_formats |= DRM_COLOR_FORMAT_YCBCR422;</span><br><span class="line"></span><br><span class="line">        drm_update_mso(connector, drm_edid);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_NON_DESKTOP) &#123;  <span class="comment">// 1&lt;&lt;12</span></span><br><span class="line">                drm_dbg_kms(connector-&gt;dev, <span class="string">&quot;[CONNECTOR:%d:%s] Non-desktop display%s\n&quot;</span>,</span><br><span class="line">                            connector-&gt;base.id, connector-&gt;name,</span><br><span class="line">                            info-&gt;non_desktop ? <span class="string">&quot; (redundant quirk)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                info-&gt;non_desktop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_CAP_DSC_15BPP)  <span class="comment">// 1&lt;&lt;13</span></span><br><span class="line">                info-&gt;max_dsc_bpp = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_FORCE_6BPC)  <span class="comment">// 1&lt;&lt;10</span></span><br><span class="line">                info-&gt;bpc = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_FORCE_8BPC)   <span class="comment">// 1&lt;&lt;8</span></span><br><span class="line">                info-&gt;bpc = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_FORCE_10BPC)   <span class="comment">// 1&lt;&lt;11</span></span><br><span class="line">                info-&gt;bpc = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_FORCE_12BPC)   <span class="comment">// 1&lt;&lt;9</span></span><br><span class="line">                info-&gt;bpc = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Depends on info-&gt;cea_rev set by drm_parse_cea_ext() above */</span></span><br><span class="line">        drm_edid_to_eld(connector, drm_edid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数的执行流程中同时会解析<code>edid</code>扩展块，由<code>drm_parse_cea_ext</code>函数实现，以我是用的<code>HDMI</code>显示器为例分析如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drm_parse_cea_ext</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> *<span class="title">info</span> = &amp;<span class="title">connector</span>-&gt;<span class="title">display_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_edid_iter</span> <span class="title">edid_iter</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cea_db</span> *<span class="title">db</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cea_db_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">        <span class="keyword">const</span> u8 *edid_ext;</span><br><span class="line">        u64 y420cmdb_map = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        drm_edid_iter_begin(drm_edid, &amp;edid_iter);</span><br><span class="line">        <span class="comment">// edid信息由edid主块和edid扩展块组成，这里是一个遍历操作，edid_ext依次指向主块的首地址、edid扩展块的首地址</span></span><br><span class="line">        drm_edid_iter_for_each(edid_ext, &amp;edid_iter) &#123;</span><br><span class="line">                <span class="comment">// 通过标记位判定是不是扩展块，如果不是跳过</span></span><br><span class="line">                <span class="keyword">if</span> (edid_ext[<span class="number">0</span>] != CEA_EXT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置版本号，未设置则进入，cea_rev设置为03H,</span></span><br><span class="line">                <span class="keyword">if</span> (!info-&gt;cea_rev)</span><br><span class="line">                        info-&gt;cea_rev = edid_ext[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (info-&gt;cea_rev != edid_ext[<span class="number">1</span>])</span><br><span class="line">                        drm_dbg_kms(connector-&gt;dev,</span><br><span class="line">                                    <span class="string">&quot;[CONNECTOR:%d:%s] CEA extension version mismatch %u != %u\n&quot;</span>,</span><br><span class="line">                                    connector-&gt;base.id, connector-&gt;name,</span><br><span class="line">                                    info-&gt;cea_rev, edid_ext[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The existence of a CTA extension should imply RGB support */</span></span><br><span class="line">                info-&gt;color_formats = DRM_COLOR_FORMAT_RGB444;</span><br><span class="line">                <span class="comment">// 是否支持YCbCr 4:4:4   支持</span></span><br><span class="line">                <span class="keyword">if</span> (edid_ext[<span class="number">3</span>] &amp; EDID_CEA_YCRCB444)</span><br><span class="line">                        info-&gt;color_formats |= DRM_COLOR_FORMAT_YCBCR444;</span><br><span class="line">                <span class="comment">// 是否支持YCbCr 4:2:2   支持</span></span><br><span class="line">                <span class="keyword">if</span> (edid_ext[<span class="number">3</span>] &amp; EDID_CEA_YCRCB422)</span><br><span class="line">                        info-&gt;color_formats |= DRM_COLOR_FORMAT_YCBCR422;</span><br><span class="line">        &#125;</span><br><span class="line">        drm_edid_iter_end(&amp;edid_iter);</span><br><span class="line"></span><br><span class="line">        cea_db_iter_edid_begin(drm_edid, &amp;iter);</span><br><span class="line">        <span class="comment">// 遍历edid扩展块的Data Blocks</span></span><br><span class="line">        cea_db_iter_for_each(db, &amp;iter) &#123;</span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> convert parsers to use struct cea_db */</span></span><br><span class="line">                <span class="keyword">const</span> u8 *data = (<span class="keyword">const</span> u8 *)db;</span><br><span class="line">                <span class="comment">// Vendor Specific类型的Data Block  不会进入</span></span><br><span class="line">                <span class="keyword">if</span> (cea_db_is_hdmi_vsdb(db))</span><br><span class="line">                        drm_parse_hdmi_vsdb_video(connector, data);</span><br><span class="line">                <span class="comment">// Forum Vendor Specific类型的Data Block  不会进入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_hdmi_forum_vsdb(db) ||</span><br><span class="line">                         cea_db_is_hdmi_forum_scdb(db))</span><br><span class="line">                        drm_parse_hdmi_forum_scds(connector, data);</span><br><span class="line">                <span class="comment">// Microsoft Vendor Specific类型的Data Block  不会进入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_microsoft_vsdb(db))</span><br><span class="line">                        drm_parse_microsoft_vsdb(connector, data);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_y420cmdb(db))</span><br><span class="line">                        parse_cta_y420cmdb(connector, db, &amp;y420cmdb_map);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_y420vdb(db))</span><br><span class="line">                        parse_cta_y420vdb(connector, db);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_vcdb(db))</span><br><span class="line">                        drm_parse_vcdb(connector, data);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_hdmi_hdr_metadata_block(db))</span><br><span class="line">                        drm_parse_hdr_metadata_block(connector, data);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_tag(db) == CTA_DB_VIDEO)</span><br><span class="line">                        parse_cta_vdb(connector, db);</span><br><span class="line">        &#125;</span><br><span class="line">        cea_db_iter_end(&amp;iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y420cmdb_map)</span><br><span class="line">                update_cta_y420cmdb(connector, y420cmdb_map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-3-drm-edid-connector-add-modes"><a href="#6-2-3-drm-edid-connector-add-modes" class="headerlink" title="6.2.3 _drm_edid_connector_add_modes"></a>6.2.3 <code>_drm_edid_connector_add_modes</code></h5><p><code>_drm_edid_connector_add_modes</code>函数是今天我们学习的重点，这个函数会从<code>edid</code>中解析<code>HDMI</code>显示设备支持的所有显示模式，在解析<code>edid</code>时，是按照<code>edid</code>规范中定义的优先级顺序来解析的；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _drm_edid_connector_add_modes(struct drm_connector *connector,</span><br><span class="line">                                         <span class="keyword">const</span> struct drm_edid *drm_edid)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> *<span class="title">info</span> = &amp;<span class="title">connector</span>-&gt;<span class="title">display_info</span>;</span></span><br><span class="line">        <span class="keyword">int</span> num_modes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!drm_edid)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * EDID spec says modes should be preferred in this order:</span></span><br><span class="line"><span class="comment">         * - preferred detailed mode</span></span><br><span class="line"><span class="comment">         * - other detailed modes from base block</span></span><br><span class="line"><span class="comment">         * - detailed modes from extension blocks</span></span><br><span class="line"><span class="comment">         * - CVT 3-byte code modes</span></span><br><span class="line"><span class="comment">         * - standard timing codes</span></span><br><span class="line"><span class="comment">         * - established timing codes</span></span><br><span class="line"><span class="comment">         * - modes inferred from GTF or CVT range information</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We get this pretty much right.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * XXX order for additional mode types in extension blocks?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        num_modes += add_detailed_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_cvt_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_standard_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_established_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_cea_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_alternate_cea_modes(connector, drm_edid);</span><br><span class="line">        num_modes += add_displayid_detailed_modes(connector, drm_edid);</span><br><span class="line">        <span class="keyword">if</span> (drm_edid-&gt;edid-&gt;features &amp; DRM_EDID_FEATURE_CONTINUOUS_FREQ)</span><br><span class="line">                num_modes += add_inferred_modes(connector, drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))</span><br><span class="line">                edid_fixup_preferred(connector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-add-detailed-modes"><a href="#6-3-add-detailed-modes" class="headerlink" title="6.3 add_detailed_modes"></a>6.3 <code>add_detailed_modes</code></h4><p><code>add_detailed_modes</code>函数用于从<code>Detailed Timings</code>中获取显示模式，并添加到<code>connector</code>的 <code>probed_modes</code> 链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * add_detailed_modes - Add modes from detailed timings</span></span><br><span class="line"><span class="comment"> * @connector: attached connector</span></span><br><span class="line"><span class="comment"> * @drm_edid: EDID block to scan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_detailed_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> <span class="title">closure</span> = &#123;</span></span><br><span class="line">                .connector = connector,</span><br><span class="line">                .drm_edid = drm_edid,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我使用的HDMI显示器revision为3，因此不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (drm_edid-&gt;edid-&gt;revision &gt;= <span class="number">4</span>)</span><br><span class="line">                closure.preferred = <span class="literal">true</span>; <span class="comment">/* first detailed timing is always preferred */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 0x18 位[1]：如果置1，推荐分辨率为第一个Detailed Timing</span></span><br><span class="line">                closure.preferred =</span><br><span class="line">                        drm_edid-&gt;edid-&gt;features &amp; DRM_EDID_FEATURE_PREFERRED_TIMING;  <span class="comment">// 1&lt;&lt;1 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历Detailed Timings，依次执行do_detailed_mode</span></span><br><span class="line">        drm_for_each_detailed_block(drm_edid, do_detailed_mode, &amp;closure);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closure.modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-Detailed-Timings信息"><a href="#6-3-1-Detailed-Timings信息" class="headerlink" title="6.3.1 Detailed Timings信息"></a>6.3.1 <code>Detailed Timings</code>信息</h5><p>以我使用的<code>HDMI</code>显示器为例，<code>Detailed Timings</code>信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">(54-71)      Detailed Descriptor #1: Preferred Detailed Timing (2560x1440 @ 120Hz)</span><br><span class="line"></span><br><span class="line">            Pixel Clock            : 483.39 MHz</span><br><span class="line">            Horizontal Image Size  : 697 mm</span><br><span class="line">            Vertical Image Size    : 392 mm</span><br><span class="line">            Refresh Mode           : Non-interlaced</span><br><span class="line">            Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">            Horizontal:</span><br><span class="line">                Active Time     : 2560 Pixels</span><br><span class="line">                Blanking Time   : 160 Pixels</span><br><span class="line">                Sync Offset     : 48 Pixels</span><br><span class="line">                Sync Pulse Width: 32 Pixels</span><br><span class="line">                Border          : 0 Pixels</span><br><span class="line">                Frequency       : 177 kHz</span><br><span class="line"></span><br><span class="line">            Vertical:</span><br><span class="line">                Active Time     : 1440 Lines</span><br><span class="line">                Blanking Time   : 41 Lines</span><br><span class="line">                Sync Offset     : 3 Lines</span><br><span class="line">                Sync Pulse Width: 5 Lines</span><br><span class="line">                Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">            Digital Separate, Horizontal Polarity (+), Vertical Polarity (-)</span><br><span class="line"></span><br><span class="line">            Modeline: &quot;2560x1440&quot; 483.390 2560 2608 2640 2720 1440 1443 1448 1481 +hsync -vsync</span><br><span class="line"></span><br><span class="line">(72-89)      Detailed Descriptor #2: Detailed Timing (2560x1440 @ 60Hz)</span><br><span class="line"></span><br><span class="line">            Pixel Clock            : 241.5 MHz</span><br><span class="line">            Horizontal Image Size  : 697 mm</span><br><span class="line">            Vertical Image Size    : 392 mm</span><br><span class="line">            Refresh Mode           : Non-interlaced</span><br><span class="line">            Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">            Horizontal:</span><br><span class="line">                Active Time     : 2560 Pixels</span><br><span class="line">                Blanking Time   : 160 Pixels</span><br><span class="line">                Sync Offset     : 48 Pixels</span><br><span class="line">                Sync Pulse Width: 32 Pixels</span><br><span class="line">                Border          : 0 Pixels</span><br><span class="line">                Frequency       : 88 kHz</span><br><span class="line"></span><br><span class="line">            Vertical:</span><br><span class="line">                Active Time     : 1440 Lines</span><br><span class="line">                Blanking Time   : 41 Lines</span><br><span class="line">                Sync Offset     : 3 Lines</span><br><span class="line">                Sync Pulse Width: 5 Lines</span><br><span class="line">                Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">            Digital Separate, Horizontal Polarity (+), Vertical Polarity (-)</span><br><span class="line"></span><br><span class="line">            Modeline: &quot;2560x1440&quot; 241.500 2560 2608 2640 2720 1440 1443 1448 1481 +hsync -vsync</span><br><span class="line"></span><br><span class="line">(90-107)     Detailed Descriptor #3: Detailed Timing (2560x1440 @ 144Hz)</span><br><span class="line"></span><br><span class="line">            Pixel Clock            : 579.59 MHz</span><br><span class="line">            Horizontal Image Size  : 697 mm</span><br><span class="line">            Vertical Image Size    : 392 mm</span><br><span class="line">            Refresh Mode           : Non-interlaced</span><br><span class="line">            Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">            Horizontal:</span><br><span class="line">                Active Time     : 2560 Pixels</span><br><span class="line">                Blanking Time   : 160 Pixels</span><br><span class="line">                Sync Offset     : 48 Pixels</span><br><span class="line">                Sync Pulse Width: 32 Pixels</span><br><span class="line">                Border          : 0 Pixels</span><br><span class="line">                Frequency       : 213 kHz</span><br><span class="line"></span><br><span class="line">            Vertical:</span><br><span class="line">                Active Time     : 1440 Lines</span><br><span class="line">                Blanking Time   : 41 Lines</span><br><span class="line">                Sync Offset     : 3 Lines</span><br><span class="line">                Sync Pulse Width: 5 Lines</span><br><span class="line">                Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">            Digital Separate, Horizontal Polarity (+), Vertical Polarity (-)</span><br><span class="line"></span><br><span class="line">            Modeline: &quot;2560x1440&quot; 579.590 2560 2608 2640 2720 1440 1443 1448 1481 +hsync -vsync</span><br><span class="line"></span><br><span class="line">(108-125)    Detailed Descriptor #4: Monitor Name</span><br><span class="line"></span><br><span class="line">            Monitor Name: MEITIANHAO</span><br></pre></td></tr></table></figure>

<p>其中第一个<code>Detailed Timing</code>为<code>HDMI</code>显示器的最佳时序：<code>2560x1440 @ 120Hz</code>；</p>
<p>这里一共有4个块，只有前3个块描述的是<code>Timing Descriptor</code>，因此<code>add_detailed_modes</code>函数会遍历这三个<code>Timing Descriptor</code>，依次执行<code>do_detailed_mode</code>。</p>
<h5 id="6-3-2-do-detailed-mode"><a href="#6-3-2-do-detailed-mode" class="headerlink" title="6.3.2 do_detailed_mode"></a>6.3.2 <code>do_detailed_mode</code></h5><p><code>do_detailed_mode</code>函数用于解析<code>Timing Descriptor</code>，创建显示模式并添加到<code>connector</code>的 <code>probed_modes</code> 链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_detailed_mode(<span class="keyword">const</span> struct detailed_timing *timing, <span class="keyword">void</span> *c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> *<span class="title">closure</span> = <span class="title">c</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是Timing Descriptor，将跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!is_detailed_timing_descriptor(timing))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析Timing Descriptor 此对于我使用的HDMI显示器，只有前3个块可以走到这一步</span></span><br><span class="line">        newmode = drm_mode_detailed(closure-&gt;connector,</span><br><span class="line">                                    closure-&gt;drm_edid, timing);</span><br><span class="line">        <span class="keyword">if</span> (!newmode)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个Timing Descriptor会进入，其他的不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (closure-&gt;preferred)</span><br><span class="line">                newmode-&gt;type |= DRM_MODE_TYPE_PREFERRED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Detailed modes are limited to 10kHz pixel clock resolution,</span></span><br><span class="line"><span class="comment">         * so fix up anything that looks like CEA/HDMI mode, but the clock</span></span><br><span class="line"><span class="comment">         * is just slightly off.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fixup_detailed_cea_mode_clock(closure-&gt;connector, newmode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list_add_tail(&amp;mode-&gt;head, &amp;connector-&gt;probed_modes);</span></span><br><span class="line">        drm_mode_probed_add(closure-&gt;connector, newmode);</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        closure-&gt;modes++;</span><br><span class="line">        <span class="comment">// 清除标志位</span></span><br><span class="line">        closure-&gt;preferred = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个函数的核心为<code>drm_mode_detailed</code>。</p>
<h5 id="6-3-3-drm-mode-detailed"><a href="#6-3-3-drm-mode-detailed" class="headerlink" title="6.3.3 drm_mode_detailed"></a>6.3.3 <code>drm_mode_detailed</code></h5><p><code>drm_mode_detailed</code>函数定义如下，下面我们以第一个<code>Timing Descriptor</code>为例进行分析该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a new mode from an EDID detailed timing section. An EDID detailed</span></span><br><span class="line"><span class="comment"> * timing block contains enough info for us to create and return a new struct</span></span><br><span class="line"><span class="comment"> * drm_display_mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct drm_display_mode *<span class="title">drm_mode_detailed</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">const</span> struct drm_edid *drm_edid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">const</span> struct detailed_timing *timing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 获取显示信息</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> *<span class="title">info</span> = &amp;<span class="title">connector</span>-&gt;<span class="title">display_info</span>;</span></span><br><span class="line">        <span class="comment">// 获取drm设备</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">connector</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">mode</span>;</span></span><br><span class="line">        <span class="comment">// 时序参数</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">detailed_pixel_timing</span> *<span class="title">pt</span> = &amp;<span class="title">timing</span>-&gt;<span class="title">data</span>.<span class="title">pixel_data</span>;</span></span><br><span class="line">        <span class="comment">// 水平活动像素高4位 | 水平活动像素低8位 = 2560 Pixels</span></span><br><span class="line">        <span class="keyword">unsigned</span> hactive = (pt-&gt;hactive_hblank_hi &amp; <span class="number">0xf0</span>) &lt;&lt; <span class="number">4</span> | pt-&gt;hactive_lo;</span><br><span class="line">        <span class="comment">// 垂直活动像素高4位 | 水平活动像素低8位 = 1440 Lines</span></span><br><span class="line">        <span class="keyword">unsigned</span> vactive = (pt-&gt;vactive_vblank_hi &amp; <span class="number">0xf0</span>) &lt;&lt; <span class="number">4</span> | pt-&gt;vactive_lo;</span><br><span class="line">        <span class="comment">// 水平blanking高4位 | 水平blanking低8位 = 160 Pixels</span></span><br><span class="line">        <span class="keyword">unsigned</span> hblank = (pt-&gt;hactive_hblank_hi &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">8</span> | pt-&gt;hblank_lo;</span><br><span class="line">        <span class="comment">// 垂直blanking高4位 | 水平blanking低8位 = 41 Lines</span></span><br><span class="line">        <span class="keyword">unsigned</span> vblank = (pt-&gt;vactive_vblank_hi &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">8</span> | pt-&gt;vblank_lo;</span><br><span class="line">        <span class="comment">// 水平同步信号偏移量 = 48 Pixels</span></span><br><span class="line">        <span class="keyword">unsigned</span> hsync_offset = (pt-&gt;hsync_vsync_offset_pulse_width_hi &amp; <span class="number">0xc0</span>) &lt;&lt; <span class="number">2</span> | pt-&gt;hsync_offset_lo;</span><br><span class="line">        <span class="comment">// 水平同步信号脉冲宽度 = 32 Pixels</span></span><br><span class="line">        <span class="keyword">unsigned</span> hsync_pulse_width = (pt-&gt;hsync_vsync_offset_pulse_width_hi &amp; <span class="number">0x30</span>) &lt;&lt; <span class="number">4</span> | pt-&gt;hsync_pulse_width_lo;</span><br><span class="line">        <span class="comment">// 垂直同步信号偏移量 = 3 Lines</span></span><br><span class="line">        <span class="keyword">unsigned</span> vsync_offset = (pt-&gt;hsync_vsync_offset_pulse_width_hi &amp; <span class="number">0xc</span>) &lt;&lt; <span class="number">2</span> | pt-&gt;vsync_offset_pulse_width_lo &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 垂直同步信号脉冲宽度 = 5 Lines</span></span><br><span class="line">        <span class="keyword">unsigned</span> vsync_pulse_width = (pt-&gt;hsync_vsync_offset_pulse_width_hi &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span> | (pt-&gt;vsync_offset_pulse_width_lo &amp; <span class="number">0xf</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ignore tiny modes，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (hactive &lt; <span class="number">64</span> || vactive &lt; <span class="number">64</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  标志位 配置了立体 0x1A&amp;1&lt;&lt;5=0, 所以跳过</span></span><br><span class="line">        <span class="keyword">if</span> (pt-&gt;misc &amp; DRM_EDID_PT_STEREO) &#123;    <span class="comment">// 1&lt;&lt;5</span></span><br><span class="line">                drm_dbg_kms(dev, <span class="string">&quot;[CONNECTOR:%d:%s] Stereo mode not supported\n&quot;</span>,</span><br><span class="line">                            connector-&gt;base.id, connector-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标志位  配置了数字分离信号 0x1A&amp;0x3&lt;&lt;3=0x3&lt;&lt;3, 所以进入</span></span><br><span class="line">        <span class="keyword">if</span> (!(pt-&gt;misc &amp; DRM_EDID_PT_SEPARATE_SYNC)) &#123; <span class="comment">// 3&lt;&lt;3</span></span><br><span class="line">                drm_dbg_kms(dev, <span class="string">&quot;[CONNECTOR:%d:%s] Composite sync not supported\n&quot;</span>,</span><br><span class="line">                            connector-&gt;base.id, connector-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* it is incorrect if hsync/vsync width is zero，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (!hsync_pulse_width || !vsync_pulse_width) &#123;</span><br><span class="line">                drm_dbg_kms(dev, <span class="string">&quot;[CONNECTOR:%d:%s] Incorrect Detailed timing. Wrong Hsync/Vsync pulse width\n&quot;</span>,</span><br><span class="line">                            connector-&gt;base.id, connector-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_FORCE_REDUCED_BLANKING) &#123;  <span class="comment">// 1&lt;&lt;7</span></span><br><span class="line">                mode = drm_cvt_mode(dev, hactive, vactive, <span class="number">60</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (!mode)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">goto</span> set_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建显示模式，动态分配内存</span></span><br><span class="line">        mode = drm_mode_create(dev);</span><br><span class="line">        <span class="keyword">if</span> (!mode)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_135_CLOCK_TOO_HIGH)   <span class="comment">// 1&lt;&lt;1</span></span><br><span class="line">                mode-&gt;clock = <span class="number">1088</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 为TMDS时钟频率：串行数据速率是实际像素时钟速率的10倍 单位10KHz</span></span><br><span class="line">                mode-&gt;clock = le16_to_cpu(timing-&gt;pixel_clock) * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 行有效像素  2560 Pixels</span></span><br><span class="line">        mode-&gt;hdisplay = hactive;</span><br><span class="line">        <span class="comment">// 行同步起始像素  2560 + 48 = 2608 Pixels</span></span><br><span class="line">        mode-&gt;hsync_start = mode-&gt;hdisplay + hsync_offset;</span><br><span class="line">        <span class="comment">// 水平同步结束 2608 + 32 = 2640 Pixels</span></span><br><span class="line">        mode-&gt;hsync_end = mode-&gt;hsync_start + hsync_pulse_width;</span><br><span class="line">        <span class="comment">// 水平总大小 2560 + 160 = 2720 Pixels</span></span><br><span class="line">        mode-&gt;htotal = mode-&gt;hdisplay + hblank;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垂直显示大小 1440 Lines</span></span><br><span class="line">        mode-&gt;vdisplay = vactive;</span><br><span class="line">        <span class="comment">// 垂直同步起始 1440 + 3 = 1443 Lines</span></span><br><span class="line">        mode-&gt;vsync_start = mode-&gt;vdisplay + vsync_offset;</span><br><span class="line">        <span class="comment">// 帧同步结束行 1443 + 5 = 1448 Lines</span></span><br><span class="line">        mode-&gt;vsync_end = mode-&gt;vsync_start + vsync_pulse_width;</span><br><span class="line">        <span class="comment">// 一帧总行数 1440 + 41 = 1481 Lines</span></span><br><span class="line">        mode-&gt;vtotal = mode-&gt;vdisplay + vblank;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Some EDIDs have bogus h/vtotal values，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (mode-&gt;hsync_end &gt; mode-&gt;htotal)</span><br><span class="line">                mode-&gt;htotal = mode-&gt;hsync_end + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (mode-&gt;vsync_end &gt; mode-&gt;vtotal)</span><br><span class="line">                mode-&gt;vtotal = mode-&gt;vsync_end + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理交叉模式，对于当前Timing Descriptor 0x47位[7]为0，该函数直接返回</span></span><br><span class="line">        drm_mode_do_interlace_quirk(mode, pt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_DETAILED_SYNC_PP) &#123;  <span class="comment">// 1&lt;&lt;6</span></span><br><span class="line">                mode-&gt;flags |= DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mode-&gt;flags |= (pt-&gt;misc &amp; DRM_EDID_PT_HSYNC_POSITIVE) ?  <span class="comment">// 1&lt;&lt;1 DRM_MODE_FLAG_PHSYNC</span></span><br><span class="line">                        DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;</span><br><span class="line">                mode-&gt;flags |= (pt-&gt;misc &amp; DRM_EDID_PT_VSYNC_POSITIVE) ?  <span class="comment">// 1&lt;&lt;2 DRM_MODE_FLAG_NVSYNC</span></span><br><span class="line">                        DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">set_size:</span><br><span class="line">        <span class="comment">// 水平图像尺寸  697mm </span></span><br><span class="line">        mode-&gt;width_mm = pt-&gt;width_mm_lo | (pt-&gt;width_height_mm_hi &amp; <span class="number">0xf0</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 垂直图像尺寸  392mm</span></span><br><span class="line">        mode-&gt;height_mm = pt-&gt;height_mm_lo | (pt-&gt;width_height_mm_hi &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_DETAILED_IN_CM) &#123; <span class="comment">// 1&lt;&lt;3</span></span><br><span class="line">                mode-&gt;width_mm *= <span class="number">10</span>;</span><br><span class="line">                mode-&gt;height_mm *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (info-&gt;quirks &amp; EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE) &#123; <span class="comment">// 1&lt;&lt;4</span></span><br><span class="line">                mode-&gt;width_mm = drm_edid-&gt;edid-&gt;width_cm * <span class="number">10</span>;</span><br><span class="line">                mode-&gt;height_mm = drm_edid-&gt;edid-&gt;height_cm * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个标志位的位掩码，主要用于表示显示模式的来源；DRM_MODE_TYPE_DRIVER标识驱动程序创建的模式</span></span><br><span class="line">        mode-&gt;type = DRM_MODE_TYPE_DRIVER;</span><br><span class="line">        <span class="comment">// 设置显示模式的名称 %dx%d%s 第一个参数为：mode-&gt;hdisplay  第二个参数为：mode-&gt;vdisplay 第三个参数为：i/&#x27;&#x27;（取决于mode-&gt;flags是否设置了DRM_MODE_FLAG_INTERLACE）</span></span><br><span class="line">        drm_mode_set_name(mode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过分析，第一个<code>Timing Descriptor</code>时序参数如下;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  41  43  44  45  46  47 </span><br><span class="line">D3  BC  00  A0  A0  A0  29  50  30  20  35  00  B9  88  21  00  00  1A</span><br><span class="line"></span><br><span class="line">(54-71)      Detailed Descriptor #1: Preferred Detailed Timing (2560x1440 @ 120Hz)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">像素时钟/10000     <span class="variable">$&#123;0x36&#125;</span>|<span class="variable">$&#123;0x37&#125;</span>&lt;&lt;8=0xBCD3  ==&gt; 48339*10000/10^6 MHz</span></span><br><span class="line">Pixel Clock            : 483.39 MHz      </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 水平图像尺寸(width_mm)     (<span class="variable">$&#123;0x44&#125;</span>&amp;0xf0)&lt;&lt;4|<span class="variable">$&#123;0x42&#125;</span>=(0 x21&amp;0xf0)&lt;&lt;4|0xB9=0x2B9=697</span></span><br><span class="line">Horizontal Image Size  : 697 mm     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 垂直图像尺寸(height_mm)    (<span class="variable">$&#123;0x44&#125;</span>&amp;0x0f)&lt;&lt;8|<span class="variable">$&#123;0x43&#125;</span>=(0x21&amp;0x0f)&lt;&lt;8|0x88=0x188=392</span></span><br><span class="line">Vertical Image Size    : 392 mm</span><br><span class="line">Refresh Mode           : Non-interlaced </span><br><span class="line">Normal Display, No Stereo</span><br><span class="line"></span><br><span class="line">Horizontal:</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 水平活动像素数(hactive)                  (<span class="variable">$&#123;0x3A&#125;</span>&amp;0xf0)&lt;&lt;4|<span class="variable">$&#123;0x38&#125;</span>=(0xA0&amp;0xf0)&lt;&lt;4|0x00=0xA00=2560</span></span><br><span class="line">    Active Time     : 2560 Pixels</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 水平blanking(hblank)                     (<span class="variable">$&#123;0x3A&#125;</span>&amp;0x0f)&lt;&lt;4|<span class="variable">$&#123;0x39&#125;</span>=(0xA0&amp;0x0f)&lt;&lt;8|0xA0=160</span></span><br><span class="line">    Blanking Time   : 160 Pixels</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 水平同步信号偏移量(hsync_offset)         (<span class="variable">$&#123;0x41&#125;</span>&amp;0xc0)&lt;&lt;2|<span class="variable">$&#123;0x3E&#125;</span>=(0x00&amp;0xc0)&lt;&lt;2|0x30=48</span></span><br><span class="line">    Sync Offset     : 48 Pixels</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 水平同步信号脉冲宽度(hsync_pulse_width)  (<span class="variable">$&#123;0x41&#125;</span>&amp;0x30)&lt;&lt;4 |<span class="variable">$&#123;0x3F&#125;</span>=(0x00&amp;0x30)&lt;&lt;4|0x20=32</span></span><br><span class="line">    Sync Pulse Width: 32 Pixels</span><br><span class="line"><span class="meta">    #</span><span class="bash"> $(0x45)=0</span></span><br><span class="line">    Border          : 0 Pixels</span><br><span class="line">    Frequency       : 177 kHz</span><br><span class="line"></span><br><span class="line">Vertical:</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 垂直活动像素数(vactive)                 (<span class="variable">$&#123;0x3D&#125;</span>&amp;0xf0)&lt;&lt;4|<span class="variable">$&#123;0x3B&#125;</span>=(0x50&amp;0xf0)&lt;&lt;4|0xA0=0x5A0=1440</span></span><br><span class="line">    Active Time     : 1440 Lines</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 垂直blanking(vblank)                    (<span class="variable">$&#123;0x3D&#125;</span>&amp;0x0f)&lt;&lt;4|<span class="variable">$&#123;0x3C&#125;</span>=(0x50&amp;0x0f)&lt;&lt;8|0x29=0x29=41</span></span><br><span class="line">    Blanking Time   : 41 Lines</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 垂直同步信号偏移量(vsync_offset)        (<span class="variable">$&#123;0x41&#125;</span>&amp;0xc)&lt;&lt;2|<span class="variable">$&#123;0x40&#125;</span>&gt;&gt; 4=(0x00&amp;0xc)&lt;&lt;2|0x35&gt;&gt;4=3</span></span><br><span class="line">    Sync Offset     : 3 Lines</span><br><span class="line"><span class="meta">    #</span><span class="bash"> 垂直同步信号脉冲宽度(vsync_pulse_width) (<span class="variable">$&#123;0x41&#125;</span>&amp;0x03)&lt;&lt;4 |(<span class="variable">$&#123;0x40&#125;</span>&amp;0x0f)=(0x00&amp;0x03)&lt;&lt;4|(0x35&amp;0x0f)=5</span></span><br><span class="line">    Sync Pulse Width: 5 Lines</span><br><span class="line"><span class="meta">    #</span><span class="bash"> $(0x46)=0 </span></span><br><span class="line">    Border          : 0 Lines</span><br><span class="line"></span><br><span class="line">Digital Separate, Horizontal Polarity (+), Vertical Polarity (-)</span><br><span class="line">                              </span><br><span class="line">Modeline: &quot;2560x1440&quot; 483.390 2560 2608 2640 2720 1440 1443 1448 1481 +hsync -vsync</span><br></pre></td></tr></table></figure>

<p><code>Modeline</code>中表示的含义依次为<code>name</code>、<code>clock</code> (单位为<code>MHz</code>)、<code>hdisplay</code>、<code>hsync_start</code>、<code>hsync_end</code>、<code>htotal</code>、<code>vdisplay</code>、<code>vsync_start</code>、<code>vsync_end</code>、<code>vtotal</code>、<code>flag</code>，有关这些时序参数我们已经在《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17778170.html"><code>Rockchip RK3399 - DRM crtc</code>基础知识</a>》中详细介绍了；</p>
<p> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm08/img0.png" alt="img0"></p>
<p> <img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm08/img0.png" alt="img1"></p>
<p>这里我们在说一下刷新率<code>120Hz</code>是如何得到的：$$刷新率=\frac{像素时钟频率}{htotal_vtotal}=\frac{483390000}{2720_1481}=120$$，也就是说每秒刷新<code>120</code>帧图片。</p>
<h4 id="6-4-add-cvt-modes"><a href="#6-4-add-cvt-modes" class="headerlink" title="6.4 add_cvt_modes"></a>6.4 <code>add_cvt_modes</code></h4><p><code>add_cvt_modes</code>函数和<code>add_detailed_modes</code>类似，均是用于从<code>Detailed Timings</code>中获取显示模式，并添加到<code>connector</code>的 <code>probed_modes</code> 链表；只不过这个函数遍历<code>Detailed Timings</code>，依次执行的是<code>do_cvt_mode</code>，其基于<code>CVT</code>算法生成显示模式；</p>
<p>在介绍函数之前，我们简单来说一下什么是<code>CVT</code>，<code>CVT</code>算法是一种用于计算显示器显示模式参数的算法，使用计算出的参数来创建<code>Modeline</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">add_cvt_modes(struct drm_connector *connector, <span class="keyword">const</span> struct drm_edid *drm_edid)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> <span class="title">closure</span> = &#123;</span></span><br><span class="line">                .connector = connector,</span><br><span class="line">                .drm_edid = drm_edid,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入</span></span><br><span class="line">        <span class="keyword">if</span> (drm_edid-&gt;edid-&gt;revision &gt;= <span class="number">3</span>)</span><br><span class="line">                <span class="comment">// 遍历Detailed Timings，依次执行do_cvt_mode，对于我使用的HDMI显示器，实际上这里什么也不会做</span></span><br><span class="line">                drm_for_each_detailed_block(drm_edid, do_cvt_mode, &amp;closure);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX should also look for CVT codes in VTB blocks */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closure.modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-4-1-do-cvt-mode"><a href="#6-4-1-do-cvt-mode" class="headerlink" title="6.4.1 do_cvt_mode"></a>6.4.1 <code>do_cvt_mode</code></h5><p><code>do_cvt_mode</code>函数用于解析<code>EDID_DETAIL_CVT_3BYTE</code>类型的<code>Monitor Descriptor</code>，基于<code>CVT</code>算法创建显示模式并添加到<code>connector</code>的 <code>probed_modes</code> 链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_cvt_mode(<span class="keyword">const</span> struct detailed_timing *timing, <span class="keyword">void</span> *c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> *<span class="title">closure</span> = <span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是EDID_DETAIL_CVT_3BYTE类型的Monitor Descriptor,对于我使用的HDMI显示器，直接return</span></span><br><span class="line">        <span class="keyword">if</span> (!is_display_descriptor(timing, EDID_DETAIL_CVT_3BYTE))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        closure-&gt;modes += drm_cvt_modes(closure-&gt;connector, timing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我使用的<code>HDMI</code>显示器，只有最后一个块是<code>Monitor Descriptor</code>，但是其类型为<code>EDID_DETAIL_MONITOR_NAME</code>，因此不会执行<code>drm_cvt_modes</code>函数。但是不妨我们可以了解一下<code>drm_cvt_modes</code>。</p>
<h5 id="6-4-2-drm-cvt-modes"><a href="#6-4-2-drm-cvt-modes" class="headerlink" title="6.4.2 drm_cvt_modes"></a>6.4.2 <code>drm_cvt_modes</code></h5><p><code>drm_cvt_modes</code>函数定义如下；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drm_cvt_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> struct detailed_timing *timing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, modes = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">connector</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cvt_timing</span> *<span class="title">cvt</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rates[] = &#123; <span class="number">60</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">60</span>, <span class="number">50</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> u8 empty[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个cvt_timing</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> width, height;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取第i个cvt_timing</span></span><br><span class="line">                cvt = &amp;(timing-&gt;data.other_data.data.cvt[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果相等，continue</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(cvt-&gt;code, empty, <span class="number">3</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 计算visplay</span></span><br><span class="line">                height = (cvt-&gt;code[<span class="number">0</span>] + ((cvt-&gt;code[<span class="number">1</span>] &amp; <span class="number">0xf0</span>) &lt;&lt; <span class="number">4</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 计算hdisplay</span></span><br><span class="line">                <span class="keyword">switch</span> (cvt-&gt;code[<span class="number">1</span>] &amp; <span class="number">0x0c</span>) &#123;</span><br><span class="line">                <span class="comment">/* default - because compiler doesn&#x27;t see that we&#x27;ve enumerated all cases */</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">                        width = height * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">                        width = height * <span class="number">16</span> / <span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">                        width = height * <span class="number">16</span> / <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0c</span>:</span><br><span class="line">                        width = height * <span class="number">15</span> / <span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++) &#123;                    </span><br><span class="line">                        <span class="keyword">if</span> (cvt-&gt;code[<span class="number">2</span>] &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                                <span class="comment">// 创建显示模式</span></span><br><span class="line">                                newmode = drm_cvt_mode(dev, width, height,</span><br><span class="line">                                                       rates[j], j == <span class="number">0</span>,</span><br><span class="line">                                                       <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                                <span class="keyword">if</span> (newmode) &#123;</span><br><span class="line">                                        <span class="comment">// list_add_tail(&amp;mode-&gt;head, &amp;connector-&gt;probed_modes);</span></span><br><span class="line">                                        drm_mode_probed_add(connector, newmode);</span><br><span class="line">                                        modes++;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-4-3-drm-cvt-mode"><a href="#6-4-3-drm-cvt-mode" class="headerlink" title="6.4.3 drm_cvt_mode"></a>6.4.3 <code>drm_cvt_mode</code></h5><p><code>drm_cvt_mode</code>函数用于<code>create a modeline based on the CVT algorithm</code>，这个函数根据<code>hdisplay</code>、<code>vdisplay</code>和<code>vrefresh</code>调用<code>CVT</code>算法来生成<code>Modeline</code>。它基于<code>Graham Loveridge</code>于2003年4月9日编写的<code>VESA(TM) Coordinated Video Timing Generator</code>。</p>
<p>函数定义在<code>drivers/gpu/drm/drm_modes.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_cvt_mode -create a modeline based on the CVT algorithm</span></span><br><span class="line"><span class="comment"> * @dev: drm device</span></span><br><span class="line"><span class="comment"> * @hdisplay: hdisplay size</span></span><br><span class="line"><span class="comment"> * @vdisplay: vdisplay size</span></span><br><span class="line"><span class="comment"> * @vrefresh: vrefresh rate</span></span><br><span class="line"><span class="comment"> * @reduced: whether to use reduced blanking</span></span><br><span class="line"><span class="comment"> * @interlaced: whether to compute an interlaced mode</span></span><br><span class="line"><span class="comment"> * @margins: whether to add margins (borders)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called to generate the modeline based on CVT algorithm</span></span><br><span class="line"><span class="comment"> * according to the hdisplay, vdisplay, vrefresh.</span></span><br><span class="line"><span class="comment"> * It is based from the VESA(TM) Coordinated Video Timing Generator by</span></span><br><span class="line"><span class="comment"> * Graham Loveridge April 9, 2003 available at</span></span><br><span class="line"><span class="comment"> * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.</span></span><br><span class="line"><span class="comment"> * What I have done is to translate it by using integer calculation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> * The modeline based on the CVT algorithm stored in a drm_display_mode object.</span></span><br><span class="line"><span class="comment"> * The display mode object is allocated with drm_mode_create(). Returns NULL</span></span><br><span class="line"><span class="comment"> * when no mode could be allocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct drm_display_mode *<span class="title">drm_cvt_mode</span><span class="params">(struct drm_device *dev, <span class="keyword">int</span> hdisplay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> vdisplay, <span class="keyword">int</span> vrefresh,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">bool</span> reduced, <span class="keyword">bool</span> interlaced, <span class="keyword">bool</span> margins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HV_FACTOR                       1000</span></span><br><span class="line">        <span class="comment">/* 1) top/bottom margin size (% of height) - default: 1.8, */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_MARGIN_PERCENTAGE           18</span></span><br><span class="line">        <span class="comment">/* 2) character cell horizontal granularity (pixels) - default 8 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_H_GRANULARITY               8</span></span><br><span class="line">        <span class="comment">/* 3) Minimum vertical porch (lines) - default 3 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_MIN_V_PORCH                 3</span></span><br><span class="line">        <span class="comment">/* 4) Minimum number of vertical back porch lines - default 6 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_MIN_V_BPORCH                6</span></span><br><span class="line">        <span class="comment">/* Pixel Clock step (kHz) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_CLOCK_STEP                  250</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">drm_mode</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vfieldrate, hperiod;</span><br><span class="line">        <span class="keyword">int</span> hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;</span><br><span class="line">        <span class="keyword">int</span> interlace;</span><br><span class="line">        u64 tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hdisplay || !vdisplay)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allocate the drm_display_mode structure. If failure, we will</span></span><br><span class="line"><span class="comment">         * return directly</span></span><br><span class="line"><span class="comment">        drm_mode = drm_mode_create(dev);</span></span><br><span class="line"><span class="comment">        if (!drm_mode)</span></span><br><span class="line"><span class="comment">                return NULL;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        /* the CVT default refresh rate is 60Hz */</span></span><br><span class="line">        <span class="keyword">if</span> (!vrefresh)</span><br><span class="line">                vrefresh = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the required field fresh rate */</span></span><br><span class="line">        <span class="keyword">if</span> (interlaced)</span><br><span class="line">                vfieldrate = vrefresh * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                vfieldrate = vrefresh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* horizontal pixels */</span></span><br><span class="line">        hdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* determine the left&amp;right borders */</span></span><br><span class="line">        hmargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (margins) &#123;</span><br><span class="line">                hmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / <span class="number">1000</span>;</span><br><span class="line">                hmargin -= hmargin % CVT_H_GRANULARITY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* find the total active pixels */</span></span><br><span class="line">        drm_mode-&gt;hdisplay = hdisplay_rnd + <span class="number">2</span> * hmargin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find the number of lines per field */</span></span><br><span class="line">        <span class="keyword">if</span> (interlaced)</span><br><span class="line">                vdisplay_rnd = vdisplay / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                vdisplay_rnd = vdisplay;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find the top &amp; bottom borders */</span></span><br><span class="line">        vmargin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (margins)</span><br><span class="line">                vmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        drm_mode-&gt;vdisplay = vdisplay + <span class="number">2</span> * vmargin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Interlaced */</span></span><br><span class="line">        <span class="keyword">if</span> (interlaced)</span><br><span class="line">                interlace = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                interlace = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Determine VSync Width from aspect ratio */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vdisplay % <span class="number">3</span>) &amp;&amp; ((vdisplay * <span class="number">4</span> / <span class="number">3</span>) == hdisplay))</span><br><span class="line">                vsync = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(vdisplay % <span class="number">9</span>) &amp;&amp; ((vdisplay * <span class="number">16</span> / <span class="number">9</span>) == hdisplay))</span><br><span class="line">                vsync = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(vdisplay % <span class="number">10</span>) &amp;&amp; ((vdisplay * <span class="number">16</span> / <span class="number">10</span>) == hdisplay))</span><br><span class="line">                vsync = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(vdisplay % <span class="number">4</span>) &amp;&amp; ((vdisplay * <span class="number">5</span> / <span class="number">4</span>) == hdisplay))</span><br><span class="line">                vsync = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(vdisplay % <span class="number">9</span>) &amp;&amp; ((vdisplay * <span class="number">15</span> / <span class="number">9</span>) == hdisplay))</span><br><span class="line">                vsync = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* custom */</span></span><br><span class="line">                vsync = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!reduced) &#123;</span><br><span class="line">                <span class="comment">/* simplify the GTF calculation */</span></span><br><span class="line">                <span class="comment">/* 4) Minimum time of vertical sync + back porch interval (µs)</span></span><br><span class="line"><span class="comment">                 * default 550.0</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> tmp1, tmp2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_MIN_VSYNC_BP        550</span></span><br><span class="line">                <span class="comment">/* 3) Nominal HSync width (% of line period) - default 8 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_HSYNC_PERCENTAGE    8</span></span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> hblank_percentage;</span><br><span class="line">                <span class="keyword">int</span> vsyncandback_porch, __maybe_unused vback_porch, hblank;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* estimated the horizontal period */</span></span><br><span class="line">                tmp1 = HV_FACTOR * <span class="number">1000000</span>  -</span><br><span class="line">                                CVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;</span><br><span class="line">                tmp2 = (vdisplay_rnd + <span class="number">2</span> * vmargin + CVT_MIN_V_PORCH) * <span class="number">2</span> +</span><br><span class="line">                                interlace;</span><br><span class="line">                hperiod = tmp1 * <span class="number">2</span> / (tmp2 * vfieldrate);</span><br><span class="line"></span><br><span class="line">                tmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* 9. Find number of lines in sync + backporch */</span></span><br><span class="line">                <span class="keyword">if</span> (tmp1 &lt; (vsync + CVT_MIN_V_PORCH))</span><br><span class="line">                        vsyncandback_porch = vsync + CVT_MIN_V_PORCH;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        vsyncandback_porch = tmp1;</span><br><span class="line">                <span class="comment">/* 10. Find number of lines in back porch */</span></span><br><span class="line">                vback_porch = vsyncandback_porch - vsync;</span><br><span class="line">                drm_mode-&gt;vtotal = vdisplay_rnd + <span class="number">2</span> * vmargin +</span><br><span class="line">                                vsyncandback_porch + CVT_MIN_V_PORCH;</span><br><span class="line">                <span class="comment">/* 5) Definition of Horizontal blanking time limitation */</span></span><br><span class="line">                <span class="comment">/* Gradient (%/kHz) - default 600 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_M_FACTOR    600</span></span><br><span class="line">                <span class="comment">/* Offset (%) - default 40 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_C_FACTOR    40</span></span><br><span class="line">                <span class="comment">/* Blanking time scaling factor - default 128 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_K_FACTOR    128</span></span><br><span class="line">                <span class="comment">/* Scaling factor weighting - default 20 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_J_FACTOR    20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_M_PRIME     (CVT_M_FACTOR * CVT_K_FACTOR / 256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CVT_C_PRIME     ((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \</span></span><br><span class="line">                         CVT_J_FACTOR)</span><br><span class="line">                <span class="comment">/* 12. Find ideal blanking duty cycle from formula */</span></span><br><span class="line">                hblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *</span><br><span class="line">                                        hperiod / <span class="number">1000</span>;</span><br><span class="line">                <span class="comment">/* 13. Blanking time */</span></span><br><span class="line">                <span class="keyword">if</span> (hblank_percentage &lt; <span class="number">20</span> * HV_FACTOR)</span><br><span class="line">                        hblank_percentage = <span class="number">20</span> * HV_FACTOR;</span><br><span class="line">                hblank = drm_mode-&gt;hdisplay * hblank_percentage /</span><br><span class="line">                         (<span class="number">100</span> * HV_FACTOR - hblank_percentage);</span><br><span class="line">                hblank -= hblank % (<span class="number">2</span> * CVT_H_GRANULARITY);</span><br><span class="line">                <span class="comment">/* 14. find the total pixels per line */</span></span><br><span class="line">                drm_mode-&gt;htotal = drm_mode-&gt;hdisplay + hblank;</span><br><span class="line">                drm_mode-&gt;hsync_end = drm_mode-&gt;hdisplay + hblank / <span class="number">2</span>;</span><br><span class="line">                drm_mode-&gt;hsync_start = drm_mode-&gt;hsync_end -</span><br><span class="line">                        (drm_mode-&gt;htotal * CVT_HSYNC_PERCENTAGE) / <span class="number">100</span>;</span><br><span class="line">                drm_mode-&gt;hsync_start += CVT_H_GRANULARITY -</span><br><span class="line">                        drm_mode-&gt;hsync_start % CVT_H_GRANULARITY;</span><br><span class="line">                <span class="comment">/* fill the Vsync values */</span></span><br><span class="line">                drm_mode-&gt;vsync_start = drm_mode-&gt;vdisplay + CVT_MIN_V_PORCH;</span><br><span class="line">                drm_mode-&gt;vsync_end = drm_mode-&gt;vsync_start + vsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Reduced blanking */</span></span><br><span class="line">                <span class="comment">/* Minimum vertical blanking interval time (µs)- default 460 */</span></span><br><span class="line">#define CVT_RB_MIN_VBLANK       <span class="number">460</span></span><br><span class="line">                <span class="comment">/* Fixed number of clocks for horizontal sync */</span></span><br><span class="line">#define CVT_RB_H_SYNC           <span class="number">32</span></span><br><span class="line">                <span class="comment">/* Fixed number of clocks for horizontal blanking */</span></span><br><span class="line">#define CVT_RB_H_BLANK          <span class="number">160</span></span><br><span class="line">                <span class="comment">/* Fixed number of lines for vertical front porch - default 3*/</span></span><br><span class="line">#define CVT_RB_VFPORCH          <span class="number">3</span></span><br><span class="line">                <span class="keyword">int</span> vbilines;</span><br><span class="line">                <span class="keyword">int</span> tmp1, tmp2;</span><br><span class="line">                <span class="comment">/* 8. Estimate Horizontal period. */</span></span><br><span class="line">                tmp1 = HV_FACTOR * <span class="number">1000000</span> -</span><br><span class="line">                        CVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;</span><br><span class="line">                tmp2 = vdisplay_rnd + <span class="number">2</span> * vmargin;</span><br><span class="line">                hperiod = tmp1 / (tmp2 * vfieldrate);</span><br><span class="line">                <span class="comment">/* 9. Find number of lines in vertical blanking */</span></span><br><span class="line">                vbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* 10. Check if vertical blanking is sufficient */</span></span><br><span class="line">                <span class="keyword">if</span> (vbilines &lt; (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))</span><br><span class="line">                        vbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;</span><br><span class="line">                <span class="comment">/* 11. Find total number of lines in vertical field */</span></span><br><span class="line">                drm_mode-&gt;vtotal = vdisplay_rnd + <span class="number">2</span> * vmargin + vbilines;</span><br><span class="line">                <span class="comment">/* 12. Find total number of pixels in a line */</span></span><br><span class="line">                drm_mode-&gt;htotal = drm_mode-&gt;hdisplay + CVT_RB_H_BLANK;</span><br><span class="line">                <span class="comment">/* Fill in HSync values */</span></span><br><span class="line">                drm_mode-&gt;hsync_end = drm_mode-&gt;hdisplay + CVT_RB_H_BLANK / <span class="number">2</span>;</span><br><span class="line">                drm_mode-&gt;hsync_start = drm_mode-&gt;hsync_end - CVT_RB_H_SYNC;</span><br><span class="line">                <span class="comment">/* Fill in VSync values */</span></span><br><span class="line">                drm_mode-&gt;vsync_start = drm_mode-&gt;vdisplay + CVT_RB_VFPORCH;</span><br><span class="line">                drm_mode-&gt;vsync_end = drm_mode-&gt;vsync_start + vsync;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 15/13. Find pixel clock frequency (kHz for xf86) */</span></span><br><span class="line">        tmp = drm_mode-&gt;htotal; <span class="comment">/* perform intermediate calcs in u64 */</span></span><br><span class="line">        tmp *= HV_FACTOR * <span class="number">1000</span>;</span><br><span class="line">        do_div(tmp, hperiod);</span><br><span class="line">        tmp -= drm_mode-&gt;clock % CVT_CLOCK_STEP;</span><br><span class="line">        drm_mode-&gt;clock = tmp;</span><br><span class="line">        <span class="comment">/* 18/16. Find actual vertical frame frequency */</span></span><br><span class="line">        <span class="comment">/* ignore - just set the mode flag for interlaced */</span></span><br><span class="line">        <span class="keyword">if</span> (interlaced) &#123;</span><br><span class="line">                drm_mode-&gt;vtotal *= <span class="number">2</span>;</span><br><span class="line">                drm_mode-&gt;flags |= DRM_MODE_FLAG_INTERLACE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Fill the mode line name */</span></span><br><span class="line">        drm_mode_set_name(drm_mode);</span><br><span class="line">        <span class="keyword">if</span> (reduced)</span><br><span class="line">                drm_mode-&gt;flags |= (DRM_MODE_FLAG_PHSYNC |</span><br><span class="line">                                        DRM_MODE_FLAG_NVSYNC);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                drm_mode-&gt;flags |= (DRM_MODE_FLAG_PVSYNC |</span><br><span class="line">                                        DRM_MODE_FLAG_NHSYNC);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> drm_mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-add-standard-modes"><a href="#6-5-add-standard-modes" class="headerlink" title="6.5 add_standard_modes"></a>6.5 <code>add_standard_modes</code></h4><p><code>add_standard_modes</code>函数用于从<code>Standard Timings</code>中获取显示模式，并添加到<code>connector</code>的 <code>probed_modes</code> 链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get standard modes from EDID and add them. Standard modes can be calculated</span></span><br><span class="line"><span class="comment"> * using the appropriate standard (DMT, GTF, or CVT). Grab them from EDID and</span></span><br><span class="line"><span class="comment"> * add them to the list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_standard_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, modes = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> <span class="title">closure</span> = &#123;</span></span><br><span class="line">                .connector = connector,</span><br><span class="line">                .drm_edid = drm_edid,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i&lt;8 循环8次，遍历每一个Standard Timing</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; EDID_STD_TIMINGS; i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line">                <span class="comment">// 解析每一个Standard Timing</span></span><br><span class="line">                newmode = drm_mode_std(connector, drm_edid,</span><br><span class="line">                                       &amp;drm_edid-&gt;edid-&gt;standard_timings[i]);</span><br><span class="line">                <span class="keyword">if</span> (newmode) &#123;</span><br><span class="line">                        drm_mode_probed_add(connector, newmode);</span><br><span class="line">                        modes++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入</span></span><br><span class="line">        <span class="keyword">if</span> (drm_edid-&gt;edid-&gt;revision &gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 遍历Detailed Timings，依次执行do_standard_modes，对于我使用的HDMI显示器，实际上这里什么也不会做</span></span><br><span class="line">                drm_for_each_detailed_block(drm_edid, do_standard_modes,</span><br><span class="line">                                            &amp;closure);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX should also look for standard codes in VTB blocks */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modes + closure.modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-1-Standard-Timings信息"><a href="#6-5-1-Standard-Timings信息" class="headerlink" title="6.5.1 Standard Timings信息"></a>6.5.1 <code>Standard Timings</code>信息</h5><p>以我使用的<code>HDMI</code>显示器为例，<code>Standard Timings</code>信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(38-53)      Standard Timings</span><br><span class="line"></span><br><span class="line">            1152x864 @ 60 Hz (4:3 Aspect Ratio)</span><br><span class="line">            1280x720 @ 60 Hz (16:9 Aspect Ratio)</span><br><span class="line">            1280x1024 @ 60 Hz (5:4 Aspect Ratio)</span><br><span class="line">            1440x900 @ 60 Hz (16:10 Aspect Ratio)</span><br><span class="line">            1600x900 @ 60 Hz (16:9 Aspect Ratio)</span><br><span class="line">            1680x1050 @ 60 Hz (16:10 Aspect Ratio)</span><br><span class="line">            1920x1080 @ 60 Hz (16:9 Aspect Ratio)</span><br><span class="line">            1920x1200 @ 60 Hz (16:10 Aspect Ratio)</span><br></pre></td></tr></table></figure>

<h5 id="6-5-2-drm-mode-std"><a href="#6-5-2-drm-mode-std" class="headerlink" title="6.5.2 drm_mode_std"></a>6.5.2 <code>drm_mode_std</code></h5><p><code>drm_mode_std</code>函数定义如下，该函数使用<code>CVT</code>/<code>GTF</code>/<code>DMT</code>算法将<code>Standard Timing</code>（在这种情况下是宽度、<code>Aspect Ratio</code>和刷新率）转换为实际的模式。</p>
<p>下面我们以第一个<code>Standard Timing</code>（两个字节为<code>0x71 0x40</code>）为例进行分析该函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Take the standard timing params (in this case width, aspect, and refresh)</span></span><br><span class="line"><span class="comment"> * and convert them into a real mode using CVT/GTF/DMT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct drm_display_mode *<span class="title">drm_mode_std</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> struct drm_edid *drm_edid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> struct std_timing *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">connector</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">m</span>, *<span class="title">mode</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">int</span> hsize, vsize;</span><br><span class="line">        <span class="keyword">int</span> vrefresh_rate;</span><br><span class="line">        <span class="comment">// (0x40 &amp; 3&lt;&lt;6)&gt;&gt;6=1</span></span><br><span class="line">        <span class="keyword">unsigned</span> aspect_ratio = (t-&gt;vfreq_aspect &amp; EDID_TIMING_ASPECT_MASK) </span><br><span class="line">                &gt;&gt; EDID_TIMING_ASPECT_SHIFT;</span><br><span class="line">        <span class="comment">// (0x40 &amp; 3f&lt;&lt;0)&gt;&gt;0=0</span></span><br><span class="line">        <span class="keyword">unsigned</span> vfreq = (t-&gt;vfreq_aspect &amp; EDID_TIMING_VFREQ_MASK)</span><br><span class="line">                &gt;&gt; EDID_TIMING_VFREQ_SHIFT;</span><br><span class="line">        <span class="comment">// 根据edid-&gt;revision来判定，应该返回LEVEL_GTF，其值为1</span></span><br><span class="line">        <span class="keyword">int</span> timing_level = standard_timing_level(drm_edid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">        <span class="keyword">if</span> (bad_std_timing(t-&gt;hsize, t-&gt;vfreq_aspect))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* According to the EDID spec, the hdisplay = hsize * 8 + 248 = 0x71*8+248=1152 */</span></span><br><span class="line">        hsize = t-&gt;hsize * <span class="number">8</span> + <span class="number">248</span>;</span><br><span class="line">        <span class="comment">/* vrefresh_rate = vfreq + 60 = 0+60=60 */</span></span><br><span class="line">        vrefresh_rate = vfreq + <span class="number">60</span>;</span><br><span class="line">        <span class="comment">/* the vdisplay is calculated based on the aspect ratio */</span></span><br><span class="line">        <span class="keyword">if</span> (aspect_ratio == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (drm_edid-&gt;edid-&gt;revision &lt; <span class="number">3</span>)</span><br><span class="line">                        vsize = hsize;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        vsize = (hsize * <span class="number">10</span>) / <span class="number">16</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aspect_ratio == <span class="number">1</span>) <span class="comment">// 走这里 1152*3/4=864</span></span><br><span class="line">                vsize = (hsize * <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aspect_ratio == <span class="number">2</span>)</span><br><span class="line">                vsize = (hsize * <span class="number">4</span>) / <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                vsize = (hsize * <span class="number">9</span>) / <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* HDTV hack, part 1，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (vrefresh_rate == <span class="number">60</span> &amp;&amp;</span><br><span class="line">            ((hsize == <span class="number">1360</span> &amp;&amp; vsize == <span class="number">765</span>) ||</span><br><span class="line">             (hsize == <span class="number">1368</span> &amp;&amp; vsize == <span class="number">769</span>))) &#123;</span><br><span class="line">                hsize = <span class="number">1366</span>;</span><br><span class="line">                vsize = <span class="number">768</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If this connector already has a mode for this size and refresh</span></span><br><span class="line"><span class="comment">         * rate (because it came from detailed or CVT info), use that</span></span><br><span class="line"><span class="comment">         * instead.  This way we don&#x27;t have to guess at interlace or</span></span><br><span class="line"><span class="comment">         * reduced blanking. 如果此连接器已经具有适合该尺寸和刷新率的模式，则使用该模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list_for_each_entry(m, &amp;connector-&gt;probed_modes, head)</span><br><span class="line">                <span class="keyword">if</span> (m-&gt;hdisplay == hsize &amp;&amp; m-&gt;vdisplay == vsize &amp;&amp;</span><br><span class="line">                    drm_mode_vrefresh(m) == vrefresh_rate)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* HDTV hack, part 2，跳过 */</span></span><br><span class="line">        <span class="keyword">if</span> (hsize == <span class="number">1366</span> &amp;&amp; vsize == <span class="number">768</span> &amp;&amp; vrefresh_rate == <span class="number">60</span>) &#123;</span><br><span class="line">                mode = drm_cvt_mode(dev, <span class="number">1366</span>, <span class="number">768</span>, vrefresh_rate, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                    <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (!mode)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                mode-&gt;hdisplay = <span class="number">1366</span>;</span><br><span class="line">                mode-&gt;hsync_start = mode-&gt;hsync_start - <span class="number">1</span>;</span><br><span class="line">                mode-&gt;hsync_end = mode-&gt;hsync_end - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> mode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check whether it can be found in default mode table，支持rb，进入 */</span></span><br><span class="line">        <span class="keyword">if</span> (drm_monitor_supports_rb(drm_edid)) &#123;</span><br><span class="line">                <span class="comment">// 遍历DMT模式列表，查找与给定参数匹配的显示模式（最后一个参数指明需要减少空白）</span></span><br><span class="line">                mode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate,</span><br><span class="line">                                         <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// NULL</span></span><br><span class="line">                <span class="keyword">if</span> (mode)</span><br><span class="line">                        <span class="keyword">return</span> mode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历DMT模式列表，查找与给定参数匹配的显示模式（最后一个参数指明不需要减少空白）</span></span><br><span class="line">        mode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">if</span> (mode)</span><br><span class="line">                <span class="keyword">return</span> mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* okay, generate it */</span></span><br><span class="line">        <span class="keyword">switch</span> (timing_level) &#123;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_DMT:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_GTF: <span class="comment">// 进入 create the modeline based on the GTF algorithm，有关GTF算法咱们就深究了</span></span><br><span class="line">                mode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_GTF2:</span><br><span class="line">                mode = drm_gtf2_mode(dev, drm_edid, hsize, vsize, vrefresh_rate);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEVEL_CVT: <span class="comment">// create a modeline based on the CVT algorithm</span></span><br><span class="line">                mode = drm_cvt_mode(dev, hsize, vsize, vrefresh_rate, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                    <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>drm_mode_find_dmt</code>函数会遍历<code>DMT</code>模式列表，查找与给定参数匹配的显示模式，并为之创建一个副本；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drm_mode_find_dmt - Create a copy of a mode if present in DMT</span></span><br><span class="line"><span class="comment"> * @dev: Device to duplicate against</span></span><br><span class="line"><span class="comment"> * @hsize: Mode width</span></span><br><span class="line"><span class="comment"> * @vsize: Mode height</span></span><br><span class="line"><span class="comment"> * @fresh: Mode refresh rate</span></span><br><span class="line"><span class="comment"> * @rb: Mode reduced-blanking-ness</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Walk the DMT mode list looking for a match for the given parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: A newly allocated copy of the mode, or NULL if not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct drm_display_mode *<span class="title">drm_mode_find_dmt</span><span class="params">(struct drm_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">int</span> hsize, <span class="keyword">int</span> vsize, <span class="keyword">int</span> fresh,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">bool</span> rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历drm_dmt_modes数组，该数组保存了一组标准显示模式参数，比如640x350@60Hz、800x600@60Hz、1280x800@60Hz等</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(drm_dmt_modes); i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">ptr</span> = &amp;<span class="title">drm_dmt_modes</span>[<span class="title">i</span>];</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 行有效像素匹配 1152</span></span><br><span class="line">                <span class="keyword">if</span> (hsize != ptr-&gt;hdisplay)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 帧有效行匹配 864</span></span><br><span class="line">                <span class="keyword">if</span> (vsize != ptr-&gt;vdisplay)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 刷新率匹配</span></span><br><span class="line">                <span class="keyword">if</span> (fresh != drm_mode_vrefresh(ptr))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// rb匹配</span></span><br><span class="line">                <span class="keyword">if</span> (rb != mode_is_rb(ptr))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 拷贝副本</span></span><br><span class="line">                <span class="keyword">return</span> drm_mode_duplicate(dev, ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们简单介绍一下最后一个参数：</p>
<ul>
<li><p><code>Mode reduced-blanking-ness</code>：指的是显示模式的减少空白程度。在视频显示中，每个帧都由可见区域和空白区域组成。可见区域是实际显示图像的部分，而空白区域是没有显示图像的部分。减少空白指的是减少空白区域的时间，从而提高帧率或提供更多的可见图像信息。通过减少空白时间，可以增加视频的连续性和流畅性。</p>
<p>比如<code>drm_dmt_modes</code>中的项<code>1280x768@60Hz RB</code>，<code>1280x768@60Hz</code>，可以看到<code>1280x768@60Hz RB</code>的<code>htotal</code>、<code>vtoatl</code>是远小于<code>1280x768@60Hz</code>，因此其空白区域要小很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0x16 - 1280x768@60Hz RB */</span></span><br><span class="line">&#123; DRM_MODE(<span class="string">&quot;1280x768&quot;</span>, DRM_MODE_TYPE_DRIVER, <span class="number">68250</span>, <span class="number">1280</span>, <span class="number">1328</span>,</span><br><span class="line">           <span class="number">1360</span>, <span class="number">1440</span>, <span class="number">0</span>, <span class="number">768</span>, <span class="number">771</span>, <span class="number">778</span>, <span class="number">790</span>, <span class="number">0</span>,  <span class="comment">// 1280+160=1440、768+22=790</span></span><br><span class="line">           DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) &#125;,</span><br><span class="line"><span class="comment">/* 0x17 - 1280x768@60Hz */</span></span><br><span class="line">&#123; DRM_MODE(<span class="string">&quot;1280x768&quot;</span>, DRM_MODE_TYPE_DRIVER, <span class="number">79500</span>, <span class="number">1280</span>, <span class="number">1344</span>,</span><br><span class="line">           <span class="number">1472</span>, <span class="number">1664</span>, <span class="number">0</span>, <span class="number">768</span>, <span class="number">771</span>, <span class="number">778</span>, <span class="number">798</span>, <span class="number">0</span>,    <span class="comment">// 1280 + 384 = 1664、768 + 30 = 798</span></span><br><span class="line">           DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) &#125;,</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>函数执行完，实际上我们在<code>drm_dmt_modes</code>中无法找到匹配项，不过可以找到一个接近的项<code>1152x864@75Hz</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0x15 - 1152x864@75Hz */</span></span><br><span class="line">&#123; DRM_MODE(<span class="string">&quot;1152x864&quot;</span>, DRM_MODE_TYPE_DRIVER, <span class="number">108000</span>, <span class="number">1152</span>, <span class="number">1216</span>,</span><br><span class="line">           <span class="number">1344</span>, <span class="number">1600</span>, <span class="number">0</span>, <span class="number">864</span>, <span class="number">865</span>, <span class="number">868</span>, <span class="number">900</span>, <span class="number">0</span>,</span><br><span class="line">           DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) &#125;,</span><br></pre></td></tr></table></figure>

<p>我们在下一篇文章会介绍如何新增分辨率时序<code>1152x864@60Hz</code>。</p>
<h5 id="6-5-3-do-standard-modes"><a href="#6-5-3-do-standard-modes" class="headerlink" title="6.5.3 do_standard_modes"></a>6.5.3 <code>do_standard_modes</code></h5><p><code>do_standard_modes</code>函数用于解析<code>EDID_DETAIL_STD_MODES</code>类型的<code>Monitor Descriptor</code>，并添加到<code>connector</code>的 <code>probed_modes</code> 链表，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">do_standard_modes(<span class="keyword">const</span> struct detailed_timing *timing, <span class="keyword">void</span> *c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> *<span class="title">closure</span> = <span class="title">c</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">detailed_non_pixel</span> *<span class="title">data</span> = &amp;<span class="title">timing</span>-&gt;<span class="title">data</span>.<span class="title">other_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span> = <span class="title">closure</span>-&gt;<span class="title">connector</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是EDID_DETAIL_STD_MODES类型的Monitor Descriptor，对于我使用的HDMI显示器，直接return</span></span><br><span class="line">        <span class="keyword">if</span> (!is_display_descriptor(timing, EDID_DETAIL_STD_MODES))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个std_timing</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取第i个std_timing</span></span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">std_timing</span> *<span class="title">std</span> = &amp;<span class="title">data</span>-&gt;<span class="title">data</span>.<span class="title">timings</span>[<span class="title">i</span>];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建显示模式，这个函数上面已经介绍过了</span></span><br><span class="line">                newmode = drm_mode_std(connector, closure-&gt;drm_edid, <span class="built_in">std</span>);</span><br><span class="line">                <span class="keyword">if</span> (newmode) &#123;</span><br><span class="line">                        drm_mode_probed_add(connector, newmode);</span><br><span class="line">                        closure-&gt;modes++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我使用的<code>HDMI</code>显示器，只有最后一个块是<code>Monitor Descriptor</code>，但是其类型为<code>EDID_DETAIL_MONITOR_NAME</code>，因此不会执行<code>drm_mode_std</code>函数。</p>
<h4 id="6-6-add-established-modes"><a href="#6-6-add-established-modes" class="headerlink" title="6.6 add_established_modes"></a>6.6 <code>add_established_modes</code></h4><p><code>add_standard_modes</code>函数用于从<code>Established Timing</code>获取显示模式，并添加到<code>connector</code>的 <code>probed_modes</code>链表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get established modes from EDID and add them. Each EDID block contains a</span></span><br><span class="line"><span class="comment"> * bitmap of the supported &quot;established modes&quot; list (defined above). Tease them</span></span><br><span class="line"><span class="comment"> * out and add them to the global modes list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_established_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">connector</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *<span class="title">edid</span> = <span class="title">drm_edid</span>-&gt;<span class="title">edid</span>;</span></span><br><span class="line">        <span class="comment">// 转换为unsigned long类型，描述17个通用时序。若支持，则相应的位为1。</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> est_bits = edid-&gt;established_timings.t1 |</span><br><span class="line">                (edid-&gt;established_timings.t2 &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">                ((edid-&gt;established_timings.mfg_rsvd &amp; <span class="number">0x80</span>) &lt;&lt; <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">int</span> i, modes = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">detailed_mode_closure</span> <span class="title">closure</span> = &#123;</span></span><br><span class="line">                .connector = connector,</span><br><span class="line">                .drm_edid = drm_edid,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i&lt;=16  循环17次，遍历每一个Established Timing</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= EDID_EST_TIMINGS; i++) &#123;</span><br><span class="line">                <span class="comment">// 位为1，表示支持当前Established Timing</span></span><br><span class="line">                <span class="keyword">if</span> (est_bits &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line">                        <span class="comment">// edid_est_modes数组中定义了这17个Established Timings对应的显示模式，因此这里实际上就是进行拷贝副本</span></span><br><span class="line">                        newmode = drm_mode_duplicate(dev, &amp;edid_est_modes[i]);</span><br><span class="line">                        <span class="keyword">if</span> (newmode) &#123;</span><br><span class="line">                                <span class="comment">// 添加到connector的probed_modes链表</span></span><br><span class="line">                                drm_mode_probed_add(connector, newmode);</span><br><span class="line">                                modes++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入</span></span><br><span class="line">        <span class="keyword">if</span> (edid-&gt;revision &gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 遍历Detailed Timings，依次执行do_established_modes，对于我使用的HDMI显示器，实际上这里什么也不会做</span></span><br><span class="line">                drm_for_each_detailed_block(drm_edid, do_established_modes,</span><br><span class="line">                                            &amp;closure);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modes + closure.modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-edid扩展块（CEA-861D）解析"><a href="#6-7-edid扩展块（CEA-861D）解析" class="headerlink" title="6.7 edid扩展块（CEA-861D）解析"></a>6.7 <code>edid扩展块（CEA-861D）解析</code></h4><p><code>add_cea_modes</code>、<code>add_alternate_cea_modes</code>、<code>add_displayid_detailed_modes</code>都是用于从<code>edid</code>扩展块中获取显示模式，并添加到<code>connector</code>的 <code>probed_modes</code> 链表；关于具体实现就不展开说了；</p>
<h5 id="6-7-1-add-cea-modes"><a href="#6-7-1-add-cea-modes" class="headerlink" title="6.7.1 add_cea_modes"></a>6.7.1 <code>add_cea_modes</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_cea_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cea_db</span> *<span class="title">db</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cea_db_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">        <span class="keyword">int</span> modes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* CTA VDB block VICs parsed earlier */</span></span><br><span class="line">        modes = add_cta_vdb_modes(connector);</span><br><span class="line"></span><br><span class="line">        cea_db_iter_edid_begin(drm_edid, &amp;iter);</span><br><span class="line">        <span class="comment">// 遍历edid扩展块 Data Blocks</span></span><br><span class="line">        cea_db_iter_for_each(db, &amp;iter) &#123;</span><br><span class="line">                <span class="comment">// Vendor Specific data block？</span></span><br><span class="line">                <span class="keyword">if</span> (cea_db_is_hdmi_vsdb(db)) &#123;</span><br><span class="line">                        <span class="comment">// Parse the HDMI Vendor Specific data block</span></span><br><span class="line">                        modes += do_hdmi_vsdb_modes(connector, (<span class="keyword">const</span> u8 *)db,</span><br><span class="line">                                                    cea_db_payload_len(db));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cea_db_is_y420vdb(db)) &#123;</span><br><span class="line">                        <span class="keyword">const</span> u8 *vdb420 = cea_db_data(db) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Add 4:2:0(only) modes present in EDID */</span></span><br><span class="line">                        <span class="comment">// Parse the CEA-861-F YCBCR 420 Video Data Block (Y420VDB)</span></span><br><span class="line">                        modes += do_y420vdb_modes(connector, vdb420,</span><br><span class="line">                                                  cea_db_payload_len(db) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cea_db_iter_end(&amp;iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-7-2-add-alternate-cea-modes"><a href="#6-7-2-add-alternate-cea-modes" class="headerlink" title="6.7.2 add_alternate_cea_modes"></a>6.7.2 <code>add_alternate_cea_modes</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_alternate_cea_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">connector</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">mode</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">        LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">int</span> modes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t add CTA modes if the CTA extension block is missing */</span></span><br><span class="line">        <span class="keyword">if</span> (!drm_edid_has_cta_extension(drm_edid))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Go through all probed modes and create a new mode</span></span><br><span class="line"><span class="comment">         * with the alternate clock for certain CEA modes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        list_for_each_entry(mode, &amp;connector-&gt;probed_modes, head) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">cea_mode</span> = <span class="title">NULL</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_mode</span> *<span class="title">newmode</span>;</span></span><br><span class="line">                u8 vic = drm_match_cea_mode(mode);</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> clock1, clock2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drm_valid_cea_vic(vic)) &#123;</span><br><span class="line">                        cea_mode = cea_mode_for_vic(vic);</span><br><span class="line">                        clock2 = cea_mode_alternate_clock(cea_mode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        vic = drm_match_hdmi_mode(mode);</span><br><span class="line">                        <span class="keyword">if</span> (drm_valid_hdmi_vic(vic)) &#123;</span><br><span class="line">                                cea_mode = &amp;edid_4k_modes[vic];</span><br><span class="line">                                clock2 = hdmi_mode_alternate_clock(cea_mode);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!cea_mode)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                clock1 = cea_mode-&gt;clock;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (clock1 == clock2)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mode-&gt;clock != clock1 &amp;&amp; mode-&gt;clock != clock2)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                newmode = drm_mode_duplicate(dev, cea_mode);</span><br><span class="line">                <span class="keyword">if</span> (!newmode)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Carry over the stereo flags */</span></span><br><span class="line">                newmode-&gt;flags |= mode-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The current mode could be either variant. Make</span></span><br><span class="line"><span class="comment">                 * sure to pick the &quot;other&quot; clock for the new mode.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (mode-&gt;clock != clock1)</span><br><span class="line">                        newmode-&gt;clock = clock1;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        newmode-&gt;clock = clock2;</span><br><span class="line"></span><br><span class="line">                list_add_tail(&amp;newmode-&gt;head, &amp;<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list_for_each_entry_safe(mode, tmp, &amp;<span class="built_in">list</span>, head) &#123;</span><br><span class="line">                list_del(&amp;mode-&gt;head);</span><br><span class="line">                drm_mode_probed_add(connector, mode);</span><br><span class="line">                modes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-7-3-add-displayid-detailed-modes"><a href="#6-7-3-add-displayid-detailed-modes" class="headerlink" title="6.7.3 add_displayid_detailed_modes"></a>6.7.3 <code>add_displayid_detailed_modes</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_displayid_detailed_modes</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> struct drm_edid *drm_edid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">displayid_block</span> *<span class="title">block</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">displayid_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">        <span class="keyword">int</span> num_modes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        displayid_iter_edid_begin(drm_edid, &amp;iter);</span><br><span class="line">        displayid_iter_for_each(block, &amp;iter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (block-&gt;tag == DATA_BLOCK_TYPE_1_DETAILED_TIMING ||</span><br><span class="line">                    block-&gt;tag == DATA_BLOCK_2_TYPE_7_DETAILED_TIMING)</span><br><span class="line">                        num_modes += add_displayid_detailed_1_modes(connector, block);</span><br><span class="line">        &#125;</span><br><span class="line">        displayid_iter_end(&amp;iter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong></p>
<p><strong>[1] [<code>Rockchip_Developer_Guide_HDMI_CN</code>]</strong></p>
<p><strong>[2] <a target="_blank" rel="noopener" href="https://www.pianshen.com/article/17262174800/"><code>Linux</code>驱动学习–<code>HDMI</code>开发(一) 相关协议及传输原理的介绍</a></strong></p>
<p><strong>[3] <a target="_blank" rel="noopener" href="https://www.freesion.com/article/69981536380/"><code>LINUX</code>驱动学习–<code>HDMI</code>开发(二)<code>HDMI</code>驱动源码分析(<code>RK</code>平台)</a></strong></p>
<p><strong>[4] <a target="_blank" rel="noopener" href="https://blog.csdn.net/yangchao315/category_12209107.html"><code>HDMI</code>协议介绍</a></strong></p>
<p><strong>[5] <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42693097/article/details/128621828"><code>HDMI</code>接口电路设计</a></strong></p>
<p><strong>[7] <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52215423/article/details/131889537"><code>HDMI</code>接口协议</a></strong></p>
<p><strong>[8] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/amxiang/p/16986146.html"><code>HDMI</code>协议1.4 好文推荐！</a></strong></p>
<p><strong>[9] <a target="_blank" rel="noopener" href="https://codeleading.com/article/84455064248/"><code>DRM</code>框架介绍及基于<code>DRM</code>框架的<code>HDMI</code>开发</a></strong></p>
<p><strong>[10] <a target="_blank" rel="noopener" href="https://www.synopsys.com/zh-cn/designware-ip/interface-ip/hdmi.html"><code>DesignWare HDMI IP</code> 解决方案</a></strong></p>
<p><strong>[11] <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34594095/article/details/109525678"><code>LVDS+HDMI</code>输出特殊分辨率<code>800*1280</code>竖屏</a></strong></p>
<p><strong>[12] <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15162069/2854887"><code>Linux DRM</code>那些事-<code>HDMI</code>接口<code>EDID</code>获取</a></strong></p>
<p><strong>[13] <a target="_blank" rel="noopener" href="https://blog.csdn.net/varistor/article/details/120882835"><code>EDID</code>的简介和解析</a></strong></p>
<p><strong>[14] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fire909090/p/10362144.html">什么是<code>EDID</code>，<code>EDID</code>能做什么，<code>EDID</code>基本介绍</a></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20240225/">https://zhoujinjian.com/posts/20240225/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/20240224/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">一、设备树配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-hdmi%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 hdmi设备节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%90%AF%E7%94%A8hdmi"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 启用hdmi</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Platform%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">二、Platform驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%9D%97%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 模块入口函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-dw-hdmi-rockchip-pltfm-driver"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 dw_hdmi_rockchip_pltfm_driver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-of-match-table"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 of_match_table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-dw-hdmi-rockchip-probe"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 dw_hdmi_rockchip_probe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81HDMI%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">三、HDMI数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-DesignWare-hdmi"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 DesignWare hdmi</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-struct-dw-hdmi"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 struct dw_hdmi</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-struct-dw-hdmi-plat-data"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 struct dw_hdmi_plat_data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-struct-edid"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 struct edid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-4-struct-est-timings"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4 struct est_timings</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-5-struct-std-timing"><span class="toc-number">3.1.5.</span> <span class="toc-text">3.1.5 struct std_timing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-6-struct-detailed-timing"><span class="toc-number">3.1.6.</span> <span class="toc-text">3.1.6 struct detailed_timing</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Rockchip-hdmi"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Rockchip hdmi</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-struct-rockchip-hdmi"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 struct rockchip_hdmi</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-struct-rockchip-hdmi-chip-data"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 struct rockchip_hdmi_chip_data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-struct-rockchip-encoder"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 struct rockchip_encoder</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81dw-hdmi-rockchip-bind"><span class="toc-number">4.</span> <span class="toc-text">四、dw_hdmi_rockchip_bind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-drm-of-find-possible-crtcs"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 drm_of_find_possible_crtcs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-rockchip-drm-encoder-set-crtc-endpoint-id"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 rockchip_drm_encoder_set_crtc_endpoint_id</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-of-graph-get-endpoint-by-regs"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 of_graph_get_endpoint_by_regs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-of-graph-get-remote-endpoint"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 of_graph_get_remote_endpoint</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-of-graph-parse-endpoint"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 of_graph_parse_endpoint</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-rockchip-hdmi-parse-dt"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 rockchip_hdmi_parse_dt</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-devm-regulator-get"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 devm_regulator_get</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-devm-phy-optional-get"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 devm_phy_optional_get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-regulator-enable"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 regulator_enable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-dw-hdmi-bind"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 dw_hdmi_bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-1-dw-hdmi-rockchip-mode-valid"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1 dw_hdmi_rockchip_mode_valid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-2-rockchip-mpll-cfg"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2 rockchip_mpll_cfg</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-3-rockchip-cur-ctr"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.3 rockchip_cur_ctr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-4-rockchip-phy-config"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.6.4 rockchip_phy_config</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-5-rk3399-chip-data"><span class="toc-number">4.6.5.</span> <span class="toc-text">4.6.5 rk3399_chip_data</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81dw-hdmi-probe"><span class="toc-number">5.</span> <span class="toc-text">五、dw_hdmi_probe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-dw-hdmi-parse-dt"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 dw_hdmi_parse_dt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-dw-hdmi-init-hw"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 dw_hdmi_init_hw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-dw-hdmi-hardirq"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 dw_hdmi_hardirq</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-hdmi-readb"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 hdmi_readb</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-hdmi-writeb"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 hdmi_writeb</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-dw-hdmi-bridge-funcs-%E9%87%8D%E7%82%B9"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 dw_hdmi_bridge_funcs(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-dw-hdmi-bridge-attach"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 dw_hdmi_bridge_attach</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-dw-hdmi-bridge-get-edid"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 dw_hdmi_bridge_get_edid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 分析小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-drm-bridge-add"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 drm_bridge_add</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81drm-add-edid-modes"><span class="toc-number">6.</span> <span class="toc-text">六、drm_add_edid_modes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-dw-hdmi-get-edid"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 dw_hdmi_get_edid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-drm-add-edid-modes"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 drm_add_edid_modes</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-drm-edid-legacy-init"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 drm_edid_legacy_init</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-update-display-info"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 update_display_info</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3-drm-edid-connector-add-modes"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 _drm_edid_connector_add_modes</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-add-detailed-modes"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 add_detailed_modes</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-Detailed-Timings%E4%BF%A1%E6%81%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1 Detailed Timings信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-do-detailed-mode"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2 do_detailed_mode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-3-drm-mode-detailed"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3 drm_mode_detailed</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-add-cvt-modes"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 add_cvt_modes</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-1-do-cvt-mode"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1 do_cvt_mode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-2-drm-cvt-modes"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2 drm_cvt_modes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-3-drm-cvt-mode"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3 drm_cvt_mode</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-add-standard-modes"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 add_standard_modes</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-1-Standard-Timings%E4%BF%A1%E6%81%AF"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.5.1 Standard Timings信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-2-drm-mode-std"><span class="toc-number">6.5.2.</span> <span class="toc-text">6.5.2 drm_mode_std</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-3-do-standard-modes"><span class="toc-number">6.5.3.</span> <span class="toc-text">6.5.3 do_standard_modes</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-add-established-modes"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 add_established_modes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-edid%E6%89%A9%E5%B1%95%E5%9D%97%EF%BC%88CEA-861D%EF%BC%89%E8%A7%A3%E6%9E%90"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 edid扩展块（CEA-861D）解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-1-add-cea-modes"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.7.1 add_cea_modes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-2-add-alternate-cea-modes"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.7.2 add_alternate_cea_modes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-3-add-displayid-detailed-modes"><span class="toc-number">6.7.3.</span> <span class="toc-text">6.7.3 add_displayid_detailed_modes</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>