<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 11 Display System源码分析（3）：App &amp;&amp; Native Surface创建流程、BufferQueue机制（V1） | zhoujinjian</title><meta name="keywords" content="Display"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 11 Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （&#x3D;&#x3D;文章基于 Android 11.0&#x3D;&#x3D;） 【zhoujin">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 11 Display System源码分析（3）：App &amp;&amp; Native Surface创建流程、BufferQueue机制（V1）">
<meta property="og:url" content="https://zhoujinjian.com/posts/20220816/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 11 Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （&#x3D;&#x3D;文章基于 Android 11.0&#x3D;&#x3D;） 【zhoujin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.43.jpg">
<meta property="article:published_time" content="2022-08-16T08:16:16.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.940Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Display">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.43.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20220816/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.43.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 11 Display System源码分析（3）：App &amp;&amp; Native Surface创建流程、BufferQueue机制（V1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-16T08:16:16.000Z" title="发表于 2022-08-16 16:16:16">2022-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.940Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Display/">Display</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料、Android 11 Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Android 11.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://wiki.radxa.com/Rockpi4">【开发板】</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.radxa.com/Rockpi4/rockpi-android11">【开发板 源码链接】</a></p>
<p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，特别感谢，由于不喜欢图片水印，去除了水印，敬请谅解！！！</p>
<p> <a href="http://zhoujinjian.com/">zhoujinjian.com</a> </p>
<hr>
<p>==源码（部分）==：</p>
<p><strong>xxx</strong></p>
<p>==源码（部分）==：</p>
<hr>
<h2 id="一、Native-Surface和App-Surface创建流程"><a href="#一、Native-Surface和App-Surface创建流程" class="headerlink" title="一、Native Surface和App Surface创建流程"></a>一、Native Surface和App Surface创建流程</h2><h3 id="（1）、App-Surface创建步骤"><a href="#（1）、App-Surface创建步骤" class="headerlink" title="（1）、App Surface创建步骤"></a>（1）、App Surface创建步骤</h3><p>app中Activity回调onCreate()，setContentView最终会走到ViewRootImpl的setView中，然后接收到vSync信号后，会执行relayoutWindow</p>
<p>进一步会请求system_server创建Surface（SurfaceControl）。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830135743625.png" alt="image-20220830135743625"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830135838170.png" alt="image-20220830135838170"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830135913055.png" alt="image-20220830135913055"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830135945276.png" alt="image-20220830135945276"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140054180.png" alt="image-20220830140054180"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140124481.png" alt="image-20220830140124481"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140158063.png" alt="image-20220830140158063"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140228359.png" alt="image-20220830140228359"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140444916.png" alt="image-20220830140444916"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830140800891.png" alt="image-20220830140800891"></p>
<p>走到这里已经到Native 创建Surface了，接下来看看Native Surface创建步骤。</p>
<h3 id="（2）、Native-Surface创建步骤"><a href="#（2）、Native-Surface创建步骤" class="headerlink" title="（2）、Native Surface创建步骤"></a>（2）、Native Surface创建步骤</h3><p>我们这里直接找hwui的一个测试Demo。</p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\base\libs\hwui\tests\common\TestContext.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112758948.png" alt="image-20220830112758948"></p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\libs\gui\SurfaceComposerClient.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111100693.png" alt="image-20220830111100693"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111125226.png" alt="image-20220830111125226"></p>
<p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成。</p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\libs\gui\ISurfaceComposerClient.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111201710.png" alt="image-20220830111201710"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111235170.png" alt="image-20220830111235170"></p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\services\surfaceflinger\Client.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111339855.png" alt="image-20220830111339855"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830111827145.png" alt="image-20220830111827145"></p>
<p>通过Binder通信进入SurfaceFlinger创建Layer。</p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\services\surfaceflinger\SurfaceFlinger.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112130154.png" alt="image-20220830112130154"></p>
<p>  SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了4种类型的Layer:</p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\libs\gui\include\gui\ISurfaceComposerClient.h</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112219815.png" alt="image-20220830112219815"></p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\services\surfaceflinger\SurfaceFlinger.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112340263.png" alt="image-20220830112340263"></p>
<p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112416247.png" alt="image-20220830112416247"></p>
<p>创建BufferQueueLayer 会首先调用onFirstRef()函数，创建IGraphicBufferProducer，IGraphicBufferConsumer，BufferQueue对象。设置最大setMaxDequeuedBufferCount为2。BufferQueueLayer继承BufferLayer，看看BufferLayer构造函数。</p>
<p>获取CompositionEngine创造对应layer，这个后面用于渲染作用。<br>看看Log：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112456785.png" alt="image-20220830112456785"></p>
<blockquote>
<p>Y:\home\zhoujinjian\android11_rockpi4\frameworks\native\services\surfaceflinger\BufferLayer.cpp</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830112644132.png" alt="image-20220830112644132"></p>
<p>上面已经创建好Layer，初始化好了GraphicBufferProducer、GraphicBufferConsumer、</p>
<h2 id="二、BufferQueue内部机制"><a href="#二、BufferQueue内部机制" class="headerlink" title="二、BufferQueue内部机制"></a>二、BufferQueue内部机制</h2><h4 id="（1）、BufferQueue介绍"><a href="#（1）、BufferQueue介绍" class="headerlink" title="（1）、BufferQueue介绍"></a>（1）、BufferQueue介绍</h4><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。<br>从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/Android-Graphics-SurfaceFlinger-BufferQueue.png" alt="Alt text"></p>
<p>先来看一下图中几个状态代表的含义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure>

<p><strong>FREE :</strong><br>FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue“拥有”。 它转换到DEQUEUED<br>当调用dequeueBuffer时。</p>
<p><strong>DEQUEUED：</strong><br>DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer“拥有”。 它可以转换到QUEUED（通过<br>queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p>
<p><strong>QUEUED：</strong><br>QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续<br>  修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue“拥有”。 它<br>  可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p>
<p><strong>ACQUIRED：</strong><br>ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到<br>获得栅栏fence信号。 BufferSlot由Consumer“拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个<br>分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p>
<p><strong>SHARED：</strong><br> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合，<br>除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p>
<p><strong>简单描述一下状态转换过程：</strong></p>
<p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p>
<p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。 </p>
<p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p>
<p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p>
<h4 id="（2）、生产者Producer"><a href="#（2）、生产者Producer" class="headerlink" title="（2）、生产者Producer"></a>（2）、生产者Producer</h4><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/Android-Graphics-SurfaceFlinger-IGraphicsBufferProducer.png" alt="Alt text"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、requestBuffer</strong><br>requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestBuffer requests a new buffer for the given index. The server (i.e.</span></span><br><span class="line"><span class="comment">// the IGraphicBufferProducer implementation) assigns the newly created</span></span><br><span class="line"><span class="comment">// buffer to the given slot index, and the client is expected to mirror the</span></span><br><span class="line"><span class="comment">// slot-&gt;buffer mapping so that it&#x27;s not necessary to transfer a</span></span><br><span class="line"><span class="comment">// GraphicBuffer for every dequeue operation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">requestBuffer</span><span class="params">(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、dequeueBuffer</strong><br>dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span></span><br><span class="line"><span class="comment">// of the slot is transfered to the client, meaning that the server will not</span></span><br><span class="line"><span class="comment">// use the contents of the buffer associated with that slot.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">dequeueBuffer</span><span class="params">(<span class="keyword">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> usage)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp <GraphicBuffer>（即必须调用requestBuffer）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been dequeued, and the caller</span></span><br><span class="line"><span class="comment">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span></span><br><span class="line"><span class="comment">// requestBuffer).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was dequeued</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously dequeued.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span>* outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="（3）、消费者Consumer"><a href="#（3）、消费者Consumer" class="headerlink" title="（3）、消费者Consumer"></a>（3）、消费者Consumer</h4><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/Android-Graphics-SurfaceFlinger-IGraphicsBufferConsumer.png" alt="Alt text"></p>
<p>这里介绍几个非常重要的函数：<br><strong>1、acquireBuffer</strong><br>acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span></span><br><span class="line"><span class="comment">// the BufferQueue.  If no buffer is pending then it returns</span></span><br><span class="line"><span class="comment">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span></span><br><span class="line"><span class="comment">// information about the buffer is returned in BufferItem.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="keyword">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、releaseBuffer</strong><br>releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releaseBuffer releases a buffer slot from the consumer back to the</span></span><br><span class="line"><span class="comment">// BufferQueue.  This may be done while the buffer&#x27;s contents are still</span></span><br><span class="line"><span class="comment">// being accessed.  The fence will signal when the buffer is no longer</span></span><br><span class="line"><span class="comment">// in use. frameNumber is used to indentify the exact buffer returned.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">releaseBuffer</span><span class="params">(<span class="keyword">int</span> buf, <span class="keyword">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">        EGLDisplay display, EGLSyncKHR fence,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、detachBuffer</strong><br>detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4、attachBuffer</strong><br>attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="三、Surface-dequeueBuffer、Surface-queueBuffer实例"><a href="#三、Surface-dequeueBuffer、Surface-queueBuffer实例" class="headerlink" title="三、Surface::dequeueBuffer、Surface::queueBuffer实例"></a>三、Surface::dequeueBuffer、Surface::queueBuffer实例</h2><h3 id="（1）、Surface-dequeueBuffer介绍"><a href="#（1）、Surface-dequeueBuffer介绍" class="headerlink" title="（1）、Surface::dequeueBuffer介绍"></a>（1）、Surface::dequeueBuffer介绍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Stack Trace:</span><br><span class="line">  RELADDR           FUNCTION                                                                                                                                                                                          FILE:LINE</span><br><span class="line">  00000000000201c8  mali_gralloc_ion_map(private_handle_t*)+96                                                                                                                                                        hardware/rockchip/libgralloc/midgard/src/allocator/mali_gralloc_ion.cpp:987</span><br><span class="line">  000000000001dd2c  mali_gralloc_reference_retain(native_handle const*)+260                                                                                                                                           hardware/rockchip/libgralloc/midgard/src/core/mali_gralloc_reference.cpp:62</span><br><span class="line">  v--------------&gt;  arm::mapper::common::registerBuffer(native_handle <span class="keyword">const</span>*)                                                                                                                                         hardware/rockchip/libgralloc/midgard/src/hidl_common/Mapper.cpp:<span class="number">73</span></span><br><span class="line">  <span class="number">000000000000f</span>b0c  arm::mapper::common::importBuffer(android::hardware::hidl_handle <span class="keyword">const</span>&amp;, <span class="built_in">std</span>::__1::function&lt;<span class="keyword">void</span> (android::hardware::graphics::mapper::V4_0::Error, <span class="keyword">void</span>*)&gt;)+<span class="number">124</span>                                  hardware/rockchip/libgralloc/midgard/src/hidl_common/Mapper.cpp:<span class="number">274</span></span><br><span class="line">  <span class="number">000000000000e450</span>  arm::mapper::GrallocMapper::importBuffer(android::hardware::hidl_handle <span class="keyword">const</span>&amp;, <span class="built_in">std</span>::__1::function&lt;<span class="keyword">void</span> (android::hardware::graphics::mapper::V4_0::Error, <span class="keyword">void</span>*)&gt;)+<span class="number">120</span>                           hardware/rockchip/libgralloc/midgard/src/<span class="number">4.</span>x/GrallocMapper.cpp:<span class="number">64</span></span><br><span class="line">  <span class="number">0000000000018</span>d88  android::hardware::graphics::mapper::V4_0::BsMapper::importBuffer(android::hardware::hidl_handle <span class="keyword">const</span>&amp;, <span class="built_in">std</span>::__1::function&lt;<span class="keyword">void</span> (android::hardware::graphics::mapper::V4_0::Error, <span class="keyword">void</span>*)&gt;)+<span class="number">152</span>  out/soong/.intermediates/hardware/interfaces/graphics/mapper/<span class="number">4.0</span>/android.hardware.graphics.mapper@<span class="number">4.0</span>_genc++_headers/gen/android/hardware/graphics/mapper/<span class="number">4.0</span>/BsMapper.h:<span class="number">73</span></span><br><span class="line">  <span class="number">000000000002e96</span>c  android::Gralloc4Mapper::importBuffer(android::hardware::hidl_handle <span class="keyword">const</span>&amp;, native_handle <span class="keyword">const</span>**) <span class="keyword">const</span>+<span class="number">100</span>                                                                                     frameworks/native/libs/ui/Gralloc4.cpp:<span class="number">144</span></span><br><span class="line">  <span class="number">000000000003943</span>c  android::GraphicBufferMapper::importBuffer(native_handle <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, native_handle <span class="keyword">const</span>**)+<span class="number">124</span>                           frameworks/native/libs/ui/GraphicBufferMapper.cpp:<span class="number">93</span></span><br><span class="line">  <span class="number">0000000000037460</span>  android::GraphicBuffer::unflatten(<span class="keyword">void</span> <span class="keyword">const</span>*&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>&amp;, <span class="keyword">int</span> <span class="keyword">const</span>*&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>&amp;)+<span class="number">688</span>                                                                                                  frameworks/native/libs/ui/GraphicBuffer.cpp:<span class="number">509</span></span><br><span class="line">  v--------------&gt;  android::Flattenable&lt;android::GraphicBuffer&gt;::unflatten(<span class="keyword">void</span> <span class="keyword">const</span>*&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>&amp;, <span class="keyword">int</span> <span class="keyword">const</span>*&amp;, <span class="keyword">unsigned</span> <span class="keyword">long</span>&amp;)                                                                                system/core/libutils/include/utils/Flattenable.h:<span class="number">143</span></span><br><span class="line">  <span class="number">0000000000095424</span>  android::Parcel::FlattenableHelper&lt;android::GraphicBuffer&gt;::unflatten(<span class="keyword">void</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span> <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>)+<span class="number">60</span>                                                                   frameworks/native/libs/binder/include/binder/Parcel.h:<span class="number">600</span></span><br><span class="line">  <span class="number">000000000006527</span>c  android::Parcel::<span class="built_in">read</span>(android::Parcel::FlattenableHelperInterface&amp;) <span class="keyword">const</span>+<span class="number">572</span>                                                                                                                     frameworks/native/libs/binder/Parcel.cpp:<span class="number">2198</span></span><br><span class="line">  v--------------&gt;  <span class="keyword">int</span> android::Parcel::<span class="built_in">read</span>&lt;android::GraphicBuffer&gt;(android::Flattenable&lt;android::GraphicBuffer&gt;&amp;) <span class="keyword">const</span>                                                                                            frameworks/native/libs/binder/include/binder/Parcel.h:<span class="number">661</span></span><br><span class="line">  <span class="number">0000000000097</span>abc  android::BpGraphicBufferProducer::requestBuffer(<span class="keyword">int</span>, android::sp&lt;android::GraphicBuffer&gt;*)+<span class="number">300</span>                                                                                                    frameworks/native/libs/gui/IGraphicBufferProducer.cpp:<span class="number">100</span></span><br><span class="line">  <span class="number">00000000000b</span>6494  android::Surface::dequeueBuffer(ANativeWindowBuffer**, <span class="keyword">int</span>*)+<span class="number">716</span>                                                                                                                                  frameworks/native/libs/gui/Surface.cpp:<span class="number">705</span></span><br><span class="line">  <span class="number">00000000009079</span>a0  egl_winsys_get_implementation@@Base+<span class="number">2712</span>                                                                                                                                                          /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">00000000009181</span>a4  eglGetCurrentDisplay@@Base+<span class="number">444</span>                                                                                                                                                                    /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">000000000091805</span>c  eglGetCurrentDisplay@@Base+<span class="number">116</span>                                                                                                                                                                    /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">000000000099132</span>c  glViewport@@Base+<span class="number">77196</span>                                                                                                                                                                            /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">0000000000988</span>a28  glViewport@@Base+<span class="number">42120</span>                                                                                                                                                                            /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">000000000098f</span>ecc  glViewport@@Base+<span class="number">71980</span>                                                                                                                                                                            /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">000000000098e81</span>c  glViewport@@Base+<span class="number">66172</span>                                                                                                                                                                            /vendor/lib64/egl/libGLES_mali.so</span><br><span class="line">  <span class="number">000000000000</span>d4ac  android::BootAnimation::android()+<span class="number">300</span>                                                                                                                                                             frameworks/base/cmds/bootanimation/BootAnimation.cpp:<span class="number">634</span></span><br><span class="line">  <span class="number">000000000000</span>ccb8  android::BootAnimation::threadLoop()+<span class="number">80</span>                                                                                                                                                           frameworks/base/cmds/bootanimation/BootAnimation.cpp:<span class="number">604</span></span><br><span class="line">  <span class="number">000000000001567</span>c  android::Thread::_threadLoop(<span class="keyword">void</span>*)+<span class="number">260</span>                                                                                                                                                           system/core/libutils/Threads.cpp:<span class="number">760</span></span><br><span class="line">  <span class="number">0000000000014f</span>14  <span class="keyword">thread_data_t</span>::trampoline(<span class="keyword">thread_data_t</span> <span class="keyword">const</span>*)+<span class="number">412</span>                                                                                                                                               system/core/libutils/Threads.cpp:<span class="number">97</span></span><br><span class="line">  <span class="number">00000000000b</span>0c08  __pthread_start(<span class="keyword">void</span>*)+<span class="number">64</span>                                                                                                                                                                         bionic/libc/bionic/pthread_create.cpp:<span class="number">347</span></span><br><span class="line">  <span class="number">00000000000505</span>d0  __start_thread+<span class="number">64</span>                                                                                                                                                                                 bionic/libc/bionic/clone.cpp:<span class="number">53</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830142844255.png" alt="image-20220830142844255"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830143243343.png" alt="image-20220830143243343"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830143404217.png" alt="image-20220830143404217"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830143427085.png" alt="image-20220830143427085"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830143542207.png" alt="image-20220830143542207"></p>
<p>这里就衔接到《Android 11 Display System源码分析（1）：GraphicBuffer allocate流程》第五步：importBuffer了。</p>
<h2 id="（2）、Surface-queueBuffer介绍"><a href="#（2）、Surface-queueBuffer介绍" class="headerlink" title="（2）、Surface::queueBuffer介绍"></a>（2）、Surface::queueBuffer介绍</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830143952610.png" alt="image-20220830143952610"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830144136110.png" alt="image-20220830144136110"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830144212163.png" alt="image-20220830144212163"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Display03/image-20220830144610675.png" alt="image-20220830144610675"></p>
<p>frameAvailableListener-&gt;onFrameAvailable(item)：通知SurfaceFlinger去消费</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20220816/">https://zhoujinjian.com/posts/20220816/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Display/">Display</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.43.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20220916/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.44.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 11 Display System源码分析（4）：SurfaceFlinger合成流程（V1）</div></div></a></div><div class="next-post pull-right"><a href="/posts/20220716/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.42.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 11 Display System源码分析（2）：IAllocator IMapper HAL服务获取流程（V1）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20220916/" title="Android 11 Display System源码分析（4）：SurfaceFlinger合成流程（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.44.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-16</div><div class="title">Android 11 Display System源码分析（4）：SurfaceFlinger合成流程（V1）</div></div></a></div><div><a href="/posts/20220616/" title="Android 11 Display System源码分析（1）：GraphicBuffer allocate流程（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.41.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-16</div><div class="title">Android 11 Display System源码分析（1）：GraphicBuffer allocate流程（V1）</div></div></a></div><div><a href="/posts/20220716/" title="Android 11 Display System源码分析（2）：IAllocator IMapper HAL服务获取流程（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.42.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-16</div><div class="title">Android 11 Display System源码分析（2）：IAllocator IMapper HAL服务获取流程（V1）</div></div></a></div><div><a href="/posts/20221016/" title="Android 11 Display System源码分析（5）：HWComposer简要分析（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.45.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">Android 11 Display System源码分析（5）：HWComposer简要分析（V1）</div></div></a></div><div><a href="/posts/20221216/" title="Android 11 Display System源码分析（7）：AMS之Activity启动流程分析（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.47.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-16</div><div class="title">Android 11 Display System源码分析（7）：AMS之Activity启动流程分析（V1）</div></div></a></div><div><a href="/posts/20230216/" title="Android 11 Display System源码分析（8）：WMS之Window显示流程分析（V1）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.48.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="title">Android 11 Display System源码分析（8）：WMS之Window显示流程分析（V1）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Native-Surface%E5%92%8CApp-Surface%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">一、Native Surface和App Surface创建流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81App-Surface%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.</span> <span class="toc-text">（1）、App Surface创建步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81Native-Surface%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.</span> <span class="toc-text">（2）、Native Surface创建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BufferQueue%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">二、BufferQueue内部机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.1.</span> <span class="toc-text">（1）、BufferQueue介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85Producer"><span class="toc-number">2.0.2.</span> <span class="toc-text">（2）、生产者Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85Consumer"><span class="toc-number">2.0.3.</span> <span class="toc-text">（3）、消费者Consumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Surface-dequeueBuffer%E3%80%81Surface-queueBuffer%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Surface::dequeueBuffer、Surface::queueBuffer实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81Surface-dequeueBuffer%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">（1）、Surface::dequeueBuffer介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81Surface-queueBuffer%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">（2）、Surface::queueBuffer介绍</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>