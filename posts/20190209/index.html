<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析 | zhoujinjian</title><meta name="keywords" content="Android,Video,Multimedia"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190209/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg">
<meta property="article:published_time" content="2019-02-09T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.968Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Video">
<meta property="article:tag" content="Multimedia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190209/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-02-09T01:25:00.000Z" title="发表于 2019-02-09 09:25:00">2019-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.968Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Multimedia/">Multimedia</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/">【特别感谢 -  Android NuPlayer播放框架】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/54926526">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<hr>
<p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p>
<p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p>
<p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p>
<p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p>
<p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p>
<p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p>
<p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p>
<hr>
<p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">&quot;/test_video.mp4&quot;</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure>

<p>前面第一章节已经分析过mMediaPlayer.setDataSource()、mMediaPlayer.setDisplay()下来的分析尝试分析解答如下疑问：</p>
<blockquote>
<p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong></p>
</blockquote>
<h4 id="（一）、多媒体文件解析-MediaExtractor分离音视频"><a href="#（一）、多媒体文件解析-MediaExtractor分离音视频" class="headerlink" title="（一）、多媒体文件解析 - MediaExtractor分离音视频"></a>（一）、多媒体文件解析 - MediaExtractor分离音视频</h4><p>接下来继续分析mMediaPlayer.prepareAsync()</p>
<h5 id="1-1、mMediaPlayer-prepareAsync"><a href="#1-1、mMediaPlayer-prepareAsync" class="headerlink" title="1.1、mMediaPlayer.prepareAsync()"></a>1.1、mMediaPlayer.prepareAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<p>通过JNI调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(st);</span><br><span class="line"></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), <span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;Prepare Async failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先设置视频的 display surface（关于IGraphicBufferProducer相关知识请参考：Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]），</p>
<h5 id="1-1-1、MediaPlayer-setVideoSurfaceTexture"><a href="#1-1-1、MediaPlayer-setVideoSurfaceTexture" class="headerlink" title="1.1.1、MediaPlayer.setVideoSurfaceTexture()"></a>1.1.1、MediaPlayer.setVideoSurfaceTexture()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaPlayer::setVideoSurfaceTexture</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;setVideoSurfaceTexture&quot;</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mPlayer == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面setDataSource()分析过，此处会调用NuPlayer的setVideoSurfaceTexture()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::setVideoSurfaceTextureAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer)</span> </span>&#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">&quot;surface&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">&quot;surface&quot;</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处首先构造了一个AMessage消息，然后new Surface()，接下来看看消息处理过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">&quot;surface&quot;</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder&#x27;s mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,</span><br><span class="line">                                           FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                        mDeferredActions.push_back(</span><br><span class="line">                                <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line"></span><br><span class="line">            processDeferredActions();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::performSetSurface</span><span class="params">(<span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;performSetSurface&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSurface = surface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX - ignore error from setVideoScalingMode for now</span></span><br><span class="line">    setVideoScalingMode(mVideoScalingMode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            driver-&gt;notifySetSurfaceComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到将surface 赋值给NuPlayer的mSurface ，待视频解码后就可以在此surface 上渲染画面了，<br>这个稍后再作分析。</p>
<h5 id="1-1-2、MediaPlayer-prepareAsync"><a href="#1-1-2、MediaPlayer-prepareAsync" class="headerlink" title="1.1.2、MediaPlayer.prepareAsync()"></a>1.1.2、MediaPlayer.prepareAsync()</h5><p>然后接着调用MediaPlayer prepareAsync()函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaPlayer::prepareAsync</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;prepareAsync&quot;</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaPlayer::prepareAsync_l</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">&quot;prepareAsync called in state %d, mPlayer(%p)&quot;</span>, mCurrentState, mPlayer.get());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处会调用NuPlayer的prepareAsync()函数，prepareAsync()发送了一个kWhatPrepare的AMessage，我们直接看看消息处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::prepareAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处又调用了GenericSource的prepareAsync()函数，发送了一个kWhatPrepareAsync消息。直接看看GenericSource如何处理的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::prepareAsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLooper-&gt;setName(<span class="string">&quot;generic&quot;</span>);</span><br><span class="line">        mLooper-&gt;start();</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPrepareAsync, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWhatPrepareAsync:</span><br><span class="line">      &#123;</span><br><span class="line">          onPrepareAsync();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::onPrepareAsync() &#123;</span><br><span class="line">    <span class="comment">// delayed data source creation</span></span><br><span class="line">    <span class="keyword">if</span> (mDataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// set to false first, if the extractor</span></span><br><span class="line">        <span class="comment">// comes back as secure, set it to true then.</span></span><br><span class="line">        mIsSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mUri.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* uri = mUri.c_str();</span><br><span class="line">            String8 contentType;</span><br><span class="line">            mIsWidevine = !strncasecmp(uri, <span class="string">&quot;widevine://&quot;</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strncasecmp(<span class="string">&quot;http://&quot;</span>, uri, <span class="number">7</span>)</span><br><span class="line">                    || !strncasecmp(<span class="string">&quot;https://&quot;</span>, uri, <span class="number">8</span>)</span><br><span class="line">                    || mIsWidevine) &#123;</span><br><span class="line">                mHttpSource = DataSource::CreateMediaHTTP(mHTTPService);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDataSource = DataSource::CreateFromURI(</span><br><span class="line">                   mHTTPService, uri, &amp;mUriHeaders, &amp;contentType,</span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;HTTPBase *&gt;(mHttpSource.get()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIsWidevine = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            mDataSource = <span class="keyword">new</span> FileSource(mFd, mOffset, mLength);</span><br><span class="line">            mFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123;</span><br><span class="line">        mCachedSource = <span class="keyword">static_cast</span>&lt;NuCachedSource2 *&gt;(mDataSource.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsStreaming = (mIsWidevine || mCachedSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init extractor from data source</span></span><br><span class="line">    <span class="keyword">status_t</span> err = initFromDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack.mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = doGetFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage;</span><br><span class="line">        err = convertMetaDataToMessage(meta, &amp;msg);</span><br><span class="line">        ......</span><br><span class="line">        notifyVideoSizeChanged(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsSecure) &#123;</span><br><span class="line">        <span class="comment">// secure decoders must be instantiated before starting widevine source</span></span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatSecureDecodersInstantiated, <span class="keyword">this</span>);</span><br><span class="line">        notifyInstantiateSecureDecoders(reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishPrepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先构造了  mDataSource = new FileSource，然后调用了initFromDataSource()，这里面包含多媒体文件格式探测，。</p>
<h5 id="1-1-3、GenericSource-initFromDataSource"><a href="#1-1-3、GenericSource-initFromDataSource" class="headerlink" title="1.1.3、GenericSource.initFromDataSource()"></a>1.1.3、GenericSource.initFromDataSource()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::GenericSource::initFromDataSource() &#123;</span><br><span class="line">    sp&lt;IMediaExtractor&gt; extractor;</span><br><span class="line">    String8 mimeType;</span><br><span class="line">    <span class="keyword">float</span> confidence;</span><br><span class="line">    sp&lt;AMessage&gt; dummy;</span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mDataSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWidevine) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsStreaming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        isWidevineStreaming = !strcasecmp(</span><br><span class="line">                mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extractor = MediaExtractor::Create(mDataSource,</span><br><span class="line">                mimeType.isEmpty() ? <span class="literal">NULL</span> : mimeType.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFileMeta = extractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (mFileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> totalBitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numtracks = extractor-&gt;countTracks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numtracks; ++i) &#123;</span><br><span class="line">        sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i);</span><br><span class="line">        </span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do the string compare immediately with &quot;mime&quot;,</span></span><br><span class="line">        <span class="comment">// we can&#x27;t assume &quot;mime&quot; would stay valid after another</span></span><br><span class="line">        <span class="comment">// extractor operation, some extractors might modify meta</span></span><br><span class="line">        <span class="comment">// during getTrack() and make it invalid.</span></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">&quot;audio/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mAudioTrack.mIndex = i;</span><br><span class="line">                mAudioTrack.mSource = track;</span><br><span class="line">                mAudioTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mVideoTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mVideoTrack.mIndex = i;</span><br><span class="line">                mVideoTrack.mSource = track;</span><br><span class="line">                mVideoTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if the source requires secure buffers</span></span><br><span class="line">                <span class="keyword">int32_t</span> secure;</span><br><span class="line">                <span class="keyword">if</span> (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure)</span><br><span class="line">                        &amp;&amp; secure) &#123;</span><br><span class="line">                    mIsSecure = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">                        extractor-&gt;setUID(mUID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSources.push(track);</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (totalBitrate &gt;= <span class="number">0</span> &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            totalBitrate += bitrate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalBitrate = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    mBitrate = totalBitrate;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过MediaExtractor::Create()得到MediaExtractor，然后将数据解析成track 赋值给mAudioTrack.mSource、mVideoTrack.mSource。</p>
<h5 id="1-1-4、MediaExtractor-Create"><a href="#1-1-4、MediaExtractor-Create" class="headerlink" title="1.1.4、MediaExtractor::Create()"></a>1.1.4、MediaExtractor::Create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaExtractor.cpp]</span><br><span class="line"><span class="function">sp&lt;IMediaExtractor&gt; <span class="title">MediaExtractor::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;MediaExtractor::Create %s&quot;</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">&quot;media.stagefright.extractremote&quot;</span>, value, <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">&quot;0&quot;</span>, value) || !strcasecmp(<span class="string">&quot;false&quot;</span>, value))) &#123;</span><br><span class="line">        <span class="comment">// local extractor</span></span><br><span class="line">        ALOGW(<span class="string">&quot;creating media extractor in calling process&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> CreateFromService(source, mime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check if it&#x27;s WVM, since WVMExtractor needs to be created in the media server process,</span></span><br><span class="line">        <span class="comment">// not the extractor process.</span></span><br><span class="line">        String8 mime8;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; meta;</span><br><span class="line">        <span class="keyword">if</span> (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp;</span><br><span class="line">                !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *drmMime = mime8.<span class="built_in">string</span>();</span><br><span class="line">            ALOGV(<span class="string">&quot;Detected media content as &#x27;%s&#x27; with confidence %.2f&quot;</span>, drmMime, confidence);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drmMime, <span class="string">&quot;drm+es_based+&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">                <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, drmMime + <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remote extractor</span></span><br><span class="line">        ALOGV(<span class="string">&quot;get service manager&quot;</span>);</span><br><span class="line">        sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(<span class="string">&quot;media.extractor&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">sp&lt;IMediaExtractorService&gt; <span class="title">mediaExService</span><span class="params">(interface_cast&lt;IMediaExtractorService&gt;(binder))</span></span>;</span><br><span class="line">            sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime);</span><br><span class="line">            <span class="keyword">return</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过Binder通信获取”media.extractor”服务得到一个Extractor。</p>
<h5 id="1-1-5、IMediaExtractor-gt-getTrack"><a href="#1-1-5、IMediaExtractor-gt-getTrack" class="headerlink" title="1.1.5、IMediaExtractor-&gt;getTrack()"></a>1.1.5、IMediaExtractor-&gt;getTrack()</h5><p>根据不同类别解析出不同的Track</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\]</span><br><span class="line"></span><br><span class="line">AACExtractor.<span class="function">cpp sp&lt;IMediaSource&gt; <span class="title">AACExtractor::getTrack</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line">AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(size_t index)</span><br><span class="line">MP3Extractor.<span class="function">cpp sp&lt;IMediaSource&gt; <span class="title">MP3Extractor::getTrack</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line">NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)</span><br><span class="line">WAVExtractor.<span class="function">cpp sp&lt;IMediaSource&gt; <span class="title">WAVExtractor::getTrack</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line">FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(size_t index) </span><br><span class="line">StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)</span><br><span class="line">AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3</span></span><br><span class="line">sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MP3Source(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MPEG4</span></span><br><span class="line"><span class="function">sp&lt;IMediaSource&gt; <span class="title">MPEG4Extractor::getTrack</span><span class="params">(<span class="keyword">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    ......</span><br><span class="line">    Track *track = mFirstTrack;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track = track-&gt;next;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trex *trex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> trackId;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTrex.size(); i++) &#123;</span><br><span class="line">            Trex *t = &amp;mTrex.editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;track_ID == (<span class="keyword">uint32_t</span>) trackId) &#123;</span><br><span class="line">                trex = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG4Source(<span class="keyword">this</span>,</span><br><span class="line">            track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable,</span><br><span class="line">            mSidxEntries, trex, mMoofOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到不同格式的 MP3Extractor、MPEG4Source ……</p>
<p>还记的前面提出的第一点疑问吗，现在我们知道了如何分离音视频了并且得到了相应的文件Source了。<br>图示（红线部分）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-01-source-demux-decoder-output-MediaExtractor.jpg" alt="Alt text"></p>
<h4 id="（二）、多媒体文件-音视频解码（Decoder）"><a href="#（二）、多媒体文件-音视频解码（Decoder）" class="headerlink" title="（二）、多媒体文件 - 音视频解码（Decoder）"></a>（二）、多媒体文件 - 音视频解码（Decoder）</h4><p>音频解码、视频解码在何处，答案就在mMediaPlayer.start()流程当中，先看看start()总体时序图，然后一步步分析</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-02-NuPlayer-Start-instantiateDecoder.png" alt="Alt text"></p>
<p>由于从Java层到JNI前面已多次分析，这里直接从NuPlayer::start()开始分析</p>
<h5 id="2-1、NuPlayer-start"><a href="#2-1、NuPlayer-start" class="headerlink" title="2.1、NuPlayer::start()"></a>2.1、NuPlayer::start()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;kWhatStart&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">                <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::onStart</span><span class="params">(<span class="keyword">int64_t</span> startPositionUs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startPositionUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        performSeek(startPositionUs);</span><br><span class="line">        <span class="keyword">if</span> (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSource-&gt;isRealTime()) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_REAL_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    ......</span><br><span class="line">    ALOGV_IF(audioMeta == <span class="literal">NULL</span>, <span class="string">&quot;no metadata for audio source&quot;</span>);  <span class="comment">// video only stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line"></span><br><span class="line">    mOffloadAudio =</span><br><span class="line">        canOffloadStream(audioMeta, (videoFormat != <span class="literal">NULL</span>), mSource-&gt;isStreaming(), streamType)</span><br><span class="line">                &amp;&amp; (mPlaybackSettings.mSpeed == <span class="number">1.f</span> &amp;&amp; mPlaybackSettings.mPitch == <span class="number">1.f</span>);</span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_OFFLOAD_AUDIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">&quot;NuPlayerRenderer&quot;</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了名为NuPlayerRenderer的Renderer对象，然后启动循环，看看初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">NuPlayer::Renderer::Renderer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    : mAudioSink(sink),</span><br><span class="line">      mUseVirtualAudioSink(<span class="literal">false</span>),</span><br><span class="line">      mNotify(notify),</span><br><span class="line">      mFlags(flags),</span><br><span class="line">      mNumFramesWritten(<span class="number">0</span>),</span><br><span class="line">      mDrainAudioQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mDrainVideoQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mAudioQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioEOSGeneration(<span class="number">0</span>),</span><br><span class="line">      mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT),</span><br><span class="line">      ......</span><br><span class="line">      mWakeLock(<span class="keyword">new</span> AWakeLock()) &#123;</span><br><span class="line">    mMediaClock = <span class="keyword">new</span> MediaClock;</span><br><span class="line">    mPlaybackRate = mPlaybackSettings.mSpeed;</span><br><span class="line">    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2、postScanSources"><a href="#2-2、postScanSources" class="headerlink" title="2.2、postScanSources()"></a>2.2、postScanSources()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NuPlayer::postScanSources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatScanSources, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mScanSourcesGeneration);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> mHadAnySourcesBefore =</span><br><span class="line">                (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">            <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don&#x27;t try to re-open audio sink if there&#x27;s an existing decoder.</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>此处调用了instantiateDecoder()来初始化音视频解码器Decoder</p>
<h5 id="2-3、instantiateDecoder"><a href="#2-3、instantiateDecoder" class="headerlink" title="2.3、instantiateDecoder()"></a>2.3、instantiateDecoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NuPlayer::instantiateDecoder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> audio, sp&lt;DecoderBase&gt; *decoder, <span class="keyword">bool</span> checkAudioModeChange)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio);</span><br><span class="line"></span><br><span class="line">    format-&gt;setInt32(<span class="string">&quot;priority&quot;</span>, <span class="number">0</span> <span class="comment">/* realtime */</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatAudioNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mAudioDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkAudioModeChange) &#123;</span><br><span class="line">            determineAudioModeChange(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">true</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> hasVideo = (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/*audio */</span>) != <span class="literal">NULL</span>);</span><br><span class="line">            format-&gt;setInt32(<span class="string">&quot;has-video&quot;</span>, hasVideo);</span><br><span class="line">            *decoder = <span class="keyword">new</span> DecoderPassThrough(notify, mSource, mRenderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">false</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            *decoder = <span class="keyword">new</span> Decoder(notify, mSource, mPID, mRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatVideoNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mVideoDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        *decoder = <span class="keyword">new</span> Decoder(</span><br><span class="line">                notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enable FRC if high-quality AV sync is requested, even if not</span></span><br><span class="line">        <span class="comment">// directly queuing to display, as this will even improve textureview</span></span><br><span class="line">        <span class="comment">// playback.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="keyword">if</span> (property_get(<span class="string">&quot;persist.sys.media.avsync&quot;</span>, value, <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (!<span class="built_in">strcmp</span>(<span class="string">&quot;1&quot;</span>, value) || !strcasecmp(<span class="string">&quot;true&quot;</span>, value))) &#123;</span><br><span class="line">                format-&gt;setInt32(<span class="string">&quot;auto-frc&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*decoder)-&gt;init();</span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-1、创建音视频解码器new-Decoder"><a href="#2-3-1、创建音视频解码器new-Decoder" class="headerlink" title="2.3.1、创建音视频解码器new Decoder()"></a>2.3.1、创建音视频解码器new Decoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line">NuPlayer::Decoder::Decoder(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Source&gt; &amp;source,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Renderer&gt; &amp;renderer,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CCDecoder&gt; &amp;ccDecoder)</span><br><span class="line">    : DecoderBase(notify),</span><br><span class="line">      mSurface(surface),</span><br><span class="line">      mSource(source),</span><br><span class="line">      mRenderer(renderer),</span><br><span class="line">      mCCDecoder(ccDecoder),</span><br><span class="line">      ......</span><br><span class="line">      mVideoWidth(<span class="number">0</span>),</span><br><span class="line">      mVideoHeight(<span class="number">0</span>),</span><br><span class="line">      mIsAudio(<span class="literal">true</span>),</span><br><span class="line">      ......</span><br><span class="line">      mComponentName(<span class="string">&quot;decoder&quot;</span>) &#123;</span><br><span class="line">    mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mCodecLooper-&gt;setName(<span class="string">&quot;NPDecoder-CL&quot;</span>);</span><br><span class="line">    mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mVideoTemporalLayerAggregateFps[<span class="number">0</span>] = mFrameRateTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建音视频解码器（NuPlayer::Decoder），为其创建名为NPDecoder-CL的mCodecLooper 【其父类NuPlayer::DecoderBase的构造中则会创建NPDecoder】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line">NuPlayer::DecoderBase::DecoderBase(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify)</span><br><span class="line">    :  mNotify(notify),</span><br><span class="line">       mBufferGeneration(<span class="number">0</span>),</span><br><span class="line">       mPaused(<span class="literal">false</span>),</span><br><span class="line">       mStats(<span class="keyword">new</span> AMessage),</span><br><span class="line">       mRequestInputBuffersPending(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Every decoder has its own looper because MediaCodec operations</span></span><br><span class="line">    <span class="comment">// are blocking, but NuPlayer needs asynchronous operations.</span></span><br><span class="line">    mDecoderLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mDecoderLooper-&gt;setName(<span class="string">&quot;NPDecoder&quot;</span>);</span><br><span class="line">    mDecoderLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2、初始化Decoder-gt-init"><a href="#2-3-2、初始化Decoder-gt-init" class="headerlink" title="2.3.2、初始化Decoder-&gt;init()"></a>2.3.2、初始化Decoder-&gt;init()</h5><p>对该解码器进行init()操作，调用NuPlayer::DecoderBase::init()为mDecoderLooper注册handler【init()和configure()都是NuPlayerDecoder继承自NuPlayer::DecoderBase的方法】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::configure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">&quot;format&quot;</span>, format);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::init() &#123;</span><br><span class="line">    mDecoderLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            CHECK(msg-&gt;findMessage(<span class="string">&quot;format&quot;</span>, &amp;format));</span><br><span class="line">            onConfigure(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>对该解码器进行configure(format)操作，调用NuPlayer::DecoderBase::configure(…)产生一个kWhatConfigure消息，然后消息处理中调用NuPlayer::Decoder::onConfigure(…)</p>
<h5 id="2-3-3、配置Decoder-gt-configure"><a href="#2-3-3、配置Decoder-gt-configure" class="headerlink" title="2.3.3、配置Decoder-&gt;configure()"></a>2.3.3、配置Decoder-&gt;configure()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">  </span><br><span class="line">    mFormatChangePending = <span class="literal">false</span>;</span><br><span class="line">    mTimeChangePending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++mBufferGeneration;</span><br><span class="line"></span><br><span class="line">    AString mime;</span><br><span class="line"></span><br><span class="line">    mIsAudio = !strncasecmp(<span class="string">&quot;audio/&quot;</span>, mime.c_str(), <span class="number">6</span>);</span><br><span class="line">    mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());</span><br><span class="line"></span><br><span class="line">    mComponentName = mime;</span><br><span class="line">    mComponentName.append(<span class="string">&quot; decoder&quot;</span>);</span><br><span class="line">    ALOGV(<span class="string">&quot;[%s] onConfigure (surface=%p)&quot;</span>, mComponentName.c_str(), mSurface.get());</span><br><span class="line"></span><br><span class="line">    mCodec = MediaCodec::CreateByType(</span><br><span class="line">            mCodecLooper, mime.c_str(), <span class="literal">false</span> <span class="comment">/* encoder */</span>, <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="keyword">int32_t</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format-&gt;findInt32(<span class="string">&quot;secure&quot;</span>, &amp;secure) &amp;&amp; secure != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line">            mComponentName.append(<span class="string">&quot;.secure&quot;</span>);</span><br><span class="line">            mCodec-&gt;release();</span><br><span class="line">            ALOGI(<span class="string">&quot;[%s] creating&quot;</span>, mComponentName.c_str());</span><br><span class="line">            mCodec = MediaCodec::CreateByComponentName(</span><br><span class="line">                    mCodecLooper, mComponentName.c_str(), <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mIsSecure = secure;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// disconnect from surface as MediaCodec will reconnect</span></span><br><span class="line">        err = native_window_api_disconnect(</span><br><span class="line">                mSurface.get(), NATIVE_WINDOW_API_MEDIA);</span><br><span class="line">        <span class="comment">// We treat this as a warning, as this is a preparatory step.</span></span><br><span class="line">        <span class="comment">// Codec will try to connect to the surface, which is where</span></span><br><span class="line">        <span class="comment">// any error signaling will occur.</span></span><br><span class="line">        ALOGW_IF(err != OK, <span class="string">&quot;failed to disconnect from surface: %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mCodec-&gt;configure(</span><br><span class="line">            format, mSurface, <span class="literal">NULL</span> <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    ......</span><br><span class="line">    rememberCodecSpecificData(format);</span><br><span class="line">    mStats-&gt;setString(<span class="string">&quot;mime&quot;</span>, mime.c_str());</span><br><span class="line">    mStats-&gt;setString(<span class="string">&quot;component-name&quot;</span>, mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;findInt32(<span class="string">&quot;width&quot;</span>, &amp;width)</span><br><span class="line">                &amp;&amp; mOutputFormat-&gt;findInt32(<span class="string">&quot;height&quot;</span>, &amp;height)) &#123;</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">&quot;width&quot;</span>, width);</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">&quot;height&quot;</span>, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"></span><br><span class="line">    err = mCodec-&gt;start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    releaseAndResetMediaBuffers();</span><br><span class="line"></span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    mResumePending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onConfigure中，首先会调用MediaCodec::CreateByType(…)或者MediaCodec::CreateByComponentName(…)根据情况创建MediaCodec，接着调用MediaCodec::init(…)，随后调用MediaCodec::configure(…)对MediaCodec进行配置使其转入Configured状态;然后又调用MediaCodec::start()使MediaCodec转入Executing状态。</p>
<h5 id="2-3-4、MediaCodec-init-…"><a href="#2-3-4、MediaCodec-init-…" class="headerlink" title="2.3.4、MediaCodec::init(…)"></a>2.3.4、MediaCodec::init(…)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="function">sp&lt;MediaCodec&gt; <span class="title">MediaCodec::CreateByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;MediaCodec&gt; <span class="title">MediaCodec::CreateByComponentName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;name, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(name, <span class="literal">false</span> <span class="comment">/* nameIsType */</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;MediaCodec&gt; <span class="title">MediaCodec::CreateByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaCodec::init</span><span class="params">(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType, <span class="keyword">bool</span> encoder)</span> </span>&#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save init parameters for reset</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    mInitNameIsType = nameIsType;</span><br><span class="line">    mInitIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current video decoders do not return from OMX_FillThisBuffer</span></span><br><span class="line">    <span class="comment">// quickly, violating the OpenMAX specs, until that is remedied</span></span><br><span class="line">    <span class="comment">// we need to invest in an extra looper to free the main event</span></span><br><span class="line">    <span class="comment">// queue.</span></span><br><span class="line"></span><br><span class="line">    mCodec = GetCodecBase(name, nameIsType);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> secureCodec = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType &amp;&amp; !strncasecmp(name.c_str(), <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        mIsVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AString tmp = name;</span><br><span class="line">        <span class="keyword">if</span> (tmp.endsWith(<span class="string">&quot;.secure&quot;</span>)) &#123;</span><br><span class="line">            secureCodec = <span class="literal">true</span>;</span><br><span class="line">            tmp.erase(tmp.size() - <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(tmp.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">            Vector&lt;AString&gt; mimes;</span><br><span class="line">            info-&gt;getSupportedMimes(&amp;mimes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mimes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mimes[i].startsWith(<span class="string">&quot;video/&quot;</span>)) &#123;</span><br><span class="line">                    mIsVideo = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        <span class="comment">// video codec needs dedicated looper</span></span><br><span class="line">        <span class="keyword">if</span> (mCodecLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">            mCodecLooper-&gt;setName(<span class="string">&quot;CodecLooper&quot;</span>);</span><br><span class="line">            mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setNotificationMessage(<span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatInit, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">&quot;nameIsType&quot;</span>, nameIsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;encoder&quot;</span>, encoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-4-1、GetCodecBase"><a href="#2-3-4-1、GetCodecBase" class="headerlink" title="2.3.4.1、GetCodecBase"></a>2.3.4.1、GetCodecBase</h5><p>当编解码以”omx.”开头则创建ACodec对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="function">sp&lt;CodecBase&gt; <span class="title">MediaCodec::GetCodecBase</span><span class="params">(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// at this time only ACodec specifies a mime type.</span></span><br><span class="line">    <span class="keyword">if</span> (nameIsType || name.startsWithIgnoreCase(<span class="string">&quot;omx.&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWithIgnoreCase(<span class="string">&quot;android.filter.&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MediaFilter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-2、MediaCodecList-getInstance"><a href="#2-3-4-2、MediaCodecList-getInstance" class="headerlink" title="2.3.4.2、MediaCodecList::getInstance()"></a>2.3.4.2、MediaCodecList::getInstance()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line"><span class="function">sp&lt;IMediaCodecList&gt; <span class="title">MediaCodecList::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">&quot;media.player&quot;</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过Binder通信获取MediaCodec列表。getCodecList()函数实现在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp]</span><br><span class="line"><span class="function">sp&lt;IMediaCodecList&gt; <span class="title">MediaPlayerService::getCodecList</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line"><span class="function">sp&lt;IMediaCodecList&gt; <span class="title">MediaCodecList::getLocalInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mUpdate(<span class="literal">false</span>),</span><br><span class="line">      mGlobalSettings(<span class="keyword">new</span> AMessage()) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">&quot;/etc/media_codecs.xml&quot;</span>);</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">&quot;/etc/media_codecs_performance.xml&quot;</span>, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">    parseTopLevelXMLFile(kProfilingResults, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，终于分析到Codecs加载的地方了。还记得第一章节分析的附录吗，高通的音视频硬解码，这里再贴一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line"></span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.avc&quot;</span> type=<span class="string">&quot;video/avc&quot;</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">&quot;requires-allocate-on-input-ports&quot;</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">&quot;requires-allocate-on-output-ports&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;size&quot;</span> min=<span class="string">&quot;64x64&quot;</span> max=<span class="string">&quot;4096x2160&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;alignment&quot;</span> value=<span class="string">&quot;2x2&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;block-size&quot;</span> value=<span class="string">&quot;16x16&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;blocks-per-second&quot;</span> min=<span class="string">&quot;1&quot;</span> max=<span class="string">&quot;1958400&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;bitrate&quot;</span> range=<span class="string">&quot;1-100000000&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;frame-rate&quot;</span> range=<span class="string">&quot;1-240&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;vt-version&quot;</span> value=<span class="string">&quot;65537&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;vt-low-latency&quot;</span> value=<span class="string">&quot;1&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;vt-max-macroblock-processing-rate&quot;</span> value=<span class="string">&quot;972000&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;vt-max-level&quot;</span> value=<span class="string">&quot;52&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;vt-max-instances&quot;</span> value=<span class="string">&quot;16&quot;</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">&quot;adaptive-playback&quot;</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">&quot;concurrent-instances&quot;</span> max=<span class="string">&quot;16&quot;</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.avc.secure&quot;</span> type=<span class="string">&quot;video/avc&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.mpeg4&quot;</span> type=<span class="string">&quot;video/mp4v-es&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.h263&quot;</span> type=<span class="string">&quot;video/3gpp&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.vc1&quot;</span> type=<span class="string">&quot;video/x-ms-wmv&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.vc1.secure&quot;</span> type=<span class="string">&quot;video/x-ms-wmv&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.divx&quot;</span> type=<span class="string">&quot;video/divx&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.divx311&quot;</span> type=<span class="string">&quot;video/divx311&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.divx4&quot;</span> type=<span class="string">&quot;video/divx4&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.vp8&quot;</span> type=<span class="string">&quot;video/x-vnd.on2.vp8&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.vp9&quot;</span> type=<span class="string">&quot;video/x-vnd.on2.vp9&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.vp9.secure&quot;</span> type=<span class="string">&quot;video/x-vnd.on2.vp9&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.hevc&quot;</span> type=<span class="string">&quot;video/hevc&quot;</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qcom.video.decoder.hevc.secure&quot;</span> type=<span class="string">&quot;video/hevc&quot;</span> &gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">&quot;OMX.qti.audio.decoder.flac&quot;</span> type=<span class="string">&quot;audio/flac&quot;</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">&quot;media_codecs_google_video.xml&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-5、MediaCodec-gt-configure"><a href="#2-3-5、MediaCodec-gt-configure" class="headerlink" title="2.3.5、MediaCodec-&gt;configure()"></a>2.3.5、MediaCodec-&gt;configure()</h5><p>产生kWhatConfigure消息，在消息处理中调用ACodec::initiateConfigureComponent(…)又产生消息kWhatConfigureComponent，然后该消息处理中又调用了ACodec::LoadedState::onConfigureComponent(…)。然后在其中又会先调用ACodec::configureCodec(…)，在configureCodec中会对IOMX进行一系列的设置以及配置操作，通过Binder通信就对OMXNodeInstance进行相应的设置和配置操作，最终就对OMX组件进行了相应的设置和配置。然后向MediaCodec发送kWhatComponentConfigured消息，在消息处理中将MediaCodec状态设为CONFIGURED；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaCodec::configure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;ICrypto&gt; &amp;crypto,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format-&gt;setObject(<span class="string">&quot;native-window&quot;</span>, obj);</span><br><span class="line">                <span class="keyword">status_t</span> err = handleSetSurface(<span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleSetSurface(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReplyID = replyID;</span><br><span class="line">            setState(CONFIGURING);</span><br><span class="line">            ......</span><br><span class="line">            extractCSD(format);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateConfigureComponent(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ACodec::initiateConfigureComponent</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span> </span>&#123;</span><br><span class="line">    msg-&gt;setWhat(kWhatConfigureComponent);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            onConfigureComponent(msg);</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">bool</span> ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findString(<span class="string">&quot;mime&quot;</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = mCodec-&gt;configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">&quot;input-format&quot;</span>, mCodec-&gt;mInputFormat);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">&quot;output-format&quot;</span>, mCodec-&gt;mOutputFormat);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-6、MediaCodec-gt-start"><a href="#2-3-6、MediaCodec-gt-start" class="headerlink" title="2.3.6、MediaCodec-&gt;start()"></a>2.3.6、MediaCodec-&gt;start()</h5><p>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">MediaCodec::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            setState(STARTING);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateStart();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ACodec::initiateStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦缓冲区成功分配到输入和输出端口，OMX组件（编解码）会为Loaded-to-Idle状态生成OMX_EventCmdComplete事件转换并使用EventHandlerCallback将其发送给客户端。</p>
<h4 id="（三）、音视频解码数据处理"><a href="#（三）、音视频解码数据处理" class="headerlink" title="（三）、音视频解码数据处理"></a>（三）、音视频解码数据处理</h4><h5 id="3-1、音视频解码数据处理-emptyBuffer"><a href="#3-1、音视频解码数据处理-emptyBuffer" class="headerlink" title="3.1、音视频解码数据处理-emptyBuffer"></a>3.1、音视频解码数据处理-emptyBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-03-acodec-emptyBuffer.png" alt="Alt text"></p>
<p>1、    MediaCodec::start()之后ACodec是在LoadedToIdleState状态，此时若ACodec::LoadedToIdleState::onOMXEvent(…)接收到组件转换至Idle状态后的OMX_EventCmdComplete事件，会向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Executing状态（这里OMX会发送OMX_EventCmdComplete事件），然后ACodec进行changeState至IdleToExecutingState。<br>2、    此时ACodec::IdleToExecutingState::onOMXEvent(…)检测到上面的OMX_EventCmdComplete事件后，会首先调用函数ACodec::ExecutingState::resume()，然后对ACodec进行changeState至ExecutingState。</p>
<h5 id="3-1-1、ACodec-ExecutingState-resume"><a href="#3-1-1、ACodec-ExecutingState-resume" class="headerlink" title="3.1.1、ACodec::ExecutingState::resume()"></a>3.1.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">&quot;buffer-id&quot;</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">&quot;buffer&quot;</span>, info-&gt;mData);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">&quot;buffer-id&quot;</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    notify-&gt;setMessage(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line"></span><br><span class="line">    notify-&gt;post();</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数ACodec::ExecutingState::resume()中会调用ACodec::BaseState::postFillThisBuffer(…)，然后其中会先向MediaCodec发送kWhatFillThisBuffer消息，消息处理中在满足相应的条件下就会去调用函数MediaCodec::onInputBufferAvailable()来通知NuPlayer::Decoder有可用的inputbuffer；然后再生成kWhatInputBufferFilled消息，消息处理中调用ACodec::BaseState::onInputBufferFilled(…)。<br>【产生两个消息，一个向上(MediaCodec)处理，一个向下(OMX)处理】</p>
<h5 id="3-1-1-1、kWhatFillThisBuffer消息处理"><a href="#3-1-1-1、kWhatFillThisBuffer消息处理" class="headerlink" title="3.1.1.1、kWhatFillThisBuffer消息处理"></a>3.1.1.1、kWhatFillThisBuffer消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">                <span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* size_t index = */</span>updateBuffers(kPortIndexInput, msg);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                onInputBufferAvailable();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">                        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">                        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">                        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        postActivityNotificationIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaCodec::onInputBufferAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;callbackID&quot;</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P.S. 1：MediaCodec::onInputBufferAvailable()的调用：<br>其中会先调用函数MediaCodec::dequeuePortBuffer(…)获取buffer的索引，然后将一个新消息发送给NuPlayer::Decoder，并设置消息的callbackID为CB_INPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_INPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnInputBuffer(…)，其会：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">&quot;index&quot;</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">&quot;buffer-ix&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">&quot;buffer&quot;</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>○1、先通过MediaCodec::getInputBuffer(…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer</p>
<p>○2、然后调用NuPlayer::Decoder::onInputBufferFetched(…)执行内存拷贝将buffer拷贝到编解码器，然后又调用了MediaCodec::queueInputBuffer(…)将buffer提交给解码器，其会产生消息kWhatQueueInputBuffer，消息处理中调用MediaCodec::onQueueInputBuffer(…)</p>
<p>○3、之后调用函数NuPlayer::DecoderBase::onRequestInputBuffers()，处理是否需要更多的数据。其中会调用NuPlayer::Decoder::doRequestBuffers，若返回true则需要更多的数据，则会产生新消息kWhatRequestInputBuffers，消息处理中又将调用onRequestInputBuffers。（实际获取更多缓冲的操作在下面ACodec部分完成）</p>
<h5 id="3-1-1-2、kWhatInputBufferFilled消息处理"><a href="#3-1-1-2、kWhatInputBufferFilled消息处理" class="headerlink" title="3.1.1.2、kWhatInputBufferFilled消息处理"></a>3.1.1.2、kWhatInputBufferFilled消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatInputBufferFilled:</span><br><span class="line">        &#123;</span><br><span class="line">            onInputBufferFilled(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onInputBufferFilled(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">&quot;buffer-id&quot;</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    <span class="keyword">int32_t</span> err = OK;</span><br><span class="line">    <span class="keyword">bool</span> eos = <span class="literal">false</span>;</span><br><span class="line">    PortMode mode = getPortMode(kPortIndexInput);</span><br><span class="line">    <span class="keyword">int32_t</span> tmp;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">                CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">                OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">                MetadataBufferType metaType = mCodec-&gt;mInputMetadataType;</span><br><span class="line">                <span class="keyword">int32_t</span> isCSD = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">&quot;csd&quot;</span>, &amp;isCSD) &amp;&amp; isCSD != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCodec-&gt;mIsLegacyVP9Decoder) &#123;</span><br><span class="line">                        postFillThisBuffer(info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flags |= OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">                    metaType = kMetadataBufferTypeInvalid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">if</span> (buffer != info-&gt;mCodecData) &#123;</span><br><span class="line">                    sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput];</span><br><span class="line">                    <span class="keyword">status_t</span> err = converter-&gt;convert(buffer, info-&gt;mCodecData);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;checkReadFence(<span class="string">&quot;onInputBufferFilled&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err2 = OK;</span><br><span class="line">                <span class="keyword">switch</span> (metaType) &#123;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeInvalid:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeNativeHandleSource:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeHandleMetadata)) &#123;</span><br><span class="line">                        VideoNativeHandleMetadata *vnhmd =</span><br><span class="line">                            (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                NativeHandle::create(vnhmd-&gt;pHandle, <span class="literal">false</span> <span class="comment">/* ownsHandle */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeANWBuffer:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeMetadata)) &#123;</span><br><span class="line">                        VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                <span class="keyword">new</span> GraphicBuffer(vnmd-&gt;pBuffer, <span class="literal">false</span> <span class="comment">/* keepOwnership */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    err2 = ERROR_UNSUPPORTED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err2 == OK) &#123;</span><br><span class="line">                    err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mCodecData-&gt;size(),</span><br><span class="line">                        flags,</span><br><span class="line">                        timeUs,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eos &amp;&amp; err == OK) &#123;</span><br><span class="line">                    getMoreInputDataIfPossible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGV(<span class="string">&quot;[%s] Signalled EOS (%d) on the input port&quot;</span>,</span><br><span class="line">                         mCodec-&gt;mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                info-&gt;checkReadFence(<span class="string">&quot;onInputBufferFilled&quot;</span>);</span><br><span class="line">                <span class="keyword">status_t</span> err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        OMX_BUFFERFLAG_EOS,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P.S. 2：ACodec::BaseState::onInputBufferFilled(…)的调用：<br>因为当前ACodec在ExecutingState，所以PortMode为RESUBMIT_BUFFERS，故会调用IOMX的emptyBuffer(…)方法，经过进程间通信调用到OMX::emptyBuffer(…)，并最终调用OMXNodeInstance::emptyBuffer(…)，其中又会调用到函数OMXNodeInstance::emptyBuffer_l(…)，其则会调用OMX_EmptyThisBuffer宏对OMX组件进行相关的操作（根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent</p>
<p>○1、其的构造函数的初始化列表中有mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;故实际会调用其EmptyThisBufferWrapper(…)函数，而其中调用SoftOMXComponent的虚函数emptyThisBuffer。</p>
<p>○2、所以调用子类的emptyThisBuffer即SimpleSoftOMXComponent::emptyThisBuffer(…)产生kWhatEmptyThisBuffer消息，消息处理中实际的解码器就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p>
<p>○3、接着会调用SoftOMXComponent::notifyEmptyBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。</p>
<p>○4、调用到OMXNodeInstance::OnEmptyBufferDone(…)，其又会调用OMX::OnEmptyBufferDone(…)，然后在其中会发送omx_message::EMPTY_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState::onOMXEmptyBufferDone(…)</p>
<p>○5、在onOMXEmptyBufferDone中获取PortMode，为RESUBMIT_BUFFERS则ACodec::BaseState::postFillThisBuffer(…)被调用，从而又从3中的postFillThisBuffer开始循环执行相关操作以处理更多的输入缓冲。</p>
<h5 id="3-2、音视频解码数据处理-fillBuffer"><a href="#3-2、音视频解码数据处理-fillBuffer" class="headerlink" title="3.2、音视频解码数据处理-fillBuffer"></a>3.2、音视频解码数据处理-fillBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-04-acodec-fillBuffer.png" alt="Alt text"></p>
<h5 id="3-2-1、ACodec-ExecutingState-resume"><a href="#3-2-1、ACodec-ExecutingState-resume" class="headerlink" title="3.2.1、ACodec::ExecutingState::resume()"></a>3.2.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitOutputBuffers() &#123;</span><br><span class="line">    submitRegularOutputBuffers();</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        submitOutputMetaBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitRegularOutputBuffers() &#123;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;checkWriteFence(<span class="string">&quot;submitRegularOutputBuffers&quot;</span>);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1、ACodec::ExecutingState::resume()函数，在resume()中调用ACodec::BaseState::postFillThisBuffer(…)前会先调用函数ACodec::ExecutingState::submitOutputBuffers()，即在获取输入数据前会先把输出端的数据提交出去。</p>
<p>2、在submitOutputBuffers()中调用ACodec::ExecutingState::submitRegularOutputBuffers()，其中又会调用到IOMX的fillBuffer (…)方法，经过进程间通信调用到OMX:: fillBuffer (…)，并最终调用OMXNodeInstance:: fillBuffer (…)，其中又会调用到OMX_FillThisBuffer宏对OMX组件进行相关的操作（同样根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent：（下面的操作与emptyBuffer时类似）</p>
<p>○1、在其构造函数的初始化列表中有mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;所以实际会调用到其FillThisBufferWrapper (…)函数<br>○2、然后调用SimpleSoftOMXComponent::fillThisBuffer(…)产生kWhatFillThisBuffer消息，消息处理中实际的组件就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p>
<p>○3、接着会调用SoftOMXComponent::notifyFillBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。<br>○4之后调用到OMXNodeInstance:: OnFillBufferDone (…)函数，其又会调用OMX:: OnFillBufferDone (…)，然后在其中会发送omx_message:: FILL_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState:: onOMXFillBufferDone (…)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">bool</span> ACodec::BaseState::onOMXFillBufferDone(</span><br><span class="line">        IOMX::buffer_id bufferID,</span><br><span class="line">        <span class="keyword">size_t</span> rangeOffset, <span class="keyword">size_t</span> rangeLength,</span><br><span class="line">        OMX_U32 flags,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;[%s] onOMXFillBufferDone %u time %&quot;</span> PRId64 <span class="string">&quot; us, flags = 0x%08x&quot;</span>,</span><br><span class="line">         mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    <span class="keyword">status_t</span> err= OK;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACK_BUFFER_TIMING</span></span><br><span class="line">    index = mCodec-&gt;mBufferStats.indexOfKey(timeUs);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index);</span><br><span class="line">        stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs();</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">&quot;frame PTS %lld: %lld&quot;</span>,</span><br><span class="line">                timeUs,</span><br><span class="line">                stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;mBufferStats.removeItemsAt(index);</span><br><span class="line">        stats = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    BufferInfo *info =</span><br><span class="line">        mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_COMPONENT) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Wrong ownership in FBD: %s(%d) buffer #%u&quot;</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ::close(fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter;</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;mRenderInfo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The fence for an emptied buffer must have signaled, but there still could be queued</span></span><br><span class="line">        <span class="comment">// or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these,</span></span><br><span class="line">        <span class="comment">// as we will soon requeue this buffer to the surface. While in theory we could still keep</span></span><br><span class="line">        <span class="comment">// track of buffers that are requeued to the surface, it is better to add support to the</span></span><br><span class="line">        <span class="comment">// buffer-queue to notify us of released buffers and their fences (in the future).</span></span><br><span class="line">        mCodec-&gt;notifyOfRenderedFrames(<span class="literal">true</span> <span class="comment">/* dropIncomplete */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte buffers cannot take fences, so wait for any fence now</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mCodec-&gt;waitForFence(fenceFd, <span class="string">&quot;onOMXFillBufferDone&quot;</span>);</span><br><span class="line">        fenceFd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;setReadFence(fenceFd, <span class="string">&quot;onOMXFillBufferDone&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PortMode mode = getPortMode(kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rangeLength == <span class="number">0</span> &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS)</span><br><span class="line">                    || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123;</span><br><span class="line">                ......</span><br><span class="line">                err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; reply =</span><br><span class="line">                <span class="keyword">new</span> AMessage(kWhatOutputBufferDrained, mCodec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// pretend that output format has changed on the first frame (we used to do this)</span></span><br><span class="line">                <span class="keyword">if</span> (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123;</span><br><span class="line">                    mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat);</span><br><span class="line">                &#125;</span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">                mCodec-&gt;sendFormatChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeLength &gt; <span class="number">0</span> &amp;&amp; mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// If potentially rendering onto a surface, always save key format data (crop &amp;</span></span><br><span class="line">                <span class="comment">// data space) so that we can set it if and once the buffer is rendered.</span></span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123;</span><br><span class="line">                <span class="keyword">native_handle_t</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">                VideoNativeHandleMetadata &amp;nativeMeta =</span><br><span class="line">                    *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data();</span><br><span class="line">                <span class="keyword">if</span> (info-&gt;mData-&gt;size() &gt;= <span class="keyword">sizeof</span>(nativeMeta)</span><br><span class="line">                        &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                    <span class="comment">// handle is only valid on 32-bit/mediaserver process</span></span><br><span class="line">                    handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    handle = (<span class="keyword">native_handle_t</span> *)nativeMeta.pHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setPointer(<span class="string">&quot;handle&quot;</span>, handle);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">&quot;rangeOffset&quot;</span>, rangeOffset);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">&quot;rangeLength&quot;</span>, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mData == info-&gt;mCodecData) &#123;</span><br><span class="line">                info-&gt;mData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">                <span class="comment">// in this case we know that mConverter is not null</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert(</span><br><span class="line">                        info-&gt;mCodecData, info-&gt;mData);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData);</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;mData-&gt;meta()-&gt;setInt64(<span class="string">&quot;timeUs&quot;</span>, timeUs);</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">            notify-&gt;setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatDrainThisBuffer);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">&quot;buffer-id&quot;</span>, info-&gt;mBufferID);</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">&quot;buffer&quot;</span>, info-&gt;mData);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">&quot;flags&quot;</span>, flags);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">&quot;buffer-id&quot;</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">            notify-&gt;setMessage(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line"></span><br><span class="line">            notify-&gt;post();</span><br><span class="line"></span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;[%s] saw output EOS&quot;</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">                sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">                notify-&gt;setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatEOS);</span><br><span class="line">                notify-&gt;setInt32(<span class="string">&quot;err&quot;</span>, mCodec-&gt;mInputEOSResult);</span><br><span class="line">                notify-&gt;post();</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexOutput] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FREE_BUFFERS:</span><br><span class="line">            err = mCodec-&gt;freeBuffer(kPortIndexOutput, index);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">&quot;Invalid port mode: %d&quot;</span>, mode);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>○5、在onOMXFillBufferDone中获取PortMode，为RESUBMIT_BUFFERS则首先如果需要继续调用到IOMX的fillBuffer (…)填充输出缓冲重复做相关操作，接着ACodec又会生成一个kWhatOutputBufferDrained消息存在reply中，作为kWhatDrainThisBuffer消息的返回消息【notify-&gt;setMessage(“reply”, reply);】，然后向MediaCodec发送消息kWhatDrainThisBuffer，消息处理中调用函数MediaCodec::onOutputBufferAvailable()通知NuPlayer::Decoder有可用的output buffer，其中会设置消息的callbackID为CB_OUTPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_OUTPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnOutputBuffer(…)，在其中会进行如下处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaCodec::onOutputBufferAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer =</span><br><span class="line">            mPortBuffers[kPortIndexOutput].itemAt(index).mData;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;callbackID&quot;</span>, CB_OUTPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">        msg-&gt;setSize(<span class="string">&quot;offset&quot;</span>, buffer-&gt;offset());</span><br><span class="line">        msg-&gt;setSize(<span class="string">&quot;size&quot;</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt64(<span class="string">&quot;timeUs&quot;</span>, timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> omxFlags;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">&quot;omxFlags&quot;</span>, &amp;omxFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_CODECCONFIG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt32(<span class="string">&quot;flags&quot;</span>, flags);</span><br><span class="line"></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（四）、多媒体文件-音视频渲染（Renderer）"><a href="#（四）、多媒体文件-音视频渲染（Renderer）" class="headerlink" title="（四）、多媒体文件 - 音视频渲染（Renderer）"></a>（四）、多媒体文件 - 音视频渲染（Renderer）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnOutputBuffer(</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">size_t</span> offset,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getOutputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mOutputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mOutputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mOutputBuffers.add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOutputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(offset, size);</span><br><span class="line">    buffer-&gt;meta()-&gt;clear();</span><br><span class="line">    buffer-&gt;meta()-&gt;setInt64(<span class="string">&quot;timeUs&quot;</span>, timeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS;</span><br><span class="line">    <span class="comment">// we do not expect CODECCONFIG or SYNCFRAME for decoder</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatRenderBuffer, <span class="keyword">this</span>);</span><br><span class="line">    reply-&gt;setSize(<span class="string">&quot;buffer-ix&quot;</span>, index);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mBufferGeneration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">&quot;eos&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        reply-&gt;setInt32(<span class="string">&quot;eos&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSkipRenderingUntilMediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123;</span><br><span class="line">            reply-&gt;post();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSkipRenderingUntilMediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumFramesTotal += !mIsAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until 1st frame comes out to signal resume complete</span></span><br><span class="line">    notifyResumeCompleteIfNecessary();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// send the buffer to renderer.</span></span><br><span class="line">        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);</span><br><span class="line">        <span class="keyword">if</span> (eos &amp;&amp; !isDiscontinuityPending()) &#123;</span><br><span class="line">            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a.    在kWhatRenderBuffer消息处理中会调用NuPlayer::Decoder::onRenderBuffer(…)，在其中根据情况调用函数MediaCodec::renderOutputBufferAndRelease(..)渲染并释放，或者调用MediaCodec::releaseOutputBuffer(…)不渲染直接释放，两中情况都会产生kWhatReleaseOutputBuffer消息，该消息处理中调用函数MediaCodec::onReleaseOutputBuffer(…)，其中判断若SoftRenderer非空则进行软件渲染，不然就会通过○5中的reply让ACodec去硬件渲染，在kWhatOutputBufferDrained消息处理就会中调用到函数ACodec::BaseState::onOutputBufferDrained(…)进行真正的硬件渲染。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onRenderBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">size_t</span> bufferIx;</span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">&quot;buffer-ix&quot;</span>, &amp;bufferIx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx];</span><br><span class="line">        buffer-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span> &amp;&amp; mCCDecoder-&gt;isSelected()) &#123;</span><br><span class="line">            mCCDecoder-&gt;display(timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">&quot;render&quot;</span>, &amp;render) &amp;&amp; render) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs;</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">&quot;timestampNs&quot;</span>, &amp;timestampNs));</span><br><span class="line">        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNumOutputFramesDropped += !mIsAudio;</span><br><span class="line">        err = mCodec-&gt;releaseOutputBuffer(bufferIx);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.    MediaCodec:: getOutputBuffer (…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer的信息<br>c.    若Renderer非空则会调用NuPlayer::Renderer::queueBuffer(…)进行Renderer的相关处理同时消耗产生的kWhatRenderBuffer消息。queueBuffer()会产生kWhatQueueBuffer消息，消息处理中会调用函数NuPlayer::Renderer::onQueueBuffer(…) –&gt; NuPlayer::Renderer::postDrainVideoQueue() 【另外有audio的相关处理】，其中产生kWhatDrainVideoQueue消息，消息处理中调用先NuPlayer::Renderer::onDrainVideoQueue()在VideoQueue中取相关数据，再调用NuPlayer::Renderer::postDrainVideoQueue()循环取video数据，接着还会发送kWhatRenderBuffer消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> audio;</span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        mHasAudio = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoScheduler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mVideoScheduler = <span class="keyword">new</span> VideoFrameScheduler();</span><br><span class="line">            mVideoScheduler-&gt;init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">&quot;buffer&quot;</span>, &amp;buffer));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notifyConsumed;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">&quot;notifyConsumed&quot;</span>, &amp;notifyConsumed));</span><br><span class="line"></span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-05-source-demux-decoder-output-render.jpg" alt="Alt text"></p>
<h4 id="（五）、视频解码输出到SurfaceFlinger"><a href="#（五）、视频解码输出到SurfaceFlinger" class="headerlink" title="（五）、视频解码输出到SurfaceFlinger"></a>（五）、视频解码输出到SurfaceFlinger</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">&quot;buffer-id&quot;</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Wrong ownership in OBD: %s(%d) buffer #%u&quot;</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_native_rect_t</span> crop;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findRect(<span class="string">&quot;crop&quot;</span>, &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom)</span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, <span class="keyword">sizeof</span>(crop)) != <span class="number">0</span>) &#123;</span><br><span class="line">        mCodec-&gt;mLastNativeWindowCrop = crop;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">&quot;failed to set crop: %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> dataSpace;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">&quot;dataspace&quot;</span>, &amp;dataSpace)</span><br><span class="line">            &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_buffers_data_space(</span><br><span class="line">                mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace);</span><br><span class="line">        mCodec-&gt;mLastNativeWindowDataSpace = dataSpace;</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">&quot;failed to set dataspace: %d&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; msg-&gt;findInt32(<span class="string">&quot;render&quot;</span>, &amp;render) &amp;&amp; render != <span class="number">0</span></span><br><span class="line">            &amp;&amp; info-&gt;mData != <span class="literal">NULL</span> &amp;&amp; info-&gt;mData-&gt;size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">        <span class="comment">// The client wants this buffer to be rendered.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save buffers sent to the surface so we can get render time when they return</span></span><br><span class="line">        <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">        info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;mediaTimeUs);</span><br><span class="line">        <span class="keyword">if</span> (mediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mCodec-&gt;mRenderTracker.onFrameQueued(</span><br><span class="line">                    mediaTimeUs, info-&gt;mGraphicBuffer, <span class="keyword">new</span> Fence(::dup(info-&gt;mFenceFd)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;findInt64(<span class="string">&quot;timestampNs&quot;</span>, &amp;timestampNs)) &#123;</span><br><span class="line">            <span class="comment">// use media timestamp if client did not request a specific render timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;timestampNs)) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;using buffer PTS of %lld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)timestampNs);</span><br><span class="line">                timestampNs *= <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line">        err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">&quot;failed to set buffer timestamp: %d&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">        info-&gt;checkReadFence(<span class="string">&quot;onOutputBufferDrained before queueBuffer&quot;</span>);</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;queueBuffer failed in onOutputBufferDrained: %d&quot;</span>, err);</span><br><span class="line">            mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">            <span class="comment">// keeping read fence as write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (info-&gt;mData == <span class="literal">NULL</span> || info-&gt;mData-&gt;size() != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// move read fence into write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">            ATRACE_NAME(<span class="string">&quot;frame-drop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-1、Surfaceflinger-视频解码缓存申请"><a href="#5-1、Surfaceflinger-视频解码缓存申请" class="headerlink" title="5.1、Surfaceflinger 视频解码缓存申请"></a>5.1、Surfaceflinger 视频解码缓存申请</h5><p>前面2.3.6、MediaCodec-&gt;start()分析过：<br>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="comment">//使用surface渲染，为输出分配图形缓存GraphicBuffer  </span></span><br><span class="line"><span class="keyword">status_t</span> ACodec::LoadedToIdleState::allocateBuffers() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ACodec::allocateBuffersOnPort</span><span class="params">(OMX_U32 portIndex)</span> </span>&#123;</span><br><span class="line">    CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    CHECK(mDealer[portIndex] == <span class="literal">NULL</span>);</span><br><span class="line">    CHECK(mBuffers[portIndex].isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">            err = allocateOutputMetadataBuffers();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = allocateOutputBuffersFromNativeWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><a href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现" class="headerlink" title="5.1.1、allocateOutputBuffersFromNativeWindow()的实现"></a>5.1.1、allocateOutputBuffersFromNativeWindow()的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ACodec::allocateOutputBuffersFromNativeWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;</span><br><span class="line">    <span class="keyword">status_t</span> err = configureOutputBuffersFromNativeWindow(</span><br><span class="line">            &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, <span class="literal">true</span> <span class="comment">/* preregister */</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    mNumUndequeuedBuffers = minUndequeuedBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">                -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Dequeue buffers and send them to OMX</span></span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">        <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">graphicBuffer</span><span class="params">(<span class="keyword">new</span> GraphicBuffer(buf, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">        info.mFenceFd = fenceFd;</span><br><span class="line">        info.mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        info.mRenderInfo = <span class="literal">NULL</span>;</span><br><span class="line">        info.mData = <span class="keyword">new</span> ABuffer(<span class="literal">NULL</span> <span class="comment">/* data */</span>, bufferSize <span class="comment">/* capacity */</span>);</span><br><span class="line">        info.mCodecData = info.mData;</span><br><span class="line">        info.mGraphicBuffer = graphicBuffer;</span><br><span class="line">        mBuffers[kPortIndexOutput].push(info);</span><br><span class="line"></span><br><span class="line">        IOMX::buffer_id bufferId;</span><br><span class="line">        err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,</span><br><span class="line">                &amp;bufferId);</span><br><span class="line">        ......</span><br><span class="line">        mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-1-1-1、首先为视频编码输出准备Surface"><a href="#5-1-1-1、首先为视频编码输出准备Surface" class="headerlink" title="5.1.1.1、首先为视频编码输出准备Surface"></a>5.1.1.1、首先为视频编码输出准备Surface</h5><p>此处通过Binder通信使用IGraphicBufferProducer请求分配一个Native Surface</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">        -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-06-Surface-ANativeWindow.png" alt="Alt text"></p>
<h5 id="5-1-1-2、Surface-gt-dequeueBuffer"><a href="#5-1-1-2、Surface-gt-dequeueBuffer" class="headerlink" title="5.1.1.2、Surface-&gt;dequeueBuffer"></a>5.1.1.2、Surface-&gt;dequeueBuffer</h5><p>为Surface分配Buffer，提供给视频解码后数据使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ACodec::allocateOutputBuffersFromNativeWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-2、Surface-gt-queueBuffer"><a href="#5-2、Surface-gt-queueBuffer" class="headerlink" title="5.2、Surface-&gt;queueBuffer()"></a>5.2、Surface-&gt;queueBuffer()</h5><p>待视频解码后，使用queueBuffer()交给SurfaceFlinger渲染，就可以在屏幕上看到视频画面了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>![Alt text](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-07-OpenMax-Based">https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/video.system/02-07-OpenMax-Based</a> video decode-surfaceflinger.png)</p>
<p>关于SurfaceFlinger的知识请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】</p>
<p><strong>（ ͡° ͜ʖ ͡°）、（ಡωಡ）累<del>~</del>，有时间再继续Todo的分析吧，(๑乛◡乛๑) ！！！</strong><br><strong>Todo：Android OpenMax机制 实现分析</strong><br><strong>Todo：Android 音视频同步机制 源码分析</strong><br><strong>Todo：Android 音视频录制（Recoder）、编码（Encode）、混合（MediaMuxer）源码分析</strong></p>
<h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/">Android NuPlayer播放框架 </a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/12812.html">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaomiao12345678/article/details/57415505">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaomiao12345678/article/details/57409783">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaomiao12345678/article/details/56961370">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/YUV">YUV - 维基百科，自由的百科全书</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/harman_zjc/article/details/53386010">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/harman_zjc/article/details/53397945">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/category/7610722">husanlim 的专栏 参考 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/54926526">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfhuang09/article/details/60132620">android MediaCodec ACodec - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/16222.html">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/nonmarking/article/category/6746500">深入理解Android音视频同步机制（总共五篇）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/junzia/article/details/54018671">Android硬编码——音频编码、视频编码及音视频混合</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190209/">https://zhoujinjian.com/posts/20190209/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Video/">Video</a><a class="post-meta__tags" href="/tags/Multimedia/">Multimedia</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190210/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.24.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20190208/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Video System（1）：Video System(视频系统)框架分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20190208/" title="Android Video System（1）：Video System(视频系统)框架分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-08</div><div class="title">Android Video System（1）：Video System(视频系统)框架分析</div></div></a></div><div><a href="/posts/20190210/" title="Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-10</div><div class="title">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</div></div></a></div><div><a href="/posts/20190211/" title="Android Video System（4）：Android Multimedia - OpenMax实现分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-11</div><div class="title">Android Video System（4）：Android Multimedia - OpenMax实现分析</div></div></a></div><div><a href="/posts/20190212/" title="Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-12</div><div class="title">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</div></div></a></div><div><a href="/posts/20190213/" title="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-13</div><div class="title">Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</div></div></a></div><div><a href="/posts/20190214/" title="Android Video System（7）：Android Multimedia Codecs - AAC编解码分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.29.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-14</div><div class="title">Android Video System（7）：Android Multimedia Codecs - AAC编解码分析</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90-MediaExtractor%E5%88%86%E7%A6%BB%E9%9F%B3%E8%A7%86%E9%A2%91"><span class="toc-number">1.</span> <span class="toc-text">（一）、多媒体文件解析 - MediaExtractor分离音视频</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81mMediaPlayer-prepareAsync"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、mMediaPlayer.prepareAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1%E3%80%81MediaPlayer-setVideoSurfaceTexture"><span class="toc-number">1.2.</span> <span class="toc-text">1.1.1、MediaPlayer.setVideoSurfaceTexture()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2%E3%80%81MediaPlayer-prepareAsync"><span class="toc-number">1.3.</span> <span class="toc-text">1.1.2、MediaPlayer.prepareAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3%E3%80%81GenericSource-initFromDataSource"><span class="toc-number">1.4.</span> <span class="toc-text">1.1.3、GenericSource.initFromDataSource()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4%E3%80%81MediaExtractor-Create"><span class="toc-number">1.5.</span> <span class="toc-text">1.1.4、MediaExtractor::Create()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-5%E3%80%81IMediaExtractor-gt-getTrack"><span class="toc-number">1.6.</span> <span class="toc-text">1.1.5、IMediaExtractor-&gt;getTrack()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%EF%BC%88Decoder%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">（二）、多媒体文件 - 音视频解码（Decoder）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81NuPlayer-start"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、NuPlayer::start()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2%E3%80%81postScanSources"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、postScanSources()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E3%80%81instantiateDecoder"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、instantiateDecoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1%E3%80%81%E5%88%9B%E5%BB%BA%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8new-Decoder"><span class="toc-number">2.4.</span> <span class="toc-text">2.3.1、创建音视频解码器new Decoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96Decoder-gt-init"><span class="toc-number">2.5.</span> <span class="toc-text">2.3.2、初始化Decoder-&gt;init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3%E3%80%81%E9%85%8D%E7%BD%AEDecoder-gt-configure"><span class="toc-number">2.6.</span> <span class="toc-text">2.3.3、配置Decoder-&gt;configure()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4%E3%80%81MediaCodec-init-%E2%80%A6"><span class="toc-number">2.7.</span> <span class="toc-text">2.3.4、MediaCodec::init(…)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1%E3%80%81GetCodecBase"><span class="toc-number">2.8.</span> <span class="toc-text">2.3.4.1、GetCodecBase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2%E3%80%81MediaCodecList-getInstance"><span class="toc-number">2.9.</span> <span class="toc-text">2.3.4.2、MediaCodecList::getInstance()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5%E3%80%81MediaCodec-gt-configure"><span class="toc-number">2.10.</span> <span class="toc-text">2.3.5、MediaCodec-&gt;configure()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6%E3%80%81MediaCodec-gt-start"><span class="toc-number">2.11.</span> <span class="toc-text">2.3.6、MediaCodec-&gt;start()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">（三）、音视频解码数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-emptyBuffer"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、音视频解码数据处理-emptyBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1%E3%80%81ACodec-ExecutingState-resume"><span class="toc-number">3.2.</span> <span class="toc-text">3.1.1、ACodec::ExecutingState::resume()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-1%E3%80%81kWhatFillThisBuffer%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">3.1.1.1、kWhatFillThisBuffer消息处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-2%E3%80%81kWhatInputBufferFilled%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">3.1.1.2、kWhatInputBufferFilled消息处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-fillBuffer"><span class="toc-number">3.5.</span> <span class="toc-text">3.2、音视频解码数据处理-fillBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1%E3%80%81ACodec-ExecutingState-resume"><span class="toc-number">3.6.</span> <span class="toc-text">3.2.1、ACodec::ExecutingState::resume()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%EF%BC%88Renderer%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">（四）、多媒体文件 - 音视频渲染（Renderer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E8%BE%93%E5%87%BA%E5%88%B0SurfaceFlinger"><span class="toc-number">5.</span> <span class="toc-text">（五）、视频解码输出到SurfaceFlinger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E3%80%81Surfaceflinger-%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E7%BC%93%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">5.1.</span> <span class="toc-text">5.1、Surfaceflinger 视频解码缓存申请</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1%E3%80%81allocateOutputBuffersFromNativeWindow-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">5.1.1、allocateOutputBuffersFromNativeWindow()的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-1%E3%80%81%E9%A6%96%E5%85%88%E4%B8%BA%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E8%BE%93%E5%87%BA%E5%87%86%E5%A4%87Surface"><span class="toc-number">5.3.</span> <span class="toc-text">5.1.1.1、首先为视频编码输出准备Surface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-2%E3%80%81Surface-gt-dequeueBuffer"><span class="toc-number">5.4.</span> <span class="toc-text">5.1.1.2、Surface-&gt;dequeueBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E3%80%81Surface-gt-queueBuffer"><span class="toc-number">5.5.</span> <span class="toc-text">5.2、Surface-&gt;queueBuffer()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">（六）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>