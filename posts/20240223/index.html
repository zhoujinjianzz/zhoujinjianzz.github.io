<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识 | zhoujinjian</title><meta name="keywords" content="Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">
<meta property="og:url" content="https://zhoujinjian.com/posts/20240223/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg">
<meta property="article:published_time" content="2024-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.940Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20240223/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.940Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Kernel-4.19</strong>==）&amp;&amp;（==<strong>文章基于 Android 11.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://shop.allnetchina.cn/collections/frontpage/products/rock-pi-4-model-b-board-only-2-4-5ghz-wlan-bluetooth-5-0">【开发板 RockPi4bPlusV1.6】</a></p>
<p><a href="">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）源码链接】</a>：（repo init -u <a target="_blank" rel="noopener" href="https://github.com/radxa/manifests.git">https://github.com/radxa/manifests.git</a> -b Android11_Radxa_rk11.1 -m rockchip-r-release.xml）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.radxa.com/Rockpi4/rockpi-android11">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）编译指南】</a></p>
<p>正是由于前人（各位大神）的分析和总结，帮助我节约了大量的时间和精力，特别感谢，由于不喜欢图片水印，去除了水印，敬请谅解！！！</p>
<p>本文转自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17810903.html">Rockchip RK3399 - DRM encoder、bridge、connector基础知识 </a>，如有侵权，请联系删除。</p>
<hr>
<p>开发板 ：<code>ROCK Pi 4B+</code>开发板<br><code>eMMC</code> ：<code>32GB</code><br><code>LPDDR4</code> ：<code>4GB</code><br>显示屏 ：<code>7</code>英寸<code>HDMI</code>接口显示屏<br><code>u-boot</code> ：<code>2017.09</code><br><code>linux</code> ：<code>4.19</code>  </p>
<hr>
<h3 id="一、encoder数据结构"><a href="#一、encoder数据结构" class="headerlink" title="一、encoder数据结构"></a>一、<code>encoder</code>数据结构</h3><h4 id="1-1-struct-drm-encoder"><a href="#1-1-struct-drm-encoder" class="headerlink" title="1.1 struct drm_encoder"></a>1.1 <code>struct drm_encoder</code></h4><p><code>linux</code>内核使用<code>struct drm_encoder</code>来表示一个编码器，将<code>crtc</code>输出的图像信号转换成一定格式的数字信号，如<code>HDMI</code>、<code>DisplayPort</code>、<code>MIPI</code>等；定义在<code>include/drm/drm_encoder.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_encoder - central DRM encoder structure</span></span><br><span class="line"><span class="comment"> * @dev: parent DRM device</span></span><br><span class="line"><span class="comment"> * @head: list management</span></span><br><span class="line"><span class="comment"> * @base: base KMS object</span></span><br><span class="line"><span class="comment"> * @name: human readable name, can be overwritten by the driver</span></span><br><span class="line"><span class="comment"> * @funcs: control functions, can be NULL for simple managed encoders</span></span><br><span class="line"><span class="comment"> * @helper_private: mid-layer private data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CRTCs drive pixels to encoders, which convert them into signals</span></span><br><span class="line"><span class="comment"> * appropriate for a given connector or set of connectors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_object</span> <span class="title">base</span>;</span></span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @encoder_type:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * One of the DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h. The following</span></span><br><span class="line"><span class="comment">         * encoder types are defined thus far:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_LVDS for display panels, or in general any panel</span></span><br><span class="line"><span class="comment">         *   with a proprietary parallel connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video,</span></span><br><span class="line"><span class="comment">         *   Component, SCART).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel</span></span><br><span class="line"><span class="comment">         *   bus.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * - DRM_MODE_ENCODER_DPMST for special fake encoders used to allow</span></span><br><span class="line"><span class="comment">         *   mutliple DP MST streams to share one physical encoder.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> encoder_type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @index: Position inside the mode_config.list, can be used as an array</span></span><br><span class="line"><span class="comment">         * index. It is invariant over the lifetime of the encoder.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> index;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @possible_crtcs: Bitmask of potential CRTC bindings, using</span></span><br><span class="line"><span class="comment">         * drm_crtc_index() as the index into the bitfield. The driver must set</span></span><br><span class="line"><span class="comment">         * the bits for all &amp;drm_crtc objects this encoder can be connected to</span></span><br><span class="line"><span class="comment">         * before calling drm_dev_register().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * You will get a WARN if you get this wrong in the driver.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that since CRTC objects can&#x27;t be hotplugged the assigned indices</span></span><br><span class="line"><span class="comment">         * are stable and hence known before registering all objects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> possible_crtcs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @possible_clones: Bitmask of potential sibling encoders for cloning,</span></span><br><span class="line"><span class="comment">         * using drm_encoder_index() as the index into the bitfield. The driver</span></span><br><span class="line"><span class="comment">         * must set the bits for all &amp;drm_encoder objects which can clone a</span></span><br><span class="line"><span class="comment">         * &amp;drm_crtc together with this encoder before calling</span></span><br><span class="line"><span class="comment">         * drm_dev_register(). Drivers should set the bit representing the</span></span><br><span class="line"><span class="comment">         * encoder itself, too. Cloning bits should be set such that when two</span></span><br><span class="line"><span class="comment">         * encoders can be used in a cloned configuration, they both should have</span></span><br><span class="line"><span class="comment">         * each another bits set.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * As an exception to the above rule if the driver doesn&#x27;t implement</span></span><br><span class="line"><span class="comment">         * any cloning it can leave @possible_clones set to 0. The core will</span></span><br><span class="line"><span class="comment">         * automagically fix this up by setting the bit for the encoder itself.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * You will get a WARN if you get this wrong in the driver.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that since encoder objects can&#x27;t be hotplugged the assigned indices</span></span><br><span class="line"><span class="comment">         * are stable and hence known before registering all objects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> possible_clones;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @crtc: Currently bound CRTC, only really meaningful for non-atomic</span></span><br><span class="line"><span class="comment">         * drivers.  Atomic drivers should instead check</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_state.crtc.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_crtc</span> *<span class="title">crtc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @bridge_chain: Bridges attached to this encoder. Drivers shall not</span></span><br><span class="line"><span class="comment">         * access this field directly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bridge_chain</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder_funcs</span> *<span class="title">funcs</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder_helper_funcs</span> *<span class="title">helper_private</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-操作函数"><a href="#1-2-操作函数" class="headerlink" title="1.2 操作函数"></a>1.2 操作函数</h4><h5 id="1-2-1-struct-drm-encoder-funcs"><a href="#1-2-1-struct-drm-encoder-funcs" class="headerlink" title="1.2.1 struct drm_encoder_funcs"></a>1.2.1 <code>struct drm_encoder_funcs</code></h5><p><code>struct drm_encoder_funcs</code>用于描述<code>encoder</code>的控制函数，定义在<code>include/drm/drm_encoder.h</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_encoder_funcs - encoder controls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Encoders sit between CRTCs and connectors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder_funcs</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @reset:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Reset encoder hardware and software state to off. This function isn&#x27;t</span></span><br><span class="line"><span class="comment">         * called by the core directly, only through drm_mode_config_reset().</span></span><br><span class="line"><span class="comment">         * It&#x27;s not a helper hook only for historical reasons.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*reset)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @destroy:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Clean up encoder resources. This is only called at driver unload time</span></span><br><span class="line"><span class="comment">         * through drm_mode_config_cleanup() since an encoder cannot be</span></span><br><span class="line"><span class="comment">         * hotplugged in DRM.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*destroy)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @late_register:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optional hook can be used to register additional userspace</span></span><br><span class="line"><span class="comment">         * interfaces attached to the encoder like debugfs interfaces.</span></span><br><span class="line"><span class="comment">         * It is called late in the driver load sequence from drm_dev_register().</span></span><br><span class="line"><span class="comment">         * Everything added from this callback should be unregistered in</span></span><br><span class="line"><span class="comment">         * the early_unregister callback.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Returns:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success, or a negative error code on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*late_register)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @early_unregister:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optional hook should be used to unregister the additional</span></span><br><span class="line"><span class="comment">         * userspace interfaces attached to the encoder from</span></span><br><span class="line"><span class="comment">         * @late_register. It is called from drm_dev_unregister(),</span></span><br><span class="line"><span class="comment">         * early in the driver unload sequence to disable userspace access</span></span><br><span class="line"><span class="comment">         * before data structures are torndown.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*early_unregister)(struct drm_encoder *encoder);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-struct-drm-encoder-helper-funcs"><a href="#1-2-2-struct-drm-encoder-helper-funcs" class="headerlink" title="1.2.2 struct drm_encoder_helper_funcs"></a>1.2.2 <code>struct drm_encoder_helper_funcs</code></h5><p><code>struct drm_encoder_helper_funcs</code>定义了一些常用的<code>encoder</code>辅助操作函数，定义在<code>include/drm/drm_modeset_helper_vtables.h</code>；</p>
<p>Hidden Code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_encoder_helper_funcs - helper operations for encoders</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These hooks are used by the legacy CRTC helpers, the transitional plane</span></span><br><span class="line"><span class="comment"> * helpers and the new atomic modesetting helpers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder_helper_funcs</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @dpms:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Callback to control power levels on the encoder.  If the mode passed in</span></span><br><span class="line"><span class="comment">         * is unsupported, the provider must use the next lowest power level.</span></span><br><span class="line"><span class="comment">         * This is used by the legacy encoder helpers to implement DPMS</span></span><br><span class="line"><span class="comment">         * functionality in drm_helper_connector_dpms().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is also used to disable an encoder by calling it with</span></span><br><span class="line"><span class="comment">         * DRM_MODE_DPMS_OFF if the @disable hook isn&#x27;t used.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the legacy CRTC helpers.  Atomic helpers</span></span><br><span class="line"><span class="comment">         * also support using this hook for enabling and disabling an encoder to</span></span><br><span class="line"><span class="comment">         * facilitate transitions to atomic, but it is deprecated. Instead</span></span><br><span class="line"><span class="comment">         * @enable and @disable should be used.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*dpms)(struct drm_encoder *encoder, <span class="keyword">int</span> mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_valid:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to check if a specific mode is valid in this</span></span><br><span class="line"><span class="comment">         * encoder. This should be implemented if the encoder has some sort</span></span><br><span class="line"><span class="comment">         * of restriction in the modes it can display. For example, a given</span></span><br><span class="line"><span class="comment">         * encoder may be responsible to set a clock value. If the clock can</span></span><br><span class="line"><span class="comment">         * not produce all the values for the available modes then this callback</span></span><br><span class="line"><span class="comment">         * can be used to restrict the number of modes to only the ones that</span></span><br><span class="line"><span class="comment">         * can be displayed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is used by the probe helpers to filter the mode list in</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes(), and it is used by the</span></span><br><span class="line"><span class="comment">         * atomic helpers to validate modes supplied by userspace in</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_check_modeset().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Since this function is both called from the check phase of an atomic</span></span><br><span class="line"><span class="comment">         * commit, and the mode validation in the probe paths it is not allowed</span></span><br><span class="line"><span class="comment">         * to look at anything else but the passed-in mode, and validate it</span></span><br><span class="line"><span class="comment">         * against configuration-invariant hardward constraints. Any further</span></span><br><span class="line"><span class="comment">         * limits which depend upon the configuration can only be checked in</span></span><br><span class="line"><span class="comment">         * @mode_fixup or @atomic_check.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * drm_mode_status Enum</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_mode_status</span> <span class="params">(*mode_valid)</span><span class="params">(struct drm_encoder *crtc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> struct drm_display_mode *mode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_fixup:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to validate and adjust a mode. The parameter</span></span><br><span class="line"><span class="comment">         * mode is the display mode that should be fed to the next element in</span></span><br><span class="line"><span class="comment">         * the display chain, either the final &amp;drm_connector or a &amp;drm_bridge.</span></span><br><span class="line"><span class="comment">         * The parameter adjusted_mode is the input mode the encoder requires. It</span></span><br><span class="line"><span class="comment">         * can be modified by this callback and does not need to match mode. See</span></span><br><span class="line"><span class="comment">         * also &amp;drm_crtc_state.adjusted_mode for more details.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is used by both legacy CRTC helpers and atomic helpers.</span></span><br><span class="line"><span class="comment">         * This hook is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the check phase of atomic modesets, which</span></span><br><span class="line"><span class="comment">         * can be aborted for any reason (including on userspace&#x27;s request to</span></span><br><span class="line"><span class="comment">         * just check whether a configuration would be possible). Atomic drivers</span></span><br><span class="line"><span class="comment">         * MUST NOT touch any persistent state (hardware or software) or data</span></span><br><span class="line"><span class="comment">         * structures except the passed in adjusted_mode parameter.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is in contrast to the legacy CRTC helpers where this was</span></span><br><span class="line"><span class="comment">         * allowed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Atomic drivers which need to inspect and adjust more state should</span></span><br><span class="line"><span class="comment">         * instead use the @atomic_check callback. If @atomic_check is used,</span></span><br><span class="line"><span class="comment">         * this hook isn&#x27;t called since @atomic_check allows a strict superset</span></span><br><span class="line"><span class="comment">         * of the functionality of @mode_fixup.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Also beware that userspace can request its own custom modes, neither</span></span><br><span class="line"><span class="comment">         * core nor helpers filter modes to the list of probe modes reported by</span></span><br><span class="line"><span class="comment">         * the GETCONNECTOR IOCTL and stored in &amp;drm_connector.modes. To ensure</span></span><br><span class="line"><span class="comment">         * that modes are filtered consistently put any encoder constraints and</span></span><br><span class="line"><span class="comment">         * limits checks into @mode_valid.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * True if an acceptable configuration is possible, false if the modeset</span></span><br><span class="line"><span class="comment">         * operation should be rejected.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> (*mode_fixup)(struct drm_encoder *encoder,</span><br><span class="line">                           <span class="keyword">const</span> struct drm_display_mode *mode,</span><br><span class="line">                           struct drm_display_mode *adjusted_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @prepare:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should prepare the encoder for a subsequent modeset,</span></span><br><span class="line"><span class="comment">         * which in practice means the driver should disable the encoder if it</span></span><br><span class="line"><span class="comment">         * is running. Most drivers ended up implementing this by calling their</span></span><br><span class="line"><span class="comment">         * @dpms hook with DRM_MODE_DPMS_OFF.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the legacy CRTC helpers.  Atomic helpers</span></span><br><span class="line"><span class="comment">         * also support using this hook for disabling an encoder to facilitate</span></span><br><span class="line"><span class="comment">         * transitions to atomic, but it is deprecated. Instead @disable should</span></span><br><span class="line"><span class="comment">         * be used.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*prepare)(struct drm_encoder *encoder);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @commit:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should commit the new mode on the encoder after a modeset,</span></span><br><span class="line"><span class="comment">         * which in practice means the driver should enable the encoder.  Most</span></span><br><span class="line"><span class="comment">         * drivers ended up implementing this by calling their @dpms hook with</span></span><br><span class="line"><span class="comment">         * DRM_MODE_DPMS_ON.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the legacy CRTC helpers.  Atomic helpers</span></span><br><span class="line"><span class="comment">         * also support using this hook for enabling an encoder to facilitate</span></span><br><span class="line"><span class="comment">         * transitions to atomic, but it is deprecated. Instead @enable should</span></span><br><span class="line"><span class="comment">         * be used.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*commit)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_set:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to update the display mode of an encoder.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that the display pipe is completely off when this function is</span></span><br><span class="line"><span class="comment">         * called. Drivers which need hardware to be running before they program</span></span><br><span class="line"><span class="comment">         * the new display mode (because they implement runtime PM) should not</span></span><br><span class="line"><span class="comment">         * use this hook, because the helper library calls it only once and not</span></span><br><span class="line"><span class="comment">         * every time the display pipeline is suspend using either DPMS or the</span></span><br><span class="line"><span class="comment">         * new &quot;ACTIVE&quot; property. Such drivers should instead move all their</span></span><br><span class="line"><span class="comment">         * encoder setup into the @enable callback.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used both by the legacy CRTC helpers and the atomic</span></span><br><span class="line"><span class="comment">         * modeset helpers. It is optional in the atomic helpers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If the driver uses the atomic modeset helpers and needs to inspect</span></span><br><span class="line"><span class="comment">         * the connector state or connector display info during mode setting,</span></span><br><span class="line"><span class="comment">         * @atomic_mode_set can be used instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*mode_set)(struct drm_encoder *encoder,</span><br><span class="line">                         struct drm_display_mode *mode,</span><br><span class="line">                         struct drm_display_mode *adjusted_mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_mode_set:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to update the display mode of an encoder.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that the display pipe is completely off when this function is</span></span><br><span class="line"><span class="comment">         * called. Drivers which need hardware to be running before they program</span></span><br><span class="line"><span class="comment">         * the new display mode (because they implement runtime PM) should not</span></span><br><span class="line"><span class="comment">         * use this hook, because the helper library calls it only once and not</span></span><br><span class="line"><span class="comment">         * every time the display pipeline is suspended using either DPMS or the</span></span><br><span class="line"><span class="comment">         * new &quot;ACTIVE&quot; property. Such drivers should instead move all their</span></span><br><span class="line"><span class="comment">         * encoder setup into the @enable callback.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the atomic modeset helpers in place of the</span></span><br><span class="line"><span class="comment">         * @mode_set callback, if set by the driver. It is optional and should</span></span><br><span class="line"><span class="comment">         * be used instead of @mode_set if the driver needs to inspect the</span></span><br><span class="line"><span class="comment">         * connector state or display info, since there is no direct way to</span></span><br><span class="line"><span class="comment">         * go from the encoder to the current connector.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_mode_set)(struct drm_encoder *encoder,</span><br><span class="line">                                struct drm_crtc_state *crtc_state,</span><br><span class="line">                                struct drm_connector_state *conn_state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @detect:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback can be used by drivers who want to do detection on the</span></span><br><span class="line"><span class="comment">         * encoder object instead of in connector functions.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * It is not used by any helper and therefore has purely driver-specific</span></span><br><span class="line"><span class="comment">         * semantics. New drivers shouldn&#x27;t use this and instead just implement</span></span><br><span class="line"><span class="comment">         * their own private callbacks.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">FIXME:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This should just be converted into a pile of driver vfuncs.</span></span><br><span class="line"><span class="comment">         * Currently radeon, amdgpu and nouveau are using it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_connector_status</span> <span class="params">(*detect)</span><span class="params">(struct drm_encoder *encoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            struct drm_connector *connector)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should be used to disable the encoder. With the atomic</span></span><br><span class="line"><span class="comment">         * drivers it is called before this encoder&#x27;s CRTC has been shut off</span></span><br><span class="line"><span class="comment">         * using their own &amp;drm_crtc_helper_funcs.atomic_disable hook. If that</span></span><br><span class="line"><span class="comment">         * sequence is too simple drivers can just add their own driver private</span></span><br><span class="line"><span class="comment">         * encoder hooks and call them from CRTC&#x27;s callback by looping over all</span></span><br><span class="line"><span class="comment">         * encoders connected to it using for_each_encoder_on_crtc().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is a variant of @disable that provides the atomic state</span></span><br><span class="line"><span class="comment">         * to the driver. If @atomic_disable is implemented, @disable is not</span></span><br><span class="line"><span class="comment">         * called by the helpers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is only used by atomic helpers. Atomic drivers don&#x27;t need</span></span><br><span class="line"><span class="comment">         * to implement it if there&#x27;s no need to disable anything at the encoder</span></span><br><span class="line"><span class="comment">         * level. To ensure that runtime PM handling (using either DPMS or the</span></span><br><span class="line"><span class="comment">         * new &quot;ACTIVE&quot; property) works @atomic_disable must be the inverse of</span></span><br><span class="line"><span class="comment">         * @atomic_enable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_disable)(struct drm_encoder *encoder,</span><br><span class="line">                               struct drm_atomic_state *state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should be used to enable the encoder. It is called</span></span><br><span class="line"><span class="comment">         * after this encoder&#x27;s CRTC has been enabled using their own</span></span><br><span class="line"><span class="comment">         * &amp;drm_crtc_helper_funcs.atomic_enable hook. If that sequence is</span></span><br><span class="line"><span class="comment">         * too simple drivers can just add their own driver private encoder</span></span><br><span class="line"><span class="comment">         * hooks and call them from CRTC&#x27;s callback by looping over all encoders</span></span><br><span class="line"><span class="comment">         * connected to it using for_each_encoder_on_crtc().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is a variant of @enable that provides the atomic state</span></span><br><span class="line"><span class="comment">         * to the driver. If @atomic_enable is implemented, @enable is not</span></span><br><span class="line"><span class="comment">         * called by the helpers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is only used by atomic helpers, it is the opposite of</span></span><br><span class="line"><span class="comment">         * @atomic_disable. Atomic drivers don&#x27;t need to implement it if there&#x27;s</span></span><br><span class="line"><span class="comment">         * no need to enable anything at the encoder level. To ensure that</span></span><br><span class="line"><span class="comment">         * runtime PM handling works @atomic_enable must be the inverse of</span></span><br><span class="line"><span class="comment">         * @atomic_disable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_enable)(struct drm_encoder *encoder,</span><br><span class="line">                              struct drm_atomic_state *state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should be used to disable the encoder. With the atomic</span></span><br><span class="line"><span class="comment">         * drivers it is called before this encoder&#x27;s CRTC has been shut off</span></span><br><span class="line"><span class="comment">         * using their own &amp;drm_crtc_helper_funcs.disable hook.  If that</span></span><br><span class="line"><span class="comment">         * sequence is too simple drivers can just add their own driver private</span></span><br><span class="line"><span class="comment">         * encoder hooks and call them from CRTC&#x27;s callback by looping over all</span></span><br><span class="line"><span class="comment">         * encoders connected to it using for_each_encoder_on_crtc().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is used both by legacy CRTC helpers and atomic helpers.</span></span><br><span class="line"><span class="comment">         * Atomic drivers don&#x27;t need to implement it if there&#x27;s no need to</span></span><br><span class="line"><span class="comment">         * disable anything at the encoder level. To ensure that runtime PM</span></span><br><span class="line"><span class="comment">         * handling (using either DPMS or the new &quot;ACTIVE&quot; property) works</span></span><br><span class="line"><span class="comment">         * @disable must be the inverse of @enable for atomic drivers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For atomic drivers also consider @atomic_disable and save yourself</span></span><br><span class="line"><span class="comment">         * from having to read the NOTE below!</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * With legacy CRTC helpers there&#x27;s a big semantic difference between</span></span><br><span class="line"><span class="comment">         * @disable and other hooks (like @prepare or @dpms) used to shut down a</span></span><br><span class="line"><span class="comment">         * encoder: @disable is only called when also logically disabling the</span></span><br><span class="line"><span class="comment">         * display pipeline and needs to release any resources acquired in</span></span><br><span class="line"><span class="comment">         * @mode_set (like shared PLLs, or again release pinned framebuffers).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Therefore @disable must be the inverse of @mode_set plus @commit for</span></span><br><span class="line"><span class="comment">         * drivers still using legacy CRTC helpers, which is different from the</span></span><br><span class="line"><span class="comment">         * rules under atomic.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*disable)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should be used to enable the encoder. With the atomic</span></span><br><span class="line"><span class="comment">         * drivers it is called after this encoder&#x27;s CRTC has been enabled using</span></span><br><span class="line"><span class="comment">         * their own &amp;drm_crtc_helper_funcs.enable hook.  If that sequence is</span></span><br><span class="line"><span class="comment">         * too simple drivers can just add their own driver private encoder</span></span><br><span class="line"><span class="comment">         * hooks and call them from CRTC&#x27;s callback by looping over all encoders</span></span><br><span class="line"><span class="comment">         * connected to it using for_each_encoder_on_crtc().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is only used by atomic helpers, it is the opposite of</span></span><br><span class="line"><span class="comment">         * @disable. Atomic drivers don&#x27;t need to implement it if there&#x27;s no</span></span><br><span class="line"><span class="comment">         * need to enable anything at the encoder level. To ensure that</span></span><br><span class="line"><span class="comment">         * runtime PM handling (using either DPMS or the new &quot;ACTIVE&quot; property)</span></span><br><span class="line"><span class="comment">         * works @enable must be the inverse of @disable for atomic drivers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*enable)(struct drm_encoder *encoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_check:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to validate encoder state for atomic drivers.</span></span><br><span class="line"><span class="comment">         * Since the encoder is the object connecting the CRTC and connector it</span></span><br><span class="line"><span class="comment">         * gets passed both states, to be able to validate interactions and</span></span><br><span class="line"><span class="comment">         * update the CRTC to match what the encoder needs for the requested</span></span><br><span class="line"><span class="comment">         * connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Since this provides a strict superset of the functionality of</span></span><br><span class="line"><span class="comment">         * @mode_fixup (the requested and adjusted modes are both available</span></span><br><span class="line"><span class="comment">         * through the passed in &amp;struct drm_crtc_state) @mode_fixup is not</span></span><br><span class="line"><span class="comment">         * called when @atomic_check is implemented.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is used by the atomic helpers, but it is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the check phase of an atomic update. The</span></span><br><span class="line"><span class="comment">         * driver is not allowed to change anything outside of the free-standing</span></span><br><span class="line"><span class="comment">         * state objects passed-in or assembled in the overall &amp;drm_atomic_state</span></span><br><span class="line"><span class="comment">         * update tracking structure.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Also beware that userspace can request its own custom modes, neither</span></span><br><span class="line"><span class="comment">         * core nor helpers filter modes to the list of probe modes reported by</span></span><br><span class="line"><span class="comment">         * the GETCONNECTOR IOCTL and stored in &amp;drm_connector.modes. To ensure</span></span><br><span class="line"><span class="comment">         * that modes are filtered consistently put any encoder constraints and</span></span><br><span class="line"><span class="comment">         * limits checks into @mode_valid.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success, -EINVAL if the state or the transition can&#x27;t be</span></span><br><span class="line"><span class="comment">         * supported, -ENOMEM on memory allocation failure and -EDEADLK if an</span></span><br><span class="line"><span class="comment">         * attempt to obtain another state object ran into a &amp;drm_modeset_lock</span></span><br><span class="line"><span class="comment">         * deadlock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*atomic_check)(struct drm_encoder *encoder,</span><br><span class="line">                            struct drm_crtc_state *crtc_state,</span><br><span class="line">                            struct drm_connector_state *conn_state);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、bridge数据结构"><a href="#二、bridge数据结构" class="headerlink" title="二、bridge数据结构"></a>二、<code>bridge</code>数据结构</h3><h4 id="2-1-struct-drm-bridge"><a href="#2-1-struct-drm-bridge" class="headerlink" title="2.1 struct drm_bridge"></a>2.1 <code>struct drm_bridge</code></h4><p><code>linux</code>内核使用<code>struct drm_bridge</code>来表示一个桥接设备，一般用于注册<code>encoder</code>后面另外再接的转换芯片；定义在<code>include/drm/drm_bridge.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_bridge - central DRM bridge control structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge</span> &#123;</span></span><br><span class="line">        <span class="comment">/** @base: inherit from &amp;drm_private_object */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_private_obj</span> <span class="title">base</span>;</span></span><br><span class="line">        <span class="comment">/** @dev: DRM device this bridge belongs to */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="comment">/** @encoder: encoder to which this bridge is connected */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *<span class="title">encoder</span>;</span></span><br><span class="line">        <span class="comment">/** @chain_node: used to form a bridge chain */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">chain_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF</span></span><br><span class="line">        <span class="comment">/** @of_node: device node pointer to the bridge */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/** @list: to keep track of all added bridges */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @timings:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * the timing specification for the bridge, if any (may be NULL)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_timings</span> *<span class="title">timings</span>;</span></span><br><span class="line">        <span class="comment">/** @funcs: control functions */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_funcs</span> *<span class="title">funcs</span>;</span></span><br><span class="line">        <span class="comment">/** @driver_private: pointer to the bridge driver&#x27;s internal context */</span></span><br><span class="line">        <span class="keyword">void</span> *driver_private;</span><br><span class="line">        <span class="comment">/** @ops: bitmask of operations supported by the bridge */</span></span><br><span class="line">        <span class="keyword">enum</span> drm_bridge_ops ops;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @type: Type of the connection at the bridge output</span></span><br><span class="line"><span class="comment">         * (DRM_MODE_CONNECTOR_*). For bridges at the end of this chain this</span></span><br><span class="line"><span class="comment">         * identifies the type of connected display.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @interlace_allowed: Indicate that the bridge can handle interlaced</span></span><br><span class="line"><span class="comment">         * modes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> interlace_allowed;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @pre_enable_prev_first: The bridge requires that the prev</span></span><br><span class="line"><span class="comment">         * bridge @pre_enable function is called before its @pre_enable,</span></span><br><span class="line"><span class="comment">         * and conversely for post_disable. This is most frequently a</span></span><br><span class="line"><span class="comment">         * requirement for DSI devices which need the host to be initialised</span></span><br><span class="line"><span class="comment">         * before the peripheral.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> pre_enable_prev_first;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @ddc: Associated I2C adapter for DDC access, if any.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">ddc</span>;</span></span><br><span class="line">        <span class="comment">/** private: */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_mutex: Protects the @hpd_cb and @hpd_data fields.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">hpd_mutex</span>;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_cb: Hot plug detection callback, registered with</span></span><br><span class="line"><span class="comment">         * drm_bridge_hpd_enable().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*hpd_cb)(<span class="keyword">void</span> *data, <span class="keyword">enum</span> drm_connector_status status);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_data: Private data passed to the Hot plug detection callback</span></span><br><span class="line"><span class="comment">         * @hpd_cb.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> *hpd_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2struct-drm-bridge-funcs"><a href="#2-2struct-drm-bridge-funcs" class="headerlink" title="2.2struct drm_bridge_funcs"></a>2.2<code>struct drm_bridge_funcs</code></h4><p><code>struct drm_bridge_funcs</code>用于描述<code>bridge</code>的控制函数，定义在<code>include/drm/drm_bridge.h</code>；</p>
<p>Hidden Code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_bridge_funcs - drm_bridge control functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_funcs</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @attach:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is invoked whenever our bridge is being attached to a</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder. The flags argument tunes the behaviour of the attach</span></span><br><span class="line"><span class="comment">         * operation (see DRM_BRIDGE_ATTACH_*).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @attach callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Zero on success, error code on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*attach)(struct drm_bridge *bridge,</span><br><span class="line">                      <span class="keyword">enum</span> drm_bridge_attach_flags flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @detach:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is invoked whenever our bridge is being detached from a</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @detach callback is optional.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*detach)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_valid:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to check if a specific mode is valid in this</span></span><br><span class="line"><span class="comment">         * bridge. This should be implemented if the bridge has some sort of</span></span><br><span class="line"><span class="comment">         * restriction in the modes it can display. For example, a given bridge</span></span><br><span class="line"><span class="comment">         * may be responsible to set a clock value. If the clock can not</span></span><br><span class="line"><span class="comment">         * produce all the values for the available modes then this callback</span></span><br><span class="line"><span class="comment">         * can be used to restrict the number of modes to only the ones that</span></span><br><span class="line"><span class="comment">         * can be displayed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is used by the probe helpers to filter the mode list in</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes(), and it is used by the</span></span><br><span class="line"><span class="comment">         * atomic helpers to validate modes supplied by userspace in</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_check_modeset().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @mode_valid callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Since this function is both called from the check phase of an atomic</span></span><br><span class="line"><span class="comment">         * commit, and the mode validation in the probe paths it is not allowed</span></span><br><span class="line"><span class="comment">         * to look at anything else but the passed-in mode, and validate it</span></span><br><span class="line"><span class="comment">         * against configuration-invariant hardward constraints. Any further</span></span><br><span class="line"><span class="comment">         * limits which depend upon the configuration can only be checked in</span></span><br><span class="line"><span class="comment">         * @mode_fixup.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * drm_mode_status Enum</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_mode_status</span> <span class="params">(*mode_valid)</span><span class="params">(struct drm_bridge *bridge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> struct drm_display_info *info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> struct drm_display_mode *mode)</span></span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_fixup:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used to validate and adjust a mode. The parameter</span></span><br><span class="line"><span class="comment">         * mode is the display mode that should be fed to the next element in</span></span><br><span class="line"><span class="comment">         * the display chain, either the final &amp;drm_connector or the next</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge. The parameter adjusted_mode is the input mode the bridge</span></span><br><span class="line"><span class="comment">         * requires. It can be modified by this callback and does not need to</span></span><br><span class="line"><span class="comment">         * match mode. See also &amp;drm_crtc_state.adjusted_mode for more details.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the only hook that allows a bridge to reject a modeset. If</span></span><br><span class="line"><span class="comment">         * this function passes all other callbacks must succeed for this</span></span><br><span class="line"><span class="comment">         * configuration.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The mode_fixup callback is optional. &amp;drm_bridge_funcs.mode_fixup()</span></span><br><span class="line"><span class="comment">         * is not called when &amp;drm_bridge_funcs.atomic_check() is implemented,</span></span><br><span class="line"><span class="comment">         * so only one of them should be provided.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the check phase of atomic modesets, which</span></span><br><span class="line"><span class="comment">         * can be aborted for any reason (including on userspace&#x27;s request to</span></span><br><span class="line"><span class="comment">         * just check whether a configuration would be possible). Drivers MUST</span></span><br><span class="line"><span class="comment">         * NOT touch any persistent state (hardware or software) or data</span></span><br><span class="line"><span class="comment">         * structures except the passed in @state parameter.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Also beware that userspace can request its own custom modes, neither</span></span><br><span class="line"><span class="comment">         * core nor helpers filter modes to the list of probe modes reported by</span></span><br><span class="line"><span class="comment">         * the GETCONNECTOR IOCTL and stored in &amp;drm_connector.modes. To ensure</span></span><br><span class="line"><span class="comment">         * that modes are filtered consistently put any bridge constraints and</span></span><br><span class="line"><span class="comment">         * limits checks into @mode_valid.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * True if an acceptable configuration is possible, false if the modeset</span></span><br><span class="line"><span class="comment">         * operation should be rejected.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> (*mode_fixup)(struct drm_bridge *bridge,</span><br><span class="line">                           <span class="keyword">const</span> struct drm_display_mode *mode,</span><br><span class="line">                           struct drm_display_mode *adjusted_mode);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should disable the bridge. It is called right before</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is disabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called before that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @disable vfunc. If the preceding element is a &amp;drm_encoder</span></span><br><span class="line"><span class="comment">         * it&#x27;s called right before the &amp;drm_encoder_helper_funcs.disable,</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.prepare or &amp;drm_encoder_helper_funcs.dpms</span></span><br><span class="line"><span class="comment">         * hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge can assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * signals) feeding it is still running when this callback is called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @disable callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is deprecated, do not use!</span></span><br><span class="line"><span class="comment">         * New drivers shall use &amp;drm_bridge_funcs.atomic_disable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*disable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @post_disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should disable the bridge. It is called right after the</span></span><br><span class="line"><span class="comment">         * preceding element in the display pipe is disabled. If the preceding</span></span><br><span class="line"><span class="comment">         * element is a bridge this means it&#x27;s called after that bridge&#x27;s</span></span><br><span class="line"><span class="comment">         * @post_disable function. If the preceding element is a &amp;drm_encoder</span></span><br><span class="line"><span class="comment">         * it&#x27;s called right after the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.disable, &amp;drm_encoder_helper_funcs.prepare</span></span><br><span class="line"><span class="comment">         * or &amp;drm_encoder_helper_funcs.dpms hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge must assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * singals) feeding it is no longer running when this callback is</span></span><br><span class="line"><span class="comment">         * called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @post_disable callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is deprecated, do not use!</span></span><br><span class="line"><span class="comment">         * New drivers shall use &amp;drm_bridge_funcs.atomic_post_disable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*post_disable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_set:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should set the given mode on the bridge. It is called</span></span><br><span class="line"><span class="comment">         * after the @mode_set callback for the preceding element in the display</span></span><br><span class="line"><span class="comment">         * pipeline has been called already. If the bridge is the first element</span></span><br><span class="line"><span class="comment">         * then this would be &amp;drm_encoder_helper_funcs.mode_set. The display</span></span><br><span class="line"><span class="comment">         * pipe (i.e.  clocks and timing signals) is off when this function is</span></span><br><span class="line"><span class="comment">         * called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The adjusted_mode parameter is the mode output by the CRTC for the</span></span><br><span class="line"><span class="comment">         * first bridge in the chain. It can be different from the mode</span></span><br><span class="line"><span class="comment">         * parameter that contains the desired mode for the connector at the end</span></span><br><span class="line"><span class="comment">         * of the bridges chain, for instance when the first bridge in the chain</span></span><br><span class="line"><span class="comment">         * performs scaling. The adjusted mode is mostly useful for the first</span></span><br><span class="line"><span class="comment">         * bridge in the chain and is likely irrelevant for the other bridges.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For atomic drivers the adjusted_mode is the mode stored in</span></span><br><span class="line"><span class="comment">         * &amp;drm_crtc_state.adjusted_mode.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is deprecated, do not use!</span></span><br><span class="line"><span class="comment">         * New drivers shall set their mode in the</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_funcs.atomic_enable operation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*mode_set)(struct drm_bridge *bridge,</span><br><span class="line">                         <span class="keyword">const</span> struct drm_display_mode *mode,</span><br><span class="line">                         <span class="keyword">const</span> struct drm_display_mode *adjusted_mode);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @pre_enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should enable the bridge. It is called right before</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is enabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called before that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @pre_enable function. If the preceding element is a</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder it&#x27;s called right before the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.enable, &amp;drm_encoder_helper_funcs.commit or</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.dpms hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The display pipe (i.e. clocks and timing signals) feeding this bridge</span></span><br><span class="line"><span class="comment">         * will not yet be running when this callback is called. The bridge must</span></span><br><span class="line"><span class="comment">         * not enable the display link feeding the next bridge in the chain (if</span></span><br><span class="line"><span class="comment">         * there is one) when this callback is called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @pre_enable callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is deprecated, do not use!</span></span><br><span class="line"><span class="comment">         * New drivers shall use &amp;drm_bridge_funcs.atomic_pre_enable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*pre_enable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should enable the bridge. It is called right after</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is enabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called after that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @enable function. If the preceding element is a</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder it&#x27;s called right after the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.enable, &amp;drm_encoder_helper_funcs.commit or</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.dpms hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge can assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * signals) feeding it is running when this callback is called. This</span></span><br><span class="line"><span class="comment">         * callback must enable the display link feeding the next bridge in the</span></span><br><span class="line"><span class="comment">         * chain if there is one.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @enable callback is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is deprecated, do not use!</span></span><br><span class="line"><span class="comment">         * New drivers shall use &amp;drm_bridge_funcs.atomic_enable.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*enable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_pre_enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should enable the bridge. It is called right before</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is enabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called before that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @atomic_pre_enable or @pre_enable function. If the preceding</span></span><br><span class="line"><span class="comment">         * element is a &amp;drm_encoder it&#x27;s called right before the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.atomic_enable hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The display pipe (i.e. clocks and timing signals) feeding this bridge</span></span><br><span class="line"><span class="comment">         * will not yet be running when this callback is called. The bridge must</span></span><br><span class="line"><span class="comment">         * not enable the display link feeding the next bridge in the chain (if</span></span><br><span class="line"><span class="comment">         * there is one) when this callback is called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @atomic_pre_enable callback is optional.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_pre_enable)(struct drm_bridge *bridge,</span><br><span class="line">                                  struct drm_bridge_state *old_bridge_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should enable the bridge. It is called right after</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is enabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called after that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @atomic_enable or @enable function. If the preceding element</span></span><br><span class="line"><span class="comment">         * is a &amp;drm_encoder it&#x27;s called right after the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.atomic_enable hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge can assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * signals) feeding it is running when this callback is called. This</span></span><br><span class="line"><span class="comment">         * callback must enable the display link feeding the next bridge in the</span></span><br><span class="line"><span class="comment">         * chain if there is one.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @atomic_enable callback is optional.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_enable)(struct drm_bridge *bridge,</span><br><span class="line">                              struct drm_bridge_state *old_bridge_state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should disable the bridge. It is called right before</span></span><br><span class="line"><span class="comment">         * the preceding element in the display pipe is disabled. If the</span></span><br><span class="line"><span class="comment">         * preceding element is a bridge this means it&#x27;s called before that</span></span><br><span class="line"><span class="comment">         * bridge&#x27;s @atomic_disable or @disable vfunc. If the preceding element</span></span><br><span class="line"><span class="comment">         * is a &amp;drm_encoder it&#x27;s called right before the</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.atomic_disable hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge can assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * signals) feeding it is still running when this callback is called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @atomic_disable callback is optional.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_disable)(struct drm_bridge *bridge,</span><br><span class="line">                               struct drm_bridge_state *old_bridge_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_post_disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback should disable the bridge. It is called right after the</span></span><br><span class="line"><span class="comment">         * preceding element in the display pipe is disabled. If the preceding</span></span><br><span class="line"><span class="comment">         * element is a bridge this means it&#x27;s called after that bridge&#x27;s</span></span><br><span class="line"><span class="comment">         * @atomic_post_disable or @post_disable function. If the preceding</span></span><br><span class="line"><span class="comment">         * element is a &amp;drm_encoder it&#x27;s called right after the encoder&#x27;s</span></span><br><span class="line"><span class="comment">         * &amp;drm_encoder_helper_funcs.atomic_disable hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The bridge must assume that the display pipe (i.e. clocks and timing</span></span><br><span class="line"><span class="comment">         * signals) feeding it is no longer running when this callback is</span></span><br><span class="line"><span class="comment">         * called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @atomic_post_disable callback is optional.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_post_disable)(struct drm_bridge *bridge,</span><br><span class="line">                                    struct drm_bridge_state *old_bridge_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_duplicate_state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Duplicate the current bridge state object (which is guaranteed to be</span></span><br><span class="line"><span class="comment">         * non-NULL).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The atomic_duplicate_state hook is mandatory if the bridge</span></span><br><span class="line"><span class="comment">         * implements any of the atomic hooks, and should be left unassigned</span></span><br><span class="line"><span class="comment">         * otherwise. For bridges that don&#x27;t subclass &amp;drm_bridge_state, the</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_bridge_duplicate_state() helper function shall be</span></span><br><span class="line"><span class="comment">         * used to implement this hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         * A valid drm_bridge_state object or NULL if the allocation fails.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_state</span> *(*<span class="title">atomic_duplicate_state</span>)(<span class="title">struct</span> <span class="title">drm_bridge</span> *<span class="title">bridge</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_destroy_state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Destroy a bridge state object previously allocated by</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_funcs.atomic_duplicate_state().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The atomic_destroy_state hook is mandatory if the bridge implements</span></span><br><span class="line"><span class="comment">         * any of the atomic hooks, and should be left unassigned otherwise.</span></span><br><span class="line"><span class="comment">         * For bridges that don&#x27;t subclass &amp;drm_bridge_state, the</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_bridge_destroy_state() helper function shall be</span></span><br><span class="line"><span class="comment">         * used to implement this hook.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_destroy_state)(struct drm_bridge *bridge,</span><br><span class="line">                                     struct drm_bridge_state *state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_get_output_bus_fmts:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Return the supported bus formats on the output end of a bridge.</span></span><br><span class="line"><span class="comment">         * The returned array must be allocated with kmalloc() and will be</span></span><br><span class="line"><span class="comment">         * freed by the caller. If the allocation fails, NULL should be</span></span><br><span class="line"><span class="comment">         * returned. num_output_fmts must be set to the returned array size.</span></span><br><span class="line"><span class="comment">         * Formats listed in the returned array should be listed in decreasing</span></span><br><span class="line"><span class="comment">         * preference order (the core will try all formats until it finds one</span></span><br><span class="line"><span class="comment">         * that works).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This method is only called on the last element of the bridge chain</span></span><br><span class="line"><span class="comment">         * as part of the bus format negotiation process that happens in</span></span><br><span class="line"><span class="comment">         * &amp;drm_atomic_bridge_chain_select_bus_fmts().</span></span><br><span class="line"><span class="comment">         * This method is optional. When not implemented, the core will</span></span><br><span class="line"><span class="comment">         * fall back to &amp;drm_connector.display_info.bus_formats[0] if</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector.display_info.num_bus_formats &gt; 0,</span></span><br><span class="line"><span class="comment">         * or to MEDIA_BUS_FMT_FIXED otherwise.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 *(*atomic_get_output_bus_fmts)(struct drm_bridge *bridge,</span><br><span class="line">                                           struct drm_bridge_state *bridge_state,</span><br><span class="line">                                           struct drm_crtc_state *crtc_state,</span><br><span class="line">                                           struct drm_connector_state *conn_state,</span><br><span class="line">                                           <span class="keyword">unsigned</span> <span class="keyword">int</span> *num_output_fmts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_get_input_bus_fmts:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Return the supported bus formats on the input end of a bridge for</span></span><br><span class="line"><span class="comment">         * a specific output bus format.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The returned array must be allocated with kmalloc() and will be</span></span><br><span class="line"><span class="comment">         * freed by the caller. If the allocation fails, NULL should be</span></span><br><span class="line"><span class="comment">         * returned. num_input_fmts must be set to the returned array size.</span></span><br><span class="line"><span class="comment">         * Formats listed in the returned array should be listed in decreasing</span></span><br><span class="line"><span class="comment">         * preference order (the core will try all formats until it finds one</span></span><br><span class="line"><span class="comment">         * that works). When the format is not supported NULL should be</span></span><br><span class="line"><span class="comment">         * returned and num_input_fmts should be set to 0.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This method is called on all elements of the bridge chain as part of</span></span><br><span class="line"><span class="comment">         * the bus format negotiation process that happens in</span></span><br><span class="line"><span class="comment">         * drm_atomic_bridge_chain_select_bus_fmts().</span></span><br><span class="line"><span class="comment">         * This method is optional. When not implemented, the core will bypass</span></span><br><span class="line"><span class="comment">         * bus format negotiation on this element of the bridge without</span></span><br><span class="line"><span class="comment">         * failing, and the previous element in the chain will be passed</span></span><br><span class="line"><span class="comment">         * MEDIA_BUS_FMT_FIXED as its output bus format.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Bridge drivers that need to support being linked to bridges that are</span></span><br><span class="line"><span class="comment">         * not supporting bus format negotiation should handle the</span></span><br><span class="line"><span class="comment">         * output_fmt == MEDIA_BUS_FMT_FIXED case appropriately, by selecting a</span></span><br><span class="line"><span class="comment">         * sensible default value or extracting this information from somewhere</span></span><br><span class="line"><span class="comment">         * else (FW property, &amp;drm_display_mode, &amp;drm_display_info, ...)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note: Even if input format selection on the first bridge has no</span></span><br><span class="line"><span class="comment">         * impact on the negotiation process (bus format negotiation stops once</span></span><br><span class="line"><span class="comment">         * we reach the first element of the chain), drivers are expected to</span></span><br><span class="line"><span class="comment">         * return accurate input formats as the input format may be used to</span></span><br><span class="line"><span class="comment">         * configure the CRTC output appropriately.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 *(*atomic_get_input_bus_fmts)(struct drm_bridge *bridge,</span><br><span class="line">                                          struct drm_bridge_state *bridge_state,</span><br><span class="line">                                          struct drm_crtc_state *crtc_state,</span><br><span class="line">                                          struct drm_connector_state *conn_state,</span><br><span class="line">                                          u32 output_fmt,</span><br><span class="line">                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> *num_input_fmts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_check:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This method is responsible for checking bridge state correctness.</span></span><br><span class="line"><span class="comment">         * It can also check the state of the surrounding components in chain</span></span><br><span class="line"><span class="comment">         * to make sure the whole pipeline can work properly.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_funcs.atomic_check() hooks are called in reverse</span></span><br><span class="line"><span class="comment">         * order (from the last to the first bridge).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This method is optional. &amp;drm_bridge_funcs.mode_fixup() is not</span></span><br><span class="line"><span class="comment">         * called when &amp;drm_bridge_funcs.atomic_check() is implemented, so only</span></span><br><span class="line"><span class="comment">         * one of them should be provided.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If drivers need to tweak &amp;drm_bridge_state.input_bus_cfg.flags or</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_state.output_bus_cfg.flags it should happen in</span></span><br><span class="line"><span class="comment">         * this function. By default the &amp;drm_bridge_state.output_bus_cfg.flags</span></span><br><span class="line"><span class="comment">         * field is set to the next bridge</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_state.input_bus_cfg.flags value or</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector.display_info.bus_flags if the bridge is the last</span></span><br><span class="line"><span class="comment">         * element in the chain.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         * zero if the check passed, a negative error code otherwise.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*atomic_check)(struct drm_bridge *bridge,</span><br><span class="line">                            struct drm_bridge_state *bridge_state,</span><br><span class="line">                            struct drm_crtc_state *crtc_state,</span><br><span class="line">                            struct drm_connector_state *conn_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_reset:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Reset the bridge to a predefined state (or retrieve its current</span></span><br><span class="line"><span class="comment">         * state) and return a &amp;drm_bridge_state object matching this state.</span></span><br><span class="line"><span class="comment">         * This function is called at attach time.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The atomic_reset hook is mandatory if the bridge implements any of</span></span><br><span class="line"><span class="comment">         * the atomic hooks, and should be left unassigned otherwise. For</span></span><br><span class="line"><span class="comment">         * bridges that don&#x27;t subclass &amp;drm_bridge_state, the</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_bridge_reset() helper function shall be used to</span></span><br><span class="line"><span class="comment">         * implement this hook.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that the atomic_reset() semantics is not exactly matching the</span></span><br><span class="line"><span class="comment">         * reset() semantics found on other components (connector, plane, ...).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. The reset operation happens when the bridge is attached, not when</span></span><br><span class="line"><span class="comment">         *    drm_mode_config_reset() is called</span></span><br><span class="line"><span class="comment">         * 2. It&#x27;s meant to be used exclusively on bridges that have been</span></span><br><span class="line"><span class="comment">         *    converted to the ATOMIC API</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         * A valid drm_bridge_state object in case of success, an ERR_PTR()</span></span><br><span class="line"><span class="comment">         * giving the reason of the failure otherwise.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_bridge_state</span> *(*<span class="title">atomic_reset</span>)(<span class="title">struct</span> <span class="title">drm_bridge</span> *<span class="title">bridge</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @detect:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Check if anything is attached to the bridge output.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional, if not implemented the bridge will be</span></span><br><span class="line"><span class="comment">         * considered as always having a component attached to its output.</span></span><br><span class="line"><span class="comment">         * Bridges that implement this callback shall set the</span></span><br><span class="line"><span class="comment">         * DRM_BRIDGE_OP_DETECT flag in their &amp;drm_bridge-&gt;ops.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * drm_connector_status indicating the bridge output status.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_connector_status</span> <span class="params">(*detect)</span><span class="params">(struct drm_bridge *bridge)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @get_modes:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Fill all modes currently valid for the sink into the &amp;drm_connector</span></span><br><span class="line"><span class="comment">         * with drm_mode_probed_add().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @get_modes callback is mostly intended to support non-probeable</span></span><br><span class="line"><span class="comment">         * displays such as many fixed panels. Bridges that support reading</span></span><br><span class="line"><span class="comment">         * EDID shall leave @get_modes unimplemented and implement the</span></span><br><span class="line"><span class="comment">         * &amp;drm_bridge_funcs-&gt;get_edid callback instead.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional. Bridges that implement it shall set the</span></span><br><span class="line"><span class="comment">         * DRM_BRIDGE_OP_MODES flag in their &amp;drm_bridge-&gt;ops.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The connector parameter shall be used for the sole purpose of</span></span><br><span class="line"><span class="comment">         * filling modes, and shall not be stored internally by bridge drivers</span></span><br><span class="line"><span class="comment">         * for future usage.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The number of modes added by calling drm_mode_probed_add().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*get_modes)(struct drm_bridge *bridge,</span><br><span class="line">                         struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @get_edid:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Read and parse the EDID data of the connected display.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The @get_edid callback is the preferred way of reporting mode</span></span><br><span class="line"><span class="comment">         * information for a display connected to the bridge output. Bridges</span></span><br><span class="line"><span class="comment">         * that support reading EDID shall implement this callback and leave</span></span><br><span class="line"><span class="comment">         * the @get_modes callback unimplemented.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The caller of this operation shall first verify the output</span></span><br><span class="line"><span class="comment">         * connection status and refrain from reading EDID from a disconnected</span></span><br><span class="line"><span class="comment">         * output.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional. Bridges that implement it shall set the</span></span><br><span class="line"><span class="comment">         * DRM_BRIDGE_OP_EDID flag in their &amp;drm_bridge-&gt;ops.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">         * The connector parameter shall be used for the sole purpose of EDID</span></span><br><span class="line"><span class="comment">         * retrieval and parsing, and shall not be stored internally by bridge</span></span><br><span class="line"><span class="comment">         * drivers for future usage.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * An edid structure newly allocated with kmalloc() (or similar) on</span></span><br><span class="line"><span class="comment">         * success, or NULL otherwise. The caller is responsible for freeing</span></span><br><span class="line"><span class="comment">         * the returned edid structure with kfree().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">edid</span> *(*<span class="title">get_edid</span>)(<span class="title">struct</span> <span class="title">drm_bridge</span> *<span class="title">bridge</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_notify:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Notify the bridge of hot plug detection.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional, it may be implemented by bridges that</span></span><br><span class="line"><span class="comment">         * need to be notified of display connection or disconnection for</span></span><br><span class="line"><span class="comment">         * internal reasons. One use case is to reset the internal state of CEC</span></span><br><span class="line"><span class="comment">         * controllers for HDMI bridges.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*hpd_notify)(struct drm_bridge *bridge,</span><br><span class="line">                           <span class="keyword">enum</span> drm_connector_status status);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_enable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Enable hot plug detection. From now on the bridge shall call</span></span><br><span class="line"><span class="comment">         * drm_bridge_hpd_notify() each time a change is detected in the output</span></span><br><span class="line"><span class="comment">         * connection status, until hot plug detection gets disabled with</span></span><br><span class="line"><span class="comment">         * @hpd_disable.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional and shall only be implemented by bridges</span></span><br><span class="line"><span class="comment">         * that support hot-plug notification without polling. Bridges that</span></span><br><span class="line"><span class="comment">         * implement it shall also implement the @hpd_disable callback and set</span></span><br><span class="line"><span class="comment">         * the DRM_BRIDGE_OP_HPD flag in their &amp;drm_bridge-&gt;ops.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*hpd_enable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hpd_disable:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Disable hot plug detection. Once this function returns the bridge</span></span><br><span class="line"><span class="comment">         * shall not call drm_bridge_hpd_notify() when a change in the output</span></span><br><span class="line"><span class="comment">         * connection status occurs.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional and shall only be implemented by bridges</span></span><br><span class="line"><span class="comment">         * that support hot-plug notification without polling. Bridges that</span></span><br><span class="line"><span class="comment">         * implement it shall also implement the @hpd_enable callback and set</span></span><br><span class="line"><span class="comment">         * the DRM_BRIDGE_OP_HPD flag in their &amp;drm_bridge-&gt;ops.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*hpd_disable)(struct drm_bridge *bridge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @debugfs_init:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Allows bridges to create bridge-specific debugfs files.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*debugfs_init)(struct drm_bridge *bridge, struct dentry *root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三、connector数据结构"><a href="#三、connector数据结构" class="headerlink" title="三、connector数据结构"></a>三、<code>connector</code>数据结构</h3><h4 id="3-1-struct-drm-connector"><a href="#3-1-struct-drm-connector" class="headerlink" title="3.1 struct drm_connector"></a>3.1 <code>struct drm_connector</code></h4><p><code>linux</code>内核使用<code>struct drm_connector</code>来表示一个连接器，用于将<code>encoder</code>输出的信号传递给显示器，并与显示器建立连接；定义在<code>include/drm/drm_connector.h</code>:</p>
<p>Hidden Code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_connector - central DRM connector control structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each connector may be connected to one or more CRTCs, or may be clonable by</span></span><br><span class="line"><span class="comment"> * another connector if they can share a CRTC.  Each connector also has a specific</span></span><br><span class="line"><span class="comment"> * position in the broader display (referred to as a &#x27;screen&#x27; though it could</span></span><br><span class="line"><span class="comment"> * span multiple monitors).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_connector</span> &#123;</span></span><br><span class="line">        <span class="comment">/** @dev: parent DRM device */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="comment">/** @kdev: kernel device for sysfs attributes */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">kdev</span>;</span></span><br><span class="line">        <span class="comment">/** @attr: sysfs attributes */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">attr</span>;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @fwnode: associated fwnode supplied by platform firmware</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Drivers can set this to associate a fwnode with a connector, drivers</span></span><br><span class="line"><span class="comment">         * are expected to get a reference on the fwnode when setting this.</span></span><br><span class="line"><span class="comment">         * drm_connector_cleanup() will call fwnode_handle_put() on this.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @head:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * List of all connectors on a @dev, linked from</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.connector_list. Protected by</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.connector_list_lock, but please only use</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_list_iter to walk this list.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @global_connector_list_entry:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Connector entry in the global connector-list, used by</span></span><br><span class="line"><span class="comment">         * drm_connector_find_by_fwnode().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">global_connector_list_entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @base: base KMS object */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_object</span> <span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @name: human readable name, can be overwritten by the driver */</span></span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mutex: Lock for general connector state, but currently only protects</span></span><br><span class="line"><span class="comment">         * @registered. Most of the connector state is still protected by</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @index: Compacted connector index, which matches the position inside</span></span><br><span class="line"><span class="comment">         * the mode_config.list for drivers not supporting hot-add/removing. Can</span></span><br><span class="line"><span class="comment">         * be used as an array index. It is invariant over the lifetime of the</span></span><br><span class="line"><span class="comment">         * connector.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @connector_type:</span></span><br><span class="line"><span class="comment">         * one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> connector_type;</span><br><span class="line">        <span class="comment">/** @connector_type_id: index into connector type enum */</span></span><br><span class="line">        <span class="keyword">int</span> connector_type_id;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @interlace_allowed:</span></span><br><span class="line"><span class="comment">         * Can this connector handle interlaced modes? Only used by</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes() for mode filtering.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> interlace_allowed;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @doublescan_allowed:</span></span><br><span class="line"><span class="comment">         * Can this connector handle doublescan? Only used by</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes() for mode filtering.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> doublescan_allowed;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @stereo_allowed:</span></span><br><span class="line"><span class="comment">         * Can this connector handle stereo modes? Only used by</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes() for mode filtering.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> stereo_allowed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @ycbcr_420_allowed : This bool indicates if this connector is</span></span><br><span class="line"><span class="comment">         * capable of handling YCBCR 420 output. While parsing the EDID</span></span><br><span class="line"><span class="comment">         * blocks it&#x27;s very helpful to know if the source is capable of</span></span><br><span class="line"><span class="comment">         * handling YCBCR 420 outputs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> ycbcr_420_allowed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @registration_state: Is this connector initializing, exposed</span></span><br><span class="line"><span class="comment">         * (registered) with userspace, or unregistered?</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Protected by @mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">enum</span> drm_connector_registration_state registration_state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @modes:</span></span><br><span class="line"><span class="comment">         * Modes available on this connector (from fill_modes() + user).</span></span><br><span class="line"><span class="comment">         * Protected by &amp;drm_mode_config.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modes</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @status:</span></span><br><span class="line"><span class="comment">         * One of the drm_connector_status enums (connected, not, or unknown).</span></span><br><span class="line"><span class="comment">         * Protected by &amp;drm_mode_config.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">enum</span> drm_connector_status status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @probed_modes:</span></span><br><span class="line"><span class="comment">         * These are modes added by probing with DDC or the BIOS, before</span></span><br><span class="line"><span class="comment">         * filtering is applied. Used by the probe helpers. Protected by</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">probed_modes</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @display_info: Display information is filled from EDID information</span></span><br><span class="line"><span class="comment">         * when a display is detected. For non hot-pluggable displays such as</span></span><br><span class="line"><span class="comment">         * flat panels in embedded systems, the driver should initialize the</span></span><br><span class="line"><span class="comment">         * &amp;drm_display_info.width_mm and &amp;drm_display_info.height_mm fields</span></span><br><span class="line"><span class="comment">         * with the physical size of the display.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Protected by &amp;drm_mode_config.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> <span class="title">display_info</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @funcs: connector control functions */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_funcs</span> *<span class="title">funcs</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_blob_ptr: DRM property containing EDID if present. Protected by</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.mutex. This should be updated only by calling</span></span><br><span class="line"><span class="comment">         * drm_connector_update_edid_property().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property_blob</span> *<span class="title">edid_blob_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @properties: property tracking for this connector */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_object_properties</span> <span class="title">properties</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @scaling_mode_property: Optional atomic property to control the</span></span><br><span class="line"><span class="comment">         * upscaling. See drm_connector_attach_content_protection_property().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">scaling_mode_property</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @vrr_capable_property: Optional property to help userspace</span></span><br><span class="line"><span class="comment">         * query hardware support for variable refresh rate on a connector.</span></span><br><span class="line"><span class="comment">         * connector. Drivers can add the property to a connector by</span></span><br><span class="line"><span class="comment">         * calling drm_connector_attach_vrr_capable_property().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This should be updated only by calling</span></span><br><span class="line"><span class="comment">         * drm_connector_set_vrr_capable_property().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">vrr_capable_property</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @colorspace_property: Connector property to set the suitable</span></span><br><span class="line"><span class="comment">         * colorspace supported by the sink.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">colorspace_property</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @path_blob_ptr:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * DRM blob property data for the DP MST path property. This should only</span></span><br><span class="line"><span class="comment">         * be updated by calling drm_connector_set_path_property().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property_blob</span> *<span class="title">path_blob_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @max_bpc_property: Default connector property for the max bpc to be</span></span><br><span class="line"><span class="comment">         * driven out of the connector.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">max_bpc_property</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @privacy_screen: drm_privacy_screen for this connector, or NULL. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_privacy_screen</span> *<span class="title">privacy_screen</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @privacy_screen_notifier: privacy-screen notifier_block */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">privacy_screen_notifier</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @privacy_screen_sw_state_property: Optional atomic property for the</span></span><br><span class="line"><span class="comment">         * connector to control the integrated privacy screen.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">privacy_screen_sw_state_property</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @privacy_screen_hw_state_property: Optional atomic property for the</span></span><br><span class="line"><span class="comment">         * connector to report the actual integrated privacy screen state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property</span> *<span class="title">privacy_screen_hw_state_property</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_CONNECTOR_POLL_HPD (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_CONNECTOR_POLL_CONNECT (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_CONNECTOR_POLL_DISCONNECT (1 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @polled:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Connector polling mode, a combination of</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * DRM_CONNECTOR_POLL_HPD</span></span><br><span class="line"><span class="comment">         *     The connector generates hotplug events and doesn&#x27;t need to be</span></span><br><span class="line"><span class="comment">         *     periodically polled. The CONNECT and DISCONNECT flags must not</span></span><br><span class="line"><span class="comment">         *     be set together with the HPD flag.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * DRM_CONNECTOR_POLL_CONNECT</span></span><br><span class="line"><span class="comment">         *     Periodically poll the connector for connection.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * DRM_CONNECTOR_POLL_DISCONNECT</span></span><br><span class="line"><span class="comment">         *     Periodically poll the connector for disconnection, without</span></span><br><span class="line"><span class="comment">         *     causing flickering even when the connector is in use. DACs should</span></span><br><span class="line"><span class="comment">         *     rarely do this without a lot of testing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Set to 0 for connectors that don&#x27;t support connection status</span></span><br><span class="line"><span class="comment">         * discovery.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> polled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @dpms: Current dpms state. For legacy drivers the</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_funcs.dpms callback must update this. For atomic</span></span><br><span class="line"><span class="comment">         * drivers, this is handled by the core atomic code, and drivers must</span></span><br><span class="line"><span class="comment">         * only take &amp;drm_crtc_state.active into account.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> dpms;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @helper_private: mid-layer private data */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_helper_funcs</span> *<span class="title">helper_private</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @cmdline_mode: mode line parsed from the kernel cmdline for this connector */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_cmdline_mode</span> <span class="title">cmdline_mode</span>;</span></span><br><span class="line">        <span class="comment">/** @force: a DRM_FORCE_&lt;foo&gt; state for forced mode sets */</span></span><br><span class="line">        <span class="keyword">enum</span> drm_connector_force force;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_override: Override EDID set via debugfs.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Do not modify or access outside of the drm_edid_override_* family of</span></span><br><span class="line"><span class="comment">         * functions.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_edid</span> *<span class="title">edid_override</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_override_mutex: Protect access to edid_override.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">edid_override_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @epoch_counter: used to detect any other changes in connector, besides status */</span></span><br><span class="line">        u64 epoch_counter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @possible_encoders: Bit mask of encoders that can drive this</span></span><br><span class="line"><span class="comment">         * connector, drm_encoder_index() determines the index into the bitfield</span></span><br><span class="line"><span class="comment">         * and the bits are set with drm_connector_attach_encoder().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 possible_encoders;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @encoder: Currently bound encoder driving this connector, if any.</span></span><br><span class="line"><span class="comment">         * Only really meaningful for non-atomic drivers. Atomic drivers should</span></span><br><span class="line"><span class="comment">         * instead look at &amp;drm_connector_state.best_encoder, and in case they</span></span><br><span class="line"><span class="comment">         * need the CRTC driving this output, &amp;drm_connector_state.crtc.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *<span class="title">encoder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ELD_BYTES   128</span></span><br><span class="line">        <span class="comment">/** @eld: EDID-like data, if present */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> eld[MAX_ELD_BYTES];</span><br><span class="line">        <span class="comment">/** @latency_present: AV delay info from ELD, if found */</span></span><br><span class="line">        <span class="keyword">bool</span> latency_present[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @video_latency: Video latency info from ELD, if found.</span></span><br><span class="line"><span class="comment">         * [0]: progressive, [1]: interlaced</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> video_latency[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @audio_latency: audio latency info from ELD, if found</span></span><br><span class="line"><span class="comment">         * [0]: progressive, [1]: interlaced</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> audio_latency[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @ddc: associated ddc adapter.</span></span><br><span class="line"><span class="comment">         * A connector usually has its associated ddc adapter. If a driver uses</span></span><br><span class="line"><span class="comment">         * this field, then an appropriate symbolic link is created in connector</span></span><br><span class="line"><span class="comment">         * sysfs directory to make it easy for the user to tell which i2c</span></span><br><span class="line"><span class="comment">         * adapter is for a particular display.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field should be set by calling drm_connector_init_with_ddc().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">ddc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @null_edid_counter: track sinks that give us all zeros for the EDID.</span></span><br><span class="line"><span class="comment">         * Needed to workaround some HW bugs where we get all 0s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> null_edid_counter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @bad_edid_counter: track sinks that give us an EDID with invalid checksum */</span></span><br><span class="line">        <span class="keyword">unsigned</span> bad_edid_counter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_corrupt: Indicates whether the last read EDID was corrupt. Used</span></span><br><span class="line"><span class="comment">         * in Displayport compliance testing - Displayport Link CTS Core 1.2</span></span><br><span class="line"><span class="comment">         * rev1.1 4.2.2.6</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> edid_corrupt;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @real_edid_checksum: real edid checksum for corrupted edid block.</span></span><br><span class="line"><span class="comment">         * Required in Displayport 1.4 compliance testing</span></span><br><span class="line"><span class="comment">         * rev1.1 4.2.2.6</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 real_edid_checksum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @debugfs_entry: debugfs directory for this connector */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Current atomic state for this connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is protected by &amp;drm_mode_config.connection_mutex. Note that</span></span><br><span class="line"><span class="comment">         * nonblocking atomic commits access the current connector state without</span></span><br><span class="line"><span class="comment">         * taking locks. Either by going through the &amp;struct drm_atomic_state</span></span><br><span class="line"><span class="comment">         * pointers, see for_each_oldnew_connector_in_state(),</span></span><br><span class="line"><span class="comment">         * for_each_old_connector_in_state() and</span></span><br><span class="line"><span class="comment">         * for_each_new_connector_in_state(). Or through careful ordering of</span></span><br><span class="line"><span class="comment">         * atomic commit operations as implemented in the atomic helpers, see</span></span><br><span class="line"><span class="comment">         * &amp;struct drm_crtc_commit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_state</span> *<span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* DisplayID bits. <span class="doctag">FIXME:</span> Extract into a substruct? */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @tile_blob_ptr:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * DRM blob property data for the tile property (used mostly by DP MST).</span></span><br><span class="line"><span class="comment">         * This is meant for screens which are driven through separate display</span></span><br><span class="line"><span class="comment">         * pipelines represented by &amp;drm_crtc, which might not be running with</span></span><br><span class="line"><span class="comment">         * genlocked clocks. For tiled panels which are genlocked, like</span></span><br><span class="line"><span class="comment">         * dual-link LVDS or dual-link DSI, the driver should try to not expose</span></span><br><span class="line"><span class="comment">         * the tiling and virtualize both &amp;drm_crtc and &amp;drm_plane if needed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This should only be updated by calling</span></span><br><span class="line"><span class="comment">         * drm_connector_set_tile_property().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_property_blob</span> *<span class="title">tile_blob_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @has_tile: is this connector connected to a tiled monitor */</span></span><br><span class="line">        <span class="keyword">bool</span> has_tile;</span><br><span class="line">        <span class="comment">/** @tile_group: tile group for the connected monitor */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_tile_group</span> *<span class="title">tile_group</span>;</span></span><br><span class="line">        <span class="comment">/** @tile_is_single_monitor: whether the tile is one monitor housing */</span></span><br><span class="line">        <span class="keyword">bool</span> tile_is_single_monitor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @num_h_tile: number of horizontal tiles in the tile group */</span></span><br><span class="line">        <span class="comment">/** @num_v_tile: number of vertical tiles in the tile group */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> num_h_tile, num_v_tile;</span><br><span class="line">        <span class="comment">/** @tile_h_loc: horizontal location of this tile */</span></span><br><span class="line">        <span class="comment">/** @tile_v_loc: vertical location of this tile */</span></span><br><span class="line">        <span class="keyword">uint8_t</span> tile_h_loc, tile_v_loc;</span><br><span class="line">        <span class="comment">/** @tile_h_size: horizontal size of this tile. */</span></span><br><span class="line">        <span class="comment">/** @tile_v_size: vertical size of this tile. */</span></span><br><span class="line">        <span class="keyword">uint16_t</span> tile_h_size, tile_v_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @free_node:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * List used only by &amp;drm_connector_list_iter to be able to clean up a</span></span><br><span class="line"><span class="comment">         * connector from any context, in conjunction with</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.connector_free_work.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">free_node</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @hdr_sink_metadata: HDR Metadata Information read from sink */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hdr_sink_metadata</span> <span class="title">hdr_sink_metadata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-1-struct-drm-display-info"><a href="#3-1-1-struct-drm-display-info" class="headerlink" title="3.1.1 struct drm_display_info"></a>3.1.1 <code>struct drm_display_info</code></h5><p><code>linux</code>内核使用<code>struct drm_display_info</code>来表示当前连接的显示设备的显示信息，它包含了一系列成员变量，用来描述显示设备的物理尺寸、颜色格式、总线格式等信息。定义在<code>include/drm/drm_connector.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_display_info - runtime data about the connected sink</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes a given display (e.g. CRT or flat panel) and its limitations. For</span></span><br><span class="line"><span class="comment"> * fixed display sinks like built-in panels there&#x27;s not much difference between</span></span><br><span class="line"><span class="comment"> * this and &amp;struct drm_connector. But for sinks with a real cable this</span></span><br><span class="line"><span class="comment"> * structure is meant to describe all the things at the other end of the cable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For sinks which provide an EDID this can be filled out by calling</span></span><br><span class="line"><span class="comment"> * drm_add_edid_modes().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_display_info</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @width_mm: Physical width in mm.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> width_mm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @height_mm: Physical height in mm.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> height_mm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @bpc: Maximum bits per color channel. Used by HDMI and DP outputs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> bpc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @subpixel_order: Subpixel order of LCD panels.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">enum</span> subpixel_order subpixel_order;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_COLOR_FORMAT_RGB444         (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_COLOR_FORMAT_YCBCR444       (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_COLOR_FORMAT_YCBCR422       (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_COLOR_FORMAT_YCBCR420       (1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @panel_orientation: Read only connector property for built-in panels,</span></span><br><span class="line"><span class="comment">         * indicating the orientation of the panel vs the device&#x27;s casing.</span></span><br><span class="line"><span class="comment">         * drm_connector_init() sets this to DRM_MODE_PANEL_ORIENTATION_UNKNOWN.</span></span><br><span class="line"><span class="comment">         * When not UNKNOWN this gets used by the drm_fb_helpers to rotate the</span></span><br><span class="line"><span class="comment">         * fb to compensate and gets exported as prop to userspace.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> panel_orientation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @color_formats: HDMI Color formats, selects between RGB and YCrCb</span></span><br><span class="line"><span class="comment">         * modes. Used DRM_COLOR_FORMAT\_ defines, which are _not_ the same ones</span></span><br><span class="line"><span class="comment">         * as used to describe the pixel format in framebuffers, and also don&#x27;t</span></span><br><span class="line"><span class="comment">         * match the formats in @bus_formats which are shared with v4l.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 color_formats;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @bus_formats: Pixel data format on the wire, somewhat redundant with</span></span><br><span class="line"><span class="comment">         * @color_formats. Array of size @num_bus_formats encoded using</span></span><br><span class="line"><span class="comment">         * MEDIA_BUS_FMT\_ defines shared with v4l and media drivers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> u32 *bus_formats;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @bus_formats: Pixel data format on the wire, somewhat redundant with</span></span><br><span class="line"><span class="comment">         * @color_formats. Array of size @num_bus_formats encoded using</span></span><br><span class="line"><span class="comment">         * MEDIA_BUS_FMT\_ defines shared with v4l and media drivers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> u32 *bus_formats;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @num_bus_formats: Size of @bus_formats array.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> num_bus_formats;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @bus_flags: Additional information (like pixel signal polarity) for</span></span><br><span class="line"><span class="comment">         * the pixel data on the bus, using &amp;enum drm_bus_flags values</span></span><br><span class="line"><span class="comment">         * DRM_BUS_FLAGS\_.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 bus_flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @max_tmds_clock: Maximum TMDS clock rate supported by the</span></span><br><span class="line"><span class="comment">         * sink in kHz. 0 means undefined.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> max_tmds_clock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @dvi_dual: Dual-link DVI sink?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> dvi_dual;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @is_hdmi: True if the sink is an HDMI device.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This field shall be used instead of calling</span></span><br><span class="line"><span class="comment">         * drm_detect_hdmi_monitor() when possible.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> is_hdmi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @has_hdmi_infoframe: Does the sink support the HDMI infoframe?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> has_hdmi_infoframe;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @rgb_quant_range_selectable: Does the sink support selecting</span></span><br><span class="line"><span class="comment">         * the RGB quantization range?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> rgb_quant_range_selectable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_hdmi_rgb444_dc_modes: Mask of supported hdmi deep color modes</span></span><br><span class="line"><span class="comment">         * in RGB 4:4:4. Even more stuff redundant with @bus_formats.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 edid_hdmi_rgb444_dc_modes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @edid_hdmi_ycbcr444_dc_modes: Mask of supported hdmi deep color</span></span><br><span class="line"><span class="comment">         * modes in YCbCr 4:4:4. Even more stuff redundant with @bus_formats.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 edid_hdmi_ycbcr444_dc_modes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @cea_rev: CEA revision of the HDMI sink.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 cea_rev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @hdmi: advance features of a HDMI sink.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_hdmi_info</span> <span class="title">hdmi</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @non_desktop: Non desktop display (HMD).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> non_desktop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @monitor_range: Frequency range supported by monitor range descriptor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_monitor_range_info</span> <span class="title">monitor_range</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @luminance_range: Luminance range supported by panel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_luminance_range_info</span> <span class="title">luminance_range</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mso_stream_count: eDP Multi-SST Operation (MSO) stream count from</span></span><br><span class="line"><span class="comment">         * the DisplayID VESA vendor block. 0 for conventional Single-Stream</span></span><br><span class="line"><span class="comment">         * Transport (SST), or 2 or 4 MSO streams.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 mso_stream_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mso_pixel_overlap: eDP MSO segment pixel overlap, 0-8 pixels.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 mso_pixel_overlap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @max_dsc_bpp: Maximum DSC target bitrate, if it is set to 0 the</span></span><br><span class="line"><span class="comment">         * monitor&#x27;s default value is used instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 max_dsc_bpp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @vics: Array of vics_len VICs. Internal to EDID parsing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u8 *vics;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @vics_len: Number of elements in vics. Internal to EDID parsing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> vics_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @quirks: EDID based quirks. Internal to EDID parsing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        u32 quirks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>width_mm</code>：物理宽度，单位<code>mm</code>；</li>
<li><code>height_mm</code>：物理高度、单位<code>mm</code>；</li>
<li><code>bpc</code>: 每个颜色通道最大位数，适用于<code>HDMI</code>、<code>DP</code>输出；</li>
<li><code>panel_orientation</code>：一个只读属性，用于描述内置面板的方向与设备外壳的方向之间的关系。在调用<code>drm_connector_init()</code>函数时，这个属性会被设置为<code>DRM_MODE_PANEL_ORIENTATION_UNKNOWN</code>，表示方向未知。当方向不是未知时，图形驱动程序中的<code>drm_fb_helpers</code>会根据该属性来旋转帧缓冲以进行补偿，并将其作为属性导出给用户空间；</li>
<li><code>color_formats</code>：用于选择<code>HDMI</code>的颜色格式，支持<code>RGB</code>和<code>YCrCb</code>模式；这里使用了<code>DRM_COLOR_FORMAT_</code>定义的值来表示不同的颜色格式，这些值与用于描述<code>framebuffer</code>中像素格式的值是不同的。此外，它们也与与<code>v4l</code>共享的<code>bus_formats</code>中的格式不匹配；</li>
<li><code>bus_formats</code>：表示在传输介质上的像素数据格式，与<code>color_formats</code>相比有些冗余。<code>bus_formats</code>是一个数组，其大小由<code>num_bus_formats</code>确定，使用<code>MEDIA_BUS_FMT_</code>定义对其进行编码，这些定义是和<code>v4l</code>（以及媒体驱动程序共享的；</li>
<li><code>num_bus_formats</code>：<code>bus_formats</code>数组的长度；</li>
<li><code>bus_flags</code>：它包含了有关总线上像素数据的附加信息，比如像素信号的极性。这些信息使用<code>enum drm_bus_flags</code>中定义的数值，其中包括了<code>DRM_BUS_FLAGS_</code>前缀；</li>
<li><code>max_tmds_clock</code>：表示显示设备支持的<code>TMDS</code>时钟的最大速率，单位是千赫兹（<code>kHz</code>）。如果值为0，则表示未定义；</li>
<li><code>dvi_dual</code>：是否支持双链<code>DVI</code>；</li>
<li><code>is_hdmi</code>：用于指示显示设备是否为<code>HDMI</code>设备，通过设置该字段来避免不必要地调用<code>drm_detect_hdmi_monitor</code>函数；</li>
<li><code>has_hdmi_infoframe</code>：显示设备是否支持<code>HDMI</code>信息帧；</li>
<li><code>rgb_quant_range_selectable</code>：表示显示设备是否支持选择<code>RGB</code>量化范围；</li>
<li><code>edid_hdmi_rgb444_dc_modes</code>：用于表示支持的<code>HDMI</code>深色模式的位掩码，适用于<code>RGB 4:4:4</code>格式；</li>
<li><code>edid_hdmi_ycbcr444_dc_modes</code>：用于表示支持的<code>HDMI</code>深色模式的位掩码，适用于<code>YCbCr 4:4:4</code>格式；</li>
<li><code>cea_rev</code>：在<code>HDMI</code>接口中，<code>CEA</code>规范定义了一系列的视频和音频格式；该字段表示<code>HDMI</code>显示设备支持的<code>CEA</code>规范版本；</li>
<li><code>hdmi</code>：<code>HDMI</code>显示设备支持的高级功能；</li>
<li><code>non_desktop</code>：表示非桌面显示；</li>
<li><code>monitor_range</code>：存储从<code>edid</code>的``Detailed Monitor Descriptor`解析出的面板支持的频率范围；</li>
<li><code>luminance_range</code>：存储从<code>edid</code>的``static hdr metadata.`解析出的面板支持的亮度范围；</li>
<li><code>mso_stream_count</code>：<code>eDP Multi-SST Operation（MSO）</code>流计数是从<code>DisplayID VESA</code>供应商块中获取的信息。它用于指示<code>eDP（Embedded DisplayPort）</code>接口支持的传输模式；<ul>
<li>当<code>eDP</code>接口使用传统的单流传输（<code>SST</code>）时，<code>MSO</code>流计数为0；</li>
<li>当<code>eDP</code>接口支持多流操作（<code>MSO</code>）时，<code>MSO</code>流计数可以是2或4；</li>
</ul>
</li>
<li><code>mso_pixel_overlap</code>：</li>
<li><code>max_dsc_bpp</code>：最大<code>DSC</code>目标比特率；</li>
<li><code>vics</code>：<code>Array of vics_len VICs. Internal to EDID parsing</code>；</li>
<li><code>vics_len</code>：<code>Number of elements in vics. Internal to EDID parsing</code>；</li>
<li><code>quirks</code>：<code>EDID based quirks. Internal to EDID parsing.</code></li>
</ul>
<h5 id="3-1-2-struct-drm-hdmi-info"><a href="#3-1-2-struct-drm-hdmi-info" class="headerlink" title="3.1.2 struct drm_hdmi_info"></a>3.1.2 <code>struct drm_hdmi_info</code></h5><p><code>linux</code>内核使用<code>struct drm_hdmi_info</code>来表示当前连接的<code>HDMI</code>显示设备的信息，定义在<code>include/drm/drm_connector.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_hdmi_info - runtime information about the connected HDMI sink</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes if a given display supports advanced HDMI 2.0 features.</span></span><br><span class="line"><span class="comment"> * This information is available in CEA-861-F extension blocks (like HF-VSDB).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_hdmi_info</span> &#123;</span></span><br><span class="line">        <span class="comment">/** @scdc: sink&#x27;s scdc support and capabilities */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_scdc</span> <span class="title">scdc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @y420_vdb_modes: bitmap of modes which can support ycbcr420</span></span><br><span class="line"><span class="comment">         * output only (not normal RGB/YCBCR444/422 outputs). The max VIC</span></span><br><span class="line"><span class="comment">         * defined by the CEA-861-G spec is 219, so the size is 256 bits to map</span></span><br><span class="line"><span class="comment">         * up to 256 VICs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> y420_vdb_modes[BITS_TO_LONGS(<span class="number">256</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @y420_cmdb_modes: bitmap of modes which can support ycbcr420</span></span><br><span class="line"><span class="comment">         * output also, along with normal HDMI outputs. The max VIC defined by</span></span><br><span class="line"><span class="comment">         * the CEA-861-G spec is 219, so the size is 256 bits to map up to 256</span></span><br><span class="line"><span class="comment">         * VICs.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> y420_cmdb_modes[BITS_TO_LONGS(<span class="number">256</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @y420_dc_modes: bitmap of deep color support index */</span></span><br><span class="line">        u8 y420_dc_modes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @max_frl_rate_per_lane: support fixed rate link */</span></span><br><span class="line">        u8 max_frl_rate_per_lane;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @max_lanes: supported by sink */</span></span><br><span class="line">        u8 max_lanes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** @dsc_cap: DSC capabilities of the sink */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_hdmi_dsc_cap</span> <span class="title">dsc_cap</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-操作函数"><a href="#3-2-操作函数" class="headerlink" title="3.2 操作函数"></a>3.2 操作函数</h4><h5 id="3-2-1-struct-drm-connector-funcs"><a href="#3-2-1-struct-drm-connector-funcs" class="headerlink" title="3.2.1 struct drm_connector_funcs"></a>3.2.1 <code>struct drm_connector_funcs</code></h5><p><code>struct drm_connector_funcs</code>用于描述<code>connector</code>的控制函数，定义在<code>include/drm/drm_connector.h</code>；</p>
<p>Hidden Code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_connector_funcs - control connectors on a given device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each CRTC may have one or more connectors attached to it.  The functions</span></span><br><span class="line"><span class="comment"> * below allow the core DRM code to control connectors, enumerate available modes,</span></span><br><span class="line"><span class="comment"> * etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_funcs</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @dpms:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Legacy entry point to set the per-connector DPMS state. Legacy DPMS</span></span><br><span class="line"><span class="comment">         * is exposed as a standard property on the connector, but diverted to</span></span><br><span class="line"><span class="comment">         * this callback in the drm core. Note that atomic drivers don&#x27;t</span></span><br><span class="line"><span class="comment">         * implement the 4 level DPMS support on the connector any more, but</span></span><br><span class="line"><span class="comment">         * instead only have an on/off &quot;ACTIVE&quot; property on the CRTC object.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is not used by atomic drivers, remapping of the legacy DPMS</span></span><br><span class="line"><span class="comment">         * property is entirely handled in the DRM core.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success or a negative error code on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*dpms)(struct drm_connector *connector, <span class="keyword">int</span> mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @reset:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Reset connector hardware and software state to off. This function isn&#x27;t</span></span><br><span class="line"><span class="comment">         * called by the core directly, only through drm_mode_config_reset().</span></span><br><span class="line"><span class="comment">         * It&#x27;s not a helper hook only for historical reasons.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Atomic drivers can use drm_atomic_helper_connector_reset() to reset</span></span><br><span class="line"><span class="comment">         * atomic state using this hook.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*reset)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @detect:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Check to see if anything is attached to the connector. The parameter</span></span><br><span class="line"><span class="comment">         * force is set to false whilst polling, true when checking the</span></span><br><span class="line"><span class="comment">         * connector due to a user request. force can be used by the driver to</span></span><br><span class="line"><span class="comment">         * avoid expensive, destructive operations during automated probing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional, if not implemented the connector will be</span></span><br><span class="line"><span class="comment">         * considered as always being attached.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">FIXME:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that this hook is only called by the probe helper. It&#x27;s not in</span></span><br><span class="line"><span class="comment">         * the helper library vtable purely for historical reasons. The only DRM</span></span><br><span class="line"><span class="comment">         * core entry point to probe connector state is @fill_modes.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that the helper library will already hold</span></span><br><span class="line"><span class="comment">         * &amp;drm_mode_config.connection_mutex. Drivers which need to grab additional</span></span><br><span class="line"><span class="comment">         * locks to avoid races with concurrent modeset changes need to use</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_helper_funcs.detect_ctx instead.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Also note that this callback can be called no matter the</span></span><br><span class="line"><span class="comment">         * state the connector is in. Drivers that need the underlying</span></span><br><span class="line"><span class="comment">         * device to be powered to perform the detection will first need</span></span><br><span class="line"><span class="comment">         * to make sure it&#x27;s been properly enabled.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * drm_connector_status indicating the connector&#x27;s status.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_connector_status</span> <span class="params">(*detect)</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">bool</span> force)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @force:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called to update internal encoder state when the</span></span><br><span class="line"><span class="comment">         * connector is forced to a certain state by userspace, either through</span></span><br><span class="line"><span class="comment">         * the sysfs interfaces or on the kernel cmdline. In that case the</span></span><br><span class="line"><span class="comment">         * @detect callback isn&#x27;t called.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">FIXME:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that this hook is only called by the probe helper. It&#x27;s not in</span></span><br><span class="line"><span class="comment">         * the helper library vtable purely for historical reasons. The only DRM</span></span><br><span class="line"><span class="comment">         * core entry point to probe connector state is @fill_modes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*force)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @fill_modes:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Entry point for output detection and basic mode validation. The</span></span><br><span class="line"><span class="comment">         * driver should reprobe the output if needed (e.g. when hotplug</span></span><br><span class="line"><span class="comment">         * handling is unreliable), add all detected modes to &amp;drm_connector.modes</span></span><br><span class="line"><span class="comment">         * and filter out any the device can&#x27;t support in any configuration. It</span></span><br><span class="line"><span class="comment">         * also needs to filter out any modes wider or higher than the</span></span><br><span class="line"><span class="comment">         * parameters max_width and max_height indicate.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The drivers must also prune any modes no longer valid from</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector.modes. Furthermore it must update</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector.status and &amp;drm_connector.edid.  If no EDID has been</span></span><br><span class="line"><span class="comment">         * received for this output connector-&gt;edid must be NULL.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Drivers using the probe helpers should use</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes() to implement this</span></span><br><span class="line"><span class="comment">         * function.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The number of modes detected and filled into &amp;drm_connector.modes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*fill_modes)(struct drm_connector *connector, <span class="keyword">uint32_t</span> max_width, <span class="keyword">uint32_t</span> max_height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @set_property:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the legacy entry point to update a property attached to the</span></span><br><span class="line"><span class="comment">         * connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional if the driver does not support any legacy</span></span><br><span class="line"><span class="comment">         * driver-private properties. For atomic drivers it is not used because</span></span><br><span class="line"><span class="comment">         * property handling is done entirely in the DRM core.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success or a negative error code on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*set_property)(struct drm_connector *connector, struct drm_property *property,</span><br><span class="line">                             <span class="keyword">uint64_t</span> val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @late_register:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optional hook can be used to register additional userspace</span></span><br><span class="line"><span class="comment">         * interfaces attached to the connector, light backlight control, i2c,</span></span><br><span class="line"><span class="comment">         * DP aux or similar interfaces. It is called late in the driver load</span></span><br><span class="line"><span class="comment">         * sequence from drm_connector_register() when registering all the</span></span><br><span class="line"><span class="comment">         * core drm connector interfaces. Everything added from this callback</span></span><br><span class="line"><span class="comment">         * should be unregistered in the early_unregister callback.</span></span><br><span class="line"><span class="comment">         * should be unregistered in the early_unregister callback.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is called while holding &amp;drm_connector.mutex.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Returns:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success, or a negative error code on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*late_register)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @early_unregister:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optional hook should be used to unregister the additional</span></span><br><span class="line"><span class="comment">         * userspace interfaces attached to the connector from</span></span><br><span class="line"><span class="comment">         * late_register(). It is called from drm_connector_unregister(),</span></span><br><span class="line"><span class="comment">         * early in the driver unload sequence to disable userspace access</span></span><br><span class="line"><span class="comment">         * before data structures are torndown.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is called while holding &amp;drm_connector.mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*early_unregister)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @destroy:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Clean up connector resources. This is called at driver unload time</span></span><br><span class="line"><span class="comment">         * through drm_mode_config_cleanup(). It can also be called at runtime</span></span><br><span class="line"><span class="comment">         * when a connector is being hot-unplugged for drivers that support</span></span><br><span class="line"><span class="comment">         * connector hotplugging (e.g. DisplayPort MST).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*destroy)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_duplicate_state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Duplicate the current atomic state for this connector and return it.</span></span><br><span class="line"><span class="comment">         * The core and helpers guarantee that any atomic state duplicated with</span></span><br><span class="line"><span class="comment">         * this hook and still owned by the caller (i.e. not transferred to the</span></span><br><span class="line"><span class="comment">         * driver by calling &amp;drm_mode_config_funcs.atomic_commit) will be</span></span><br><span class="line"><span class="comment">         * cleaned up by calling the @atomic_destroy_state hook in this</span></span><br><span class="line"><span class="comment">         * structure.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is mandatory for atomic drivers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Atomic drivers which don&#x27;t subclass &amp;struct drm_connector_state should use</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_connector_duplicate_state(). Drivers that subclass the</span></span><br><span class="line"><span class="comment">         * state structure to extend it with driver-private state should use</span></span><br><span class="line"><span class="comment">         * __drm_atomic_helper_connector_duplicate_state() to make sure shared state is</span></span><br><span class="line"><span class="comment">         * duplicated in a consistent fashion across drivers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * It is an error to call this hook before &amp;drm_connector.state has been</span></span><br><span class="line"><span class="comment">         * initialized correctly.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If the duplicate state references refcounted resources this hook must</span></span><br><span class="line"><span class="comment">         * acquire a reference for each of them. The driver must release these</span></span><br><span class="line"><span class="comment">         * references again in @atomic_destroy_state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Duplicated atomic state or NULL when the allocation failed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_state</span> *(*<span class="title">atomic_duplicate_state</span>)(<span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_destroy_state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Destroy a state duplicated with @atomic_duplicate_state and release</span></span><br><span class="line"><span class="comment">         * or unreference all resources it references</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is mandatory for atomic drivers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_destroy_state)(struct drm_connector *connector,</span><br><span class="line">                                     struct drm_connector_state *state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_set_property:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Decode a driver-private property value and store the decoded value</span></span><br><span class="line"><span class="comment">         * into the passed-in state structure. Since the atomic core decodes all</span></span><br><span class="line"><span class="comment">         * standardized properties (even for extensions beyond the core set of</span></span><br><span class="line"><span class="comment">         * properties which might not be implemented by all drivers) this</span></span><br><span class="line"><span class="comment">         * requires drivers to subclass the state structure.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Such driver-private properties should really only be implemented for</span></span><br><span class="line"><span class="comment">         * truly hardware/vendor specific state. Instead it is preferred to</span></span><br><span class="line"><span class="comment">         * standardize atomic extension and decode the properties used to expose</span></span><br><span class="line"><span class="comment">         * such an extension in the core.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Do not call this function directly, use</span></span><br><span class="line"><span class="comment">         * drm_atomic_connector_set_property() instead.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional if the driver does not support any</span></span><br><span class="line"><span class="comment">         * driver-private atomic properties.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the state assembly phase of atomic</span></span><br><span class="line"><span class="comment">         * modesets, which can be aborted for any reason (including on</span></span><br><span class="line"><span class="comment">         * userspace&#x27;s request to just check whether a configuration would be</span></span><br><span class="line"><span class="comment">         * possible). Drivers MUST NOT touch any persistent state (hardware or</span></span><br><span class="line"><span class="comment">         * software) or data structures except the passed in @state parameter.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Also since userspace controls in which order properties are set this</span></span><br><span class="line"><span class="comment">         * function must not do any input validation (since the state update is</span></span><br><span class="line"><span class="comment">         * incomplete and hence likely inconsistent). Instead any such input</span></span><br><span class="line"><span class="comment">         * validation must be done in the various atomic_check callbacks.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 if the property has been found, -EINVAL if the property isn&#x27;t</span></span><br><span class="line"><span class="comment">         * implemented by the driver (which shouldn&#x27;t ever happen, the core only</span></span><br><span class="line"><span class="comment">         * asks for properties attached to this connector). No other validation</span></span><br><span class="line"><span class="comment">         * is allowed by the driver. The core already checks that the property</span></span><br><span class="line"><span class="comment">         * value is within the range (integer, valid enum value, ...) the driver</span></span><br><span class="line"><span class="comment">         * set when registering the property.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*atomic_set_property)(struct drm_connector *connector,</span><br><span class="line">                                   struct drm_connector_state *state,</span><br><span class="line">                                   struct drm_property *property,</span><br><span class="line">                                   <span class="keyword">uint64_t</span> val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_get_property:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Reads out the decoded driver-private property. This is used to</span></span><br><span class="line"><span class="comment">         * implement the GETCONNECTOR IOCTL.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Do not call this function directly, use</span></span><br><span class="line"><span class="comment">         * drm_atomic_connector_get_property() instead.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional if the driver does not support any</span></span><br><span class="line"><span class="comment">         * driver-private atomic properties.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success, -EINVAL if the property isn&#x27;t implemented by the</span></span><br><span class="line"><span class="comment">         * driver (which shouldn&#x27;t ever happen, the core only asks for</span></span><br><span class="line"><span class="comment">         * properties attached to this connector).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*atomic_get_property)(struct drm_connector *connector,</span><br><span class="line">                                   <span class="keyword">const</span> struct drm_connector_state *state,</span><br><span class="line">                                   struct drm_property *property,</span><br><span class="line">                                   <span class="keyword">uint64_t</span> *val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_print_state:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If driver subclasses &amp;struct drm_connector_state, it should implement</span></span><br><span class="line"><span class="comment">         * this optional hook for printing additional driver specific state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Do not call this directly, use drm_atomic_connector_print_state()</span></span><br><span class="line"><span class="comment">         * instead.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_print_state)(struct drm_printer *p,</span><br><span class="line">                                   <span class="keyword">const</span> struct drm_connector_state *state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @oob_hotplug_event:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This will get called when a hotplug-event for a drm-connector</span></span><br><span class="line"><span class="comment">         * has been received from a source outside the display driver / device.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*oob_hotplug_event)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @debugfs_init:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Allows connectors to create connector-specific debugfs files.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*debugfs_init)(struct drm_connector *connector, struct dentry *root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-struct-drm-connector-helper-funcs"><a href="#3-2-2-struct-drm-connector-helper-funcs" class="headerlink" title="3.2.2 struct drm_connector_helper_funcs"></a>3.2.2 <code>struct drm_connector_helper_funcs</code></h5><p><code>struct drm_connector_helper_funcs</code>定义了一些常用的<code>connector</code>辅助操作函数，定义在<code>include/drm/drm_modeset_helper_vtables.h</code>；</p>
<p>Hidden Code</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_connector_helper_funcs - helper operations for connectors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These functions are used by the atomic and legacy modeset helpers and by the</span></span><br><span class="line"><span class="comment"> * probe helpers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_connector_helper_funcs</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @get_modes:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function should fill in all modes currently valid for the sink</span></span><br><span class="line"><span class="comment">         * into the &amp;drm_connector.probed_modes list. It should also update the</span></span><br><span class="line"><span class="comment">         * EDID property by calling drm_connector_update_edid_property().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The usual way to implement this is to cache the EDID retrieved in the</span></span><br><span class="line"><span class="comment">         * probe callback somewhere in the driver-private connector structure.</span></span><br><span class="line"><span class="comment">         * In this function drivers then parse the modes in the EDID and add</span></span><br><span class="line"><span class="comment">         * them by calling drm_add_edid_modes(). But connectors that drive a</span></span><br><span class="line"><span class="comment">         * fixed panel can also manually add specific modes using</span></span><br><span class="line"><span class="comment">         * drm_mode_probed_add(). Drivers which manually add modes should also</span></span><br><span class="line"><span class="comment">         * make sure that the &amp;drm_connector.display_info,</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector.width_mm and &amp;drm_connector.height_mm fields are</span></span><br><span class="line"><span class="comment">         * filled in.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that the caller function will automatically add standard VESA</span></span><br><span class="line"><span class="comment">         * DMT modes up to 1024x768 if the .get_modes() helper operation returns</span></span><br><span class="line"><span class="comment">         * no mode and if the connector status is connector_status_connected or</span></span><br><span class="line"><span class="comment">         * connector_status_unknown. There is no need to call</span></span><br><span class="line"><span class="comment">         * drm_add_modes_noedid() manually in that case.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Virtual drivers that just want some standard VESA mode with a given</span></span><br><span class="line"><span class="comment">         * resolution can call drm_add_modes_noedid(), and mark the preferred</span></span><br><span class="line"><span class="comment">         * one using drm_set_preferred_mode().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is only called after the @detect hook has indicated</span></span><br><span class="line"><span class="comment">         * that a sink is connected and when the EDID isn&#x27;t overridden through</span></span><br><span class="line"><span class="comment">         * sysfs or the kernel commandline.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the probe helpers in e.g.</span></span><br><span class="line"><span class="comment">         * drm_helper_probe_single_connector_modes().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To avoid races with concurrent connector state updates, the helper</span></span><br><span class="line"><span class="comment">         * libraries always call this with the &amp;drm_mode_config.connection_mutex</span></span><br><span class="line"><span class="comment">         * held. Because of this it&#x27;s safe to inspect &amp;drm_connector-&gt;state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The number of modes added by calling drm_mode_probed_add().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*get_modes)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @detect_ctx:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Check to see if anything is attached to the connector. The parameter</span></span><br><span class="line"><span class="comment">         * force is set to false whilst polling, true when checking the</span></span><br><span class="line"><span class="comment">         * connector due to a user request. force can be used by the driver to</span></span><br><span class="line"><span class="comment">         * avoid expensive, destructive operations during automated probing.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is optional, if not implemented the connector will be</span></span><br><span class="line"><span class="comment">         * considered as always being attached.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the atomic version of &amp;drm_connector_funcs.detect.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To avoid races against concurrent connector state updates, the</span></span><br><span class="line"><span class="comment">         * helper libraries always call this with ctx set to a valid context,</span></span><br><span class="line"><span class="comment">         * and &amp;drm_mode_config.connection_mutex will always be locked with</span></span><br><span class="line"><span class="comment">         * the ctx parameter set to this ctx. This allows taking additional</span></span><br><span class="line"><span class="comment">         * locks as required.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_status indicating the connector&#x27;s status,</span></span><br><span class="line"><span class="comment">         * or the error code returned by drm_modeset_lock(), -EDEADLK.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*detect_ctx)(struct drm_connector *connector,</span><br><span class="line">                          struct drm_modeset_acquire_ctx *ctx,</span><br><span class="line">                          <span class="keyword">bool</span> force);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_valid:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Callback to validate a mode for a connector, irrespective of the</span></span><br><span class="line"><span class="comment">         * specific display configuration.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the probe helpers to filter the mode list</span></span><br><span class="line"><span class="comment">         * (which is usually derived from the EDID data block from the sink).</span></span><br><span class="line"><span class="comment">         * See e.g. drm_helper_probe_single_connector_modes().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This only filters the mode list supplied to userspace in the</span></span><br><span class="line"><span class="comment">         * GETCONNECTOR IOCTL. Compared to &amp;drm_encoder_helper_funcs.mode_valid,</span></span><br><span class="line"><span class="comment">         * &amp;drm_crtc_helper_funcs.mode_valid and &amp;drm_bridge_funcs.mode_valid,</span></span><br><span class="line"><span class="comment">         * which are also called by the atomic helpers from</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_check_modeset(). This allows userspace to force and</span></span><br><span class="line"><span class="comment">         * ignore sink constraint (like the pixel clock limits in the screen&#x27;s</span></span><br><span class="line"><span class="comment">         * EDID), which is useful for e.g. testing, or working around a broken</span></span><br><span class="line"><span class="comment">         * EDID. Any source hardware constraint (which always need to be</span></span><br><span class="line"><span class="comment">         * enforced) therefore should be checked in one of the above callbacks,</span></span><br><span class="line"><span class="comment">         * and not this one here.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To avoid races with concurrent connector state updates, the helper</span></span><br><span class="line"><span class="comment">         * libraries always call this with the &amp;drm_mode_config.connection_mutex</span></span><br><span class="line"><span class="comment">         * held. Because of this it&#x27;s safe to inspect &amp;drm_connector-&gt;state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Either &amp;drm_mode_status.MODE_OK or one of the failure reasons in &amp;enum</span></span><br><span class="line"><span class="comment">         * drm_mode_status.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> <span class="title">drm_mode_status</span> <span class="params">(*mode_valid)</span><span class="params">(struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           struct drm_display_mode *mode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @mode_valid_ctx:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Callback to validate a mode for a connector, irrespective of the</span></span><br><span class="line"><span class="comment">         * specific display configuration.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the probe helpers to filter the mode list</span></span><br><span class="line"><span class="comment">         * (which is usually derived from the EDID data block from the sink).</span></span><br><span class="line"><span class="comment">         * See e.g. drm_helper_probe_single_connector_modes().</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is optional, and is the atomic version of</span></span><br><span class="line"><span class="comment">         * &amp;drm_connector_helper_funcs.mode_valid.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * To allow for accessing the atomic state of modesetting objects, the</span></span><br><span class="line"><span class="comment">         * helper libraries always call this with ctx set to a valid context,</span></span><br><span class="line"><span class="comment">         * and &amp;drm_mode_config.connection_mutex will always be locked with</span></span><br><span class="line"><span class="comment">         * the ctx parameter set to @ctx. This allows for taking additional</span></span><br><span class="line"><span class="comment">         * locks as required.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Even though additional locks may be acquired, this callback is</span></span><br><span class="line"><span class="comment">         * still expected not to take any constraints into account which would</span></span><br><span class="line"><span class="comment">         * be influenced by the currently set display state - such constraints</span></span><br><span class="line"><span class="comment">         * should be handled in the driver&#x27;s atomic check. For example, if a</span></span><br><span class="line"><span class="comment">         * connector shares display bandwidth with other connectors then it</span></span><br><span class="line"><span class="comment">         * would be ok to validate the minimum bandwidth requirement of a mode</span></span><br><span class="line"><span class="comment">         * against the maximum possible bandwidth of the connector. But it</span></span><br><span class="line"><span class="comment">         * wouldn&#x27;t be ok to take the current bandwidth usage of other</span></span><br><span class="line"><span class="comment">         * connectors into account, as this would change depending on the</span></span><br><span class="line"><span class="comment">         * display state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Returns:</span></span><br><span class="line"><span class="comment">         * 0 if &amp;drm_connector_helper_funcs.mode_valid_ctx succeeded and wrote</span></span><br><span class="line"><span class="comment">         * the &amp;enum drm_mode_status value to @status, or a negative error</span></span><br><span class="line"><span class="comment">         * code otherwise.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*mode_valid_ctx)(struct drm_connector *connector,</span><br><span class="line">                              struct drm_display_mode *mode,</span><br><span class="line">                              struct drm_modeset_acquire_ctx *ctx,</span><br><span class="line">                              <span class="keyword">enum</span> drm_mode_status *status);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @best_encoder:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function should select the best encoder for the given connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is used by both the atomic helpers (in the</span></span><br><span class="line"><span class="comment">         * drm_atomic_helper_check_modeset() function) and in the legacy CRTC</span></span><br><span class="line"><span class="comment">         * helpers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * In atomic drivers this function is called in the check phase of an</span></span><br><span class="line"><span class="comment">         * atomic update. The driver is not allowed to change or inspect</span></span><br><span class="line"><span class="comment">         * anything outside of arguments passed-in. Atomic drivers which need to</span></span><br><span class="line"><span class="comment">         * inspect dynamic configuration state should instead use</span></span><br><span class="line"><span class="comment">         * @atomic_best_encoder.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * You can leave this function to NULL if the connector is only</span></span><br><span class="line"><span class="comment">         * attached to a single encoder. In this case, the core will call</span></span><br><span class="line"><span class="comment">         * drm_connector_get_single_encoder() for you.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Encoder that should be used for the given connector and connector</span></span><br><span class="line"><span class="comment">         * state, or NULL if no suitable encoder exists. Note that the helpers</span></span><br><span class="line"><span class="comment">         * will ensure that encoders aren&#x27;t used twice, drivers should not check</span></span><br><span class="line"><span class="comment">         * for this.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">best_encoder</span>)(<span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>);</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_best_encoder:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is the atomic version of @best_encoder for atomic drivers which</span></span><br><span class="line"><span class="comment">         * need to select the best encoder depending upon the desired</span></span><br><span class="line"><span class="comment">         * configuration and can&#x27;t select it statically.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is used by drm_atomic_helper_check_modeset().</span></span><br><span class="line"><span class="comment">         * If it is not implemented, the core will fallback to @best_encoder</span></span><br><span class="line"><span class="comment">         * (or drm_connector_get_single_encoder() if @best_encoder is NULL).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the check phase of an atomic update. The</span></span><br><span class="line"><span class="comment">         * driver is not allowed to change anything outside of the</span></span><br><span class="line"><span class="comment">         * &amp;drm_atomic_state update tracking structure passed in.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Encoder that should be used for the given connector and connector</span></span><br><span class="line"><span class="comment">         * state, or NULL if no suitable encoder exists. Note that the helpers</span></span><br><span class="line"><span class="comment">         * will ensure that encoders aren&#x27;t used twice, drivers should not check</span></span><br><span class="line"><span class="comment">         * for this.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_encoder</span> *(*<span class="title">atomic_best_encoder</span>)(<span class="title">struct</span> <span class="title">drm_connector</span> *<span class="title">connector</span>,</span></span><br><span class="line"><span class="class">                                                   <span class="title">struct</span> <span class="title">drm_atomic_state</span> *<span class="title">state</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_check:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is used to validate connector state. This function is</span></span><br><span class="line"><span class="comment">         * called from &amp;drm_atomic_helper_check_modeset, and is called when</span></span><br><span class="line"><span class="comment">         * a connector property is set, or a modeset on the crtc is forced.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Because &amp;drm_atomic_helper_check_modeset may be called multiple times,</span></span><br><span class="line"><span class="comment">         * this function should handle being called multiple times as well.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is also allowed to inspect any other object&#x27;s state and</span></span><br><span class="line"><span class="comment">         * can add more state objects to the atomic commit if needed. Care must</span></span><br><span class="line"><span class="comment">         * be taken though to ensure that state check and compute functions for</span></span><br><span class="line"><span class="comment">         * these added states are all called, and derived state in other objects</span></span><br><span class="line"><span class="comment">         * all updated. Again the recommendation is to just call check helpers</span></span><br><span class="line"><span class="comment">         * until a maximal configuration is reached.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span></span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This function is called in the check phase of an atomic update. The</span></span><br><span class="line"><span class="comment">         * driver is not allowed to change anything outside of the free-standing</span></span><br><span class="line"><span class="comment">         * state objects passed-in or assembled in the overall &amp;drm_atomic_state</span></span><br><span class="line"><span class="comment">         * update tracking structure.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RETURNS:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 0 on success, -EINVAL if the state or the transition can&#x27;t be</span></span><br><span class="line"><span class="comment">         * supported, -ENOMEM on memory allocation failure and -EDEADLK if an</span></span><br><span class="line"><span class="comment">         * attempt to obtain another state object ran into a &amp;drm_modeset_lock</span></span><br><span class="line"><span class="comment">         * deadlock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*atomic_check)(struct drm_connector *connector,</span><br><span class="line">                            struct drm_atomic_state *state);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @atomic_commit:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is to be used by drivers implementing writeback connectors</span></span><br><span class="line"><span class="comment">         * that need a point when to commit the writeback job to the hardware.</span></span><br><span class="line"><span class="comment">         * The writeback_job to commit is available in the new connector state,</span></span><br><span class="line"><span class="comment">         * in &amp;drm_connector_state.writeback_job.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This hook is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the atomic modeset helpers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*atomic_commit)(struct drm_connector *connector,</span><br><span class="line">                              struct drm_atomic_state *state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @prepare_writeback_job:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * As writeback jobs contain a framebuffer, drivers may need to</span></span><br><span class="line"><span class="comment">         * prepare and clean them up the same way they can prepare and</span></span><br><span class="line"><span class="comment">         * clean up framebuffers for planes. This optional connector operation</span></span><br><span class="line"><span class="comment">         * is used to support the preparation of writeback jobs. The job</span></span><br><span class="line"><span class="comment">         * prepare operation is called from drm_atomic_helper_prepare_planes()</span></span><br><span class="line"><span class="comment">         * for struct &amp;drm_writeback_connector connectors only.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This operation is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the atomic modeset helpers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> (*prepare_writeback_job)(struct drm_writeback_connector *connector,</span><br><span class="line">                                     struct drm_writeback_job *job);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @cleanup_writeback_job:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optional connector operation is used to support the</span></span><br><span class="line"><span class="comment">         * cleanup of writeback jobs. The job cleanup operation is called</span></span><br><span class="line"><span class="comment">         * from the existing drm_writeback_cleanup_job() function, invoked</span></span><br><span class="line"><span class="comment">         * both when destroying the job as part of an aborted commit, or when</span></span><br><span class="line"><span class="comment">         * the job completes.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This operation is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the atomic modeset helpers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*cleanup_writeback_job)(struct drm_writeback_connector *connector,</span><br><span class="line">                                      struct drm_writeback_job *job);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @enable_hpd:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Enable hot-plug detection for the connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This operation is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the drm_kms_helper_poll_enable() helpers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*enable_hpd)(struct drm_connector *connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @disable_hpd:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Disable hot-plug detection for the connector.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This operation is optional.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This callback is used by the drm_kms_helper_poll_disable() helpers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">void</span> (*disable_hpd)(struct drm_connector *connector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="四、核心API"><a href="#四、核心API" class="headerlink" title="四、核心API"></a>四、核心API</h3><h4 id="4-1-encoder初始化"><a href="#4-1-encoder初始化" class="headerlink" title="4.1 encoder初始化"></a>4.1 <code>encoder</code>初始化</h4><p><code>drm_encoder_init</code>函数用于初始化<code>encoder</code>对象，定义在<code>drivers/gpu/drm/drm_encoder.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_encoder_init - Init a preallocated encoder</span></span><br><span class="line"><span class="comment"> * @dev: drm device</span></span><br><span class="line"><span class="comment"> * @encoder: the encoder to init</span></span><br><span class="line"><span class="comment"> * @funcs: callbacks for this encoder</span></span><br><span class="line"><span class="comment"> * @encoder_type: user visible type of the encoder</span></span><br><span class="line"><span class="comment"> * @name: printf style format string for the encoder name, or NULL for default name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes a preallocated encoder. Encoder should be subclassed as part of</span></span><br><span class="line"><span class="comment"> * driver encoder objects. At driver unload time the driver&#x27;s</span></span><br><span class="line"><span class="comment"> * &amp;drm_encoder_funcs.destroy hook should call drm_encoder_cleanup() and kfree()</span></span><br><span class="line"><span class="comment"> * the encoder structure. The encoder structure should not be allocated with</span></span><br><span class="line"><span class="comment"> * devm_kzalloc().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: consider using drmm_encoder_alloc() or drmm_encoder_init()</span></span><br><span class="line"><span class="comment"> * instead of drm_encoder_init() to let the DRM managed resource</span></span><br><span class="line"><span class="comment"> * infrastructure take care of cleanup and deallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> * Zero on success, error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_encoder_init</span><span class="params">(struct drm_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct drm_encoder *encoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> struct drm_encoder_funcs *funcs,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> encoder_type, <span class="keyword">const</span> <span class="keyword">char</span> *name, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        WARN_ON(!funcs-&gt;destroy);</span><br><span class="line"></span><br><span class="line">        va_start(ap, name);</span><br><span class="line">        ret = __drm_encoder_init(dev, encoder, funcs, encoder_type, name, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现位于函数<code>__drm_encoder_init</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__printf(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __drm_encoder_init(struct drm_device *dev,</span><br><span class="line">                              struct drm_encoder *encoder,</span><br><span class="line">                              <span class="keyword">const</span> struct drm_encoder_funcs *funcs,</span><br><span class="line">                              <span class="keyword">int</span> encoder_type, <span class="keyword">const</span> <span class="keyword">char</span> *name, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* encoder index is used with 32bit bitmasks */</span></span><br><span class="line">        <span class="keyword">if</span> (WARN_ON(dev-&gt;mode_config.num_encoder &gt;= <span class="number">32</span>))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        ret = drm_mode_object_add(dev, &amp;encoder-&gt;base, DRM_MODE_OBJECT_ENCODER);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        encoder-&gt;dev = dev;</span><br><span class="line">        encoder-&gt;encoder_type = encoder_type;</span><br><span class="line">        encoder-&gt;funcs = funcs;</span><br><span class="line">        <span class="keyword">if</span> (name) &#123;</span><br><span class="line">                encoder-&gt;name = kvasprintf(GFP_KERNEL, name, ap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                encoder-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s-%d&quot;</span>,</span><br><span class="line">                                          drm_encoder_enum_list[encoder_type].name,</span><br><span class="line">                                          encoder-&gt;base.id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!encoder-&gt;name) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> out_put;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INIT_LIST_HEAD(&amp;encoder-&gt;bridge_chain);</span><br><span class="line">        list_add_tail(&amp;encoder-&gt;head, &amp;dev-&gt;mode_config.encoder_list);</span><br><span class="line">        encoder-&gt;index = dev-&gt;mode_config.num_encoder++;</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                drm_mode_object_unregister(dev, &amp;encoder-&gt;base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-2-connector初始化"><a href="#4-2-connector初始化" class="headerlink" title="4.2 connector初始化"></a>4.2 <code>connector</code>初始化</h4><p><code>drm_connector_init</code>函数用于初始化<code>connector</code>对象，定义在<code>drivers/gpu/drm/drm_connector.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_connector_init - Init a preallocated connector</span></span><br><span class="line"><span class="comment"> * @dev: DRM device</span></span><br><span class="line"><span class="comment"> * @connector: the connector to init</span></span><br><span class="line"><span class="comment"> * @funcs: callbacks for this connector</span></span><br><span class="line"><span class="comment"> * @connector_type: user visible type of the connector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialises a preallocated connector. Connectors should be</span></span><br><span class="line"><span class="comment"> * subclassed as part of driver connector objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At driver unload time the driver&#x27;s &amp;drm_connector_funcs.destroy hook</span></span><br><span class="line"><span class="comment"> * should call drm_connector_cleanup() and free the connector structure.</span></span><br><span class="line"><span class="comment"> * The connector structure should not be allocated with devm_kzalloc().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: consider using drmm_connector_init() instead of</span></span><br><span class="line"><span class="comment"> * drm_connector_init() to let the DRM managed resource infrastructure</span></span><br><span class="line"><span class="comment"> * take care of cleanup and deallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> * Zero on success, error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_connector_init</span><span class="params">(struct drm_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct drm_connector *connector,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> struct drm_connector_funcs *funcs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> connector_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (drm_WARN_ON(dev, !(funcs &amp;&amp; funcs-&gt;destroy)))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __drm_connector_init(dev, connector, funcs, connector_type, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现位于函数<code>__drm_connector_init</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __drm_connector_init(struct drm_device *dev,</span><br><span class="line">                                struct drm_connector *connector,</span><br><span class="line">                                <span class="keyword">const</span> struct drm_connector_funcs *funcs,</span><br><span class="line">                                <span class="keyword">int</span> connector_type,</span><br><span class="line">                                struct i2c_adapter *ddc)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config</span> *<span class="title">config</span> = &amp;<span class="title">dev</span>-&gt;<span class="title">mode_config</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ida</span> *<span class="title">connector_ida</span> =</span></span><br><span class="line"><span class="class">                &amp;<span class="title">drm_connector_enum_list</span>[<span class="title">connector_type</span>].<span class="title">ida</span>;</span></span><br><span class="line"></span><br><span class="line">        WARN_ON(drm_drv_uses_atomic_modeset(dev) &amp;&amp;</span><br><span class="line">                (!funcs-&gt;atomic_destroy_state ||</span><br><span class="line">                 !funcs-&gt;atomic_duplicate_state));</span><br><span class="line"></span><br><span class="line">        ret = __drm_mode_object_add(dev, &amp;connector-&gt;base,</span><br><span class="line">                                    DRM_MODE_OBJECT_CONNECTOR,</span><br><span class="line">                                    <span class="literal">false</span>, drm_connector_free);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        connector-&gt;base.properties = &amp;connector-&gt;properties;</span><br><span class="line">        connector-&gt;dev = dev;</span><br><span class="line">        connector-&gt;funcs = funcs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* connector index is used with 32bit bitmasks */</span></span><br><span class="line">        ret = ida_alloc_max(&amp;config-&gt;connector_ida, <span class="number">31</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                DRM_DEBUG_KMS(<span class="string">&quot;Failed to allocate %s connector index: %d\n&quot;</span>,</span><br><span class="line">                              drm_connector_enum_list[connector_type].name,</span><br><span class="line">                              ret);</span><br><span class="line">                <span class="keyword">goto</span> out_put;</span><br><span class="line">        &#125;</span><br><span class="line">        connector-&gt;index = ret;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        connector-&gt;connector_type = connector_type;</span><br><span class="line">        connector-&gt;connector_type_id =</span><br><span class="line">                ida_alloc_min(connector_ida, <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (connector-&gt;connector_type_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = connector-&gt;connector_type_id;</span><br><span class="line">                <span class="keyword">goto</span> out_put_id;</span><br><span class="line">        &#125;</span><br><span class="line">        connector-&gt;name =</span><br><span class="line">                kasprintf(GFP_KERNEL, <span class="string">&quot;%s-%d&quot;</span>,</span><br><span class="line">                          drm_connector_enum_list[connector_type].name,</span><br><span class="line">                          connector-&gt;connector_type_id);</span><br><span class="line">        <span class="keyword">if</span> (!connector-&gt;name) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> out_put_type_id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* provide ddc symlink in sysfs */</span></span><br><span class="line">        connector-&gt;ddc = ddc;</span><br><span class="line"></span><br><span class="line">        INIT_LIST_HEAD(&amp;connector-&gt;global_connector_list_entry);</span><br><span class="line">        INIT_LIST_HEAD(&amp;connector-&gt;probed_modes);</span><br><span class="line">        INIT_LIST_HEAD(&amp;connector-&gt;modes);</span><br><span class="line">        mutex_init(&amp;connector-&gt;mutex);</span><br><span class="line">        mutex_init(&amp;connector-&gt;edid_override_mutex);</span><br><span class="line">        connector-&gt;edid_blob_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        connector-&gt;epoch_counter = <span class="number">0</span>;</span><br><span class="line">        connector-&gt;tile_blob_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        connector-&gt;status = connector_status_unknown;</span><br><span class="line">        connector-&gt;display_info.panel_orientation =</span><br><span class="line">                DRM_MODE_PANEL_ORIENTATION_UNKNOWN;</span><br><span class="line"></span><br><span class="line">        drm_connector_get_cmdline_mode(connector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We should add connectors at the end to avoid upsetting the connector</span></span><br><span class="line"><span class="comment">         * index too much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock_irq(&amp;config-&gt;connector_list_lock);</span><br><span class="line">        list_add_tail(&amp;connector-&gt;head, &amp;config-&gt;connector_list);</span><br><span class="line">        config-&gt;num_connector++;</span><br><span class="line">        spin_unlock_irq(&amp;config-&gt;connector_list_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &amp;&amp;</span><br><span class="line">            connector_type != DRM_MODE_CONNECTOR_WRITEBACK)</span><br><span class="line">                drm_connector_attach_edid_property(connector);</span><br><span class="line"></span><br><span class="line">        drm_object_attach_property(&amp;connector-&gt;base,</span><br><span class="line">                                      config-&gt;dpms_property, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        drm_object_attach_property(&amp;connector-&gt;base,</span><br><span class="line">                                   config-&gt;link_status_property,</span><br><span class="line">                                   <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        drm_object_attach_property(&amp;connector-&gt;base,</span><br><span class="line">                                   config-&gt;non_desktop_property,</span><br><span class="line">                                   <span class="number">0</span>);</span><br><span class="line">        drm_object_attach_property(&amp;connector-&gt;base,</span><br><span class="line">                                   config-&gt;tile_property,</span><br><span class="line">                                   <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drm_core_check_feature(dev, DRIVER_ATOMIC)) &#123;</span><br><span class="line">                drm_object_attach_property(&amp;connector-&gt;base, config-&gt;prop_crtc_id, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connector-&gt;debugfs_entry = <span class="literal">NULL</span>;</span><br><span class="line">out_put_type_id:</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                ida_free(connector_ida, connector-&gt;connector_type_id);</span><br><span class="line">out_put_id:</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                ida_free(&amp;config-&gt;connector_ida, connector-&gt;index);</span><br><span class="line">out_put:</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                drm_mode_object_unregister(dev, &amp;connector-&gt;base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong></p>
<p><strong>[1] <a target="_blank" rel="noopener" href="https://mculover666.blog.csdn.net/article/details/128131538"><code>RK3399</code>驱动开发 | 20 - 阿美林7寸<code>mipi</code>屏幕调试</a></strong></p>
<p><strong>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/512181966?utm_id=0"><code>Linux MIPI DSI</code>驱动开发 | 基于<code>RK3399</code></a></strong></p>
<p><strong>[3] <a target="_blank" rel="noopener" href="https://www.freesion.com/article/3102348159/"><code>RK3399 LINUX-SDK MIPI</code>屏幕驱动及调试</a></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20240223/">https://zhoujinjian.com/posts/20240223/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20240224/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</div></div></a></div><div class="next-post pull-right"><a href="/posts/20240222/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81encoder%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">一、encoder数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-struct-drm-encoder"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 struct drm_encoder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-struct-drm-encoder-funcs"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 struct drm_encoder_funcs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-struct-drm-encoder-helper-funcs"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 struct drm_encoder_helper_funcs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81bridge%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、bridge数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-struct-drm-bridge"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 struct drm_bridge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2struct-drm-bridge-funcs"><span class="toc-number">2.2.</span> <span class="toc-text">2.2struct drm_bridge_funcs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81connector%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">三、connector数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-struct-drm-connector"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 struct drm_connector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-struct-drm-display-info"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 struct drm_display_info</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-struct-drm-hdmi-info"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 struct drm_hdmi_info</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-struct-drm-connector-funcs"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 struct drm_connector_funcs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-struct-drm-connector-helper-funcs"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 struct drm_connector_helper_funcs</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83API"><span class="toc-number">4.</span> <span class="toc-text">四、核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-encoder%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 encoder初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-connector%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 connector初始化</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>