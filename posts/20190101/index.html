<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Camera System（1）：Camera 系统 框架、Open()过程分析 | zhoujinjian</title><meta name="keywords" content="Camera,Android,Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Camera System（1）：Camera 系统 框架、Open()过程分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20190101/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg">
<meta property="article:published_time" content="2019-01-01T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.964Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Camera">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20190101/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Camera System（1）：Camera 系统 框架、Open()过程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-01-01T01:25:00.000Z" title="发表于 2019-01-01 09:25:00">2019-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.964Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Camera/">Camera</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/category/6282972">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775897/article/category/7112759">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/guming-camera.html">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p>
<hr>
<p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p>
<p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p>
<p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p>
<p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p>
<p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p>
<p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p>
<hr>
<h4 id="（一）、Android-Camera-System-Architecture（Camera系统框架）"><a href="#（一）、Android-Camera-System-Architecture（Camera系统框架）" class="headerlink" title="（一）、Android Camera System Architecture（Camera系统框架）"></a>（一）、Android Camera System Architecture（Camera系统框架）</h4><h5 id="1-1、Android-Camera-System总体框架（Qualcomm平台）"><a href="#1-1、Android-Camera-System总体框架（Qualcomm平台）" class="headerlink" title="1.1、Android Camera System总体框架（Qualcomm平台）"></a>1.1、Android Camera System总体框架（Qualcomm平台）</h5><h5 id="1-1-1、首先看看Android-官方Camera总体架构："><a href="#1-1-1、首先看看Android-官方Camera总体架构：" class="headerlink" title="1.1.1、首先看看Android 官方Camera总体架构："></a>1.1.1、首先看看Android 官方Camera总体架构：</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-01-android_ape_fwk_camera.png" alt="Alt text"></p>
<p><strong>☯应用框架</strong><br>应用代码位于应用框架级别，它利用 android.hardware.Camera API 来与相机硬件进行互动。在内部，此代码会调用相应的 JNI 粘合类，以访问与该相机互动的原生代码。<br><strong>☯JNI</strong><br>与 android.hardware.Camera 关联的 JNI 代码位于 frameworks/base/core/jni/android_hardware_Camera.cpp 中。此代码会调用较低级别的原生代码以获取对物理相机的访问权限，并返回用于在框架级别创建 android.hardware.Camera 对象的数据。<br><strong>☯原生框架</strong><br>在 frameworks/av/camera/Camera.cpp 中定义的原生框架可提供相当于 android.hardware.Camera 类的原生类。此类会调用 IPC binder 代理，以获取对相机服务的访问权限。<br><strong>☯Binder IPC 代理</strong><br>IPC binder 代理用于促进跨越进程边界的通信。调用相机服务的 frameworks/av/camera 目录中有 3 个相机 binder 类。ICameraService 是相机服务的接口，ICamera 是已打开的特定相机设备的接口，ICameraClient 是返回应用框架的设备接口。<br><strong>☯相机服务</strong><br>位于 frameworks/av/services/camera/libcameraservice/CameraService.cpp 下的相机服务是与 HAL 进行互动的实际代码。<br><strong>☯HAL</strong><br>硬件抽象层定义了由相机服务调用且您必须实现以确保相机硬件正常运行的标准接口。<br><strong>☯内核驱动程序</strong><br>相机的驱动程序可与实际相机硬件以及您的 HAL 实现进行互动。相机和驱动程序必须支持 YV12 和 NV21 图片格式，以便在显示和视频录制时支持预览相机图片。</p>
<h5 id="1-1-2、Qualcomm平台Camera-架构"><a href="#1-1-2、Qualcomm平台Camera-架构" class="headerlink" title="1.1.2、Qualcomm平台Camera 架构"></a>1.1.2、Qualcomm平台Camera 架构</h5><p>Qualcomm平台Camera 架构主要区别在于HAL层和Kernel层的变化，总体架构图如下：</p>
<h5 id="1-1-2-1、Qualcomm平台Camera总体架构"><a href="#1-1-2-1、Qualcomm平台Camera总体架构" class="headerlink" title="1.1.2.1、Qualcomm平台Camera总体架构"></a>1.1.2.1、Qualcomm平台Camera总体架构</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-02-Android-Camera-Software-Architecture.png" alt="Alt text"></p>
<h5 id="1-1-2-2、Qualcomm平台Camera的HAL、mm-camera"><a href="#1-1-2-2、Qualcomm平台Camera的HAL、mm-camera" class="headerlink" title="1.1.2.2、Qualcomm平台Camera的HAL、mm-camera"></a>1.1.2.2、Qualcomm平台Camera的HAL、mm-camera</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-03-HAL-and-mm-camera-interface.png" alt="Alt text"></p>
<h5 id="1-1-2-3、Qualcomm平台Camera的Kernel"><a href="#1-1-2-3、Qualcomm平台Camera的Kernel" class="headerlink" title="1.1.2.3、Qualcomm平台Camera的Kernel"></a>1.1.2.3、Qualcomm平台Camera的Kernel</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-04-Camera-Kernel-Architecture.png" alt="Alt text"></p>
<h5 id="1-2、Android-Camera-API-2-0-全新的HAL-子系统"><a href="#1-2、Android-Camera-API-2-0-全新的HAL-子系统" class="headerlink" title="1.2、Android Camera API 2.0 全新的HAL 子系统"></a>1.2、Android Camera API 2.0 全新的HAL 子系统</h5><p>Android 7.1.2现在使用的是Camera API 2.0 和 Camera Device 3以及 HAL3。</p>
<h5 id="1-2-1、请求"><a href="#1-2-1、请求" class="headerlink" title="1.2.1、请求"></a>1.2.1、请求</h5><p>应用框架针对捕获的结果向相机子系统发出请求。一个请求对应一组结果。请求包含有关捕获和处理这些结果的所有配置信息。其中包括分辨率和像素格式；手动传感器、镜头和闪光灯控件；3A 操作模式；RAW 到 YUV 处理控件；以及统计信息的生成。这样一来，便可更好地控制结果的输出和处理。一次可发起多个请求，而且提交的请求不会出现阻塞的情况。请求始终按照接收的顺序进行处理。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-05-camera2api.png.png" alt="Alt text"></p>
<h5 id="1-2-2、HAL-和相机子系统"><a href="#1-2-2、HAL-和相机子系统" class="headerlink" title="1.2.2、HAL 和相机子系统"></a>1.2.2、HAL 和相机子系统</h5><p>相机子系统包括相机管道中组件的实现，例如 3A 算法和处理控件。相机 HAL 为您提供了实现您版本的这些组件所需的接口。为了保持多个设备制造商和图像信号处理器（ISP，也称为相机传感器）供应商之间的跨平台兼容性，相机管道模型是虚拟的，且不直接对应任何真正的 ISP。不过，它与真正的处理管道足够相似，因此您可以有效地将其映射到硬件。此外，它足够抽象，可支持多种不同的算法和操作顺序，而不会影响质量、效率或跨设备兼容性。<br>相机管道还支持应用框架开启自动对焦等功能的触发器。它还会将通知发送回应用框架，以通知应用自动对焦锁定或错误等事件。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-06-camera_hal_request_control.png.png" alt="Alt text"></p>
<blockquote>
<p>RAW Bayer 输出在 ISP 内部不经过任何处理。<br>统计信息根据原始传感器数据生成。<br>将原始传感器数据转换为 YUV 的各种处理块按任意顺序排列。<br>当显示多个刻度和剪裁单元时，所有的缩放器单元共享输出区域控件（数字缩放）。不过，每个单元都可能具有不同的输出分辨率和像素格式。</p>
</blockquote>
<h5 id="1-2-3、HAL-操作摘要"><a href="#1-2-3、HAL-操作摘要" class="headerlink" title="1.2.3、HAL 操作摘要"></a>1.2.3、HAL 操作摘要</h5><p>☯ 捕获的异步请求来自于框架。<br>☯ HAL 设备必须按顺序处理请求。对于每个请求，均产生输出结果元数据以及一个或多个输出图片缓冲区。<br>☯ 请求和结果以及后续请求引用的流遵守先进先出规则。<br>☯ 指定请求的所有输出的时间戳必须完全相同，以便框架可以根据需要将它们匹配在一起。<br>☯ 所有捕获配置和状态（不包括 3A 例程）都包含在请求和结果中。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-07-camera-hal-overview-oo.png.png" alt="Alt text"></p>
<h5 id="1-2-4、启动和预期操作顺序"><a href="#1-2-4、启动和预期操作顺序" class="headerlink" title="1.2.4、启动和预期操作顺序"></a>1.2.4、启动和预期操作顺序</h5><p>1、框架调用 camera_module_t-&gt;common.open()，而这会返回一个 hardware_device_t 结构。<br>2、框架检查 hardware_device_t-&gt;version 字段，并为该版本的相机硬件设备实例化相应的处理程序。如果版本是 CAMERA_DEVICE_API_VERSION_3_0，则该设备会转型为 camera3_device_t。<br>3、框架调用 camera3_device_t-&gt;ops-&gt;initialize() 并显示框架回调函数指针。在调用 ops 结构中的任何其他函数之前，这只会在 open() 之后调用一次。<br>4、框架调用 camera3_device_t-&gt;ops-&gt;configure_streams() 并显示到 HAL 设备的输入/输出流列表。<br>5、框架为 configure_streams 中列出的至少一个输出流分配 gralloc 缓冲区并调用 camera3_device_t-&gt;ops-&gt;register_stream_buffers()。相同的流仅注册一次。<br>6、框架通过调用 camera3_device_t-&gt;ops-&gt;construct_default_request_settings() 来为某些使用情形请求默认设置。这可能会在第 3 步之后的任何时间发生。<br>7、框架通过基于其中一组默认设置的设置以及至少一个框架之前注册的输出流来构建第一个捕获请求并将其发送到 HAL。它通过 camera3_device_t-&gt;ops-&gt;process_capture_request() 发送到 HAL。HAL 必须阻止此调用返回，直到准备好发送下一个请求。<br>8、框架继续提交请求，并且可能会为尚未注册的流调用 register_stream_buffers()，并调用 construct_default_request_settings 来为其他使用情形获取默认设置缓冲区。<br>9、当请求捕获开始（传感器开始曝光以进行捕获）时，HAL 会调用 camera3_callback_ops_t-&gt;notify() 并显示 SHUTTER 事件，包括帧号和开始曝光的时间戳。此通知调用必须在第一次调用该帧号的 process_capture_result() 之前进行。<br>10、在某个管道延迟后，HAL 开始使用 camera3_callback_ops_t-&gt;process_capture_result() 将完成的捕获返回到框架。这些捕获按照与提交请求相同的顺序返回。一次可发起多个请求，具体取决于相机 HAL 设备的管道深度。<br>11、一段时间后，框架可能会停止提交新的请求、等待现有捕获完成（所有缓冲区都已填充，所有结果都已返回），然后再次调用 configure_streams()。这会重置相机硬件和管道，以获得一组新的输入/输出流。可重复使用先前配置中的部分流；如果这些流的缓冲区已经过 HAL 注册，则不会再次注册。如果至少还有一个已注册的输出流，则框架从第 7 步继续（否则，需要先完成第 5 步）。<br>12、或者，框架可能会调用 camera3_device_t-&gt;common-&gt;close() 以结束相机会话。当框架中没有其他处于活动状态的调用时，它可能随时会被调用；尽管在所有发起的捕获完成（所有结果都已返回，所有缓冲区都已填充）之前，调用可能会阻塞。在 close 调用返回后，不允许再从 HAL 对 camera3_callback_ops_t 函数进行更多调用。一旦进行 close() 调用，该框架可能不会调用任何其他 HAL 设备函数。<br>13、在发生错误或其他异步事件时，HAL 必须调用 camera3_callback_ops_t-&gt;notify() 并返回相应的错误/事件消息。从严重的设备范围错误通知返回后，HAL 应表现为在其上调用了 close()。但是，HAL 必须在调用 notify() 之前取消或完成所有待处理的捕获，以便在调用 notify() 并返回严重错误时，框架不会收到来自设备的更多回调。在严重的错误消息返回 notify() 方法后，close() 之外的方法应该返回 -ENODEV 或 NULL。</p>
<h5 id="1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍"><a href="#1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍" class="headerlink" title="1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍"></a>1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-08-Android-graphics-SurfaceFlinger-BufferQueue.jpg.png" alt="Alt text"></p>
<p>Graphics 系统详细分析请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】()</p>
<h5 id="1-4、Camera类之间的关系和作用"><a href="#1-4、Camera类之间的关系和作用" class="headerlink" title="1.4、Camera类之间的关系和作用"></a>1.4、Camera类之间的关系和作用</h5><h5 id="1-4-1、Camera类关系总体概览"><a href="#1-4-1、Camera类关系总体概览" class="headerlink" title="1.4.1、Camera类关系总体概览"></a>1.4.1、Camera类关系总体概览</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-09-Android-Camera-class.png" alt="Alt text"></p>
<p>☯ 1、ICameraClient: 这主要是一些消息发送的接口，包括帧可用通知，回调一些信息给client等消息。不过这里要注意的是，BnCameraClient对象其实是在client这端，不在CameraService端。<br>☯ 2、ICamera:camera的一些标准操作接口，比如startpreview，takepicuture,autofocus,所有的操作动作都是用的这一套接口。<br>☯ 3、ICameraService: 链接Camera服务，Camera device,获取Camera数量，Camera硬件信息，视厂角，镜头等信息。</p>
<h5 id="1-4-2、ICameraClient"><a href="#1-4-2、ICameraClient" class="headerlink" title="1.4.2、ICameraClient"></a>1.4.2、ICameraClient</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-10-ICameraClient.png" alt="Alt text"></p>
<h5 id="1-4-3、ICamera"><a href="#1-4-3、ICamera" class="headerlink" title="1.4.3、ICamera"></a>1.4.3、ICamera</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-11-ICamera.png" alt="Alt text"></p>
<h5 id="1-4-4、ICameraService"><a href="#1-4-4、ICameraService" class="headerlink" title="1.4.4、ICameraService"></a>1.4.4、ICameraService</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-12-ICameraService.png" alt="Alt text"></p>
<h4 id="（二）、Android-CameraService开机初始化分析"><a href="#（二）、Android-CameraService开机初始化分析" class="headerlink" title="（二）、Android CameraService开机初始化分析"></a>（二）、Android CameraService开机初始化分析</h4><p>首先看下总体时序图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-13-CameraService_onFirstRef.png" alt="Alt text"></p>
<h5 id="2-1、CameraService-初始化过程"><a href="#2-1、CameraService-初始化过程" class="headerlink" title="2.1、CameraService 初始化过程"></a>2.1、CameraService 初始化过程</h5><p>Android启动的时候会收集系统的.rc文件，启动对应的Native Service：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\cameraserver.rc]</span><br><span class="line">service cameraserver /system/bin/cameraserver</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">audio</span> <span class="title">camera</span> <span class="title">input</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">ioprio</span> <span class="title">rt</span> 4</span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">camera</span>-<span class="title">daemon</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">top</span>-<span class="title">app</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\main_cameraserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span>** argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraService继承自BinderService，instantiate也是在BinderService中定义的，此方法就是调用publish方法，所以来看publish方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\include\binder\BinderService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">status_t</span> <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="comment">//将服务添加到ServiceManager</span></span><br><span class="line">    <span class="keyword">return</span> sm-&gt;addService(String16(SERVICE::getServiceName()),<span class="keyword">new</span> SERVICE(), allowIsolated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，将会把CameraService服务加入到ServiceManager进行管理。 CameraService的构造时，会调用CameraService的onFirstRef方法：</p>
<h5 id="2-1-1、CameraService-onFirstRef"><a href="#2-1-1、CameraService-onFirstRef" class="headerlink" title="2.1.1、CameraService::onFirstRef()"></a>2.1.1、CameraService::onFirstRef()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CameraService::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;CameraService process starting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update battery life tracking if service is restarting</span></span><br><span class="line">    <span class="function">BatteryNotifier&amp; <span class="title">notifier</span><span class="params">(BatteryNotifier::getInstance())</span></span>;</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    err = mModule-&gt;init();</span><br><span class="line">    ......</span><br><span class="line">    mFlashlight = <span class="keyword">new</span> CameraFlashlight(*mModule, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mModule-&gt;getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_1) &#123;</span><br><span class="line">        mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会通过HAL框架的hw_get_module来创建CameraModule对象，然后会对其进行相应的初始化，并会进行一些参数的设置，如camera的数量，闪光灯的初始化，以及回调函数的设置等，到这里，Camera2 HAL的模块就初始化结束了。</p>
<h5 id="2-1-2、Camera-动态库加载过程"><a href="#2-1-2、Camera-动态库加载过程" class="headerlink" title="2.1.2、Camera 动态库加载过程"></a>2.1.2、Camera 动态库加载过程</h5><p>在源码中不知大家有没有注意到第二个参数是hw_module_t <strong>module,这里是指针的指针，而我们刚才传的是camera_module_t</strong>指针。大家可以看到camera_module_t 结构第一个域就是hw_module_t 所以这里就不难理解了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">源码路径：hardware/libhardware/hardware.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base path of the hal modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">&quot;/system/lib/hw&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">&quot;/vendor/lib/hw&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="comment">//这里的id就是camera模块的id，每一个hal module都有对应的id，</span></span><br><span class="line">    <span class="comment">//区分他们就通过这个id来区分了。</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123; <span class="comment">//关键字数组，上面有宏代码。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s/%s.%s.so&quot;</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s/%s.%s.so&quot;</span>, <span class="comment">//拼接完整的camera库。</span></span><br><span class="line">                     HAL_LIBRARY_PATH1, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s/%s.default.so&quot;</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;%s/%s.default.so&quot;</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH1, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT+<span class="number">1</span>) &#123;</span><br><span class="line">        status = load(class_id, path, <span class="keyword">module</span>); <span class="comment">//如果上面都进行完毕，走到这里，说明已经找到库了，这里就去加载。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id来加载hal的module</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **pHmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = dlopen(path, RTLD_NOW); <span class="comment">//动态加载内存的api，这里的path=/system/lib/hw/camera.msm8996.so</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Get the address of the struct hal_module_info. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;   <span class="comment">//别的地方定义#define HAL_MODULE_INFO_SYM_AS_STR  &quot;HMI&quot;</span></span><br><span class="line">    hmi = (struct <span class="keyword">hw_module_t</span> *)dlsym(handle, sym); <span class="comment">//我们动态链接的是&quot;HMI&quot;这个符号。</span></span><br><span class="line">    ......</span><br><span class="line">    *pHmi = hmi; <span class="comment">//最后将这个指针，赋给我们之前定义的 struct camera_module变量。这里模块就加载进来了。</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hal代码</span></span><br><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Hal.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">hw_module_t</span> camera_common = &#123;</span><br><span class="line">    .tag                    = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version     = CAMERA_MODULE_API_VERSION_2_4,</span><br><span class="line">    .hal_api_version        = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id                     = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">    .name                   = <span class="string">&quot;QCamera Module&quot;</span>,</span><br><span class="line">    .author                 = <span class="string">&quot;Qualcomm Innovation Center Inc&quot;</span>,</span><br><span class="line">    .methods                = &amp;qcamera::QCamera2Factory::mModuleMethods, <span class="comment">//它的方法数组里绑定了open接口</span></span><br><span class="line">    .dso                    = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common                 = camera_common,</span><br><span class="line">    .get_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = qcamera::QCamera2Factory::get_camera_info,</span><br><span class="line">    .set_callbacks          = qcamera::QCamera2Factory::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = qcamera::QCamera2Factory::open_legacy,</span><br><span class="line">    .set_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,</span><br><span class="line">    .init                   = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">QCamera2Factory</span>:</span>:mModuleMethods = &#123;</span><br><span class="line">    <span class="comment">//open方法的绑定</span></span><br><span class="line">    open: QCamera2Factory::camera_device_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Camera HAL层的open入口其实就是camera_device_open方法：</p>
<h5 id="2-1-3、图解camera-module和camera-device-t关系"><a href="#2-1-3、图解camera-module和camera-device-t关系" class="headerlink" title="2.1.3、图解camera_module和camera_device_t关系"></a>2.1.3、图解camera_module和camera_device_t关系</h5><p>camer module在系统中转指camera模块，camera_device_t 转指某一个camera 设备。在流程上，native framwork 先加载在hal层定义的camer_module对象，然后通过camera_module的methods open方法填充camera_device_t 结构体，并最终获取到camera ops这一整个camera最重要的操作集合。下图中我们可以看到struct hw_module_t在camera_module最上面 而camera_device_t最开始保存的是struct hw_device_t. 由此我们平时在看代码时，要注意一些指针转换。</p>
<p>![Alt text](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-14-camera_module">https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-14-camera_module</a> camera_device_t.png)</p>
<h4 id="（三）、Android-Camera-Open过程"><a href="#（三）、Android-Camera-Open过程" class="headerlink" title="（三）、Android Camera Open过程"></a>（三）、Android Camera Open过程</h4><h5 id="3-1、Camera2-HAL层Open-过程分析"><a href="#3-1、Camera2-HAL层Open-过程分析" class="headerlink" title="3.1、Camera2 HAL层Open()过程分析"></a>3.1、Camera2 HAL层Open()过程分析</h5><p>高通的Camera，它在后台会有一个守护进程daemon，daemon是介于应用和驱动之间翻译ioctl的中间层(委托处理)。本节将以Camera中的open流程为例，来分析Camera HAL的工作过程，在应用对硬件发出open请求后，会通过Camera HAL来发起open请求，而Camera HAL的open入口在QCamera2Hal.cpp进行了定义，即前面分析的Camera HAL层的open入口其实就是camera_device_open方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera2Factory::camera_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">hw_device_t</span> **hw_device)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了cameraDeviceOpen方法，而其中的hw_device就是最后要返回给应用层的CameraDeviceImpl在Camera HAL层的对象，继续分析cameraDeviceOpen方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera2Factory::cameraDeviceOpen</span><span class="params">(<span class="keyword">int</span> camera_id, struct <span class="keyword">hw_device_t</span> **hw_device)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Camera2采用的Camera HAL版本为HAL3.0</span></span><br><span class="line">    <span class="keyword">if</span> ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123;</span><br><span class="line">        <span class="comment">//初始化QCamera3HardwareInterface对象，这里构造函数里将会进行configure_streams以及</span></span><br><span class="line">        <span class="comment">//process_capture_result等的绑定</span></span><br><span class="line">        QCamera3HardwareInterface *hw = <span class="keyword">new</span> QCamera3HardwareInterface(</span><br><span class="line">            mHalDescriptors[camera_id].cameraId, mCallbacks);</span><br><span class="line">        <span class="comment">//通过QCamera3HardwareInterface来打开Camera</span></span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        <span class="comment">//HAL API为2.0</span></span><br><span class="line">        QCamera2HardwareInterface *hw = <span class="keyword">new</span> QCamera2HardwareInterface((<span class="keyword">uint32_t</span>)camera_id);</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法有两个关键点：一个是QCamera3HardwareInterface对象的创建，它是用户空间与内核空间进行交互的接口；另一个是调用它的openCamera方法来打开Camera，下面将分别进行分析。</p>
<h5 id="3-1-1、QCamera3HardwareInterface构造函数分析"><a href="#3-1-1、QCamera3HardwareInterface构造函数分析" class="headerlink" title="3.1.1、QCamera3HardwareInterface构造函数分析"></a>3.1.1、QCamera3HardwareInterface构造函数分析</h5><p>在它的构造函数里面有一个关键的初始化，即mCameraDevice.ops = &amp;mCameraOps，它会定义Device操作的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">camera3_device_ops_t</span> QCamera3HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    initialize:                         QCamera3HardwareInterface::initialize,</span><br><span class="line">    <span class="comment">//配置流数据的相关处理</span></span><br><span class="line">    configure_streams:                  QCamera3HardwareInterface::configure_streams,</span><br><span class="line">    register_stream_buffers:            <span class="literal">NULL</span>,</span><br><span class="line">    construct_default_request_settings: </span><br><span class="line">        QCamera3HardwareInterface::construct_default_request_settings,</span><br><span class="line">    <span class="comment">//处理结果的接口</span></span><br><span class="line">    process_capture_request:            </span><br><span class="line">        QCamera3HardwareInterface::process_capture_request,</span><br><span class="line">    get_metadata_vendor_tag_ops:        <span class="literal">NULL</span>,</span><br><span class="line">    dump:                               QCamera3HardwareInterface::dump,</span><br><span class="line">    flush:                              QCamera3HardwareInterface::flush,</span><br><span class="line">    reserved:                           &#123;<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>其中，会在configure_streams中配置好流的处理handle：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera3HardwareInterface::configure_streams</span><span class="params">(<span class="keyword">const</span> struct camera3_device *device,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">camera3_stream_configuration_t</span> *stream_list)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获得QCamera3HardwareInterface对象</span></span><br><span class="line">    QCamera3HardwareInterface *hw =<span class="keyword">reinterpret_cast</span>&lt;QCamera3HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用它的configureStreams进行配置</span></span><br><span class="line">    <span class="keyword">int</span> rc = hw-&gt;configureStreams(stream_list);</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追踪configureStream方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera3HardwareInterface::configureStreams</span><span class="params">(<span class="keyword">camera3_stream_configuration_t</span> *streamList)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Camera版本</span></span><br><span class="line">    al_version = CAM_HAL_V3;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//开始配置stream</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化相关Channel为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (mMetadataChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mMetadataChannel;</span><br><span class="line">        mMetadataChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSupportChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mSupportChannel;</span><br><span class="line">        mSupportChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAnalysisChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mAnalysisChannel;</span><br><span class="line">        mAnalysisChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Metadata Channel，并对其进行初始化</span></span><br><span class="line">    mMetadataChannel = <span class="keyword">new</span> QCamera3MetadataChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-&gt;padding_info, </span><br><span class="line">        CAM_QCOM_FEATURE_NONE, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    rc = mMetadataChannel-&gt;initialize(IS_TYPE_NONE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果h/w support可用，则创建分析stream的Channel</span></span><br><span class="line">    <span class="keyword">if</span> (gCamCapability[mCameraId]-&gt;hw_analysis_supported) &#123;</span><br><span class="line">        mAnalysisChannel = <span class="keyword">new</span> QCamera3SupportChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                mCameraHandle-&gt;ops,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">                CAM_QCOM_FEATURE_PP_SUPERSET_HAL3,CAM_STREAM_TYPE_ANALYSIS,</span><br><span class="line">                &amp;gCamCapability[mCameraId]-&gt;analysis_recommended_res,<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isRawStreamRequested = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//清空stream配置信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mStreamConfigInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cam_stream_size_info_t</span>));</span><br><span class="line">    <span class="comment">//为requested stream分配相关的channel对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; streamList-&gt;num_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">camera3_stream_t</span> *newStream = streamList-&gt;streams[i];</span><br><span class="line">        <span class="keyword">uint32_t</span> stream_usage = newStream-&gt;usage;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].width = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;width;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].height = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;height;</span><br><span class="line">        <span class="keyword">if</span> ((newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL||newStream-&gt;usage &amp; </span><br><span class="line">                GRALLOC_USAGE_HW_CAMERA_ZSL) &amp;&amp;newStream-&gt;format == </span><br><span class="line">                HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &amp;&amp; jpegStream)&#123;</span><br><span class="line">            mStreamConfigInfo.type[mStreamConfigInfo.num_streams] = CAM_STREAM_TYPE_SNAPSHOT;</span><br><span class="line">            mStreamConfigInfo.postprocess_mask[mStreamConfigInfo.num_streams] = </span><br><span class="line">                CAM_QCOM_FEATURE_NONE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="comment">//为非zsl streams查找他们的format</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;priv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//为新的stream构造Channel</span></span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;stream_type) &#123;<span class="comment">//分类型构造</span></span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_INPUT:</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_READ;</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_WRITE;<span class="comment">//WR for inplace algo&#x27;s</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_BIDIRECTIONAL:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_OUTPUT:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据前面的得到的stream的参数类型以及format分别对各类型的channel进行构造</span></span><br><span class="line">            <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_OUTPUT ||</span><br><span class="line">                    newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL) &#123;</span><br><span class="line">                QCamera3Channel *channel = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:</span><br><span class="line">                    <span class="comment">/* use higher number of buffers for HFR mode */</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建Regular Channel</span></span><br><span class="line">                    channel = <span class="keyword">new</span> QCamera3RegularChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-</span><br><span class="line">                        &gt;padding_info,<span class="keyword">this</span>,newStream,(<span class="keyword">cam_stream_type_t</span>)mStreamConfigInfo.type[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mStreamConfigInfo.postprocess_mask[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mMetadataChannel,numBuffers);</span><br><span class="line">                    ...</span><br><span class="line">                    newStream-&gt;max_buffers = channel-&gt;getNumBuffers();</span><br><span class="line">                    newStream-&gt;priv = channel;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_YCbCr_420_888:</span><br><span class="line">                    <span class="comment">//创建YWV Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW_OPAQUE:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW16:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW10:</span><br><span class="line">                    <span class="comment">//创建Raw Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_BLOB:</span><br><span class="line">                    <span class="comment">//创建QCamera3PicChannel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">                newStream-&gt;max_buffers = MAX_INFLIGHT_REPROCESS_REQUESTS;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;<span class="keyword">stream_info_t</span>*&gt;::iterator it=mStreamInfo.begin();it != mStreamInfo.end(); </span><br><span class="line">                    it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it)-&gt;stream == newStream) &#123;</span><br><span class="line">                    (*it)-&gt;channel = (QCamera3Channel*) newStream-&gt;priv;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;stream_type != CAMERA3_STREAM_INPUT)</span><br><span class="line">            mStreamConfigInfo.num_streams++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isZsl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPictureChannel) &#123;</span><br><span class="line">           mPictureChannel-&gt;overrideYuvSize(zslStream-&gt;width, zslStream-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPictureChannel &amp;&amp; m_bIs4KVideo) &#123;</span><br><span class="line">        mPictureChannel-&gt;overrideYuvSize(videoWidth, videoHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RAW DUMP channel</span></span><br><span class="line">    <span class="keyword">if</span> (mEnableRawDump &amp;&amp; isRawStreamRequested == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">cam_dimension_t</span> rawDumpSize;</span><br><span class="line">        rawDumpSize = getMaxRawSize(mCameraId);</span><br><span class="line">        mRawDumpChannel = <span class="keyword">new</span> QCamera3RawDumpChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">            mCameraHandle-&gt;ops,rawDumpSize,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">            <span class="keyword">this</span>, CAM_QCOM_FEATURE_NONE);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行相关Channel的配置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Initialize mPendingRequestInfo and mPendnigBuffersMap */</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">        clearInputBuffer(i-&gt;input_buffer);</span><br><span class="line">        i = mPendingRequestsList.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingFrameDropList.clear();</span><br><span class="line">    <span class="comment">// Initialize/Reset the pending buffers list</span></span><br><span class="line">    mPendingBuffersMap.num_buffers = <span class="number">0</span>;</span><br><span class="line">    mPendingBuffersMap.mPendingBufferList.clear();</span><br><span class="line">    mPendingReprocessResultList.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法内容比较多，只抽取其中核心的代码进行说明，它首先会根据HAL的版本来对stream进行相应的配置初始化，然后再根据stream类型对stream_list的stream创建相应的Channel，主要有QCamera3MetadataChannel，QCamera3SupportChannel等，然后再进行相应的配置，其中QCamera3MetadataChannel在后面的处理capture request的时候会用到，这里就不做分析，而Camerametadata则是Java层和CameraService之间传递的元数据，见android6.0源码分析之Camera API2.0简介中的Camera2架构图，至此，QCamera3HardwareInterface构造结束，与本文相关的就是配置了mCameraDevice.ops。</p>
<h5 id="3-1-2、openCamera-分析"><a href="#3-1-2、openCamera-分析" class="headerlink" title="3.1.2、openCamera()分析"></a>3.1.2、openCamera()分析</h5><p>本节主要分析Module是如何打开Camera的，openCamera的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera3HardwareInterface::openCamera</span><span class="params">(struct <span class="keyword">hw_device_t</span> **hw_device)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOpened) &#123;<span class="comment">//如果Camera已经被打开，则此次打开的设备为NULL，并且打开结果为PERMISSION_DENIED</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用openCamera方法来打开</span></span><br><span class="line">    rc = openCamera();</span><br><span class="line">    <span class="comment">//打开结果处理</span></span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取打开成功的hw_device_t对象</span></span><br><span class="line">        *hw_device = &amp;mCameraDevice.common;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了openCamera()方法来打开Camera:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QCamera3HardwareInterface::openCamera</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开camera，获取mCameraHandle</span></span><br><span class="line">    mCameraHandle = camera_open((<span class="keyword">uint8_t</span>)mCameraId);</span><br><span class="line">    ...</span><br><span class="line">    mCameraOpened = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//注册mm-camera-interface里的事件处理,其中camEctHandle为事件处理Handle</span></span><br><span class="line">    rc = mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,camEvtHandle</span><br><span class="line">            ,(<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用camera_open方法来打开Camera，并且向CameraHandle注册了Camera 时间处理的Handle–camEvtHandle，首先分析camera_open方法，这里就将进入高通的Camera的实现了，而Mm_camera_interface.c是高通提供的相关操作的接口，接下来分析高通Camera的camera_open方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="function"><span class="keyword">mm_camera_vtbl_t</span> * <span class="title">camera_open</span><span class="params">(<span class="keyword">uint8_t</span> camera_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span>* cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* opened already 如果已经打开*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[camera_idx]) &#123;</span><br><span class="line">        <span class="comment">/* Add reference */</span></span><br><span class="line">        g_cam_ctrl.cam_obj[camera_idx]-&gt;ref_count++;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        <span class="keyword">return</span> &amp;g_cam_ctrl.cam_obj[camera_idx]-&gt;vtbl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cam_obj = (<span class="keyword">mm_camera_obj_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* initialize camera obj */</span></span><br><span class="line">    <span class="built_in">memset</span>(cam_obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    cam_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ref_count++;</span><br><span class="line">    cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(camera_idx);</span><br><span class="line">    cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; <span class="comment">/* set handler */</span></span><br><span class="line">    <span class="comment">//mm_camera_ops里绑定了相关的操作接口</span></span><br><span class="line">    cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops;</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">    <span class="comment">//调用mm_camera_open方法来打开camera</span></span><br><span class="line">    rc = mm_camera_open(cam_obj);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//结果处理，并返回</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，这里将会初始化一个mm_camera_obj_t对象，其中，ds_fd为socket fd，而mm_camera_ops则绑定了相关的接口，最后调用mm_camera_open来打开Camera，首先来看看mm_camera_ops绑定了哪些方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mm_camera_ops_t</span> mm_camera_ops = &#123;</span><br><span class="line">    .query_capability = mm_camera_intf_query_capability,</span><br><span class="line">    <span class="comment">//注册事件通知的方法</span></span><br><span class="line">    .register_event_notify = mm_camera_intf_register_event_notify,</span><br><span class="line">    .close_camera = mm_camera_intf_close,</span><br><span class="line">    .set_parms = mm_camera_intf_set_parms,</span><br><span class="line">    .get_parms = mm_camera_intf_get_parms,</span><br><span class="line">    .do_auto_focus = mm_camera_intf_do_auto_focus,</span><br><span class="line">    .cancel_auto_focus = mm_camera_intf_cancel_auto_focus,</span><br><span class="line">    .prepare_snapshot = mm_camera_intf_prepare_snapshot,</span><br><span class="line">    .start_zsl_snapshot = mm_camera_intf_start_zsl_snapshot,</span><br><span class="line">    .stop_zsl_snapshot = mm_camera_intf_stop_zsl_snapshot,</span><br><span class="line">    .map_buf = mm_camera_intf_map_buf,</span><br><span class="line">    .unmap_buf = mm_camera_intf_unmap_buf,</span><br><span class="line">    .add_channel = mm_camera_intf_add_channel,</span><br><span class="line">    .delete_channel = mm_camera_intf_del_channel,</span><br><span class="line">    .get_bundle_info = mm_camera_intf_get_bundle_info,</span><br><span class="line">    .add_stream = mm_camera_intf_add_stream,</span><br><span class="line">    .link_stream = mm_camera_intf_link_stream,</span><br><span class="line">    .delete_stream = mm_camera_intf_del_stream,</span><br><span class="line">    <span class="comment">//配置stream的方法</span></span><br><span class="line">    .config_stream = mm_camera_intf_config_stream,</span><br><span class="line">    .qbuf = mm_camera_intf_qbuf,</span><br><span class="line">    .get_queued_buf_count = mm_camera_intf_get_queued_buf_count,</span><br><span class="line">    .map_stream_buf = mm_camera_intf_map_stream_buf,</span><br><span class="line">    .unmap_stream_buf = mm_camera_intf_unmap_stream_buf,</span><br><span class="line">    .set_stream_parms = mm_camera_intf_set_stream_parms,</span><br><span class="line">    .get_stream_parms = mm_camera_intf_get_stream_parms,</span><br><span class="line">    .start_channel = mm_camera_intf_start_channel,</span><br><span class="line">    .stop_channel = mm_camera_intf_stop_channel,</span><br><span class="line">    .request_super_buf = mm_camera_intf_request_super_buf,</span><br><span class="line">    .cancel_super_buf_request = mm_camera_intf_cancel_super_buf_request,</span><br><span class="line">    .flush_super_buf_queue = mm_camera_intf_flush_super_buf_queue,</span><br><span class="line">    .configure_notify_mode = mm_camera_intf_configure_notify_mode,</span><br><span class="line">    <span class="comment">//处理capture的方法</span></span><br><span class="line">    .process_advanced_capture = mm_camera_intf_process_advanced_capture</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着分析mm_camera_open方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">mm_camera_open</span><span class="params">(<span class="keyword">mm_camera_obj_t</span> *my_obj)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        <span class="comment">//根据设备名字，打开相应的设备驱动fd</span></span><br><span class="line">        my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) || (errno != EIO) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开domain socket</span></span><br><span class="line">    n_try = MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;msg_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;cb_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;evt_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;my_obj-&gt;evt_cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启线程，它的线程体在mm_camera_dispatch_app_event方法中</span></span><br><span class="line">    mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread,</span><br><span class="line">                                mm_camera_dispatch_app_event,</span><br><span class="line">                                (<span class="keyword">void</span> *)my_obj);</span><br><span class="line">    mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread,</span><br><span class="line">                                 MM_CAMERA_POLL_TYPE_EVT);</span><br><span class="line">    mm_camera_evt_sub(my_obj, TRUE);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，它会打开Camera的设备文件，然后开启dispatch_app_event线程，线程方法体mm_camera_dispatch_app_event方法代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm_camera_dispatch_app_event</span><span class="params">(<span class="keyword">mm_camera_cmdcb_t</span> *cmd_cb,<span class="keyword">void</span>* user_data)</span></span>&#123;</span><br><span class="line">    mm_camera_cmd_thread_name(<span class="string">&quot;mm_cam_event&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mm_camera_event_t</span> *event = &amp;cmd_cb-&gt;u.evt;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span> * my_obj = (<span class="keyword">mm_camera_obj_t</span> *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != my_obj) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MM_CAMERA_EVT_ENTRY_MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(my_obj-&gt;evt.evt[i].evt_cb) &#123;</span><br><span class="line">                <span class="comment">//调用camEvtHandle方法</span></span><br><span class="line">                my_obj-&gt;evt.evt[i].evt_cb(</span><br><span class="line">                    my_obj-&gt;my_hdl,</span><br><span class="line">                    event,</span><br><span class="line">                    my_obj-&gt;evt.evt[i].user_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后会调用mm-camera-interface中注册好的事件处理evt_cb，它就是在前面注册好的camEvtHandle：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QCamera3HardwareInterface::camEvtHandle</span><span class="params">(<span class="keyword">uint32_t</span> <span class="comment">/*camera_handle*/</span>,<span class="keyword">mm_camera_event_t</span> *evt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *user_data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取QCamera3HardwareInterface接口指针</span></span><br><span class="line">    QCamera3HardwareInterface *obj = (QCamera3HardwareInterface *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; evt) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(evt-&gt;server_event_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_DIED:</span><br><span class="line">                <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">                notify_msg.type = CAMERA3_MSG_ERROR;</span><br><span class="line">                notify_msg.message.error.error_code = CAMERA3_MSG_ERROR_DEVICE;</span><br><span class="line">                notify_msg.message.error.error_stream = <span class="literal">NULL</span>;</span><br><span class="line">                notify_msg.message.error.frame_number = <span class="number">0</span>;</span><br><span class="line">                obj-&gt;mCallbackOps-&gt;notify(obj-&gt;mCallbackOps, &amp;notify_msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_PULL_REQ:</span><br><span class="line">                pthread_mutex_lock(&amp;obj-&gt;mMutex);</span><br><span class="line">                obj-&gt;mWokenUpByDaemon = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//开启process_capture_request</span></span><br><span class="line">                obj-&gt;unblockRequestIfNecessary();</span><br><span class="line">                pthread_mutex_unlock(&amp;obj-&gt;mMutex);</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，它会调用QCamera3HardwareInterface的unblockRequestIfNecessary来发起结果处理请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QCamera3HardwareInterface::unblockRequestIfNecessary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Unblock process_capture_request</span></span><br><span class="line">   <span class="comment">//开启process_capture_request</span></span><br><span class="line">   pthread_cond_signal(&amp;mRequestCond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化QCamera3HardwareInterface对象的时候，就绑定了处理Metadata的回调captureResultCb方法：它主要是对数据源进行相应的处理，而具体的capture请求的结果处理还是由process_capture_request来进行处理的，而这里会调用方法unblockRequestIfNecessary来触发process_capture_request方法执行，而在Camera框架中，发起请求时会启动一个RequestThread线程，在它的threadLoop方法中，会不停的调用process_capture_request方法来进行请求的处理，而它最后会回调Camera3Device中的processCaptureResult方法来进行结果处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::processCaptureResult</span><span class="params">(<span class="keyword">const</span> camera3_capture_result *result)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mUsePartialResult &amp;&amp; result-&gt;result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">camera_metadata_ro_entry_t</span> partialResultEntry;</span><br><span class="line">                res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT, &amp;partialResultEntry);</span><br><span class="line">                <span class="keyword">if</span> (res != NAME_NOT_FOUND &amp;&amp;partialResultEntry.count &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        partialResultEntry.data.u8[<span class="number">0</span>] ==ANDROID_QUIRKS_PARTIAL_RESULT_PARTIAL) &#123;</span><br><span class="line">                    isPartialResult = <span class="literal">true</span>;</span><br><span class="line">                    request.partialResult.collectedResult.append(</span><br><span class="line">                        result-&gt;result);</span><br><span class="line">                    request.partialResult.collectedResult.erase(</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                <span class="comment">// Fire off a 3A-only result if possible</span></span><br><span class="line">                <span class="keyword">if</span> (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    <span class="comment">//处理3A结果</span></span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//查找camera元数据入口</span></span><br><span class="line">        <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">        res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                ANDROID_SENSOR_TIMESTAMP, &amp;entry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">            request.pendingOutputBuffers.appendArray(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            重要的分析<span class="comment">//返回处理的outputbuffer</span></span><br><span class="line">            returnOutputBuffers(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers, shutterTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result-&gt;result != <span class="literal">NULL</span> &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                <span class="comment">//发送Capture结构，即调用通知回调</span></span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras,</span><br><span class="line">                    collectedPartialResult, frameNumber, hasInputBufferInRequest,</span><br><span class="line">                    request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; <span class="comment">// scope for mInFlightLock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;input_buffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasInputBufferInRequest) &#123;</span><br><span class="line">            Camera3Stream *stream =</span><br><span class="line">                Camera3Stream::cast(result-&gt;input_buffer-&gt;stream);</span><br><span class="line">            重要的分析<span class="comment">//返回处理的inputbuffer</span></span><br><span class="line">            res = stream-&gt;returnInputBuffer(*(result-&gt;input_buffer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析returnOutputBuffers方法，inputbuffer的runturnInputBuffer方法流程类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera3Device::returnOutputBuffers</span><span class="params">(<span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span> *outputBuffers, <span class="keyword">size_t</span> </span></span></span><br><span class="line"><span class="function"><span class="params">        numBuffers, <span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numBuffers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Camera3Stream *stream = Camera3Stream::cast(outputBuffers[i].stream);</span><br><span class="line">        <span class="keyword">status_t</span> res = stream-&gt;returnBuffer(outputBuffers[i], timestamp);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法里调用了returnBuffer方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Stream.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Stream::returnBuffer</span><span class="params">(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> res = returnBufferLocked(buffer, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        fireBufferListenersLocked(buffer, <span class="comment">/*acquired*/</span><span class="literal">false</span>, <span class="comment">/*output*/</span><span class="literal">true</span>);</span><br><span class="line">        mOutputBufferReturnedSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再继续看returnBufferLocked,它调用了returnAnyBufferLocked方法，而returnAnyBufferLocked方法又调用了returnBufferCheckedLocked方法，现在分析returnBufferCheckedLocked：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3OutputStream.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Camera3OutputStream::returnBufferCheckedLocked</span><span class="params">(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">nsecs_t</span> timestamp,<span class="keyword">bool</span> output,<span class="comment">/*out*/</span>sp&lt;Fence&gt; *releaseFenceOut)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Fence management - always honor release fence from HAL</span></span><br><span class="line">    sp&lt;Fence&gt; releaseFence = <span class="keyword">new</span> Fence(buffer.release_fence);</span><br><span class="line">    <span class="keyword">int</span> anwReleaseFence = releaseFence-&gt;dup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer.status == CAMERA3_BUFFER_STATUS_ERROR) &#123;</span><br><span class="line">        <span class="comment">// Cancel buffer</span></span><br><span class="line">        res = currentConsumer-&gt;cancelBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        res = currentConsumer-&gt;queueBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，如果Buffer没有出现状态错误，它会调用currentConsumer的queueBuffer方法，而具体的Consumer则是在应用层初始化Camera时进行绑定的，典型的Consumer有SurfaceTexture，ImageReader等，而在Native层中，它会调用BufferQueueProducer的queueBuffer方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\gui\BufferQueueProducer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="keyword">int</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Frame可用的监听器</span></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    <span class="keyword">int</span> callbackTicket = <span class="number">0</span>;</span><br><span class="line">    BufferItem item;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">graphicBuffer</span><span class="params">(mSlots[slot].mGraphicBuffer)</span></span>;</span><br><span class="line">        <span class="function">Rect <span class="title">bufferRect</span><span class="params">(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight())</span></span>;</span><br><span class="line">        Rect croppedRect;</span><br><span class="line">        crop.intersect(bufferRect, &amp;croppedRect);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;</span><br><span class="line">            mCore-&gt;mQueue.push_back(item);</span><br><span class="line">            frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，不为空，对Buffer进行处理，并获取FrameAvailableListener监听</span></span><br><span class="line">            BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin());</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;mIsDroppable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCore-&gt;stillTracking(front)) &#123;</span><br><span class="line">                    mSlots[front-&gt;mSlot].mBufferState = BufferSlot::FREE;</span><br><span class="line">                    mCore-&gt;mFreeBuffers.push_front(front-&gt;mSlot);</span><br><span class="line">                &#125;</span><br><span class="line">                *front = item;</span><br><span class="line">                frameReplacedListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCore-&gt;mQueue.push_back(item);</span><br><span class="line">                frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;</span><br><span class="line">        mCore-&gt;mDequeueCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        output-&gt;inflate(mCore-&gt;mDefaultWidth, mCore-&gt;mDefaultHeight,mCore-&gt;mTransformHint,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(mCore-&gt;mQueue.size()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take a ticket for the callback functions</span></span><br><span class="line">        callbackTicket = mNextCallbackTicket++;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;validateConsistencyLocked();</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//回调SurfaceTexture中定义好的监听IConsumerListener的onFrameAvailable方法来对数据进行处理</span></span><br><span class="line">            frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++mCurrentCallbackTicket;</span><br><span class="line">        mCallbackCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，它最后会调用Consumer的回调FrameAvailableListener的onFrameAvailable方法，到这里，就比较清晰为什么我们在写Camera应用，为其初始化Surface时，我们需要重写FrameAvailableListener了，因为在此方法里面，会进行结果的处理，至此，Camera HAL的Open流程就分析结束了。下面给出流程的时序图： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-15-open_camera.png" alt="Alt text"></p>
<h4 id="（四）、Camera-API2-0-初始化流程分析"><a href="#（四）、Camera-API2-0-初始化流程分析" class="headerlink" title="（四）、Camera API2.0 初始化流程分析"></a>（四）、Camera API2.0 初始化流程分析</h4><h5 id="4-1、Camera2-应用层（Java层）Open-过程分析"><a href="#4-1、Camera2-应用层（Java层）Open-过程分析" class="headerlink" title="4.1、Camera2 应用层（Java层）Open()过程分析"></a>4.1、Camera2 应用层（Java层）Open()过程分析</h5><p>Camera2的初始化流程与Camera1.0有所区别，本文将就Camera2的内置应用来分析Camera2.0的初始化过程。Camera2.0首先启动的是CameraActivity，而它继承自QuickActivity，在代码中你会发现没有重写OnCreate等生命周期方法，因为此处采用的是模板方法的设计模式，在QuickActivity中的onCreate方法调用的是onCreateTasks等方法，所以要看onCreate方法就只须看onCreateTasks方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateTasks</span><span class="params">(Bundle state)</span> </span>&#123;</span><br><span class="line">    Profile profile = mProfiler.create(<span class="string">&quot;CameraActivity.onCreateTasks&quot;</span>)</span><br><span class="line">                            .start();</span><br><span class="line">    ...</span><br><span class="line">    mOnCreateTime = System.currentTimeMillis();</span><br><span class="line">    mAppContext = getApplicationContext();</span><br><span class="line">    mMainHandler = <span class="keyword">new</span> MainHandler(<span class="keyword">this</span>, getMainLooper());</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化OneCameraOpener对象</span></span><br><span class="line">        ①mOneCameraOpener = OneCameraModule.provideOneCameraOpener(</span><br><span class="line">                mFeatureConfig, mAppContext,mActiveCameraDeviceTracker,</span><br><span class="line">                ResolutionUtil.getDisplayMetrics(<span class="keyword">this</span>));</span><br><span class="line">        mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;...&#125;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//建立模块信息</span></span><br><span class="line">    ②ModulesInfo.setupModules(mAppContext, mModuleManager, mFeatureConfig);</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//进行初始化</span></span><br><span class="line">    ③mCurrentModule.init(<span class="keyword">this</span>, isSecureCamera(), isCaptureIntent());</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，重要的有以上三点，先看第一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OneCameraOpener <span class="title">provideOneCameraOpener</span><span class="params">(OneCameraFeatureConfig     </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker,DisplayMetrics displayMetrics)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> OneCameraException </span>&#123;</span><br><span class="line">    <span class="comment">//创建OneCameraOpener对象</span></span><br><span class="line">    Optional&lt;OneCameraOpener&gt; manager = Camera2OneCameraOpenerImpl.create(</span><br><span class="line">              featureConfig, context, activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">if</span> (!manager.isPresent()) &#123;</span><br><span class="line">        manager = LegacyOneCameraOpenerImpl.create();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> manager.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用Camera2OneCameraOpenerImpl的create方法来获得一个OneCameraOpener对象，以供CameraActivity之后的操作使用，继续看create方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;OneCameraOpener&gt; <span class="title">create</span><span class="params">(OneCameraFeatureConfig </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker, DisplayMetrics displayMetrics)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    CameraManager cameraManager;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cameraManager = AndroidServices.instance().provideCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;...&#125;</span><br><span class="line">    <span class="comment">//新建一个Camera2OneCameraOpenerImpl对象</span></span><br><span class="line">    OneCameraOpener oneCameraOpener = <span class="keyword">new</span> Camera2OneCameraOpenerImpl(</span><br><span class="line">                featureConfig, context, cameraManager,</span><br><span class="line">                activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">return</span> Optional.of(oneCameraOpener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，它首先获取一个cameraManger对象，然后根据这个cameraManager对象来新创建了一个Camera2OneCameraOpenerImpl对象，所以第一步主要是为了获取一个OneCameraOpener对象，它的实现为Camera2OneCameraOpenerImpl类。<br>继续看第二步，ModulesInfo.setupModules:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupModules</span><span class="params">(Context context, ModuleManager moduleManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            OneCameraFeatureConfig config)</span> </span>&#123;</span><br><span class="line">        Resources res = context.getResources();</span><br><span class="line">        <span class="keyword">int</span> photoModuleId = context.getResources().getInteger(</span><br><span class="line">            R.integer.camera_mode_photo);</span><br><span class="line">        <span class="comment">//注册Photo模块</span></span><br><span class="line">        registerPhotoModule(moduleManager, photoModuleId, </span><br><span class="line">            SettingsScopeNamespaces.PHOTO,config.isUsingCaptureModule());</span><br><span class="line">        <span class="comment">//计算你还Photo模块设置为默认的模块</span></span><br><span class="line">        moduleManager.setDefaultModuleIndex(photoModuleId);</span><br><span class="line">        <span class="comment">//注册Videa模块</span></span><br><span class="line">        registerVideoModule(moduleManager, res.getInteger(</span><br><span class="line">            R.integer.camera_mode_video),SettingsScopeNamespaces.VIDEO);</span><br><span class="line">        <span class="keyword">if</span> (PhotoSphereHelper.hasLightCycleCapture(context)) &#123;<span class="comment">//开启闪光</span></span><br><span class="line">            <span class="comment">//注册广角镜头</span></span><br><span class="line">            registerWideAngleModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_panorama),SettingsScopeNamespaces</span><br><span class="line">                .PANORAMA);</span><br><span class="line">            <span class="comment">//注册光球模块</span></span><br><span class="line">            registerPhotoSphereModule(moduleManager,res.getInteger(</span><br><span class="line">                R.integer.camera_mode_photosphere),</span><br><span class="line">                SettingsScopeNamespaces.PANORAMA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若需重新聚焦</span></span><br><span class="line">        <span class="keyword">if</span> (RefocusHelper.hasRefocusCapture(context)) &#123;</span><br><span class="line">            <span class="comment">//注册重聚焦模块</span></span><br><span class="line">            registerRefocusModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_refocus),</span><br><span class="line">                SettingsScopeNamespaces.REFOCUS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有色分离模块</span></span><br><span class="line">        <span class="keyword">if</span> (GcamHelper.hasGcamAsSeparateModule(config)) &#123;</span><br><span class="line">            <span class="comment">//注册色分离模块</span></span><br><span class="line">            registerGcamModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_gcam),SettingsScopeNamespaces.PHOTO,</span><br><span class="line">                config.getHdrPlusSupportLevel(OneCamera.Facing.BACK));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imageCaptureIntentModuleId = res.getInteger(</span><br><span class="line">            R.integer.camera_mode_capture_intent);</span><br><span class="line">        registerCaptureIntentModule(moduleManager, </span><br><span class="line">            imageCaptureIntentModuleId,SettingsScopeNamespaces.PHOTO,</span><br><span class="line">            config.isUsingCaptureModule());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码根据配置信息，进行一系列模块的注册，其中PhotoModule和VideoModule被注册，而其他的module则是根据配置来进行的，因为打开Camera应用，既可以拍照片也可以拍视频，此处，只分析PhoneModule的注册：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerPhotoModule</span><span class="params">(ModuleManager moduleManager, <span class="keyword">final</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> moduleId, <span class="keyword">final</span> String <span class="keyword">namespace</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> boolean enableCaptureModule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向ModuleManager注册PhotoModule模块</span></span><br><span class="line">        moduleManager.registerModule(<span class="keyword">new</span> ModuleManager.ModuleAgent() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> getModuleId() &#123;</span><br><span class="line">                <span class="keyword">return</span> moduleId;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> boolean requestAppForCamera() &#123;</span><br><span class="line">                <span class="keyword">return</span> !enableCaptureModule;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> String getScopeNamespace() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">namespace</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> ModuleController createModule(AppController app, Intent </span><br><span class="line">                    intent) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">&quot;EnableCaptureModule = &quot;</span> + enableCaptureModule);</span><br><span class="line">                <span class="comment">//创建ModuleController</span></span><br><span class="line">                <span class="keyword">return</span> enableCaptureModule ? <span class="keyword">new</span> CaptureModule(app) </span><br><span class="line">                        : <span class="keyword">new</span> PhotoModule(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，它最终是由ModuleManager来新建一个CaptureModule实例，而CaptureModule其实实现了ModuleController ，即创建了一个CaptureModule模式下的ModuleController对象，而真正的CaptureModule的具体实现为ModuleManagerImpl。<br>至此，前两步已经获得了OneCameraOpener以及新建了ModuleController，并进行了注册，接下来分析第三步，mCurrentModule.init(this, isSecureCamera(), isCaptureIntent()):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(CameraActivity activity, <span class="keyword">boolean</span> isSecureCamera, <span class="keyword">boolean</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            isCaptureIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;CaptureModule.mCameraHandler&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        mCameraHandler = <span class="keyword">new</span> Handler(thread.getLooper());</span><br><span class="line">        <span class="comment">//获取第一步中创建的OneCameraOpener对象</span></span><br><span class="line">        mOneCameraOpener = mAppController.getCameraOpener();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取前面创建的OneCameraManager对象</span></span><br><span class="line">            mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Unable to provide a OneCameraManager. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">       `...</span><br><span class="line">        <span class="comment">//新建CaptureModule的UI</span></span><br><span class="line">        mUI = <span class="keyword">new</span> CaptureModuleUI(activity, mAppController.</span><br><span class="line">                getModuleLayoutRoot(), mUIListener);</span><br><span class="line">        <span class="comment">//设置预览状态的监听</span></span><br><span class="line">        mAppController.setPreviewStatusListener(mPreviewStatusListener);</span><br><span class="line">        <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">            <span class="comment">//获取SurfaceTexture</span></span><br><span class="line">            mPreviewSurfaceTexture = mAppController.getCameraAppUI()</span><br><span class="line">                .getSurfaceTexture();</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取前面创建的OneCameraOpener对象以及OneCameraManager对象，然后再设置预览状态监听，这里主要分析预览状态的监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PreviewStatusListener mPreviewStatusListener = <span class="keyword">new</span> </span><br><span class="line">    PreviewStatusListener() &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            updatePreviewTransform(width, height, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = surface;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打开Camera</span></span><br><span class="line">            reopenCamera();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onSurfaceTextureDestroyed&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭Camera</span></span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//更新预览尺寸</span></span><br><span class="line">            updatePreviewBufferSize();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>由代码可知，当SurfaceTexture的状态变成可用的时候，会调用reopenCamera()方法来打开Camera，所以继续分析reopenCamera()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reopenCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">if</span>(!mAppController.isPaused()) &#123;</span><br><span class="line">                <span class="comment">//开启Camera并开始预览</span></span><br><span class="line">                openCameraAndStartPreview();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它采用异步任务的方法，开启一个异步线程来进行启动操作，首先关闭打开的Camera，然后如果AppController不处于暂停状态，则打开Camera并启动Preview操作，所以继续分析openCameraAndStartPreview方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCameraAndStartPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mOneCameraOpener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;no available OneCameraManager, showing error dialog&quot;</span>);</span><br><span class="line">        <span class="comment">//释放CameraOpenCloseLock锁</span></span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mAppController.getFatalErrorHandler().onGenericCameraAccessFailure();</span><br><span class="line">        guard.stop(<span class="string">&quot;No OneCameraManager&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Derive objects necessary for camera creation.</span></span><br><span class="line">    MainThread mainThread = MainThread.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找需要打开的CameraId</span></span><br><span class="line">    CameraId cameraId = mOneCameraManager.findFirstCameraFacing(</span><br><span class="line">        mCameraFacing);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开Camera</span></span><br><span class="line">    mOneCameraOpener.open(cameraId, captureSetting, mCameraHandler,</span><br><span class="line">        mainThread, imageRotationCalculator, mBurstController, </span><br><span class="line">        mSoundPlayer,<span class="keyword">new</span> OpenCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//进行失败的处理</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraOpened</span><span class="params">(<span class="meta">@Nonnull</span> <span class="keyword">final</span> OneCamera camera)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onCameraOpened: &quot;</span> + camera);</span><br><span class="line">                mCamera = camera;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mAppController.isPaused()) &#123;</span><br><span class="line">                    onFailure();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//通知UI，Camera状态变化</span></span><br><span class="line">                        mAppController.getCameraAppUI().onChangeCamera();</span><br><span class="line">                        <span class="comment">//使能拍照按钮</span></span><br><span class="line">                        mAppController.getButtonManager().enableCameraButton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//至此，Camera打开成功，开始预览                    </span></span><br><span class="line">                camera.startPreview(<span class="keyword">new</span> Surface(getPreviewSurfaceTexture()), </span><br><span class="line">                    <span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//释放锁</span></span><br><span class="line">                            mCameraOpenCloseLock.release();</span><br><span class="line">                            mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    ...</span><br><span class="line">                                    onPreviewStarted();</span><br><span class="line">                                    ...</span><br><span class="line">                                    onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                                    <span class="comment">//设置CaptureModule为Capture准备的状态监听</span></span><br><span class="line">                                    mCamera.setReadyStateChangedListener(</span><br><span class="line">                                        CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                        mUI.initializeZoom(mCamera.getMaxZoom());                                 </span><br><span class="line">                                        mCamera.setFocusStateListener(</span><br><span class="line">                                            CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; </span><br><span class="line">              &#125;, mAppController.getFatalErrorHandler());</span><br><span class="line">        guard.stop(<span class="string">&quot;mOneCameraOpener.open()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，它主要会调用Camera2OneCameraOpenerImpl的open方法来打开Camera，并定义了开启的回调函数，对开启结束后的结果进行处理，如失败则释放mCameraOpenCloseLock，并暂停mAppController，如果打开成功，通知UI成功，并开启Camera的Preview，并且定义了Preview的各种回调操作，这里主要分析Open过程，所以继续分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/Camera2OneCameraOpenerImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    mActiveCameraDeviceTracker.onCameraOpening(cameraKey)</span></span>;</span><br><span class="line">    <span class="comment">//打开Camera，此处调用框架层的CameraManager类的openCamera，进入frameworks层</span></span><br><span class="line">    mCameraManager.openCamera(cameraKey.getValue(), </span><br><span class="line">        <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstCallback = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice device)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第一次调用此回调</span></span><br><span class="line">            <span class="keyword">if</span> (isFirstCallback) &#123;</span><br><span class="line">                isFirstCallback = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    CameraCharacteristics characteristics = mCameraManager</span><br><span class="line">                        .getCameraCharacteristics(device.getId());</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建OneCamera对象</span></span><br><span class="line">                    OneCamera oneCamera = OneCameraCreator.create(device,</span><br><span class="line">                        characteristics, mFeatureConfig, captureSetting,</span><br><span class="line">                        mDisplayMetrics, mContext, mainThread,</span><br><span class="line">                        imageRotationCalculator, burstController, soundPlayer,</span><br><span class="line">                        fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (oneCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果oneCamera不为空，则回调onCameraOpened，后面将做分析</span></span><br><span class="line">                        openCallback.onCameraOpened(oneCamera);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        openCallback.onFailure();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OneCameraAccessException e) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Could not create OneCamera&quot;</span>, e);</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Camera的初始化流程中应用层的分析就差不多了，下一步将会调用CameraManager的openCamera方法来进入框架层，并进行Camera的初始化，下面将应用层的初始化时序图： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-16-camera_open_java.png" alt="Alt text"></p>
<h5 id="4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析"><a href="#4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析" class="headerlink" title="4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析"></a>4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析</h5><p>由上面的分析可知，将由应用层进入到框架层处理，将会调用CameraManager的openCamera方法，并且定义了CameraDevice的状态回调函数，具体的回调操作此处不做分析，继续跟踪openCamera()方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line">@RequiresPermission(android.Manifest.permission.CAMERA)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId,@NonNull <span class="keyword">final</span> </span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, @Nullable Handler handler)</span></span></span><br><span class="line"><span class="function">        throws CameraAccessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    openCameraDeviceUserAsync(cameraId, callback, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，此处与Camera1.0有明显不同，Camera1.0是通过一个异步的线程以及JNI来调用android_hardware_camera.java里面的native_setup方法来连接Camera，其使用的是C++的Binder来与CameraService进行通信的，而此处则不一样，它直接使用的是Java层的Binder来进行通信，先看openCameraDeviceUserAsync代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CameraDevice <span class="title">openCameraDeviceUserAsync</span><span class="params">(String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, Handler handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">    CameraCharacteristics characteristics = getCameraCharacteristics(</span><br><span class="line">        cameraId);</span><br><span class="line">    CameraDevice device = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ICameraDeviceUser cameraUser = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//初始化一个CameraDevice对象</span></span><br><span class="line">            android.hardware.camera2.impl.CameraDeviceImpl deviceImpl =</span><br><span class="line">                <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(cameraId,</span><br><span class="line">                callback, handler, characteristics);</span><br><span class="line">            BinderHolder holder = <span class="keyword">new</span> BinderHolder();</span><br><span class="line">            <span class="comment">//获取回调</span></span><br><span class="line">            ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();</span><br><span class="line">            <span class="keyword">int</span> id = Integer.parseInt(cameraId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (supportsCamera2ApiLocked(cameraId)) &#123;</span><br><span class="line">                    <span class="comment">//通过Java层的Binder获取CameraService                        </span></span><br><span class="line">                    ICameraService cameraService = CameraManagerGlobal.get()</span><br><span class="line">                        .getCameraService();</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//通过CameraService连接Camera设备</span></span><br><span class="line">                    cameraService.connectDevice(callbacks, id, mContext</span><br><span class="line">                        .getOpPackageName(), USE_CALLING_UID, holder);</span><br><span class="line">                    <span class="comment">//获取连接成功的CameraUser对象，它用来与CameraService通信</span></span><br><span class="line">                    cameraUser = ICameraDeviceUser.Stub.asInterface(</span><br><span class="line">                        holder.getBinder());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使用遗留的API</span></span><br><span class="line">                    cameraUser = CameraDeviceUserShim.connectBinderShim(</span><br><span class="line">                        callbacks, id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将其包装成DeviceImpl对象，供应用层使用</span></span><br><span class="line">            deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">            device = deviceImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.asChecked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法的目的是通过CameraService来连接并获取CameraDevice对象，该对象用来与Camera进行通信操作。代码首先通过Java层的Binder机制获取CameraService，然后调用其connectDevice方法来连接CaneraDevice，最后Camera返回的是CameraDeviceUser对象，而接着将其封装成Jav层CameraDevice对象，而之后所有与Camera的通信都通过CameraDevice的接口来进行。接下来分析一下Native层下的CameraDevice的初始化过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraService::connectDevice</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraDeviceCallbacks&gt;&amp; cameraCb,<span class="keyword">int</span> cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> String16&amp; clientPackageName,<span class="keyword">int</span> clientUid,<span class="comment">/*out*/</span>sp&lt;ICameraDeviceUser&gt;&amp; device)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    String8 id = String8::format(<span class="string">&quot;%d&quot;</span>, cameraId);</span><br><span class="line">    sp&lt;CameraDeviceClient&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    ret = connectHelper&lt;ICameraDeviceCallbacks,CameraDeviceClient&gt;(cameraCb, id,</span><br><span class="line">            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, API_2, <span class="literal">false</span>, <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*out*/</span>client);<span class="comment">//client为输出对象</span></span><br><span class="line">    ...</span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Native层的connectDevice方法就是调用了connectHelper方法，所以继续分析connectHelper：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.h]</span><br><span class="line"><span class="comment">//CameraService.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CALLBACK</span>, <span class="title">class</span> <span class="title">CLIENT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">CameraService</span>:</span>:connectHelper(<span class="keyword">const</span> sp&lt;CALLBACK&gt;&amp; cameraCb, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid,</span><br><span class="line">        apiLevel effectiveApiLevel, <span class="keyword">bool</span> legacyMode, <span class="keyword">bool</span> shimUpdateOnly,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;CLIENT&gt;&amp; device) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    <span class="function">String8 <span class="title">clientName8</span><span class="params">(clientPackageName)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> clientPid = getCallingPid();</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;CLIENT&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有必要，给FlashLight关闭设备的机会</span></span><br><span class="line">        mFlashlight-&gt;prepareDeviceOpen(cameraId);</span><br><span class="line">        <span class="comment">//获取CameraId</span></span><br><span class="line">        <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取Device的版本，此处为Device3</span></span><br><span class="line">        <span class="keyword">int</span> deviceVersion = getDeviceVersion(id, <span class="comment">/*out*/</span>&amp;facing);</span><br><span class="line">        sp&lt;BasicClient&gt; tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//获取client对象</span></span><br><span class="line">        <span class="keyword">if</span>((ret = makeClient(<span class="keyword">this</span>, cameraCb, clientPackageName, cameraId, facing, clientPid,</span><br><span class="line">                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,</span><br><span class="line">                <span class="comment">/*out*/</span>&amp;tmp)) != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get());</span><br><span class="line">        <span class="comment">//调用client的初始化函数来初始化模块</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = client-&gt;initialize(mModule)) != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;%s: Could not initialize client from HAL module.&quot;</span>, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;IBinder&gt; remoteCallback = client-&gt;getRemote();</span><br><span class="line">        <span class="keyword">if</span> (remoteCallback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            remoteCallback-&gt;linkToDeath(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// lock is destroyed, allow further connect calls</span></span><br><span class="line">    <span class="comment">//将client赋值给输出Device</span></span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraService根据Camera的相关参数来获取一个client，如makeClient方法，然后再调用client的initialize来进行初始化，首先看makeClient：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraService::makeClient</span><span class="params">(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;IInterface&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; packageName, <span class="keyword">const</span> String8&amp; cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> facing, <span class="keyword">int</span> clientPid, <span class="keyword">uid_t</span> clientUid, <span class="keyword">int</span> servicePid, <span class="keyword">bool</span> legacyMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> halVersion, <span class="keyword">int</span> deviceVersion, apiLevel effectiveApiLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">/*out*/</span>sp&lt;BasicClient&gt;* client)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串的CameraId转换成整形</span></span><br><span class="line">    <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (halVersion &lt; <span class="number">0</span> || halVersion == deviceVersion) &#123;<span class="comment">//判断Camera HAL版本是否和Device的版本相同</span></span><br><span class="line">        <span class="keyword">switch</span>(deviceVersion) &#123;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123;  <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                ALOGW(<span class="string">&quot;Camera using old HAL version: %d&quot;</span>, deviceVersion);</span><br><span class="line">                <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123; <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> Camera2Client(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                sp&lt;ICameraDeviceCallbacks&gt; tmp =</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;ICameraDeviceCallbacks*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, id,</span><br><span class="line">                        facing, clientPid, clientUid, servicePid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Should not be reachable</span></span><br><span class="line">            ALOGE(<span class="string">&quot;Unknown camera device HAL version: %d&quot;</span>, deviceVersion);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// A particular HAL version is requested by caller. Create CameraClient</span></span><br><span class="line">        <span class="comment">// based on the requested HAL version.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            <span class="comment">// Only support higher HAL version device opened as HAL1.0 device.</span></span><br><span class="line">            sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">            *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                    clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span></span><br><span class="line">            ALOGE(<span class="string">&quot;Invalid camera HAL version %x: HAL %x device can only be&quot;</span></span><br><span class="line">                    <span class="string">&quot; opened as HAL %x device&quot;</span>, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中就是创建一个Client对象，由于此处分析的是Camera API2.0，其HAL的版本是3.0+，而Device的版本则其Device的版本即为3.0+，所以会创建一个CameraDeviceClient对象，至此，makeClient已经创建了client对象，并返回了，接着看它的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::initialize</span><span class="params">(CameraModule *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    <span class="comment">//调用Camera2ClientBase的初始化函数来初始化CameraModule模块</span></span><br><span class="line">    res = Camera2ClientBase::initialize(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 threadName;</span><br><span class="line">    <span class="comment">//初始化FrameProcessor</span></span><br><span class="line">    mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice);</span><br><span class="line">    threadName = String8::format(<span class="string">&quot;CDU-%d-FrameProc&quot;</span>, mCameraId);</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.<span class="built_in">string</span>());</span><br><span class="line">    <span class="comment">//并注册监听，监听的实现就在CameraDeviceClient类中</span></span><br><span class="line">    mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,</span><br><span class="line">            FRAME_PROCESSOR_LISTENER_MAX_ID, <span class="comment">/*listener*/</span><span class="keyword">this</span>,<span class="comment">/*sendPartials*/</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会调用Camera2ClientBase的initialize方法来初始化，并且会初始化一个FrameProcessor来进行帧处理，主要是回调每一帧的ExtraResult到应用中，也就是3A相关的数据信息。而Camera1.0中各种Processor模块，即将数据打包处理后再返回到应用的模块都已经不存在，而Camera2.0中将由MediaRecorder、SurfaceView、ImageReader等来直接处理，总体来说效率更好。继续看initialize：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line"><span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(CameraModule *<span class="keyword">module</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用Device的initialie方法</span></span><br><span class="line">    res = mDevice-&gt;initialize(<span class="keyword">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    res = mDevice-&gt;setNotifyCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码就是调用了Device的initialize方法，此处的Device是在Camera2ClientBase的构造函数中创建的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line">Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;TCamCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid,</span><br><span class="line">        <span class="keyword">uid_t</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid):</span><br><span class="line">        TClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">        mSharedCameraCallbacks(remoteCallback),</span><br><span class="line">        mDeviceVersion(cameraService-&gt;getDeviceVersion(cameraId)),</span><br><span class="line">        mDeviceActive(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">&quot;Camera %d: Opened. Client: %s (PID %d, UID %d)&quot;</span>, cameraId,</span><br><span class="line">            String8(clientPackageName).<span class="built_in">string</span>(), clientPid, clientUid);</span><br><span class="line"></span><br><span class="line">    mInitialClientPid = clientPid;</span><br><span class="line">    mDevice = <span class="keyword">new</span> Camera3Device(cameraId);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDevice == <span class="number">0</span>, <span class="string">&quot;Device should never be NULL here.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前Camera API是2.0，而Device的API已经是3.0+了，继续看Camera3Device的构造方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line">Camera3Device::Camera3Device(<span class="keyword">int</span> id):</span><br><span class="line">        mId(id),</span><br><span class="line">        mIsConstrainedHighSpeedConfiguration(<span class="literal">false</span>),</span><br><span class="line">        mHal3Device(<span class="literal">NULL</span>),</span><br><span class="line">        mStatus(STATUS_UNINITIALIZED),</span><br><span class="line">        mStatusWaiters(<span class="number">0</span>),</span><br><span class="line">        mUsePartialResult(<span class="literal">false</span>),</span><br><span class="line">        mNumPartialResults(<span class="number">1</span>),</span><br><span class="line">        mTimestampOffset(<span class="number">0</span>),</span><br><span class="line">        mNextResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mListener(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    camera3_callback_ops::notify = &amp;sNotify;</span><br><span class="line">    camera3_callback_ops::process_capture_result = &amp;sProcessCaptureResult;</span><br><span class="line">    ALOGV(<span class="string">&quot;%s: Created device for camera %d&quot;</span>, __FUNCTION__, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，它将会创建一个Camera3Device对象，所以，Device的initialize就是调用了Camera3Device的initialize方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Device::initialize</span><span class="params">(CameraModule *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">camera3_device_t</span> *device;</span><br><span class="line">    <span class="comment">//打开Camera HAL层的Deivce</span></span><br><span class="line">    res = <span class="keyword">module</span>-&gt;open(deviceName.<span class="built_in">string</span>(),</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span>**&gt;(&amp;device));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交叉检查Device的版本</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;common.version &lt; CAMERA_DEVICE_API_VERSION_3_0) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">&quot;Could not open camera: &quot;</span></span><br><span class="line">                <span class="string">&quot;Camera device should be at least %x, reports %x instead&quot;</span>,</span><br><span class="line">                CAMERA_DEVICE_API_VERSION_3_0,</span><br><span class="line">                device-&gt;common.version);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用回调函数来进行初始化，即调用打开Device的initialize方法来进行初始化</span></span><br><span class="line">    res = device-&gt;ops-&gt;initialize(device, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动请求队列线程</span></span><br><span class="line">    mRequestThread = <span class="keyword">new</span> RequestThread(<span class="keyword">this</span>, mStatusTracker, device, aeLockAvailable);</span><br><span class="line">    res = mRequestThread-&gt;run(String8::format(<span class="string">&quot;C3Dev-%d-ReqQueue&quot;</span>, mId).<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">&quot;Unable to start request queue thread: %s (%d)&quot;</span>,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        mRequestThread.clear();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回初始成功</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，会依赖HAL框架打开并获得相应的Device对象，具体的流程请参考android6.0源码分析之Camera2 HAL分析，然后再回调此对象的initialize方法进行初始化，最后再启动RequestThread等线程，并返回initialize成功。至此Camera API2.0下的初始化过程就分析结束了。框架层的初始化时序图如下： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-17-camera_open_native.png" alt="Alt text"></p>
<h5 id="4-2、总结"><a href="#4-2、总结" class="headerlink" title="4.2、总结"></a>4.2、总结</h5><p>Open()过程道路艰辛，主要为了后续Camera正常工作，添砖加瓦，铺路。下面我们列举一下，主要都准备了什么。<br>1、Camera应用将一些Callback函数，注册到Camera.java中，以使在线程处理函数中可以调用到相应的回调函数。<br>2、camera connect成功后，创建了BpCamera代理对象和BnCameraClient本地对象。<br>3、在JNICameraContext实现CameraListener接口，并将接口注册到客户端camera本地对象中，并在BnCameraClient本地对象中回调这些接口。<br>4、CameraService connect过程中，根据hal硬件版本，创建对应的CameraClient对象。在后续的初始化过程中，创建6大线程。<br>最后以一个简单的工作流程图来结束博文 </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/camera.system/01-18-Camera_open_overview.png" alt="Alt text"></p>
<h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/camera/">Android Camera官方文档</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/eternity9255">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/stonedemo/category/1080451.html">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shell812/article/category/5905525">Android Camera 系统架构源码分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbw1992322/article/details/75259311">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanbixing123/article/details/52294305/">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ecb1be82e6a8">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1baad2a5281d">mm-camera层frame数据流源码分析 - 简书</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/category/6282972">@@Android Camera fw学习 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721">@@Android Camera API2分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775897/article/category/7112759">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangzhihuiguming/article/details/51382267">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/details/73709808">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/details/52076879">android camera动态库加载过程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20190101/">https://zhoujinjian.com/posts/20190101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Camera/">Camera</a><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20190109/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20181108/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.15.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Audio System（3）：Android audio system(音频系统)分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20190109/" title="Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-09</div><div class="title">Android Camera System（2）：Camera 系统 startPreview、takePicture、Recorder流程分析</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Android-Camera-System-Architecture%EF%BC%88Camera%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">（一）、Android Camera System Architecture（Camera系统框架）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1%E3%80%81Android-Camera-System%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6%EF%BC%88Qualcomm%E5%B9%B3%E5%8F%B0%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、Android Camera System总体框架（Qualcomm平台）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1%E3%80%81%E9%A6%96%E5%85%88%E7%9C%8B%E7%9C%8BAndroid-%E5%AE%98%E6%96%B9Camera%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">1.1.1、首先看看Android 官方Camera总体架构：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2%E3%80%81Qualcomm%E5%B9%B3%E5%8F%B0Camera-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">1.1.2、Qualcomm平台Camera 架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-1%E3%80%81Qualcomm%E5%B9%B3%E5%8F%B0Camera%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.1.2.1、Qualcomm平台Camera总体架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-2%E3%80%81Qualcomm%E5%B9%B3%E5%8F%B0Camera%E7%9A%84HAL%E3%80%81mm-camera"><span class="toc-number">1.5.</span> <span class="toc-text">1.1.2.2、Qualcomm平台Camera的HAL、mm-camera</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-3%E3%80%81Qualcomm%E5%B9%B3%E5%8F%B0Camera%E7%9A%84Kernel"><span class="toc-number">1.6.</span> <span class="toc-text">1.1.2.3、Qualcomm平台Camera的Kernel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2%E3%80%81Android-Camera-API-2-0-%E5%85%A8%E6%96%B0%E7%9A%84HAL-%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.</span> <span class="toc-text">1.2、Android Camera API 2.0 全新的HAL 子系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1%E3%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">1.8.</span> <span class="toc-text">1.2.1、请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2%E3%80%81HAL-%E5%92%8C%E7%9B%B8%E6%9C%BA%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.9.</span> <span class="toc-text">1.2.2、HAL 和相机子系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3%E3%80%81HAL-%E6%93%8D%E4%BD%9C%E6%91%98%E8%A6%81"><span class="toc-number">1.10.</span> <span class="toc-text">1.2.3、HAL 操作摘要</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4%E3%80%81%E5%90%AF%E5%8A%A8%E5%92%8C%E9%A2%84%E6%9C%9F%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.11.</span> <span class="toc-text">1.2.4、启动和预期操作顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3%E3%80%81Android-Graphics-%E5%AD%A6%E4%B9%A0%EF%BC%8D%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E3%80%81BufferQueue%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.12.</span> <span class="toc-text">1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4%E3%80%81Camera%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">1.4、Camera类之间的关系和作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1%E3%80%81Camera%E7%B1%BB%E5%85%B3%E7%B3%BB%E6%80%BB%E4%BD%93%E6%A6%82%E8%A7%88"><span class="toc-number">1.14.</span> <span class="toc-text">1.4.1、Camera类关系总体概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2%E3%80%81ICameraClient"><span class="toc-number">1.15.</span> <span class="toc-text">1.4.2、ICameraClient</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3%E3%80%81ICamera"><span class="toc-number">1.16.</span> <span class="toc-text">1.4.3、ICamera</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-4%E3%80%81ICameraService"><span class="toc-number">1.17.</span> <span class="toc-text">1.4.4、ICameraService</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Android-CameraService%E5%BC%80%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">（二）、Android CameraService开机初始化分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1%E3%80%81CameraService-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1、CameraService 初始化过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1%E3%80%81CameraService-onFirstRef"><span class="toc-number">2.2.</span> <span class="toc-text">2.1.1、CameraService::onFirstRef()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2%E3%80%81Camera-%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.1.2、Camera 动态库加载过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3%E3%80%81%E5%9B%BE%E8%A7%A3camera-module%E5%92%8Ccamera-device-t%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.</span> <span class="toc-text">2.1.3、图解camera_module和camera_device_t关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Android-Camera-Open%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">（三）、Android Camera Open过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1%E3%80%81Camera2-HAL%E5%B1%82Open-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、Camera2 HAL层Open()过程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1%E3%80%81QCamera3HardwareInterface%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">3.1.1、QCamera3HardwareInterface构造函数分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2%E3%80%81openCamera-%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">3.1.2、openCamera()分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Camera-API2-0-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">（四）、Camera API2.0 初始化流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E3%80%81Camera2-%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%88Java%E5%B1%82%EF%BC%89Open-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">4.1、Camera2 应用层（Java层）Open()过程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E3%80%81Camera2-%E6%A1%86%E6%9E%B6%E5%B1%82%EF%BC%88JNI-amp-Native%EF%BC%89Open-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">4.2、总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">（五）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>