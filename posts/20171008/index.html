<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android N 基础（3）：Android 7.1.2 Android 系统启动流程分析 | zhoujinjian</title><meta name="keywords" content="Android"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="源码：system&#x2F;core&#x2F;rootdir&#x2F;  init.rc init.zygote64.rc  system&#x2F;core&#x2F;init&#x2F;  init.cpp init_parser.cpp signal_handler.cpp  frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;  App_main.cpp  frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;  AndroidRu">
<meta property="og:type" content="article">
<meta property="og:title" content="Android N 基础（3）：Android 7.1.2 Android 系统启动流程分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20171008/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="源码：system&#x2F;core&#x2F;rootdir&#x2F;  init.rc init.zygote64.rc  system&#x2F;core&#x2F;init&#x2F;  init.cpp init_parser.cpp signal_handler.cpp  frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;  App_main.cpp  frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;  AndroidRu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.02.jpg">
<meta property="article:published_time" content="2017-10-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.956Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.02.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20171008/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.02.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android N 基础（3）：Android 7.1.2 Android 系统启动流程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-10-08T01:25:00.000Z" title="发表于 2017-10-08 09:25:00">2017-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.956Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p><strong>system/core/rootdir/</strong></p>
<ul>
<li>init.rc</li>
<li>init.zygote64.rc</li>
</ul>
<p><strong>system/core/init/</strong></p>
<ul>
<li>init.cpp</li>
<li>init_parser.cpp</li>
<li>signal_handler.cpp</li>
</ul>
<p><strong>frameworks/base/cmds/app_process/</strong></p>
<ul>
<li>App_main.cpp</li>
</ul>
<p><strong>frameworks/base/core/jni/</strong></p>
<ul>
<li>AndroidRuntime.cpp</li>
</ul>
<p><strong>frameworks/base/core/java/com/android/internal/os/</strong></p>
<ul>
<li>ZygoteInit.java</li>
<li>Zygote.java</li>
<li>ZygoteConnection.java</li>
</ul>
<p><strong>frameworks/base/core/java/com/android/internal/os/</strong></p>
<ul>
<li>ZygoteInit.java</li>
<li>RuntimeInit.java</li>
<li>Zygote.java</li>
</ul>
<p><strong>frameworks/base/core/services/java/com/android/server/</strong></p>
<ul>
<li>SystemServer.java</li>
</ul>
<p><strong>frameworks/base/core/jni/</strong></p>
<ul>
<li>com_android_internal_os_Zygote.cpp</li>
<li>AndroidRuntime.cpp</li>
</ul>
<p><strong>frameworks/base/services/java/com/android/server/</strong></p>
<ul>
<li>SystemServer.java</li>
</ul>
<p><strong>frameworks/base/services/core/java/com/android/server/</strong></p>
<ul>
<li>SystemServiceManager.java</li>
<li>ServiceThread.java</li>
<li>am/ActivityManagerService.java</li>
</ul>
<p><strong>frameworks/base/core/java/android/app/</strong></p>
<ul>
<li>ActivityThread.java</li>
<li>LoadedApk.java</li>
<li>ContextImpl.java</li>
</ul>
<p><strong>frameworks/base/core/java/android/app/</strong></p>
<ul>
<li>ActivityThread.java</li>
<li>LoadedApk.java</li>
<li>ContextImpl.java</li>
</ul>
<p><strong>frameworks/base/services/java/com/android/server/</strong></p>
<ul>
<li>SystemServer.java</li>
</ul>
<p><strong>frameworks/base/services/core/java/com/android/server/</strong></p>
<ul>
<li>SystemServiceManager.java</li>
<li>ServiceThread.java</li>
<li>pm/Installer.java</li>
<li>am/ActivityManagerService.java</li>
</ul>
<h3 id="一、Android概述"><a href="#一、Android概述" class="headerlink" title="一、Android概述"></a>一、Android概述</h3><p>Android系统非常庞大，底层是采用Linux作为基底，上层采用带有虚拟机的Java层，通过通过JNI技术，将上下打通，融为一体。下图是Google提供的一张经典的4层架构图，从下往上，依次分为Linux内核，系统库和Android Runtime，应用框架层，应用程序层这4层架构，每一层都包含大量的子模块或子系统。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N01-android-system-start-arch.png" alt="Markdown"></p>
<h3 id="二、系统启动"><a href="#二、系统启动" class="headerlink" title="二、系统启动"></a>二、系统启动</h3><p>Google提供的4层架构图，是非常经典，但只是如垒砖般的方式，简单地分层，而不足表达Android整个系统的启动过程，环环相扣的连接关系，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌。 系统启动架构图<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N02-android-system-start-arch.png" alt="Markdown"><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N03-android-system-start-arch.png" alt="Markdown"><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N04-android-system-start-arch.png" alt="Markdown"></p>
<h3 id="三、设备启动过程"><a href="#三、设备启动过程" class="headerlink" title="三、设备启动过程"></a>三、设备启动过程</h3><h4 id="3-1、Bootloader引导"><a href="#3-1、Bootloader引导" class="headerlink" title="3.1、Bootloader引导"></a>3.1、Bootloader引导</h4><p>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM；</p>
<p>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件设备（如CPU、内存、Flash等）并且通过建立内存空间映射，为装载Linux内核准备合适的环境。一旦Linux内核装载完毕，Bootloader将会从内存中清除掉。 如果用户在Bootloader运行期间，按下预定义的组合健，可以进入系统的更新模块。Android的下载更新可以选择进入Fastboot模式或者Recovery模式。</p>
<p>Fastboot是Android设计的一套通过USB来更新手机分区映像的协议，方便开发人员能快速更新指定的手机分区。但是一般的零售机上往往去掉了Fastboot，Google销售的开发机则带有Fastboot模块。 Recovery模式是Android特有的升级系统。利用Recovery模式，手机可以进行恢复出厂设置或进行OTA、补丁和固件升级。进入Recovery模式实际上是启动了一个文本模式的Linux。</p>
<h4 id="3-2、装载和启动Linux内核"><a href="#3-2、装载和启动Linux内核" class="headerlink" title="3.2、装载和启动Linux内核"></a>3.2、装载和启动Linux内核</h4><p>到这里才刚刚开始进入Android系统.</p>
<p>启动Kernel的0号进程：初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</p>
<p>Android的boot.img存放的就是Linux内核和一个根文件系统。Bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成后装载根文件系统，最后启动Init进程。</p>
<h4 id="3-3、启动Init进程"><a href="#3-3、启动Init进程" class="headerlink" title="3.3、启动Init进程"></a>3.3、启动Init进程</h4><p>Linux内核加载完毕后，会首先启动Init进程，Init进程是系统的第一个进程。在Init进程的启动过程中，会解析Linux的配置脚本init.rc文件，根据init.rc文件的内容，Init进程会装载Android的文件系统、创建系统目录。初始 化属性系统、启动Android系统重要的守护进程，这些进程包括USB守护进程、adb守护进程、vold守护进程、rild守护进程。</p>
<p>启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖。</p>
<p>init进程启动Media Server(多媒体服务)、servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程还会孵化出installd、ueventd、adbd、等用户守护进程； init进程孵化出Zygote进程，Zygote进程是Android系统的首个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 <a target="_blank" rel="noopener" href="http://blog.csdn.net/sunao2002002/article/details/52454878">Android 7.0 init.rc的一点改变 - 哈哈的个人专栏 - CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/system/core/rootdir/init.rc</span><br><span class="line">.....</span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"><span class="title">critical</span></span></span><br><span class="line">seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"><span class="title">critical</span></span></span><br><span class="line">seclabel u:r:healthd:s0</span><br><span class="line">group root system wakelock</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="3-4、启动Zygote进程"><a href="#3-4、启动Zygote进程" class="headerlink" title="3.4、启动Zygote进程"></a>3.4、启动Zygote进程</h4><p>init进程初始化结束时，会启动Zygote进程。Zygote进程负责fork出应用进程，是所有应用进程的父进程。Zygote进程初始化时会创建Dalivik虚拟机、预装系统的资源文件和Java类。所有从Zygote进程fork出的用户进程将继承和共享这些预加载的资源，不用浪费时间重新加载，加快了应用程序的启动过程。启动结束后，Zygote进程也将变成守护进程，负责响应和启动APK应用程序的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/system/core/rootdir/init.zygote64.rc</span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class"><span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class"><span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-5、启动SystemServer"><a href="#3-5、启动SystemServer" class="headerlink" title="3.5、启动SystemServer"></a>3.5、启动SystemServer</h4><p>SystemServer是Zygote进程fork出的第一个进程，也是整个Android系统的核心进程。在SystemServer中运行着系统大部分的Binder服务，SystemServer首先启动本地服务SensorService；接着启动ActivityManagerService、WindowManagerService、PackageManagerService在内的所有Java服务。</p>
<p>Zygote进程fork出System Server进程，System Server是Zygote孵化的第一个进程，地位非常重要； System Server进程：负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。 Media Server进程：负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line">SystemServer().run()</span><br></pre></td></tr></table></figure>

<h4 id="3-6、启动ActivityManagerService"><a href="#3-6、启动ActivityManagerService" class="headerlink" title="3.6、启动ActivityManagerService"></a>3.6、启动ActivityManagerService</h4><h4 id="3-7、启动Launcher-Activity"><a href="#3-7、启动Launcher-Activity" class="headerlink" title="3.7、启动Launcher(Activity)"></a>3.7、启动Launcher(Activity)</h4><p>SystemServer加载完所有的Java服务后，最后会调用ActivityManagerService的SystemReady()方法，在这个方法的执行中，会发出Intent”android.intent.category.HOME”。凡是响应这个Intent的APK都会运行起来，Launcher应用就是Android系统默认的桌面应用，一般只有它会响应这个Intent，因此，系统开机后，第一个运行的应用就是Launcher。 Zygote进程孵化出的第一个App进程是Launcher；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">startHomeActivityLocked(mCurrentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="四、设备启动过程详细分析"><a href="#四、设备启动过程详细分析" class="headerlink" title="四、设备启动过程详细分析"></a>四、设备启动过程详细分析</h3><h3 id="（1）、启动Init进程"><a href="#（1）、启动Init进程" class="headerlink" title="（1）、启动Init进程"></a>（1）、启动Init进程</h3><p>概述： init是Linux系统中用户空间的第一个进程，进程号为1。Kernel启动后，在用户空间，启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能分为4部分：</p>
<p>分析和运行所有的init.rc文件; 生成设备驱动节点; （通过rc文件创建） 处理子进程的终止(signal方式); 提供属性服务。 接下来从main()方法说起。</p>
<h4 id="4-1-1、main"><a href="#4-1-1、main" class="headerlink" title="4.1.1、main()"></a>4.1.1、main()</h4><p>[-&gt; init.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;watchdogd&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the umask.</span></span><br><span class="line"><span class="comment">//设置文件属性0777</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">add_environment(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--second-stage&quot;</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line"><span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line"><span class="comment">//创建文件系统目录并挂载相关的文件系统</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));</span><br><span class="line">    mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We must have some place other than / to create the device nodes for</span></span><br><span class="line"><span class="comment">// kmsg and null, otherwise we won&#x27;t be able to remount / read-only</span></span><br><span class="line"><span class="comment">// later on. Now that tmpfs is mounted on /dev, we can actually talk</span></span><br><span class="line"><span class="comment">// to the outside world.</span></span><br><span class="line"><span class="comment">//屏蔽标准的输入输出</span></span><br><span class="line">open_devnull_stdio();</span><br><span class="line"> <span class="comment">//初始化kernel log，位于设备节点/dev/kmsg</span></span><br><span class="line">klog_init();</span><br><span class="line"> <span class="comment">//设置输出的log级别</span></span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"> <span class="comment">// 输出init启动阶段的log</span></span><br><span class="line">NOTICE(<span class="string">&quot;init %s started!\n&quot;</span>, is_first_stage ? <span class="string">&quot;first stage&quot;</span> : <span class="string">&quot;second stage&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    close(open(<span class="string">&quot;/dev/.booting&quot;</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    <span class="comment">//创建一块共享的内存空间，用于属性服务</span></span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line">    <span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate the kernel variables to internal variables</span></span><br><span class="line">    <span class="comment">// used by init as well as the current required properties.</span></span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span></span><br><span class="line">selinux_initialize(is_first_stage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we&#x27;re in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line"><span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    <span class="keyword">if</span> (restorecon(<span class="string">&quot;/init&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;restorecon failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">&quot;--second-stage&quot;</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (execv(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;execv(\&quot;%s\&quot;) failed: %s\n&quot;</span>, path, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line"><span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line"><span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">NOTICE(<span class="string">&quot;Running restorecon...\n&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev/socket&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev/__properties__&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/property_contexts&quot;</span>);</span><br><span class="line">restorecon_recursive(<span class="string">&quot;/sys&quot;</span>);</span><br><span class="line"></span><br><span class="line">epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;epoll_create1 failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化子进程退出的信号处理过程</span></span><br><span class="line">signal_handler_init();</span><br><span class="line"></span><br><span class="line">property_load_boot_defaults();</span><br><span class="line">export_oem_lock_status();</span><br><span class="line">start_property_service();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;service&quot;</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">parser.ParseConfig(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line"></span><br><span class="line">ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">am.QueueEventTrigger(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">&quot;set_mmap_rnd_bits&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, <span class="string">&quot;keychord_init&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, <span class="string">&quot;console_init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.QueueEventTrigger(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line"><span class="comment">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bootmode = property_get(<span class="string">&quot;ro.bootmode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">&quot;charger&quot;</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;charger&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;late-init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">&quot;queue_property_triggers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        restart_processes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">        timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">    epoll_event ev;</span><br><span class="line">    <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;epoll_wait failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2、创建文件系统目录并挂载相关的文件系统"><a href="#4-1-2、创建文件系统目录并挂载相关的文件系统" class="headerlink" title="4.1.2、创建文件系统目录并挂载相关的文件系统"></a>4.1.2、创建文件系统目录并挂载相关的文件系统</h4><p>此时android的log系统还没有启动，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过cat /dev/kmsg来获取内核log。</p>
<p>接下来，设置log的输出级别为KLOG_NOTICE_LEVEL(5)，当log级别小于5时则会输出到kernel log， 默认值为3.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_environment(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--second-stage&quot;</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line"><span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));</span><br><span class="line">    mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该部分主要用于创建和挂载启动所需的文件目录。 需要注意的是，在编译Android系统源码时，在生成的根文件系统中，并不存在这些目录，它们是系统运行时的目录，即当系统终止时，就会消失。</p>
<p>在init初始化过程中，Android分别挂载了tmpfs，devpts，proc，sysfs这4类文件系统。</p>
<p>tmpfs是一种虚拟内存文件系统，它会将所有的文件存储在虚拟内存中，如果你将tmpfs文件系统卸载后，那么其下的所有的内容将不复存在。 tmpfs既可以使用RAM，也可以使用交换分区，会根据你的实际需要而改变大小。tmpfs的速度非常惊人，毕竟它是驻留在RAM中的，即使用了交换分区，性能仍然非常卓越。 由于tmpfs是驻留在RAM的，因此它的内容是不持久的。断电后，tmpfs的内容就消失了，这也是被称作tmpfs的根本原因。</p>
<p>devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/ pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。</p>
<p>proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。</p>
<p>与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。</p>
<h4 id="4-1-3、屏蔽标准的输入输出"><a href="#4-1-3、屏蔽标准的输入输出" class="headerlink" title="4.1.3、屏蔽标准的输入输出"></a>4.1.3、屏蔽标准的输入输出</h4><p>[-&gt; init.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_devnull_stdio</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Try to avoid the mknod() call if we can. Since SELinux makes</span></span><br><span class="line"><span class="comment">// a /dev/null replacement available for free, let&#x27;s use it.</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;/sys/fs/selinux/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// OOPS, /sys/fs/selinux/null isn&#x27;t available, likely because</span></span><br><span class="line">    <span class="comment">// /sys/fs/selinux isn&#x27;t mounted. Fall back to mknod.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">&quot;/dev/__null__&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (mknod(name, S_IFCHR | <span class="number">0600</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        fd = open(name, O_RDWR);</span><br><span class="line">        unlink(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dup2(fd, <span class="number">0</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line">dup2(fd, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文生成/dev目录后，init进程将调用open_devnull_stdio函数，屏蔽标准的输入输出。 open_devnull_stdio函数会在/dev目录下生成__null__设备节点文件，并将标准输入、标准输出、标准错误输出全部重定向到__null__设备中。 open_devnull_stdio函数定义于system/core/init/util.cpp中。</p>
<p>这里需要说明的是，dup2函数的作用是用来复制一个文件的描述符，通常用来重定向进程的stdin、stdout和stderr。它的函数原形是：</p>
<p>int dup2(int oldfd, int targetfd)</p>
<p>该函数执行后，targetfd将变成oldfd的复制品。</p>
<p>因此上述过程其实就是：创建出<strong>null</strong>设备后，将0、1、2绑定到<strong>null</strong>设备上。因此init进程调用open_devnull_stdio函数后，通过标准的输入输出无法输出信息。</p>
<h4 id="4-1-4、初始化内核log系统"><a href="#4-1-4、初始化内核log系统" class="headerlink" title="4.1.4、初始化内核log系统"></a>4.1.4、初始化内核log系统</h4><p>我们继续回到init进程的main函数，init进程通过klog_init函数，提供输出log信息的设备。 [-&gt; init.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">klog_init();</span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klog_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* Already initialized */</span></span><br><span class="line"></span><br><span class="line">klog_fd = open(<span class="string">&quot;/dev/kmsg&quot;</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;/dev/__kmsg__&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (mknod(name, S_IFCHR | <span class="number">0600</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    klog_fd = open(name, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    unlink(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>klog_init函数定义于system/core/libcutils/klog.c中。通过klog_init函数，init进程生成kmsg设备节点文件。该设备可以调用内核信息输出函数printk，以输出log信息。</p>
<h4 id="4-1-5、初始化属性域"><a href="#4-1-5、初始化属性域" class="headerlink" title="4.1.5、初始化属性域"></a>4.1.5、初始化属性域</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">.......</span><br><span class="line">property_init();</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用property_init初始化属性域。在Android平台中，为了让运行中的所有进程共享系统运行时所需要的各种设置值，系统开辟了属性存储区域，并提供了访问该区域的API。</p>
<p>这里存在一个问题是，在init进程中有部分代码块以is_first_stage标志进行区分，决定是否需要进行初始化。 is_first_stage的值，由init进程main函数的入口参数决定，之前不太明白具体的含义。 后来写博客后，有朋友留言，在引入selinux机制后，有些操作必须要在内核态才能完成； 但init进程作为android的第一个进程，又是运行在用户态的。 于是，最终设计为用is_first_stage进行区分init进程的运行状态。init进程在运行的过程中，会完成从内核态到用户态的切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__system_property_area_init()) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;Failed to initialize property area\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>property_init函数定义于system/core/init/property_service.cpp中，如上面代码所示，最终调用_system_property_area_init函数初始化属性域。</p>
<h4 id="4-1-6、完成SELinux相关工作"><a href="#4-1-6、完成SELinux相关工作" class="headerlink" title="4.1.6、完成SELinux相关工作"></a>4.1.6、完成SELinux相关工作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up SELinux, including loading the SELinux policy if we&#x27;re in the kernel domain.</span></span><br><span class="line">selinux_initialize(is_first_stage);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selinux_initialize</span><span class="params">(<span class="keyword">bool</span> in_kernel_domain)</span> </span>&#123;</span><br><span class="line">Timer t;</span><br><span class="line"></span><br><span class="line">selinux_callback cb;</span><br><span class="line"><span class="comment">//用于打印log的回调函数</span></span><br><span class="line">cb.func_log = selinux_klog_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"><span class="comment">//用于检查权限的回调函数</span></span><br><span class="line">cb.func_audit = audit_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_kernel_domain) &#123;</span><br><span class="line">   <span class="comment">//内核态处理流程</span></span><br><span class="line">    INFO(<span class="string">&quot;Loading SELinux policy...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//用于加载sepolicy文件。该函数最终将sepolicy文件传递给kernel，这样kernel就有了安全策略配置文件，后续的MAC才能开展起来。</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_load_policy() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;failed to load policy: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内核中读取的信息</span></span><br><span class="line">    <span class="keyword">bool</span> kernel_enforcing = (security_getenforce() == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//命令行中得到的数据</span></span><br><span class="line">    <span class="keyword">bool</span> is_enforcing = selinux_is_enforcing();</span><br><span class="line">    <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">        <span class="comment">//用于设置selinux的工作模式。selinux有两种工作模式：</span></span><br><span class="line">        <span class="comment">//1、”permissive”，所有的操作都被允许（即没有MAC），但是如果违反权限的话，会记录日志</span></span><br><span class="line">        <span class="comment">//2、”enforcing”，所有操作都会进行权限检查。在一般的终端中，应该工作于enforing模式</span></span><br><span class="line">        <span class="keyword">if</span> (security_setenforce(is_enforcing)) &#123;</span><br><span class="line">            ERROR(<span class="string">&quot;security_setenforce(%s) failed: %s\n&quot;</span>,</span><br><span class="line">                  is_enforcing ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="comment">//将重启进入recovery mode</span></span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_file(<span class="string">&quot;/sys/fs/selinux/checkreqprot&quot;</span>, <span class="string">&quot;0&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NOTICE(<span class="string">&quot;(Initializing SELinux %s took %.2fs.)\n&quot;</span>,</span><br><span class="line">           is_enforcing ? <span class="string">&quot;enforcing&quot;</span> : <span class="string">&quot;non-enforcing&quot;</span>, t.duration());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    selinux_init_all_handles();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init进程进程调用selinux_initialize启动SELinux。从注释来看，init进程的运行确实是区分用户态和内核态的。</p>
<h4 id="4-1-7、重新设置属性"><a href="#4-1-7、重新设置属性" class="headerlink" title="4.1.7、重新设置属性"></a>4.1.7、重新设置属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we&#x27;re in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line"><span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line"><span class="comment">//按selinux policy要求，重新设置init文件属性</span></span><br><span class="line">    <span class="keyword">if</span> (restorecon(<span class="string">&quot;/init&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;restorecon failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">&quot;--second-stage&quot;</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="comment">//这里就是前面所说的，启动用户态的init进程，即second-stage</span></span><br><span class="line">    <span class="keyword">if</span> (execv(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;execv(\&quot;%s\&quot;) failed: %s\n&quot;</span>, path, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line"><span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line"><span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">NOTICE(<span class="string">&quot;Running restorecon...\n&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev/socket&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/dev/__properties__&quot;</span>);</span><br><span class="line">restorecon(<span class="string">&quot;/property_contexts&quot;</span>);</span><br><span class="line">restorecon_recursive(<span class="string">&quot;/sys&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述文件节点在加载Sepolicy之前已经被创建了，因此在加载完Sepolicy后，需要重新设置相关的属性。</p>
<h4 id="4-1-8、创建epoll句柄"><a href="#4-1-8、创建epoll句柄" class="headerlink" title="4.1.8、创建epoll句柄"></a>4.1.8、创建epoll句柄</h4><p>如下面代码所示，init进程调用epoll_create1创建epoll句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;epoll_create1 failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p>
<p>epoll机制一般使用epoll_create(int size)函数创建epoll句柄，size用来告诉内核这个句柄可监听的fd的数目。注意这个参数不同于select()中的第一个参数，在select中需给出最大监听数加1的值。 此外，当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，能够看到创建出的fd，因此在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 上述代码使用的epoll_create1(EPOLLCLOEXEC)来创建epoll句柄，该标志位表示生成的epoll fd具有”执行后关闭”特性。</p>
<h4 id="4-1-9、装载子进程信号处理器"><a href="#4-1-9、装载子进程信号处理器" class="headerlink" title="4.1.9、装载子进程信号处理器"></a>4.1.9、装载子进程信号处理器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a signalling mechanism for SIGCHLD.</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//利用socketpair创建出已经连接的两个socket，分别作为信号的读、写端</span></span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>, s) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;socketpair failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal_write_fd = s[<span class="number">0</span>];</span><br><span class="line">signal_read_fd = s[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to signal_write_fd if we catch SIGCHLD.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line"><span class="comment">//信号处理器为SIGCHLD_handler，其被存在sigaction结构体中，负责处理SIGCHLD消息</span></span><br><span class="line">act.sa_handler = SIGCHLD_handler;</span><br><span class="line">act.sa_flags = SA_NOCLDSTOP;</span><br><span class="line"><span class="comment">//调用信号安装函数sigaction，将监听的信号及对应的信号处理器注册到内核中</span></span><br><span class="line">sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//相对于6.0的代码，进一步作了封装，用于终止出现问题的子进程，详细代码于后文分析。</span></span><br><span class="line">ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line"></span><br><span class="line">register_epoll_handler(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux进程通过互相发送接收消息来实现进程间的通信，这些消息被称为”信号”。每个进程在处理其它进程发送的信号时都要注册处理者，处理者被称为信号处理器。</p>
<p>注意到sigaction结构体的sa_flags为SA_NOCLDSTOP。由于系统默认在子进程暂停时也会发送信号SIGCHLD，init需要忽略子进程在暂停时发出的SIGCHLD信号，因此将act.sa_flags 置为SA_NOCLDSTOP，该标志位表示仅当进程终止时才接受SIGCHLD信号。</p>
<p>我们来看看SIGCHLD_handler的具体工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SIGCHLD_handler</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (TEMP_FAILURE_RETRY(write(signal_write_fd, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;write(signal_write_fd) failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码我们知道，init进程是所有进程的父进程，当其子进程终止产生SIGCHLD信号时，SIGCHLD_handler对signal_write_fd执行写操作。由于socketpair的绑定关系，这将触发信号对应的signal_read_fd收到数据。</p>
<p>在装载信号监听器的最后，signal_handler_init调用register_epoll_handler，其代码如下所示，传入参数分别为signal_read_fd和handle_signal。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_epoll_handler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> (*fn)())</span> </span>&#123;</span><br><span class="line">epoll_event ev;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(fn);</span><br><span class="line"><span class="comment">//epoll_fd增加一个监听对象fd,fd上有数据到来时，调用fn处理</span></span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;epoll_ctl failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码，我们知道：当epoll句柄监听到signal_read_fd中有数据可读时，将调用handle_signal进行处理。</p>
<p>至此，结合上文我们知道：当init进程调用signal_handler_init后，一旦收到子进程终止带来的SIGCHLD消息后，将利用信号处理者SIGCHLD_handler向signal_write_fd写入信息； epoll句柄监听到signal_read_fd收消息后，将调用handle_signal进行处理。整个过程如下图所示。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N05-android-system-start-signal_handler.jpg" alt="Markdown"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Clear outstanding requests.</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">read(signal_read_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，handle_signal只是清空signal_read_fd中的数据，然后调用ServiceManager::GetInstance().ReapAnyOutstandingChildren()。</p>
<p>ServiceManager定义于system/core/init/service.cpp中，是一个单例对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">............</span><br><span class="line"><span class="comment">//c中默认是private属性</span></span><br><span class="line">ServiceManager::ServiceManager() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ServiceManager&amp; <span class="title">ServiceManager::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> ServiceManager instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServiceManager::ReapAnyOutstandingChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (ReapOneProcess()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">............</span><br></pre></td></tr></table></figure>

<p>ReapAnyOutstandingChildren函数实际上调用了ReapOneProcess。 我们结合代码，看看ReapOneProcess的具体工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceManager::ReapOneProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//用waitpid函数获取状态发生变化的子进程pid</span></span><br><span class="line"><span class="comment">//waitpid的标记为WNOHANG，即非阻塞，返回为正值就说明有进程挂掉了</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = TEMP_FAILURE_RETRY(waitpid(<span class="number">-1</span>, &amp;status, WNOHANG));</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;waitpid failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用FindServiceByPid函数，找到pid对应的服务。</span></span><br><span class="line"><span class="comment">//FindServiceByPid主要通过轮询解析init.rc生成的service_list，找到pid与参数一致的srvc。</span></span><br><span class="line">Service* svc = FindServiceByPid(pid);</span><br><span class="line"><span class="comment">//输出服务结束的原因</span></span><br><span class="line">.........</span><br><span class="line"><span class="keyword">if</span> (!svc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务，相对于6.0作了进一步的封装</span></span><br><span class="line"><span class="keyword">if</span> (svc-&gt;Reap()) &#123;</span><br><span class="line">    waiting_for_exec = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//移除服务对应的信息</span></span><br><span class="line">    RemoveService(*svc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::Reap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//清理未携带SVC_ONESHOT 或 携带了SVC_RESTART标志的srvc的子进程</span></span><br><span class="line"><span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    NOTICE(<span class="string">&quot;Service &#x27;%s&#x27; (pid %d) killing any children in process group\n&quot;</span>, name_.c_str(), pid_);</span><br><span class="line">    kill(-pid_, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除srvc中创建出的socket</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp = StringPrintf(ANDROID_SOCKET_DIR <span class="string">&quot;/%s&quot;</span>, si.name.c_str());</span><br><span class="line">    unlink(tmp.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags_ &amp; SVC_EXEC) &#123;</span><br><span class="line">    INFO(<span class="string">&quot;SVC_EXEC pid %d finished...\n&quot;</span>, pid_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid_ = <span class="number">0</span>;</span><br><span class="line">flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于携带了SVC_ONESHOT并且未携带SVC_RESTART的srvc，将这类服务的标志置为SVC_DISABLED，不再启动</span></span><br><span class="line"><span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    flags_ |= SVC_DISABLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line"><span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">    svc-&gt;NotifyStateChange(<span class="string">&quot;stopped&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> now = gettime();</span><br><span class="line"><span class="comment">//未携带SVC_RESTART的关键服务，在规定的间隔内，crash字数过多时，会导致整机重启；</span></span><br><span class="line"><span class="keyword">if</span> ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (time_crashed_ + CRITICAL_CRASH_WINDOW &gt;= now) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++nr_crashed_ &gt; CRITICAL_CRASH_THRESHOLD) &#123;</span><br><span class="line">            ..........</span><br><span class="line">            android_reboot(ANDROID_RB_RESTART2, <span class="number">0</span>, <span class="string">&quot;recovery&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        time_crashed_ = now;</span><br><span class="line">        nr_crashed_ = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将待重启srvc的标志位置为SVC_RESTARTING（init进程将根据该标志位，重启服务）</span></span><br><span class="line">flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line"><span class="comment">//重启在init.rc文件中带有onrestart选项的服务，相对于6.0，此处也增加了封装性</span></span><br><span class="line">onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">svc-&gt;NotifyStateChange(<span class="string">&quot;restarting&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteAllCommands</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : commands_) &#123;</span><br><span class="line">    ExecuteCommand(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">Timer t;</span><br><span class="line"><span class="comment">//服务重启时，将执行对应的选项</span></span><br><span class="line"><span class="keyword">int</span> result = command.InvokeFunc();</span><br><span class="line"><span class="comment">//打印log</span></span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waitpid的函数原型为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure>

<p>其中，第一个参数pid为预等待的子进程的识别码，pid=-1表示等待任何子进程是否发出SIGCHLD。第二个参数status，用于返回子进程的结束状态。第三个参数决定waitpid函数是否处于阻塞处理方式，WNOHANG表示若pid指定的子进程没有结束，则waitpid()函数返回0，不予等待；若子进程结束，则返回子进程的pid。waitpid如果出错，则返回-1。</p>
<p>总结一下：整个signal_handler_init其实就是为了重启子进程用的，上述过程其实最终可以简化为下图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N06-android-system-start-signal.jpg" alt="Markdown"></p>
<h4 id="4-1-10、设置默认系统属性"><a href="#4-1-10、设置默认系统属性" class="headerlink" title="4.1.10、设置默认系统属性"></a>4.1.10、设置默认系统属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property_load_boot_defaults();</span><br></pre></td></tr></table></figure>

<p>接下来，进程调用property_load_boot_defaults进行默认属性配置相关的工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_load_boot_defaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>如代码所示，property_load_boot_defaults实际上就是调用load_properties_from_file解析配置文件；然后根据解析的结果，设置系统属性。该部分功能较为单一，不再深入分析。</p>
<h4 id="4-1-11、配置属性的服务端"><a href="#4-1-11、配置属性的服务端" class="headerlink" title="4.1.11、配置属性的服务端"></a>4.1.11、配置属性的服务端</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">start_property_service();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建了一个非阻塞socket</span></span><br><span class="line">property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, <span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (property_set_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;start_property_service socket creation failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用listen函数监听property_set_fd， 于是该socket变成一个server</span></span><br><span class="line">listen(property_set_fd, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//监听server socket上是否有数据到来</span></span><br><span class="line">register_epoll_handler(property_set_fd,  handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，在create_socket函数返回套接字property_set_fd时，property_set_fd是一个主动连接的套接字。此时，系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接。</p>
<p>由于在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接，于是需要调用listen函数使用主动连接套接字变为被连接套接字，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。</p>
<p>因此，调用listen后，init进程成为一个服务进程，其它进程可以通过property_set_fd连接init进程，提交设置系统属性的申请。</p>
<p>listen函数的第二个参数，涉及到一些网络的细节。</p>
<p>在进程处理一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态。有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。</p>
<p>因此，内核会在自己的进程空间里维护一个队列，以跟踪那些已完成连接但服务器进程还没有接手处理的用户，或正在进行的连接的用户。这样的一个队列不可能任意大，所以必须有一个上限。listen的第二个参数就是告诉内核使用这个数值作为上限。因此，init进程作为系统属性设置的服务器，最多可以同时为8个试图设置属性的用户提供服务。</p>
<p>在启动配置属性服务的最后，调用函数register_epoll_handler。根据上文所述，我们知道该函数将利用之前创建出的epoll句柄监听property_set_fd。当property_set_fd中有数据到来时，init进程将利用handle_property_set_fd函数进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">    <span class="keyword">if</span> ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">    r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, <span class="keyword">sizeof</span>(msg), MSG_DONTWAIT));</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">switch</span>(msg.cmd) &#123;</span><br><span class="line">    .........</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_propery_set_fd函数实际上是调用accept函数监听连接请求，接收property_set_fd中到来的数据，然后利用recv函数接受到来的数据，最后根据到来数据的类型，进行设置系统属性等相关操作，在此不做深入分析。</p>
<p>在这一部分的最后，我们简单举例介绍一下，系统属性改变的一些用途。 在init.rc中定义了一些与属性相关的触发器。当某个条件相关的属性被改变时，与该条件相关的触发器就会被触发。举例来说，如下面代码所示，debuggable属性变为1时，将执行启动console进程等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on property:ro.debuggable=<span class="number">1</span></span><br><span class="line"># Give writes to anyone <span class="keyword">for</span> the trace folder on debug builds.</span><br><span class="line"># The folder is used to store method traces.</span><br><span class="line">chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">start console</span><br></pre></td></tr></table></figure>

<p>总结一下，其它进程修改系统属性时，大致的流程如下图所示：其它的进程像init进程发送请求后，由init进程检查权限后，修改共享内存区。</p>
<h4 id="4-1-12、解析init-rc文件"><a href="#4-1-12、解析init-rc文件" class="headerlink" title="4.1.12、解析init.rc文件"></a>4.1.12、解析init.rc文件</h4><p>关于解析init.rc的代码，Android 7.0相对于6.0，作了巨大的修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里将Action的function_map_替换为BuiltinFunctionMap</span></span><br><span class="line"><span class="comment">//下文将通过BuiltinFuntionMap的map方法，获取keyword对应的处理函数</span></span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造出解析文件用的parser对象</span></span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line"><span class="comment">//为一些类型的关键字，创建特定的parser</span></span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;service&quot;</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line"><span class="comment">//开始实际的解析过程</span></span><br><span class="line">parser.ParseConfig(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<p>在解析init.rc文件的过程前，我们先来简单介绍一下init.rc文件。 init.rc文件是在init进程启动后执行的启动脚本，文件中记录着init进程需执行的操作。在Android系统中，使用init.rc和init.{ hardware }.rc两个文件。</p>
<p>其中init.rc文件在Android系统运行过程中用于通用的环境设置与进程相关的定义，init.{hardware}.rc（例如，高通有init.qcom.rc，MTK有init.mediatek.rc）用于定义Android在不同平台下的特定进程和环境设置等。</p>
<p>此处解析函数传入的参数为”/init.rc”，解析的是运行时与init进程同在根目录下的init.rc文件。该文件在编译前，定义于system/core/rootdir/init.rc中（与平台相关的rc文件不在这里加载）。</p>
<p>init.rc文件大致分为两大部分，一部分是以”on”关键字开头的动作列表（action list）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    # Set init <span class="keyword">and</span> its forked children<span class="number">&#x27;</span>s oom_adj.</span><br><span class="line">    write /proc/<span class="number">1</span>/oom_score_adj <span class="number">-1000</span></span><br><span class="line">    .........</span><br><span class="line">    start ueventd</span><br></pre></td></tr></table></figure>

<p>另一部分是以”service”关键字开头的服务列表（service list）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">seclabel</span> <span class="title">u</span>:</span>r:ueventd:s0</span><br></pre></td></tr></table></figure>

<p>借助系统环境变量或Linux命令，动作列表用于创建所需目录，以及为某些特定文件指定权限，而服务列表用来记录init进程需要启动的一些子进程。如上面代码所示，service关键字后的第一个字符串表示服务（子进程）的名称，第二个字符串表示服务的执行路径。</p>
<p>接下来，我们从ParseConfig函数入手，逐步分析整个解析过程(函数定义于system/core/init/ init_parser.cpp中)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="comment">//传入参数为目录地址</span></span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入参数为文件地址</span></span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigDir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    ...........</span><br><span class="line">    std::unique_ptr&lt;DIR, int(*)(DIR*)&gt; config_dir(opendir(path.c_str()), closedir);</span><br><span class="line">    ..........</span><br><span class="line">    <span class="comment">//看起来很复杂，其实就是递归目录</span></span><br><span class="line">    <span class="keyword">while</span> ((current_file = readdir(config_dir.get()))) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> current_path = android::base::StringPrintf(<span class="string">&quot;%s/%s&quot;</span>, path.c_str(), current_file-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">//最终还是靠ParseConfigFile来解析实际的文件</span></span><br><span class="line">            <span class="keyword">if</span> (!ParseConfigFile(current_path)) &#123;</span><br><span class="line">                .............</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，解析init.rc文件的函数是ParseConfigFile：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">    <span class="comment">//读取路径指定文件中的内容，保存为字符串形式</span></span><br><span class="line">    <span class="keyword">if</span> (!read_file(path.c_str(), &amp;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="comment">//解析获取的字符串</span></span><br><span class="line">    ParseData(path, data);</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ParseData函数定义于system/core/init/init_parser.cpp中，根据关键字解析出服务和动作。动作与服务会以链表节点的形式注册到service_list与action_list中，service_list与action_list是init进程中声明的全局结构体，其中的关键代码下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">.......</span><br><span class="line">parse_state state;</span><br><span class="line">.......</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//next_token以行为单位分割参数传递过来的字符串</span></span><br><span class="line">    <span class="comment">//最先走到T_TEXT分支</span></span><br><span class="line">    <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_EOF:</span><br><span class="line">        <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">            <span class="comment">//EOF,解析结束</span></span><br><span class="line">            section_parser-&gt;EndSection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">        state.line++;</span><br><span class="line">        <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在前文创建parser时，我们为service，on，import定义了对应的parser</span></span><br><span class="line">        <span class="comment">//这里就是根据第一个参数，判断是否有对应的parser</span></span><br><span class="line">        <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                <span class="comment">//结束上一个parser的工作，将构造出的对象加入到对应的service_list与action_list中</span></span><br><span class="line">                section_parser-&gt;EndSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取参数对应的parser</span></span><br><span class="line">            section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">            <span class="comment">//调用实际parser的ParseSection函数</span></span><br><span class="line">            <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</span><br><span class="line">                parse_error(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.c_str());</span><br><span class="line">                section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">            <span class="comment">//如果第一个参数不是service，on，import</span></span><br><span class="line">            <span class="comment">//则调用前一个parser的ParseLineSection函数</span></span><br><span class="line">            <span class="comment">//这里相当于解析一个参数块的子项</span></span><br><span class="line">            <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename, state.line, &amp;ret_err)) &#123;</span><br><span class="line">                parse_error(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.c_str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空本次解析的数据</span></span><br><span class="line">        args.clear();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_TEXT:</span><br><span class="line">        <span class="comment">//将本次解析的内容写入到args中</span></span><br><span class="line">        args.emplace_back(state.text);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的解析看起来比较复杂，在6.0以前的版本中，整个解析是面向过程的。init进程统一调用一个函数来进行解析，然后在该函数中利用switch-case的形式，根据解析的内容进行相应的处理。 在Android 7.0中，为了更好地封装及面向对象，对于不同的关键字定义了不同的parser对象，每个对象通过多态实现自己的解析操作。</p>
<p>我们现在回忆一下init进程main函数中，创建parser的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...........</span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;service&quot;</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>

<p>看看三个Parser的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;......&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;......&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;.......&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到三个Parser均是继承SectionParser，具体的实现各有不同，我们以比较常用的ServiceParser和ActionParser为例，看看解析的结果如何处理。</p>
<h5 id="4-1-12-1-ServiceParser"><a href="#4-1-12-1-ServiceParser" class="headerlink" title="4.1.12.1 ServiceParser"></a>4.1.12.1 ServiceParser</h5><p>ServiceParser定义于system/core/init/service.cpp中。从前面的代码，我们知道，解析一个service块，首先需要调用ParseSection函数，接着利用ParseLineSection处理子块，解析完所有数据后，调用EndSection。 因此，我们着重看看ServiceParser的这三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ServiceParser::ParseSection</span><span class="params">(.....)</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    .......</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">str_args</span><span class="params">(args.begin() + <span class="number">2</span>, args.end())</span></span>;</span><br><span class="line">    <span class="comment">//主要根据参数，构造出一个service对象</span></span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">&quot;default&quot;</span>, str_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里已经在解析子项了</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceParser::ParseLineSection</span><span class="params">(......)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用service对象的HandleLine</span></span><br><span class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::HandleLine</span><span class="params">(.....)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//OptionHandlerMap继承自keywordMap&lt;OptionHandler&gt;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;</span><br><span class="line">    <span class="comment">//根据子项的内容，找到对应的handler函数</span></span><br><span class="line">    <span class="comment">//FindFunction定义与keyword模块中,FindFunction方法利用子类生成对应的map中，然后通过通用的查找方法，即比较键值找到对应的处理函数</span></span><br><span class="line">    <span class="keyword">auto</span> handler = handler_map.FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用handler函数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span>:</span>:OptionHandlerMap : <span class="keyword">public</span> KeywordMap&lt;OptionHandler&gt; &#123;</span><br><span class="line">    ...........</span><br><span class="line">    Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;class&quot;</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;console&quot;</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;critical&quot;</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;disabled&quot;</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;group&quot;</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ioprio&quot;</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;keycodes&quot;</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;oneshot&quot;</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;onrestart&quot;</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;seclabel&quot;</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;setenv&quot;</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;socket&quot;</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;user&quot;</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;writepid&quot;</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> option_handlers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以class对应的处理函数为例，可以看出其实就是填充service对象对应的域</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::HandleClass</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="built_in">std</span>::<span class="built_in">string</span>* err)</span> </span>&#123;</span><br><span class="line">    classname_ = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意此时service对象已经处理完毕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServiceParser::EndSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServiceManager::AddService</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service)</span> </span>&#123;</span><br><span class="line">    Service* old_service = FindServiceByName(service-&gt;name());</span><br><span class="line">    <span class="keyword">if</span> (old_service) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;ignored duplicate definition of service &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将service对象加入到services_里</span></span><br><span class="line">    <span class="comment">//7.0里，services_已经是个vector了</span></span><br><span class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的一系列代码，我们可以看出ServiceParser其实就是：首先根据第一行的名字和参数创建出service对象，然后根据选项域的内容填充service对象，最后将创建出的service对象加入到vector类型的service链表中。</p>
<h4 id="4-1-12-2-ActionParser"><a href="#4-1-12-2-ActionParser" class="headerlink" title="4.1.12.2 ActionParser"></a>4.1.12.2 ActionParser</h4><p>ActionParser定义于system/core/init/action.cpp中。Action的解析过程，其实与Service一样，也是先后调用ParseSection， ParseLineSection和EndSection。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ActionParser::ParseSection</span><span class="params">(....)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//创建出新的action对象</span></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//根据参数，填充action的trigger域，不详细分析了</span></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;InitTriggers(triggers, err)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ActionParser::ParseLineSection</span><span class="params">(.......)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造Action对象的command域</span></span><br><span class="line">    <span class="keyword">return</span> action_ ? action_-&gt;AddCommand(args, filename, line, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Action::AddCommand</span><span class="params">(.....)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//找出action对应的执行函数</span></span><br><span class="line">    <span class="keyword">auto</span> function = function_map_-&gt;FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//利用所有信息构造出command，加入到action对象中</span></span><br><span class="line">    AddCommand(function, args, filename, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::AddCommand</span><span class="params">(......)</span> </span>&#123;</span><br><span class="line">    commands_.emplace_back(f, args, filename, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionParser::EndSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action_ &amp;&amp; action_-&gt;NumCommands() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ActionManager::GetInstance().AddAction(<span class="built_in">std</span>::move(action_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::AddAction</span><span class="params">(.....)</span> </span>&#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">auto</span> old_action_it = <span class="built_in">std</span>::find_if(actions_.begin(),</span><br><span class="line">                     actions_.end(),</span><br><span class="line">                     [&amp;action] (<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123;</span><br><span class="line">                         <span class="keyword">return</span> action-&gt;TriggersEqual(*a);</span><br><span class="line">                     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_action_it != actions_.end()) &#123;</span><br><span class="line">        (*old_action_it)-&gt;CombineAction(*action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//加入到action链表中，类型也是vector，其中装的是指针</span></span><br><span class="line">        actions_.emplace_back(<span class="built_in">std</span>::move(action));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，加载action块的逻辑和service一样，不同的是需要填充trigger和command域。当然，最后解析出的action也需要加入到action链表中。</p>
<p>这里最后还剩下一个问题，那就是哪里定义了Action中command对应处理函数？ 实际上，前文已经出现了过了，在init.cpp的main函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>因此，Action中调用function_map_-&gt;FindFunction时，实际上调用的是BuiltinFunctionMap的FindFunction函数。我们已经知道FindFunction是keyword定义的通用函数，重点是重构的map函数。我们看看system/core/init/builtins.cpp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BuiltinFunctionMap::Map&amp; <span class="title">BuiltinFunctionMap::map</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;bootchart_init&quot;</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_bootchart_init&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;chmod&quot;</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_chmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;chown&quot;</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    do_chown&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;class_reset&quot;</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_reset&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;class_start&quot;</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;class_stop&quot;</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;copy&quot;</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_copy&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;domainname&quot;</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_domainname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;enable&quot;</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_enable&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;exec&quot;</span>,                    &#123;<span class="number">1</span>,     kMax, do_exec&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;export&quot;</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_export&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;hostname&quot;</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_hostname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;ifup&quot;</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_ifup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;init_user0&quot;</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_init_user0&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;insmod&quot;</span>,                  &#123;<span class="number">1</span>,     kMax, do_insmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;installkey&quot;</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_installkey&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;load_persist_props&quot;</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_persist_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;load_system_props&quot;</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_system_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;loglevel&quot;</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_loglevel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mkdir&quot;</span>,                   &#123;<span class="number">1</span>,     <span class="number">4</span>,    do_mkdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mount_all&quot;</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;mount&quot;</span>,                   &#123;<span class="number">3</span>,     kMax, do_mount&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;powerctl&quot;</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_powerctl&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;restart&quot;</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_restart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;restorecon&quot;</span>,              &#123;<span class="number">1</span>,     kMax, do_restorecon&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;restorecon_recursive&quot;</span>,    &#123;<span class="number">1</span>,     kMax, do_restorecon_recursive&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rm&quot;</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rm&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;rmdir&quot;</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rmdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;setprop&quot;</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_setprop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;setrlimit&quot;</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    do_setrlimit&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;stop&quot;</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;swapon_all&quot;</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_swapon_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;symlink&quot;</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_symlink&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;sysclktz&quot;</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_sysclktz&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;trigger&quot;</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_trigger&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;verity_load_state&quot;</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_load_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;verity_update_state&quot;</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_update_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;wait&quot;</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    do_wait&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;write&quot;</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_write&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的第四项就是Action每个command对应的执行函数。</p>
<h4 id="4-1-13、向执行队列中添加其它action"><a href="#4-1-13、向执行队列中添加其它action" class="headerlink" title="4.1.13、向执行队列中添加其它action"></a>4.1.13、向执行队列中添加其它action</h4><p>介绍完init进程解析init.rc文件的过程后，我们继续将视角拉回到init进程的main函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">am.QueueEventTrigger(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">m.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">&quot;set_mmap_rnd_bits&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, <span class="string">&quot;keychord_init&quot;</span>);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, <span class="string">&quot;console_init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.QueueEventTrigger(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line"><span class="comment">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bootmode = property_get(<span class="string">&quot;ro.bootmode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">&quot;charger&quot;</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;charger&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;late-init&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">&quot;queue_property_triggers&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，接下来init进程中调用了大量的QueueEventTrigger和QueueBuiltinAction函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::QueueEventTrigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; trigger)</span> </span>&#123;</span><br><span class="line">    trigger_queue_.push(<span class="built_in">std</span>::make_unique&lt;EventTrigger&gt;(trigger));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处QueueEventTrigger函数就是利用参数构造EventTrigger，然后加入到trigger_queue_中。后续init进程处理trigger事件时，将会触发相应的操作。根据前文的分析，我们知道实际上就是将action_list中，对应trigger与第一个参数匹配的action，加入到运行队列action_queue中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::QueueBuiltinAction</span><span class="params">(BuiltinFunction func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建action</span></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; name_vector&#123;name&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证唯一性</span></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;InitSingleTrigger(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建action的cmd，指定执行函数和参数</span></span><br><span class="line">    action-&gt;AddCommand(func, name_vector);</span><br><span class="line"></span><br><span class="line">    trigger_queue_.push(<span class="built_in">std</span>::make_unique&lt;BuiltinTrigger&gt;(action.get()));</span><br><span class="line">    actions_.emplace_back(<span class="built_in">std</span>::move(action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QueueBuiltinAction函数中构造新的action加入到actions_中，第一个参数作为新建action携带cmd的执行函数；第二个参数既作为action的trigger name，也作为action携带cmd的参数。</p>
<h4 id="4-1-14、处理添加到运行队列的事件"><a href="#4-1-14、处理添加到运行队列的事件" class="headerlink" title="4.1.14、处理添加到运行队列的事件"></a>4.1.14、处理添加到运行队列的事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否有事件需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">        <span class="comment">//依次执行每个action中携带command对应的执行函数</span></span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        <span class="comment">//重启一些挂掉的进程</span></span><br><span class="line">        restart_processes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下决定timeout的时间，将影响while循环的间隔</span></span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//有进程需要重启时，等待该进程重启</span></span><br><span class="line">    <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">        timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有action待处理，不等待</span></span><br><span class="line">    <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bootchart_sample应该是进行性能数据采样</span></span><br><span class="line">    bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">    epoll_event ev;</span><br><span class="line">    <span class="comment">//没有事件到来的话，最多阻塞timeout时间</span></span><br><span class="line">    <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;epoll_wait failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//有事件到来，执行对应处理函数</span></span><br><span class="line">        <span class="comment">//根据上文知道，epoll句柄（即epoll_fd）主要监听子进程结束，及其它进程设置系统属性的请求。</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，init进程将所有需要操作的action加入运行队列后， 进入无限循环过程，不断处理运行队列中的事件，同时进行重启service等操作。</p>
<p>ExecuteOneCommand中的主要部分如下图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop through the trigger queue until we have an action to execute</span></span><br><span class="line">    <span class="comment">//当有可执行action或trigger queue为空时结束</span></span><br><span class="line">    <span class="keyword">while</span> (current_executing_actions_.empty() &amp;&amp; !trigger_queue_.empty()) &#123;</span><br><span class="line">        <span class="comment">//轮询actions链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">            <span class="comment">//依次查找trigger表</span></span><br><span class="line">            <span class="keyword">if</span> (trigger_queue_.front()-&gt;CheckTriggers(*action)) &#123;</span><br><span class="line">                <span class="comment">//当action与trigger对应时，就可以执行当前action</span></span><br><span class="line">                <span class="comment">//一个trigger可以对应多个action，均加入current_executing_actions_</span></span><br><span class="line">                current_executing_actions_.emplace(action.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//trigger event出队</span></span><br><span class="line">        trigger_queue_.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次只执行一个action，下次init进程while循环时，跳过上面的while循环，接着执行</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.front();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = action-&gt;BuildTriggersString();</span><br><span class="line">        INFO(<span class="string">&quot;processing action (%s)\n&quot;</span>, trigger_name.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际的执行过程，此处仅处理当前action中的一个cmd</span></span><br><span class="line">    action-&gt;ExecuteOneCommand(current_command_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适当地清理工作，注意只有当前action中所有的command均执行完毕后，才会将该action从current_executing_actions_移除</span></span><br><span class="line">    <span class="comment">// If this was the last command in the current action, then remove</span></span><br><span class="line">    <span class="comment">// the action from the executing list.</span></span><br><span class="line">    <span class="comment">// If this action was oneshot, then also remove it from actions_.</span></span><br><span class="line">    ++current_command_;</span><br><span class="line">    <span class="keyword">if</span> (current_command_ == action-&gt;NumCommands()) &#123;</span><br><span class="line">        current_executing_actions_.pop();</span><br><span class="line">        current_command_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (action-&gt;oneshot()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> eraser = [&amp;action] (<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.get() == action;</span><br><span class="line">            &#125;;</span><br><span class="line">            actions_.erase(<span class="built_in">std</span>::remove_if(actions_.begin(), actions_.end(), eraser));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    <span class="comment">//执行该command对应的处理函数</span></span><br><span class="line">    <span class="keyword">int</span> result = command.InvokeFunc();</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，当while循环不断调用ExecuteOneCommand函数时，将按照trigger表的顺序，依次取出action链表中与trigger匹配的action。 每次均执行一个action中的一个command对应函数（一个action可能携带多个command）。 当一个action所有的command均执行完毕后，再执行下一个action。 当一个trigger对应的action均执行完毕后，再执行下一个trigger对应action。</p>
<p>restart_processes函数负责按需重启service，代码如下图所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    process_needs_restart = <span class="number">0</span>;</span><br><span class="line">    ServiceManager::GetInstance().ForEachServiceWithFlags(</span><br><span class="line">        SVC_RESTARTING,</span><br><span class="line">        [] (Service* s) &#123;</span><br><span class="line">            s-&gt;RestartIfNeeded(process_needs_restart);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，该函数轮询service对应的链表，对于有SVC_RESTARING标志的service执行RestartIfNeeded（如上文所述，当子进程终止时，init进程会将可被重启进程的服务标志位置为SVC_RESTARTING）。</p>
<p>如下面代码所示，restart_service_if_needed可以重新启动服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Service::RestartIfNeeded</span><span class="params">(<span class="keyword">time_t</span>&amp; process_needs_restart)</span><span class="params">(struct service *svc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> next_start_time = svc-&gt;time_started + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两次服务启动时间的间隔要大于5s</span></span><br><span class="line">    <span class="keyword">if</span> (next_start_time &lt;= gettime()) &#123;</span><br><span class="line">        svc-&gt;flags &amp;= (~SVC_RESTARTING);</span><br><span class="line">        <span class="comment">//满足时间间隔的要求后，重启服务</span></span><br><span class="line">        <span class="comment">//Start将会重新fork服务进程，并做相应的配置</span></span><br><span class="line">        Start(svc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新main函数中，while循环需要等待的时间</span></span><br><span class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</span><br><span class="line">        (process_needs_restart == <span class="number">0</span>)) &#123;</span><br><span class="line">        process_needs_restart = next_start_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查阅资料发现：Bootchart 是一个能对 GNU/Linux boot 过程进行性能分析并把结果直观化的工具。它在 boot 过程中搜集资源利用情况及进程信息然后以PNG, SVG或EPS格式来显示结果。BootChart 包含数据收集工具和图像产生工具。数据收集工具在原始的BootChart中是独立的shell程序，但在Android中，数据收集工具被集成到了init 程序中。资料与代码基本吻合。</p>
<h3 id="（2）、启动Zygote进程"><a href="#（2）、启动Zygote进程" class="headerlink" title="（2）、启动Zygote进程"></a>（2）、启动Zygote进程</h3><h4 id="4-2-1、概述"><a href="#4-2-1、概述" class="headerlink" title="4.2.1、概述"></a>4.2.1、概述</h4><p>Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    socket zygote_secondary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>Zygote进程能够重启的地方:</p>
<p>servicemanager进程被杀; (onresart) surfaceflinger进程被杀; (onresart) Zygote进程自己被杀; (oneshot=false) system_server进程被杀; (waitpid) 从App_main()开始，Zygote启动过程的函数调用类大致流程如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N07-android-system-start-zygote_process.jpg" alt="Markdown"></p>
<h4 id="4-2-2、Zygote启动过程"><a href="#4-2-2、Zygote启动过程" class="headerlink" title="4.2.2、Zygote启动过程"></a>4.2.2、Zygote启动过程</h4><h5 id="4-2-2-1、App-main-main"><a href="#4-2-2-1、App-main-main" class="headerlink" title="4.2.2.1、App_main.main()"></a>4.2.2.1、App_main.main()</h5><p>[-&gt; App_main.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Older kernels don&#x27;t understand PR_SET_NO_NEW_PRIVS and return</span></span><br><span class="line">        <span class="comment">// EINVAL. Don&#x27;t die on such kernels.</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EINVAL) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传到的参数argv为“-Xzygote /system/bin --zygote --start-system-server”</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0] //忽略第一个参数</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="comment">//参数解析</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused &quot;parent dir&quot; argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        <span class="comment">// 运行application或tool程序</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re in zygote mode.</span></span><br><span class="line">         <span class="comment">//进入zygote模式，创建 /data/dalvik-cache路径</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>());</span><br><span class="line">        set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">       <span class="comment">// 启动AppRuntime</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//没有指定类名或zygote，参数错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-2、AndroidRuntime-start"><a href="#4-2-2-2、AndroidRuntime-start" class="headerlink" title="4.2.2.2、AndroidRuntime.start()"></a>4.2.2.2、AndroidRuntime.start()</h4><p>[-&gt; AndroidRuntime.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ALOGD(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;</span>,</span><br><span class="line">        className != <span class="literal">NULL</span> ? className : <span class="string">&quot;(unknown)&quot;</span>, getuid());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">&quot;start-system-server&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;startSystemServer == true&#x27; means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment"> * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">       <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">       LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    rootDir = <span class="string">&quot;/system&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasDir(<span class="string">&quot;/system&quot;</span>)) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">&quot;No root directory specified, and /android does not exist.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);</span></span><br><span class="line"><span class="comment">//ALOGD(&quot;Found LD_ASSUME_KERNEL=&#x27;%s&#x27;\n&quot;, kernelHack);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the virtual machine */</span></span><br><span class="line">JniInvocation jni_invocation;</span><br><span class="line">jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="comment">// 虚拟机创建</span></span><br><span class="line"><span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">onVmCreated(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register android functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// JNI方法注册</span></span><br><span class="line"><span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment"> * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment"> * Create an array to hold them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass stringClass;</span><br><span class="line">jobjectArray strArray;</span><br><span class="line">jstring classNameStr;</span><br><span class="line"><span class="comment">//等价 strArray= new String[options.size() + 1];</span></span><br><span class="line">stringClass = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等价 strArray[0] = &quot;com.android.internal.os.ZygoteInit&quot;</span></span><br><span class="line">classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"><span class="comment">//等价 strArray[1] = &quot;start-system-server&quot;；</span></span><br><span class="line"><span class="comment">//    strArray[2] = &quot;--abi-list=xxx&quot;；</span></span><br><span class="line"><span class="comment">//其中xxx为系统响应的cpu架构类型，比如arm64-v8a.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">    assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment"> * not return until the VM exits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//将&quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com/android/internal/os/ZygoteInit&quot;</span></span><br><span class="line"><span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line"><span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">    <span class="comment">/* keep going */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">        <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用ZygoteInit.main()方法</span></span><br><span class="line">        env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">            threadExitUncaughtException(env);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">ALOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">    ALOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">    ALOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-3、AndroidRuntime-startVm"><a href="#4-2-2-3、AndroidRuntime-startVm" class="headerlink" title="4.2.2.3、AndroidRuntime.startVm()"></a>4.2.2.3、AndroidRuntime.startVm()</h4><p>[–&gt; AndroidRuntime.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// JNI检测功能，用于native层调用jni函数时进行常规检测，比较弱字符串格式是否符合要求，资源是否正确释放。该功能一般用于早期系统调试或手机Eng版，对于User版往往不会开启，引用该功能比较消耗系统CPU资源，降低系统性能。</span></span><br><span class="line">   <span class="keyword">bool</span> checkJni = <span class="literal">false</span>;</span><br><span class="line">property_get(<span class="string">&quot;dalvik.vm.checkjni&quot;</span>, propBuf, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;true&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    checkJni = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;false&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* property is neither true nor false; fall back on kernel parameter */</span></span><br><span class="line">    property_get(<span class="string">&quot;ro.kernel.android.checkjni&quot;</span>, propBuf, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (propBuf[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        checkJni = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ALOGD(<span class="string">&quot;CheckJNI is %s\n&quot;</span>, checkJni ? <span class="string">&quot;ON&quot;</span> : <span class="string">&quot;OFF&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (checkJni) &#123;</span><br><span class="line">    addOption(<span class="string">&quot;-Xcheck:jni&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"> <span class="comment">//虚拟机产生的trace文件，主要用于分析系统问题，路径默认为/data/anr/traces.txt</span></span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.stack-trace-file&quot;</span>, stackTraceFileBuf, <span class="string">&quot;-Xstacktracefile:&quot;</span>);</span><br><span class="line"><span class="comment">//对于不同的软硬件环境，这些参数往往需要调整、优化，从而使系统达到最佳性能</span></span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapstartsize&quot;</span>, heapstartsizeOptsBuf, <span class="string">&quot;-Xms&quot;</span>, <span class="string">&quot;4m&quot;</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapsize&quot;</span>, heapsizeOptsBuf, <span class="string">&quot;-Xmx&quot;</span>, <span class="string">&quot;16m&quot;</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapgrowthlimit&quot;</span>, heapgrowthlimitOptsBuf, <span class="string">&quot;-XX:HeapGrowthLimit=&quot;</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapminfree&quot;</span>, heapminfreeOptsBuf, <span class="string">&quot;-XX:HeapMinFree=&quot;</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapmaxfree&quot;</span>, heapmaxfreeOptsBuf, <span class="string">&quot;-XX:HeapMaxFree=&quot;</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">&quot;dalvik.vm.heaptargetutilization&quot;</span>,</span><br><span class="line">                   heaptargetutilizationOptsBuf, <span class="string">&quot;-XX:HeapTargetUtilization=&quot;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//preloaded-classes文件内容是由WritePreloadedClassFile.java生成的，</span></span><br><span class="line"><span class="comment">//在ZygoteInit类中会预加载工作将其中的classes提前加载到内存，以提高系统性能</span></span><br><span class="line"><span class="keyword">if</span> (!hasFile(<span class="string">&quot;/system/etc/preloaded-classes&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化虚拟机</span></span><br><span class="line"><span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;JNI_CreateJavaVM failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Java虚拟机方法的主要篇幅是关于虚拟机参数的设置，下面只列举部分在调试优化过程中常用参数。</p>
<h4 id="4-2-2-4、AndroidRuntime-startReg"><a href="#4-2-2-4、AndroidRuntime-startReg" class="headerlink" title="4.2.2.4、AndroidRuntime.startReg()"></a>4.2.2.4、AndroidRuntime.startReg()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置线程创建方法为javaCreateThreadEtc</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//进程NI方法的注册</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-4-1、Threads-androidSetCreateThreadFunc"><a href="#4-2-2-4-1、Threads-androidSetCreateThreadFunc" class="headerlink" title="4.2.2.4.1、Threads.androidSetCreateThreadFunc()"></a>4.2.2.4.1、Threads.androidSetCreateThreadFunc()</h4><p>[-&gt; Threads.cpp]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">androidSetCreateThreadFunc</span><span class="params">(android_create_thread_fn func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCreateThreadFn = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机启动后startReg()过程，会设置线程创建函数指针gCreateThreadFn指向javaCreateThreadEtc.</p>
<h4 id="4-2-2-4-2、register-jni-procs"><a href="#4-2-2-4-2、register-jni-procs" class="headerlink" title="4.2.2.4.2、register_jni_procs()"></a>4.2.2.4.2、register_jni_procs()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-4-3、gRegJNI-mProc"><a href="#4-2-2-4-3、gRegJNI-mProc" class="headerlink" title="4.2.2.4.3、gRegJNI.mProc"></a>4.2.2.4.3、gRegJNI.mProc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    REG_JNI(register_android_os_Binder)，</span><br><span class="line">    ...</span><br><span class="line">&#125;；*</span><br></pre></td></tr></table></figure>

<p>array[i]是指gRegJNI数组, 该数组有100多个成员。其中每一项成员都是通过REG_JNI宏定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，调用mProc，就等价于调用其参数名所指向的函数。 例如REG_JNI(register_com_android_internal_os_RuntimeInit).mProc也就是指进入register_com_android_internal_os_RuntimeInit方法，接下来就继续以此为例来说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">&quot;com/android/internal/os/RuntimeInit&quot;</span>,</span><br><span class="line">        gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//gMethods：java层方法名与jni层的方法的一一映射关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;nativeFinishInit&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;nativeZygoteInit&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;nativeSetExitWithoutCleanup&quot;</span>, <span class="string">&quot;(Z)V&quot;</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N08-android-system-start-ZygoteInit.main.png" alt="Markdown"></p>
<h4 id="4-2-2-5、进入Java层"><a href="#4-2-2-5、进入Java层" class="headerlink" title="4.2.2.5、进入Java层"></a>4.2.2.5、进入Java层</h4><p>AndroidRuntime.start()执行到最后通过反射调用到ZygoteInit.main(),见下文:</p>
<h5 id="4-2-2-5-1、ZygoteInit-main"><a href="#4-2-2-5-1、ZygoteInit-main" class="headerlink" title="4.2.2.5.1、ZygoteInit.main()"></a>4.2.2.5.1、ZygoteInit.main()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;Init<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    //开启DDMS功能</span></span><br><span class="line"><span class="string">    RuntimeInit.enableDdms();</span></span><br><span class="line"><span class="string">    SamplingProfilerIntegration.start();</span></span><br><span class="line"><span class="string">    boolean startSystemServer = false;</span></span><br><span class="line"><span class="string">    String socketName = &quot;</span>zygote<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    String abiList = null;</span></span><br><span class="line"><span class="string">    for (int i = 1; i &lt; argv.length; i++) &#123;</span></span><br><span class="line"><span class="string">        if (&quot;</span>start-system-server<span class="string">&quot;.equals(argv[i])) &#123;</span></span><br><span class="line"><span class="string">            startSystemServer = true;</span></span><br><span class="line"><span class="string">        &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span></span><br><span class="line"><span class="string">            abiList = argv[i].substring(ABI_LIST_ARG.length());</span></span><br><span class="line"><span class="string">        &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span></span><br><span class="line"><span class="string">            socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            throw new RuntimeException(&quot;</span>Unknown command line argument: <span class="string">&quot; + argv[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    //为Zygote注册socket</span></span><br><span class="line"><span class="string">    registerZygoteSocket(socketName);</span></span><br><span class="line"><span class="string">    preload();// 预加载类和资源</span></span><br><span class="line"><span class="string">    SamplingProfilerIntegration.writeZygoteSnapshot();</span></span><br><span class="line"><span class="string">    gcAndFinalize();//GC操作</span></span><br><span class="line"><span class="string">    Zygote.nativeUnmountStorageOnInit();</span></span><br><span class="line"><span class="string">    ZygoteHooks.stopZygoteNoThreadCreation();</span></span><br><span class="line"><span class="string">    if (startSystemServer) &#123;//启动system_server</span></span><br><span class="line"><span class="string">        startSystemServer(abiList, socketName);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    runSelectLoop(abiList);//进入循环模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    closeServerSocket();</span></span><br><span class="line"><span class="string">&#125; catch (MethodAndArgsCaller caller) &#123;</span></span><br><span class="line"><span class="string">    caller.run();</span></span><br><span class="line"><span class="string">&#125; catch (Throwable ex) &#123;</span></span><br><span class="line"><span class="string">    closeServerSocket();</span></span><br><span class="line"><span class="string">    throw ex;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在异常捕获后调用的方法caller.run()，会在后续的system_server文章会讲到。</p>
<h5 id="4-2-2-5-2、ZygoteInit-registerZygoteSocket"><a href="#4-2-2-5-2、ZygoteInit-registerZygoteSocket" class="headerlink" title="4.2.2.5.2、ZygoteInit.registerZygoteSocket()"></a>4.2.2.5.2、ZygoteInit.registerZygoteSocket()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> fileDesc;</span><br><span class="line">    <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.setInt$(fileDesc); <span class="comment">//设置文件描述符</span></span><br><span class="line">        sServerSocket = <span class="keyword">new</span> LocalServerSocket(fd); <span class="comment">//创建Socket的本地服务端</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-5-2、ZygoteInit-preload"><a href="#4-2-2-5-2、ZygoteInit-preload" class="headerlink" title="4.2.2.5.2、ZygoteInit.preload()"></a>4.2.2.5.2、ZygoteInit.preload()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预加载位于/system/etc/preloaded-classes文件中的类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载资源，包含drawable和color资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载OpenGL</span></span><br><span class="line">    preloadOpenGL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过System.loadLibrary()方法，</span></span><br><span class="line">    <span class="comment">//预加载&quot;android&quot;,&quot;compiler_rt&quot;,&quot;jnigraphics&quot;这3个共享库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载  文本连接符资源</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅用于zygote进程，用于内存共享的进程</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行Zygote进程的初始化,对于类加载，采用反射机制Class.forName()方法来加载。对于资源加载，主要是 com.android.internal.R.array.preloaded_drawables和com.android.internal.R.array.preloaded_color_state_lists，在应用程序中以com.android.internal.R.xxx开头的资源，便是此时由Zygote加载到内存的。</p>
<p>zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N09-android-system-start-zygote_fork.jpg" alt="Markdown"></p>
<h5 id="4-2-2-5-3、ZygoteInit-startSystemServer"><a href="#4-2-2-5-3、ZygoteInit-startSystemServer" class="headerlink" title="4.2.2.5.3、ZygoteInit.startSystemServer()"></a>4.2.2.5.3、ZygoteInit.startSystemServer()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_BLOCK_SUSPEND,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//参数准备</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//用于解析参数，生成目标格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork子进程，用于运行system_server</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。</p>
<h5 id="4-2-2-5-4、ZygoteInit-runSelectLoop"><a href="#4-2-2-5-4、ZygoteInit-runSelectLoop" class="headerlink" title="4.2.2.5.4、ZygoteInit.runSelectLoop()"></a>4.2.2.5.4、ZygoteInit.runSelectLoop()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    <span class="comment">//sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span></span><br><span class="line">            <span class="comment">// 否则进入continue，跳出本次循环。</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；</span></span><br><span class="line">                <span class="comment">// 则创建ZygoteConnection对象,并添加到fds。</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor()); <span class="comment">//添加到fds.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i); <span class="comment">//处理完则从fds中移除该文件描述符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。</p>
<h5 id="4-2-2-5-4、ZygoteConnection-runOnce"><a href="#4-2-2-5-4、ZygoteConnection-runOnce" class="headerlink" title="4.2.2.5.4、ZygoteConnection.runOnce()"></a>4.2.2.5.4、ZygoteConnection.runOnce()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">String args[];</span><br><span class="line">Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//读取socket客户端发送过来的参数列表</span></span><br><span class="line">    args = readArgumentList();</span><br><span class="line">    descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//将binder客户端传递过来的参数，解析成Arguments对象格式</span></span><br><span class="line">    parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">    ...</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程执行</span></span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//进入子进程流程</span></span><br><span class="line">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程执行</span></span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">    IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-6、总结"><a href="#4-2-2-6、总结" class="headerlink" title="4.2.2.6、总结"></a>4.2.2.6、总结</h5><p>Zygote启动过程的调用流程图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N10-android-system-start-zygote_start.jpg" alt="Markdown"></p>
<blockquote>
<p>1、解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；<br>2、 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；<br>3、通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；<br>4、registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；<br>5、preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；<br>6、zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。<br>7、 zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N11-android-system-start-System_Server.png" alt="Markdown"></p>
</blockquote>
<h3 id="（3）、启动SystemServer上篇"><a href="#（3）、启动SystemServer上篇" class="headerlink" title="（3）、启动SystemServer上篇"></a>（3）、启动SystemServer上篇</h3><h4 id="4-3-1、启动流程"><a href="#4-3-1、启动流程" class="headerlink" title="4.3.1、启动流程"></a>4.3.1、启动流程</h4><p>SystemServer的在Android体系中所处的地位，SystemServer由Zygote fork生成的，进程名为system_server，该进程承载着framework的核心服务。 Android系统启动-zygote篇中讲到Zygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N12-android-system-start-system_server_.jpg" alt="Markdown"></p>
<h4 id="4-3-2、ZygoteInit-startSystemServer"><a href="#4-3-2、ZygoteInit-startSystemServer" class="headerlink" title="4.3.2、ZygoteInit.startSystemServer()"></a>4.3.2、ZygoteInit.startSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//参数准备</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//用于解析参数，生成目标格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork子进程，该进程是system_server进程</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。</p>
<h4 id="4-3-3、Zygote-forkSystemServer"><a href="#4-3-3、Zygote-forkSystemServer" class="headerlink" title="4.3.3、Zygote. forkSystemServer()"></a>4.3.3、Zygote. forkSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="comment">// 调用native方法fork system_server进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeForkSystemServer()方法在AndroidRuntime.cpp中注册的，调用com_android_internal_os_Zygote.cpp中的register_com_android_internal_os_Zygote()方法建立native方法的映射关系，所以接下来进入如下方法。</p>
<h4 id="4-3-4、com-android-internal-os-Zygote-nativeForkSystemServer"><a href="#4-3-4、com-android-internal-os-Zygote-nativeForkSystemServer" class="headerlink" title="4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()"></a>4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//fork子进程，</span></span><br><span class="line">  pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, <span class="keyword">true</span>, NULL,</span><br><span class="line">                                      NULL, NULL);</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// zygote进程，检测system_server进程是否创建</span></span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//当system_server进程死亡后，重启zygote进程</span></span><br><span class="line">          RuntimeAbort(env);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当system_server进程创建失败时，将会重启zygote进程。这里需要注意，对于Android 5.0以上系统，有两个zygote进程，分别是zygote、zygote64两个进程，system_server的父进程，一般来说64位系统其父进程是zygote64进程</p>
<p>当kill system_server进程后，只重启zygote64和system_server，不重启zygote; 当kill zygote64进程后，只重启zygote64和system_server，也不重启zygote； 当kill zygote进程，则重启zygote、zygote64以及system_server。</p>
<h4 id="4-3-5、com-android-internal-os-Zygote-ForkAndSpecializeCommon"><a href="#4-3-5、com-android-internal-os-Zygote-ForkAndSpecializeCommon" class="headerlink" title="4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()"></a>4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     bool is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  SetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数</span></span><br><span class="line">  pid_t pid = fork(); <span class="comment">//fork子进程</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入子进程</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose); <span class="comment">//关闭并清除文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="comment">//对于非system_server子进程，则创建进程组</span></span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); <span class="comment">//设置设置group</span></span><br><span class="line">    SetRLimits(env, javaRlimits); <span class="comment">//设置资源limit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); <span class="comment">//设置调度策略</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//selinux上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">&quot;system_server&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); <span class="comment">//设置线程名为system_server，方便调试</span></span><br><span class="line">    &#125;</span><br><span class="line">    UnsetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数为默认函数</span></span><br><span class="line">    <span class="comment">//等价于调用zygote.callPostForkChildHooks()</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入父进程，即zygote进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork()创建新进程，采用copy on write方式，这是linux创建进程的标准方法，会有两次return,对于pid==0为子进程的返回，对于pid&gt;0为父进程的返回。 到此system_server进程已完成了创建的所有工作，接下来开始了system_server进程的真正工作。在前面startSystemServer()方法中，zygote进程执行完forkSystemServer()后，新创建出来的system_server进程便进入handleSystemServerProcess()方法。</p>
<h4 id="4-3-5、ZygoteInit-handleSystemServerProcess"><a href="#4-3-5、ZygoteInit-handleSystemServerProcess" class="headerlink" title="4.3.5、ZygoteInit.handleSystemServerProcess()"></a>4.3.5、ZygoteInit.handleSystemServerProcess()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    closeServerSocket(); <span class="comment">//关闭父进程zygote复制而来的Socket</span></span><br><span class="line"></span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName); <span class="comment">//设置当前进程名为&quot;system_server&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">&quot;SYSTEMSERVERCLASSPATH&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//执行dex优化操作</span></span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] args = parsedArgs.remainingArgs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">            amendedArgs[<span class="number">0</span>] = <span class="string">&quot;-cp&quot;</span>;</span><br><span class="line">            amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">            System.arraycopy(parsedArgs.remainingArgs, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, parsedArgs.remainingArgs.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动应用进程</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            创建类加载器，并赋予当前线程</span><br><span class="line">            cl = <span class="keyword">new</span> PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//system_server故进入此分支</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处systemServerClasspath环境变量主要有/system/framework/目录下的services.jar，ethernet-service.jar, wifi-service.jar这3个文件</p>
<h4 id="4-3-6、ZygoteInit-performSystemServerDexOpt"><a href="#4-3-6、ZygoteInit-performSystemServerDexOpt" class="headerlink" title="4.3.6、ZygoteInit.performSystemServerDexOpt()"></a>4.3.6、ZygoteInit.performSystemServerDexOpt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performSystemServerDexOpt</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String[] classPathElements = classPath.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="comment">//创建一个与installd的建立socket连接</span></span><br><span class="line">    <span class="keyword">final</span> InstallerConnection installer = <span class="keyword">new</span> InstallerConnection();</span><br><span class="line">    <span class="comment">//执行ping操作，直到与installd服务端连通为止</span></span><br><span class="line">    installer.waitForConnection();</span><br><span class="line">    <span class="keyword">final</span> String instructionSet = VMRuntime.getRuntime().vmInstructionSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String classPathElement : classPathElements) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> dexoptNeeded = DexFile.getDexOptNeeded(</span><br><span class="line">                    classPathElement, <span class="string">&quot;*&quot;</span>, instructionSet, <span class="keyword">false</span> <span class="comment">/* defer */</span>);</span><br><span class="line">            <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                <span class="comment">//以system权限，执行dex文件优化</span></span><br><span class="line">                installer.dexopt(classPathElement, Process.SYSTEM_UID, <span class="keyword">false</span>,</span><br><span class="line">                        instructionSet, dexoptNeeded);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Error starting system_server&quot;</span>, ioe);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        installer.disconnect(); <span class="comment">//断开与installd的socket连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将classPath字符串中的apk，分别进行dex优化操作。真正执行优化工作通过socket通信将相应的命令参数，发送给installd来完成。</p>
<h4 id="4-3-7、RuntimeInit-zygoteInit"><a href="#4-3-7、RuntimeInit-zygoteInit" class="headerlink" title="4.3.7、RuntimeInit.zygoteInit()"></a>4.3.7、RuntimeInit.zygoteInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;RuntimeInit&quot;</span>);</span><br><span class="line">    redirectLogStreams(); <span class="comment">//重定向log输出</span></span><br><span class="line"></span><br><span class="line">    commonInit(); <span class="comment">// 通用的一些初始化</span></span><br><span class="line">    nativeZygoteInit(); <span class="comment">// zygote初始化</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); <span class="comment">// 应用初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-8、RuntimeInit-commonInit"><a href="#4-3-8、RuntimeInit-commonInit" class="headerlink" title="4.3.8、RuntimeInit.commonInit()"></a>4.3.8、RuntimeInit.commonInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置默认的未捕捉异常处理方法</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置市区，中国时区为&quot;Asia/Shanghai&quot;</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">&quot;persist.sys.timezone&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">&quot;http.agent&quot;</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket的tag，用于网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的HTTP User-agent格式，例如：</p>
<p>“Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)”.</p>
<h4 id="4-3-9、AndroidRuntime-nativeZygoteInit"><a href="#4-3-9、AndroidRuntime-nativeZygoteInit" class="headerlink" title="4.3.9、AndroidRuntime.nativeZygoteInit()"></a>4.3.9、AndroidRuntime.nativeZygoteInit()</h4><p>nativeZygoteInit()方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span></span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[–&gt;app_main.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">//启动新binder线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的<a target="_blank" rel="noopener" href="http://gityuan.com/2015/11/14/binder-add-service/">注册服务(addService)</a>详细这两个方法的执行原理。</p>
<h4 id="4-3-10、RuntimeInit-applicationInit"><a href="#4-3-10、RuntimeInit-applicationInit" class="headerlink" title="4.3.10、RuntimeInit.applicationInit()"></a>4.3.10、RuntimeInit.applicationInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置虚拟机的内存利用率参数值为0.75</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv); <span class="comment">//解析参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用startClass的static方法 main()</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startSystemServer()方法中通过硬编码初始化参数，可知此处args.startClass为”com.android.server.SystemServer”。</p>
<h4 id="4-3-11、RuntimeInit-invokeStaticMain"><a href="#4-3-11、RuntimeInit-invokeStaticMain" class="headerlink" title="4.3.11、RuntimeInit.invokeStaticMain()"></a>4.3.11、RuntimeInit.invokeStaticMain()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-12、MethodAndArgsCaller-run"><a href="#4-3-12、MethodAndArgsCaller-run" class="headerlink" title="4.3.12、MethodAndArgsCaller.run()"></a>4.3.12、MethodAndArgsCaller.run()</h4><p>在Zygote中遗留了一个问题没有讲解，如下：</p>
<p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);<span class="comment">//启动system_server</span></span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经很明显了，是invokeStaticMain()方法中抛出的异常MethodAndArgsCaller，从而进入caller.run()方法。</p>
<p>[–&gt;ZygoteInit.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，总算是进入到了SystemServer类的main()方法， 在文章Android系统启动-SystemServer下篇中会紧接着这里开始讲述。</p>
<h3 id="（4）、启动SystemServer下篇"><a href="#（4）、启动SystemServer下篇" class="headerlink" title="（4）、启动SystemServer下篇"></a>（4）、启动SystemServer下篇</h3><p>上篇文章Android系统启动-systemServer上篇 从Zygote一路启动到SystemServer的过程。 简单回顾下，在RuntimeInit.java中invokeStaticMain方法通过创建并抛出异常ZygoteInit.MethodAndArgsCaller，在ZygoteInit.java中的main()方法会捕捉该异常，并调用caller.run()，再通过反射便会调用到SystemServer.main()方法，该方法主要执行流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        createSystemContext</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure>

<p>接下来，从其main方法说起。</p>
<h4 id="4-4-1、SystemServer-main"><a href="#4-4-1、SystemServer-main" class="headerlink" title="4.4.1、SystemServer.main()"></a>4.4.1、SystemServer.main()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先初始化SystemServer对象，再调用对象的run()方法</span></span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2、SystemServer-run"><a href="#4-4-2、SystemServer-run" class="headerlink" title="4.4.2、SystemServer.run()"></a>4.4.2、SystemServer.run()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当系统时间比1970年更早，就设置当前系统时间为1970年</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//变更虚拟机的库文件，对于Android 6.0默认采用的是libart.so</span></span><br><span class="line">    SystemProperties.set(<span class="string">&quot;persist.sys.dalvik.vm.lib.2&quot;</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除vm内存增长上限，由于启动过程需要较多的虚拟机内存空间</span></span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置内存的可能有效使用率为0.8</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line">    <span class="comment">// 针对部分设备依赖于运行时就产生指纹信息，因此需要在开机完成前已经定义</span></span><br><span class="line">    Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问环境变量前，需要明确地指定用户</span></span><br><span class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保当前系统进程的binder调用，总是运行在前台优先级(foreground priority)</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程looper就在当前线程运行</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测上次关机过程是否失败，该方法可能不会返回</span></span><br><span class="line">    performPendingShutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化系统上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    <span class="comment">//将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于debug版本，将log事件不断循环地输出到dropbox（用于分析）</span></span><br><span class="line">    <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Enabled StrictMode for system server main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一直循环执行</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p>
<h4 id="4-4-3、SystemServer-performPendingShutdown"><a href="#4-4-3、SystemServer-performPendingShutdown" class="headerlink" title="4.4.3、SystemServer.performPendingShutdown()"></a>4.4.3、SystemServer.performPendingShutdown()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPendingShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String shutdownAction = SystemProperties.get(</span><br><span class="line">            ShutdownThread.SHUTDOWN_ACTION_PROPERTY, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (shutdownAction != <span class="keyword">null</span> &amp;&amp; shutdownAction.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> reboot = (shutdownAction.charAt(<span class="number">0</span>) == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String reason;</span><br><span class="line">        <span class="keyword">if</span> (shutdownAction.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            reason = shutdownAction.substring(<span class="number">1</span>, shutdownAction.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reason = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当&quot;sys.shutdown.requested&quot;值不为空,则会重启或者关机</span></span><br><span class="line">        ShutdownThread.rebootOrShutdown(<span class="keyword">null</span>, reboot, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-4、SystemServer-createSystemContext"><a href="#4-4-4、SystemServer-createSystemContext" class="headerlink" title="4.4.4、SystemServer.createSystemContext()"></a>4.4.4、SystemServer.createSystemContext()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建system_server进程的上下文信息</span></span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    <span class="comment">//设置主题</span></span><br><span class="line">    mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://gityuan.com/2017/04/02/android-application/">理解Application创建过程</a>已介绍过createSystemContext()过程， 该过程会创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application。</p>
<h4 id="4-4-5、SystemServer-startBootstrapServices"><a href="#4-4-5、SystemServer-startBootstrapServices" class="headerlink" title="4.4.5、SystemServer.startBootstrapServices()"></a>4.4.5、SystemServer.startBootstrapServices()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞等待与installd建立socket通道</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务ActivityManagerService</span></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务PowerManagerService</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化power management</span></span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务LightsService</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务DisplayManagerService</span></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Phase100: 在初始化package manager之前，需要默认的显示.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当设备正在加密时，仅运行核心</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">&quot;vold.decrypt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务PackageManagerService</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务UserManagerService，新建目录/data/user/</span></span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置AMS</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动传感器服务</span></span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务.</p>
<h4 id="4-4-5、SystemServer-startCoreServices"><a href="#4-4-5、SystemServer-startCoreServices" class="headerlink" title="4.4.5、SystemServer.startCoreServices()"></a>4.4.5、SystemServer.startCoreServices()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    &#x2F;&#x2F;启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动服务WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务BatteryService，UsageStatsService，WebViewUpdateService。</p>
<h4 id="4-4-6、SystemServer-startOtherServices"><a href="#4-4-6、SystemServer-startOtherServices" class="headerlink" title="4.4.6、SystemServer.startOtherServices()"></a>4.4.6、SystemServer.startOtherServices()</h4><p>该方法比较长，有近千行代码，逻辑很简单，主要是启动一系列的服务，这里就不具体列举源码了，在第四节直接对其中的服务进行一个简单分类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       SystemConfig.getInstance();</span><br><span class="line">       mContentResolver = context.getContentResolver(); <span class="comment">// resolver</span></span><br><span class="line">       ...</span><br><span class="line">       mActivityManagerService.installSystemProviders(); <span class="comment">//provider</span></span><br><span class="line">       mSystemServiceManager.startService(AlarmManagerService.class); // alarm</span><br><span class="line">       <span class="comment">// watchdog</span></span><br><span class="line">       watchdog.init(context, mActivityManagerService);</span><br><span class="line">       inputManager = <span class="keyword">new</span> InputManagerService(context); <span class="comment">// input</span></span><br><span class="line">       wm = WindowManagerService.main(...); <span class="comment">// window</span></span><br><span class="line">       inputManager.start();  <span class="comment">//启动input</span></span><br><span class="line">       mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">       ...</span><br><span class="line">       mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); <span class="comment">// mount</span></span><br><span class="line">       mPackageManagerService.performBootDexOpt();  <span class="comment">// dexopt操作</span></span><br><span class="line">       ActivityManagerNative.getDefault().showBootMessage(...); <span class="comment">//显示启动界面</span></span><br><span class="line">       ...</span><br><span class="line">       statusBar = <span class="keyword">new</span> StatusBarManagerService(context, wm); <span class="comment">//statusBar</span></span><br><span class="line">       <span class="comment">//dropbox</span></span><br><span class="line">       ServiceManager.addService(Context.DROPBOX_SERVICE,</span><br><span class="line">                   <span class="keyword">new</span> DropBoxManagerService(context, <span class="keyword">new</span> File(<span class="string">&quot;/data/system/dropbox&quot;</span>)));</span><br><span class="line">        mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler</span><br><span class="line">        lockSettings.systemReady(); <span class="comment">//lockSettings</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//phase480 和phase500</span></span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 准备好window, power, package, display服务</span></span><br><span class="line">       wm.systemReady();</span><br><span class="line">       mPowerManagerService.systemReady(...);</span><br><span class="line">       mPackageManagerService.systemReady();</span><br><span class="line">       mDisplayManagerService.systemReady(...);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//重头戏</span></span><br><span class="line">       mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-7、服务启动阶段"><a href="#4-4-7、服务启动阶段" class="headerlink" title="4.4.7、服务启动阶段"></a>4.4.7、服务启动阶段</h4><p>SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N13-android-system-start-system_server_boot_process.jpg" alt="Markdown"></p>
<p>其中PHASE_BOOT_COMPLETED=1000，该阶段是发生在Boot完成和home应用启动完毕。系统服务更倾向于监听该阶段，而不是注册广播ACTION_BOOT_COMPLETED，从而降低系统延迟。</p>
<p>各个启动阶段所在源码的大致位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//phase100</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//phase480 &amp;&amp; 500</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//phase550</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">//phase600</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来再说说简单每个阶段的大概完成的工作：</p>
<h5 id="4-4-7-1、Phase0"><a href="#4-4-7-1、Phase0" class="headerlink" title="4.4.7.1、Phase0"></a>4.4.7.1、Phase0</h5><p>创建四大引导服务:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService</span><br><span class="line">PowerManagerService</span><br><span class="line">LightsService</span><br><span class="line">DisplayManagerService</span><br></pre></td></tr></table></figure>

<h5 id="4-4-7-1-2、Phase100"><a href="#4-4-7-1-2、Phase100" class="headerlink" title="4.4.7.1.2、Phase100"></a>4.4.7.1.2、Phase100</h5><p>进入阶段PHASE_WAIT_FOR_DEFAULT_DISPLAY=100回调服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">DisplayManagerService</span><br></pre></td></tr></table></figure>

<p>然后创建大量服务下面列举部分:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PackageManagerService</span><br><span class="line">WindowManagerService</span><br><span class="line">InputManagerService</span><br><span class="line">NetworkManagerService</span><br><span class="line">DropBoxManagerService</span><br><span class="line">FingerprintService</span><br><span class="line">LauncherAppsService</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<h5 id="4-4-7-1-3、Phase480"><a href="#4-4-7-1-3、Phase480" class="headerlink" title="4.4.7.1.3、Phase480"></a>4.4.7.1.3、Phase480</h5><p>进入阶段PHASE_LOCK_SETTINGS_READY=480回调服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">480</span>)</span><br><span class="line"></span><br><span class="line">DevicePolicyManagerService</span><br></pre></td></tr></table></figure>

<p>阶段480后马上就进入阶段500.</p>
<h5 id="4-4-7-1-4、Phase500"><a href="#4-4-7-1-4、Phase500" class="headerlink" title="4.4.7.1.4、Phase500"></a>4.4.7.1.4、Phase500</h5><p>PHASE_SYSTEM_SERVICES_READY=500，进入该阶段服务能安全地调用核心系统服务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">AlarmManagerService</span><br><span class="line">JobSchedulerService</span><br><span class="line">NotificationManagerService</span><br><span class="line">BackupManagerService</span><br><span class="line">UsageStatsService</span><br><span class="line">DeviceIdleController</span><br><span class="line">TrustManagerService</span><br><span class="line">UiModeManagerService</span><br><span class="line">BluetoothService</span><br><span class="line">BluetoothManagerService</span><br><span class="line">EthernetService</span><br><span class="line">WifiP2pService</span><br><span class="line">WifiScanningService</span><br><span class="line">WifiService</span><br><span class="line">RttService</span><br></pre></td></tr></table></figure>

<p>各大服务执行systemReady():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerService.systemReady():</span><br><span class="line">PowerManagerService.systemReady():</span><br><span class="line">PackageManagerService.systemReady():</span><br><span class="line">DisplayManagerService.systemReady():</span><br></pre></td></tr></table></figure>

<p>接下来就绪AMS.systemReady方法.</p>
<h5 id="4-4-7-1-5、Phase550"><a href="#4-4-7-1-5、Phase550" class="headerlink" title="4.4.7.1.5、Phase550"></a>4.4.7.1.5、Phase550</h5><p>PHASE_ACTIVITY_MANAGER_READY=550， AMS.mSystemReady=true, 已准备就绪,进入该阶段服务能广播Intent;但是system_server主线程并没有就绪.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">550</span>)</span><br><span class="line"></span><br><span class="line">MountService</span><br><span class="line">TelecomLoaderService</span><br><span class="line">UsbService</span><br><span class="line">WebViewUpdateService</span><br><span class="line">DockObserver</span><br><span class="line">BatteryService</span><br></pre></td></tr></table></figure>

<p>接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUI等),如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line">startSystemUi(context);</span><br><span class="line">networkScoreF.systemReady();</span><br><span class="line">networkManagementF.systemReady();</span><br><span class="line">networkStatsF.systemReady();</span><br><span class="line">networkPolicyF.systemReady();</span><br><span class="line">connectivityF.systemReady();</span><br><span class="line">audioServiceF.systemReady();</span><br><span class="line">Watchdog.getInstance().start();</span><br></pre></td></tr></table></figure>

<h5 id="4-4-7-1-6、Phase600"><a href="#4-4-7-1-6、Phase600" class="headerlink" title="4.4.7.1.6、Phase600"></a>4.4.7.1.6、Phase600</h5><p>PHASE_THIRD_PARTY_APPS_CAN_START=600</p>
<p>onBootPhase(600)</p>
<blockquote>
<p>JobSchedulerService<br>NotificationManagerService<br>BackupManagerService<br>AppWidgetService<br>GestureLauncherService<br>DreamManagerService<br>TrustManagerService<br>VoiceInteractionManagerService</p>
</blockquote>
<p>接下来,各种服务的systemRunning过程:</p>
<p>WallpaperManagerService、InputMethodManagerService、LocationManagerService、CountryDetectorService、NetworkTimeUpdateService、CommonTimeManagementService、TextServicesManagerService、AssetAtlasService、InputManagerService、TelephonyRegistry、MediaRouterService、MmsServiceBroker这些服务依次执行其systemRunning()方法。</p>
<h5 id="4-4-7-1-7、Phase1000"><a href="#4-4-7-1-7、Phase1000" class="headerlink" title="4.4.7.1.7、Phase1000"></a>4.4.7.1.7、Phase1000</h5><p>在经过一系列流程，再调用AMS.finishBooting()时，则进入阶段Phase1000。</p>
<p>到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入Looper.loop()状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。</p>
<h4 id="4-4-8、服务类别"><a href="#4-4-8、服务类别" class="headerlink" title="4.4.8、服务类别"></a>4.4.8、服务类别</h4><p>system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。 以下这些系统服务的注册过程, 见Android系统服务的注册方式</p>
<p>引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService； 核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService； 其他服务(70个+)：AlarmManagerService、VibratorService等。 合计总大约80个系统服务：</p>
<blockquote>
<p>ActivityManagerService PackageManagerService WindowManagerService PowerManagerService BatteryService BatteryStatsService DreamManagerService DropBoxManagerService SamplingProfilerService UsageStatsService DiskStatsService DeviceStorageMonitorService SchedulingPolicyService AlarmManagerService DeviceIdleController ThermalObserver JobSchedulerService AccessibilityManagerService DisplayManagerService LightsService GraphicsStatsService StatusBarManagerService NotificationManagerService WallpaperManagerService UiModeManagerService AppWidgetService LauncherAppsService TextServicesManagerService ContentService LockSettingsService InputMethodManagerService InputManagerService MountService FingerprintService TvInputManagerService DockObserver NetworkManagementService NetworkScoreService NetworkStatsService NetworkPolicyManagerService ConnectivityService BluetoothService WifiP2pService WifiService WifiScanningService AudioService MediaRouterService VoiceInteractionManagerService MediaProjectionManagerService MediaSessionService<br><br>DevicePolicyManagerService PrintManagerService BackupManagerService UserManagerService AccountManagerService TrustManagerService SensorService LocationManagerService VibratorService CountryDetectorService GestureLauncherService PersistentDataBlockService EthernetService WebViewUpdateService ClipboardService TelephonyRegistry TelecomLoaderService NsdService UpdateLockService SerialService SearchManagerService CommonTimeManagementService AssetAtlasService ConsumerIrService MidiServiceCameraService TwilightService RestrictionsManagerService MmsServiceBroker RttService UsbService</p>
</blockquote>
<p>Service类别众多，其中表中加粗项是指博主挑选的较重要或者较常见的Service，并且在本博客中已经展开或者计划展开讲解的Service，当然如果有精力会讲解更多service，后续再更新。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N15-android-system-start-AMS.jpg" alt="Markdown"></p>
<h3 id="（5）、启动ActivityManagerService"><a href="#（5）、启动ActivityManagerService" class="headerlink" title="（5）、启动ActivityManagerService"></a>（5）、启动ActivityManagerService</h3><h4 id="4-5-1、概述"><a href="#4-5-1、概述" class="headerlink" title="4.5.1、概述"></a>4.5.1、概述</h4><p>ActivityManagerService(AMS)是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。</p>
<p>AMS通信结构如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N14-android-system-start-.png" alt="Markdown"></p>
<h4 id="4-5-2、SystemServer-startBootstrapServices"><a href="#4-5-2、SystemServer-startBootstrapServices" class="headerlink" title="4.5.2、SystemServer.startBootstrapServices()"></a>4.5.2、SystemServer.startBootstrapServices()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//启动AMS服务</span></span><br><span class="line">mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">        ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置AMS的系统服务管理器</span></span><br><span class="line">mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line"><span class="comment">//设置AMS的APP安装器</span></span><br><span class="line">mActivityManagerService.setInstaller(installer);</span><br><span class="line"><span class="comment">//初始化AMS相关的PMS</span></span><br><span class="line">mActivityManagerService.initPowerManagement();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置SystemServer</span></span><br><span class="line">mActivityManagerService.setSystemProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3、启动AMS服务"><a href="#4-5-3、启动AMS服务" class="headerlink" title="4.5.3、启动AMS服务"></a>4.5.3、启动AMS服务</h4><p>SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要：</p>
<p>创建ActivityManagerService.Lifecycle对象； 调用Lifecycle.onStart()方法。</p>
<h4 id="4-5-4、启动AMS服务"><a href="#4-5-4、启动AMS服务" class="headerlink" title="4.5.4、启动AMS服务"></a>4.5.4、启动AMS服务</h4><p><strong>4.5.4.1 AMS.Lifecycle</strong> [-&gt; ActivityManagerService.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    <span class="comment">//创建ActivityManagerService</span></span><br><span class="line">    mService = <span class="keyword">new</span> ActivityManagerService(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mService.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start();</p>
<p><strong>4.5.4.2 AMS创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">mContext = systemContext;</span><br><span class="line">mFactoryTest = FactoryTest.getMode();<span class="comment">//默认为FACTORY_TEST_OFF</span></span><br><span class="line">mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建名为&quot;ActivityManager&quot;的前台线程，并获取mHandler</span></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span>);</span><br><span class="line">mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过UiThread类，创建名为&quot;android.ui&quot;的线程</span></span><br><span class="line">mUiHandler = <span class="keyword">new</span> UiHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">//前台广播接收器，在运行超过10s将放弃执行</span></span><br><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">&quot;foreground&quot;</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//后台广播接收器，在运行超过60s将放弃执行</span></span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">&quot;background&quot;</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ActiveServices，其中非低内存手机mMaxStartingBackground为8</span></span><br><span class="line">mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line">mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建目录/data/system</span></span><br><span class="line">File dataDir = Environment.getDataDirectory();</span><br><span class="line">File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">&quot;system&quot;</span>);</span><br><span class="line">systemDir.mkdirs();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务BatteryStatsService</span></span><br><span class="line">mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemDir, mHandler);</span><br><span class="line">mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程统计服务，信息保存在目录/data/system/procstats，</span></span><br><span class="line">mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">&quot;procstats&quot;</span>));</span><br><span class="line"></span><br><span class="line">mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;appops.xml&quot;</span>), mHandler);</span><br><span class="line">mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;urigrants.xml&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 0是第一个，也是唯一的一个开机过程中运行的用户</span></span><br><span class="line">mStartedUsers.put(UserHandle.USER_OWNER, <span class="keyword">new</span> UserState(UserHandle.OWNER, <span class="keyword">true</span>));</span><br><span class="line">mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">updateStartedUserArrayLocked();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU使用情况的追踪器执行初始化</span></span><br><span class="line">mProcessCpuTracker.init();</span><br><span class="line">...</span><br><span class="line">mRecentTasks = <span class="keyword">new</span> RecentTasks(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 创建ActivityStackSupervisor对象</span></span><br><span class="line">mStackSupervisor = <span class="keyword">new</span> ActivityStackSupervisor(<span class="keyword">this</span>, mRecentTasks);</span><br><span class="line">mTaskPersister = <span class="keyword">new</span> TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建名为&quot;CpuTracker&quot;的线程</span></span><br><span class="line">mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">&quot;CpuTracker&quot;</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">              <span class="keyword">long</span> nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">              <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">              <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                  nextCpuDelay = nextWriteDelay;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          updateCpuStatsNow(); <span class="comment">//更新CPU状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.5.4.3、AMS的start函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成统计前的复位工作</span></span><br><span class="line">    Process.removeAllProcessGroups();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始监控进程的CPU使用情况</span></span><br><span class="line">    mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册服务</span></span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    Slog.d(<span class="string">&quot;AppOps&quot;</span>, <span class="string">&quot;AppOpsService published&quot;</span>);</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br></pre></td></tr></table></figure>

<p>AMS的start函数比较简单，主要是： 1、启动CPU监控线程。该线程将会开始统计不同进程使用CPU的情况。 2、发布一些服务，如BatteryStatsService、AppOpsService(权限管理相关)和本地实现的继承ActivityManagerInternal的服务。</p>
<h4 id="4-5-5-AMS-setSystemProcess"><a href="#4-5-5-AMS-setSystemProcess" class="headerlink" title="4.5.5 AMS.setSystemProcess()"></a><strong>4.5.5 AMS.setSystemProcess()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;meminfo&quot;</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;gfxinfo&quot;</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;dbinfo&quot;</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;cpuinfo&quot;</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;permission&quot;</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;processinfo&quot;</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                <span class="string">&quot;android&quot;</span>, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//创建ProcessRecord对象</span></span><br><span class="line">            ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">            app.persistent = <span class="keyword">true</span>; <span class="comment">//设置为persistent进程</span></span><br><span class="line">            app.pid = MY_PID;</span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);<span class="comment">//维护进程lru</span></span><br><span class="line">            updateOomAdjLocked(); <span class="comment">//更新adj</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要工作是注册各种服务。</p>
<p><strong>4.5.5.1 AT.installSystemApplicationInfo()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        getSystemContext().installSystemApplicationInfo(info, classLoader);</span><br><span class="line">        <span class="comment">//创建用于性能统计的Profiler对象</span></span><br><span class="line">        mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为”android”的package</p>
<p><strong>4.5.5.2 installSystemApplicationInfo()</strong> [-&gt; LoadedApk.java]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> info.packageName.equals(<span class="string">&quot;android&quot;</span>);</span><br><span class="line">    mApplicationInfo = info; <span class="comment">//将包名为&quot;android&quot;的应用信息保存到mApplicationInfo</span></span><br><span class="line">    mClassLoader = classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-6-startOtherServices"><a href="#4-5-6-startOtherServices" class="headerlink" title="4.5.6 startOtherServices()"></a><strong>4.5.6 startOtherServices()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//安装系统Provider</span></span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//phase480 &amp;&amp; 500</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//phase550</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">//phase600</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.5.6.1 AMS.installSystemProviders()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ProcessRecord app = mProcessNames.get(<span class="string">&quot;system&quot;</span>, Process.SYSTEM_UID);</span><br><span class="line">        providers = generateApplicationProvidersLocked(app);</span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=providers.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                <span class="comment">//移除非系统的provider</span></span><br><span class="line">                <span class="keyword">if</span> ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//安装所有的系统provider</span></span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建核心Settings Observer，用于监控Settings的改变。</span></span><br><span class="line">    mCoreSettingsObserver = <span class="keyword">new</span> CoreSettingsObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-7、AMS-systemReady"><a href="#4-5-7、AMS-systemReady" class="headerlink" title="4.5.7、AMS.systemReady()"></a>4.5.7、AMS.systemReady()</h4><h4 id="4-5-7-1、阶段一"><a href="#4-5-7-1、阶段一" class="headerlink" title="4.5.7.1、阶段一"></a>4.5.7.1、阶段一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ..........</span><br><span class="line">        <span class="comment">//这一部分主要是调用一些关键服务SystemReady相关的函数，</span></span><br><span class="line">        <span class="comment">//进行一些等待AMS初始完，才能进行的工作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure we have the current profile info, since it is needed for security checks.</span></span><br><span class="line">        mUserController.onSystemReady();</span><br><span class="line"></span><br><span class="line">        mRecentTasks.onSystemReadyLocked();</span><br><span class="line">        mAppOpsService.systemReady();</span><br><span class="line">        mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procsToKill = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(mPidsSelfLocked) &#123;</span><br><span class="line">        <span class="comment">//mPidsSelfLocked中保存当前正在运行的所有进程的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPidsSelfLocked.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProcessRecord proc = mPidsSelfLocked.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在AMS启动完成前，如果没有FLAG_PERSISTENT标志的进程已经启动了，</span></span><br><span class="line">            <span class="comment">//就将这个进程加入到procsToKill中</span></span><br><span class="line">            <span class="keyword">if</span> (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">                <span class="keyword">if</span> (procsToKill == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    procsToKill = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                procsToKill.add(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//利用removeProcessLocked关闭procsToKill中的进程</span></span><br><span class="line">        <span class="keyword">if</span> (procsToKill != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=procsToKill.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProcessRecord proc = procsToKill.get(i);</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;Removing system update proc: &quot;</span> + proc);</span><br><span class="line">                removeProcessLocked(proc, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">&quot;system update done&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that we have cleaned up any update processes, we</span></span><br><span class="line">        <span class="comment">// are ready to start launching real processes and know that</span></span><br><span class="line">        <span class="comment">// we won&#x27;t trample on them any more.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//至此系统准备完毕</span></span><br><span class="line">        mProcessesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//根据数据库和资源文件，获取一些配置参数</span></span><br><span class="line">    retrieveSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//得到当前的用户ID</span></span><br><span class="line">        currentUserId = mUserController.getCurrentUserIdLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取urigrants.xml，为其中定义的ContentProvider配置对指定Uri数据的访问/修改权限</span></span><br><span class="line">        <span class="comment">//原生代码中，似乎没有urigrants.xml文件</span></span><br><span class="line">        <span class="comment">//实际使用的grant-uri-permission是分布式定义的</span></span><br><span class="line">        readGrantedUriPermissionsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure>

<p>这一部分的工作主要是调用一些关键服务的初始化函数， 然后杀死那些没有FLAG_PERSISTENT却在AMS启动完成前已经存在的进程， 同时获取一些配置参数。 需要注意的是，由于只有Java进程才会向AMS注册，而一般的Native进程不会向AMS注册，因此此处杀死的进程是Java进程。</p>
<h4 id="4-5-7-2、阶段二"><a href="#4-5-7-2、阶段二" class="headerlink" title="4.5.7.2、阶段二"></a>4.5.7.2、阶段二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、调用参数传入的runnable对象，SystemServer中有具体的定义</span></span><br><span class="line"><span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line">..............</span><br><span class="line"><span class="comment">//调用所有系统服务的onStartUser接口</span></span><br><span class="line">mSystemServiceManager.startUser(currentUserId);</span><br><span class="line">.............</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// Only start up encryption-aware persistent apps; once user is</span></span><br><span class="line">    <span class="comment">// unlocked we&#x27;ll come back around and start unaware apps</span></span><br><span class="line">    <span class="number">2</span>、启动persistent为<span class="number">1</span>的application所在的进程</span><br><span class="line">    startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up initial activity.</span></span><br><span class="line">    mBooting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable home activity for system user, so that the system can always boot</span></span><br><span class="line">    <span class="comment">//当isSplitSystemUser返回true时，意味者system user和primary user是分离的</span></span><br><span class="line">    <span class="comment">//这里应该是让system user也有启动home activity的权限吧</span></span><br><span class="line">    <span class="keyword">if</span> (UserManager.isSplitSystemUser()) &#123;</span><br><span class="line">        ComponentName cName = <span class="keyword">new</span> ComponentName(mContext, SystemUserHomeActivity.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setComponentEnabledSetting(cName,</span><br><span class="line">                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED, <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_SYSTEM);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、启动Home</span></span><br><span class="line">    startHomeActivityLocked(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送消息，触发处理Uid错误的Application</span></span><br><span class="line">        <span class="keyword">if</span> (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123;</span><br><span class="line">            ..........</span><br><span class="line">            mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送一些广播信息</span></span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//这里暂时先不深入，等进一步了解Activity的启动过程后，再做了解</span></span><br><span class="line">    mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>

<p>从部分代码来看，主要的工作就是通知一些服务可以进行systemReady相关的工作，并进行启动服务或应用进程的工作。</p>
<h4 id="2-1、调用回调接口"><a href="#2-1、调用回调接口" class="headerlink" title="2.1、调用回调接口"></a>2.1、调用回调接口</h4><p>回调接口的具体内容定义与SystemServer.java中，其中会调用大量服务的onBootPhase函数、一些对象的systemReady函数或systemRunning函数。 此处，我们仅截取一些比较特别的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ............</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动NativeCrashListener监听&quot;/data/system/ndebugsocket&quot;中的信息</span></span><br><span class="line">        <span class="comment">//实际上是监听debuggerd传入的信息</span></span><br><span class="line">        mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;observing native crashes&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动SystemUi</span></span><br><span class="line">        startSystemUi(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;starting System UI&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//这个以前分析过，启动Watchdog</span></span><br><span class="line">    Watchdog.getInstance().start();</span><br><span class="line">    ....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调接口中的内容较多，不做一一分析。</p>
<h4 id="2-2、启动persistent标志的进程"><a href="#2-2、启动persistent标志的进程" class="headerlink" title="2.2、启动persistent标志的进程"></a>2.2、启动persistent标志的进程</h4><p>我们看看startPersistentApps对应的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPersistentApps</span><span class="params">(<span class="keyword">int</span> matchFlags)</span> </span>&#123;</span><br><span class="line">    .............</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从PKMS中得到persistent为1的ApplicationInfo</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()</span><br><span class="line">                    .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo app : apps) &#123;</span><br><span class="line">                <span class="comment">//由于framework-res.apk已经由系统启动，所以此处不再启动它</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;android&quot;</span>.equals(app.packageName)) &#123;</span><br><span class="line">                    <span class="comment">//addAppLocked中将启动application所在进程</span></span><br><span class="line">                    addAppLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进一下addAppLocked函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">addAppLocked</span><span class="params">(ApplicationInfo info, <span class="keyword">boolean</span> isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以下是取出或构造出ApplicationInfo对应的ProcessRecord</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(info.processName, info.uid, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="comment">// This package really, really can not be stopped.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PKMS将package对应数据结构的StoppedState置为fasle</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                info.packageName, <span class="keyword">false</span>, UserHandle.getUserId(app.uid));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed trying to unstop package &quot;</span></span><br><span class="line">                + info.packageName + <span class="string">&quot;: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        app.persistent = <span class="keyword">true</span>;</span><br><span class="line">        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPersistentStartingProcesses.add(app);</span><br><span class="line">        <span class="comment">//启动应用所在进程，将发送消息给zygote，后者fork出进程</span></span><br><span class="line">        startProcessLocked(app, <span class="string">&quot;added application&quot;</span>, app.processName, abiOverride,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终将通过startProcessLocked函数，启动实际的应用进程。 正如之前分析zygote进程时，提过的一样，zygote中的server socket将接收消息，然后为应用fork出进程。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于整个AMS启动过程而言，博客中涉及的内容可能只是极小的一部分。 但即使我们尽可能的简化，整个过程的内容还是非常多。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.boot/N16-android-system-start-flow.jpg" alt="Markdown"><br>不过我们回头看看整个过程，还是能比较清晰地将AMS的启动过程分为四步，如上图所示： 1、创建出SystemServer进程的Android运行环境。 在这一部分，SystemServer进程主要创建出对应的ActivityThread和ContextImpl，构成Android运行环境。 AMS的后续工作依赖于SystemServer在此创建出的运行环境。</p>
<p>2、完成AMS的初始化和启动。 在这一部分，单纯地调用AMS的构造函数和start函数，完成AMS的一些初始化工作。</p>
<p>3、将SystemServer进程纳入到AMS的管理体系中。 AMS作为Java世界的进程管理和调度中心，要对所有Java进程一视同仁，因此SystemServer进程也必须被AMS管理。 在这个过程中，AMS加载了SystemServer中framework-res.apk的信息，并启动和注册了SettingsProvider.apk。</p>
<p>4、开始执行AMS启动完毕后才能进行的工作。 系统中的一些服务和进程，必须等待AMS完成启动后，才能展开后续工作。 在这一部分，AMS通过调用systemReady函数，通知系统中的其它服务和进程，可以进行对应工作了。 在这个过程中，值得我们关注的是：Home Activity被启动了。当该Activity被加载完成后，最终会触发ACTION_BOOT_COMPLETED广播。</p>
<h4 id="（6）、启动Launcher-Activity"><a href="#（6）、启动Launcher-Activity" class="headerlink" title="（6）、启动Launcher(Activity)"></a>（6）、启动Launcher(Activity)</h4><p>看看启动Home Activity对应的startHomeActivityLocked函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    ..............</span><br><span class="line">    Intent intent = getHomeIntent();</span><br><span class="line">    <span class="comment">//根据intent中携带的ComponentName，利用PKMS得到ActivityInfo</span></span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时home对应进程应该还没启动，app为null</span></span><br><span class="line">        ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            <span class="comment">//启动home</span></span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ..........</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里暂时先不深究Home Activity启动的具体过程。 从手头的资料来看，当Home Activity启动后， ActivityStackSupervisor中的activityIdleInternalLocked函数将被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config)</span> </span>&#123;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="keyword">if</span> (isFocusedStack(r.task.stack) || fromTimeout) &#123;</span><br><span class="line">        booting = checkFinishBootingLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在checkFinishBootingLocked函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFinishBootingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mService为AMS，mBooting变量在AMS回调SystemServer中定义的Runnable时，置为了true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> booting = mService.mBooting;</span><br><span class="line">    <span class="keyword">boolean</span> enableScreen = <span class="keyword">false</span>;</span><br><span class="line">    mService.mBooting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooted) &#123;</span><br><span class="line">        mService.mBooted = <span class="keyword">true</span>;</span><br><span class="line">        enableScreen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (booting || enableScreen) &#123;、</span><br><span class="line">        <span class="comment">//调用AMS的接口，发送消息</span></span><br><span class="line">        mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> booting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，AMS的finishBooting函数将被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishBooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .........</span><br><span class="line">    <span class="comment">//以下是注册广播接收器，用于处理需要重启的package</span></span><br><span class="line">    IntentFilter pkgFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">    pkgFilter.addDataScheme(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);</span><br><span class="line">            <span class="keyword">if</span> (pkgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String pkg : pkgs) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (forceStopPackageLocked(pkg, -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                                <span class="number">0</span>, <span class="string">&quot;query restart&quot;</span>)) &#123;</span><br><span class="line">                            setResultCode(Activity.RESULT_OK);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, pkgFilter);</span><br><span class="line">    ...........</span><br><span class="line">    <span class="comment">// Let system services know.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是启动那些等待启动的进程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// Ensure that any processes we had put on hold are now started</span></span><br><span class="line">        <span class="comment">// up.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NP = mProcessesOnHold.size();</span><br><span class="line">            <span class="keyword">if</span> (NP &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ArrayList&lt;ProcessRecord&gt; procs =</span><br><span class="line">                        <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ip=<span class="number">0</span>; ip&lt;NP; ip++) &#123;</span><br><span class="line">                    .................</span><br><span class="line">                    startProcessLocked(procs.get(ip), <span class="string">&quot;on-hold&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ..............</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="comment">// Start looking for apps that are abusing wake locks.</span></span><br><span class="line">        <span class="comment">//每15min检查一次系统各应用进程使用电量的情况，如果某个进程使用WakeLock的时间过长</span></span><br><span class="line">        <span class="comment">//AMS将关闭该进程</span></span><br><span class="line">        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell anyone interested that we are done booting!</span></span><br><span class="line">        SystemProperties.set(<span class="string">&quot;sys.boot_completed&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        .................</span><br><span class="line">        <span class="comment">//此处从代码来看发送的是ACTION_LOCKED_BOOT_COMPLETED广播</span></span><br><span class="line">        <span class="comment">//在进行unlock相关的工作后，mUserController将调用finishUserUnlocking，发送SYSTEM_USER_UNLOCK_MSG消息给AMS</span></span><br><span class="line">        <span class="comment">//AMS收到消息后，调用mUserController的finishUserUnlocked函数，经过相应的处理后，</span></span><br><span class="line">        <span class="comment">//在mUserController的finishUserUnlockedCompleted中，最终将会发送ACTION_BOOT_COMPLETED广播</span></span><br><span class="line">        mUserController.sendBootCompletedLocked(.........);</span><br><span class="line">        .................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，当AMS启动Home Activity结束，并发送ACTION_BOOT_COMPLETED广播时，AMS的启动过程告一段落。</p>
<p>具体启动流程请参考：【Android 7.1.2 (Android N) Activity启动流程分析】</p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/Gaugamela/article/category/6383486">Android 7.0 ActivityManagerService 1 - 10</a><br><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/jay_richard/Android-Init%E8%BF%9B%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Android Init进程源码分析(1) - jay_richard</a><br><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/jay_richard/Android-Init%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%A7%A3%E6%9E%90init.rc">Android Init进程源码分析(2) - jay_richard</a><br><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/jay_richard/Android-Zygote%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90">Android Zygote进程分析 - jay_richard</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/samchen2009/p/3294713.html">图解Android - Zygote, System Server 启动分析 - 漫天尘沙 - 博客园</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/gaugamela/article/details/52133186">Android7.0 init进程源码分析 - ZhangJian的博客 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/02/20/android-system-server/">Android系统启动-SystemServer上篇 - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/02/05/android-init/">Android系统启动-Init篇 - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/02/13/android-zygote/">Android系统启动-zygote篇 - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/02/20/android-system-server-2/">Android系统启动-SystemServer下篇 - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/02/21/activity-manager-service/">ActivityManagerService启动过程 - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yangwen123/article/details/9029959">Android Init进程源码分析 - 深入剖析Android系统 - CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20171008/">https://zhoujinjian.com/posts/20171008/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20171108/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.03.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android N 基础（4）：Android 7.1.2 Activity 启动流程 （AMS）分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20170908/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.06.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android N 基础（2）：Android 7.1.2 Android Binder 系统分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">源码：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Android%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、Android概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二、系统启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">三、设备启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81Bootloader%E5%BC%95%E5%AF%BC"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1、Bootloader引导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E8%A3%85%E8%BD%BD%E5%92%8C%E5%90%AF%E5%8A%A8Linux%E5%86%85%E6%A0%B8"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2、装载和启动Linux内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E3%80%81%E5%90%AF%E5%8A%A8Init%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3、启动Init进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E3%80%81%E5%90%AF%E5%8A%A8Zygote%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4、启动Zygote进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E3%80%81%E5%90%AF%E5%8A%A8SystemServer"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5、启动SystemServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6%E3%80%81%E5%90%AF%E5%8A%A8ActivityManagerService"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6、启动ActivityManagerService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7%E3%80%81%E5%90%AF%E5%8A%A8Launcher-Activity"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7、启动Launcher(Activity)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E5%A4%87%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">四、设备启动过程详细分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8Init%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">（1）、启动Init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E3%80%81main"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1.1、main()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%E3%80%81%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E5%B9%B6%E6%8C%82%E8%BD%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.1.2、创建文件系统目录并挂载相关的文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3%E3%80%81%E5%B1%8F%E8%94%BD%E6%A0%87%E5%87%86%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.1.3、屏蔽标准的输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E6%A0%B8log%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.1.4、初始化内核log系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B1%9E%E6%80%A7%E5%9F%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.1.5、初始化属性域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6%E3%80%81%E5%AE%8C%E6%88%90SELinux%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.5.6.</span> <span class="toc-text">4.1.6、完成SELinux相关工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-7%E3%80%81%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.7.</span> <span class="toc-text">4.1.7、重新设置属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-8%E3%80%81%E5%88%9B%E5%BB%BAepoll%E5%8F%A5%E6%9F%84"><span class="toc-number">1.5.8.</span> <span class="toc-text">4.1.8、创建epoll句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-9%E3%80%81%E8%A3%85%E8%BD%BD%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.5.9.</span> <span class="toc-text">4.1.9、装载子进程信号处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-10%E3%80%81%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.10.</span> <span class="toc-text">4.1.10、设置默认系统属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-11%E3%80%81%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.5.11.</span> <span class="toc-text">4.1.11、配置属性的服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-12%E3%80%81%E8%A7%A3%E6%9E%90init-rc%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.12.</span> <span class="toc-text">4.1.12、解析init.rc文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-12-1-ServiceParser"><span class="toc-number">1.5.12.1.</span> <span class="toc-text">4.1.12.1 ServiceParser</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-12-2-ActionParser"><span class="toc-number">1.5.13.</span> <span class="toc-text">4.1.12.2 ActionParser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-13%E3%80%81%E5%90%91%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%B6%E5%AE%83action"><span class="toc-number">1.5.14.</span> <span class="toc-text">4.1.13、向执行队列中添加其它action</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-14%E3%80%81%E5%A4%84%E7%90%86%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.15.</span> <span class="toc-text">4.1.14、处理添加到运行队列的事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8Zygote%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">（2）、启动Zygote进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">4.2.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E3%80%81Zygote%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">4.2.2、Zygote启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-1%E3%80%81App-main-main"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">4.2.2.1、App_main.main()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-2%E3%80%81AndroidRuntime-start"><span class="toc-number">1.6.3.</span> <span class="toc-text">4.2.2.2、AndroidRuntime.start()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-3%E3%80%81AndroidRuntime-startVm"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.2.2.3、AndroidRuntime.startVm()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4%E3%80%81AndroidRuntime-startReg"><span class="toc-number">1.6.5.</span> <span class="toc-text">4.2.2.4、AndroidRuntime.startReg()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4-1%E3%80%81Threads-androidSetCreateThreadFunc"><span class="toc-number">1.6.6.</span> <span class="toc-text">4.2.2.4.1、Threads.androidSetCreateThreadFunc()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4-2%E3%80%81register-jni-procs"><span class="toc-number">1.6.7.</span> <span class="toc-text">4.2.2.4.2、register_jni_procs()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-4-3%E3%80%81gRegJNI-mProc"><span class="toc-number">1.6.8.</span> <span class="toc-text">4.2.2.4.3、gRegJNI.mProc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-5%E3%80%81%E8%BF%9B%E5%85%A5Java%E5%B1%82"><span class="toc-number">1.6.9.</span> <span class="toc-text">4.2.2.5、进入Java层</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-1%E3%80%81ZygoteInit-main"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">4.2.2.5.1、ZygoteInit.main()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-2%E3%80%81ZygoteInit-registerZygoteSocket"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">4.2.2.5.2、ZygoteInit.registerZygoteSocket()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-2%E3%80%81ZygoteInit-preload"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">4.2.2.5.2、ZygoteInit.preload()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-3%E3%80%81ZygoteInit-startSystemServer"><span class="toc-number">1.6.9.4.</span> <span class="toc-text">4.2.2.5.3、ZygoteInit.startSystemServer()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-4%E3%80%81ZygoteInit-runSelectLoop"><span class="toc-number">1.6.9.5.</span> <span class="toc-text">4.2.2.5.4、ZygoteInit.runSelectLoop()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-5-4%E3%80%81ZygoteConnection-runOnce"><span class="toc-number">1.6.9.6.</span> <span class="toc-text">4.2.2.5.4、ZygoteConnection.runOnce()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-6%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.9.7.</span> <span class="toc-text">4.2.2.6、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8SystemServer%E4%B8%8A%E7%AF%87"><span class="toc-number">1.7.</span> <span class="toc-text">（3）、启动SystemServer上篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">4.3.1、启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2%E3%80%81ZygoteInit-startSystemServer"><span class="toc-number">1.7.2.</span> <span class="toc-text">4.3.2、ZygoteInit.startSystemServer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3%E3%80%81Zygote-forkSystemServer"><span class="toc-number">1.7.3.</span> <span class="toc-text">4.3.3、Zygote. forkSystemServer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4%E3%80%81com-android-internal-os-Zygote-nativeForkSystemServer"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5%E3%80%81com-android-internal-os-Zygote-ForkAndSpecializeCommon"><span class="toc-number">1.7.5.</span> <span class="toc-text">4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5%E3%80%81ZygoteInit-handleSystemServerProcess"><span class="toc-number">1.7.6.</span> <span class="toc-text">4.3.5、ZygoteInit.handleSystemServerProcess()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6%E3%80%81ZygoteInit-performSystemServerDexOpt"><span class="toc-number">1.7.7.</span> <span class="toc-text">4.3.6、ZygoteInit.performSystemServerDexOpt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-7%E3%80%81RuntimeInit-zygoteInit"><span class="toc-number">1.7.8.</span> <span class="toc-text">4.3.7、RuntimeInit.zygoteInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-8%E3%80%81RuntimeInit-commonInit"><span class="toc-number">1.7.9.</span> <span class="toc-text">4.3.8、RuntimeInit.commonInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-9%E3%80%81AndroidRuntime-nativeZygoteInit"><span class="toc-number">1.7.10.</span> <span class="toc-text">4.3.9、AndroidRuntime.nativeZygoteInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-10%E3%80%81RuntimeInit-applicationInit"><span class="toc-number">1.7.11.</span> <span class="toc-text">4.3.10、RuntimeInit.applicationInit()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-11%E3%80%81RuntimeInit-invokeStaticMain"><span class="toc-number">1.7.12.</span> <span class="toc-text">4.3.11、RuntimeInit.invokeStaticMain()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-12%E3%80%81MethodAndArgsCaller-run"><span class="toc-number">1.7.13.</span> <span class="toc-text">4.3.12、MethodAndArgsCaller.run()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8SystemServer%E4%B8%8B%E7%AF%87"><span class="toc-number">1.8.</span> <span class="toc-text">（4）、启动SystemServer下篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E3%80%81SystemServer-main"><span class="toc-number">1.8.1.</span> <span class="toc-text">4.4.1、SystemServer.main()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E3%80%81SystemServer-run"><span class="toc-number">1.8.2.</span> <span class="toc-text">4.4.2、SystemServer.run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E3%80%81SystemServer-performPendingShutdown"><span class="toc-number">1.8.3.</span> <span class="toc-text">4.4.3、SystemServer.performPendingShutdown()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4%E3%80%81SystemServer-createSystemContext"><span class="toc-number">1.8.4.</span> <span class="toc-text">4.4.4、SystemServer.createSystemContext()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5%E3%80%81SystemServer-startBootstrapServices"><span class="toc-number">1.8.5.</span> <span class="toc-text">4.4.5、SystemServer.startBootstrapServices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5%E3%80%81SystemServer-startCoreServices"><span class="toc-number">1.8.6.</span> <span class="toc-text">4.4.5、SystemServer.startCoreServices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-6%E3%80%81SystemServer-startOtherServices"><span class="toc-number">1.8.7.</span> <span class="toc-text">4.4.6、SystemServer.startOtherServices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-7%E3%80%81%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5"><span class="toc-number">1.8.8.</span> <span class="toc-text">4.4.7、服务启动阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1%E3%80%81Phase0"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">4.4.7.1、Phase0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-2%E3%80%81Phase100"><span class="toc-number">1.8.8.2.</span> <span class="toc-text">4.4.7.1.2、Phase100</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-3%E3%80%81Phase480"><span class="toc-number">1.8.8.3.</span> <span class="toc-text">4.4.7.1.3、Phase480</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-4%E3%80%81Phase500"><span class="toc-number">1.8.8.4.</span> <span class="toc-text">4.4.7.1.4、Phase500</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-5%E3%80%81Phase550"><span class="toc-number">1.8.8.5.</span> <span class="toc-text">4.4.7.1.5、Phase550</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-6%E3%80%81Phase600"><span class="toc-number">1.8.8.6.</span> <span class="toc-text">4.4.7.1.6、Phase600</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-7-1-7%E3%80%81Phase1000"><span class="toc-number">1.8.8.7.</span> <span class="toc-text">4.4.7.1.7、Phase1000</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-8%E3%80%81%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%88%AB"><span class="toc-number">1.8.9.</span> <span class="toc-text">4.4.8、服务类别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8ActivityManagerService"><span class="toc-number">1.9.</span> <span class="toc-text">（5）、启动ActivityManagerService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">4.5.1、概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2%E3%80%81SystemServer-startBootstrapServices"><span class="toc-number">1.9.2.</span> <span class="toc-text">4.5.2、SystemServer.startBootstrapServices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3%E3%80%81%E5%90%AF%E5%8A%A8AMS%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.3.</span> <span class="toc-text">4.5.3、启动AMS服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4%E3%80%81%E5%90%AF%E5%8A%A8AMS%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.9.4.</span> <span class="toc-text">4.5.4、启动AMS服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-5-AMS-setSystemProcess"><span class="toc-number">1.9.5.</span> <span class="toc-text">4.5.5 AMS.setSystemProcess()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-6-startOtherServices"><span class="toc-number">1.9.6.</span> <span class="toc-text">4.5.6 startOtherServices()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7%E3%80%81AMS-systemReady"><span class="toc-number">1.9.7.</span> <span class="toc-text">4.5.7、AMS.systemReady()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7-1%E3%80%81%E9%98%B6%E6%AE%B5%E4%B8%80"><span class="toc-number">1.9.8.</span> <span class="toc-text">4.5.7.1、阶段一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7-2%E3%80%81%E9%98%B6%E6%AE%B5%E4%BA%8C"><span class="toc-number">1.9.9.</span> <span class="toc-text">4.5.7.2、阶段二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.10.</span> <span class="toc-text">2.1、调用回调接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E5%90%AF%E5%8A%A8persistent%E6%A0%87%E5%BF%97%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.9.11.</span> <span class="toc-text">2.2、启动persistent标志的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.12.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E3%80%81%E5%90%AF%E5%8A%A8Launcher-Activity"><span class="toc-number">1.9.13.</span> <span class="toc-text">（6）、启动Launcher(Activity)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%EF%BC%9A"><span class="toc-number">1.10.</span> <span class="toc-text">参考文档：</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>