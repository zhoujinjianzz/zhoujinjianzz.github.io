<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析 | zhoujinjian</title><meta name="keywords" content="Android,Input"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="源码（部分）： kernel&#x2F;msm-3.18&#x2F;include&#x2F;linux  Input.h evdev.h  kernel&#x2F;msm-3.18&#x2F;drivers&#x2F;input  Input.c evdev.c gpio_keys.c  kernel&#x2F;msm-3.18&#x2F;drivers&#x2F;input&#x2F;touchscreen&#x2F;synaptics_dsx_htc_2.6  Makefile Kconfig sy">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20180208/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="源码（部分）： kernel&#x2F;msm-3.18&#x2F;include&#x2F;linux  Input.h evdev.h  kernel&#x2F;msm-3.18&#x2F;drivers&#x2F;input  Input.c evdev.c gpio_keys.c  kernel&#x2F;msm-3.18&#x2F;drivers&#x2F;input&#x2F;touchscreen&#x2F;synaptics_dsx_htc_2.6  Makefile Kconfig sy">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg">
<meta property="article:published_time" content="2018-02-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.952Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Input">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20180208/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-02-08T01:25:00.000Z" title="发表于 2018-02-08 09:25:00">2018-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.952Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Input/">Input</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>源码（部分）：</p>
<p><strong>kernel/msm-3.18/include/linux</strong></p>
<ul>
<li>Input.h</li>
<li>evdev.h</li>
</ul>
<p><strong>kernel/msm-3.18/drivers/input</strong></p>
<ul>
<li>Input.c</li>
<li>evdev.c</li>
<li>gpio_keys.c</li>
</ul>
<p><strong>kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6</strong></p>
<ul>
<li>Makefile</li>
<li>Kconfig</li>
<li>synaptics_dsx_core.c</li>
</ul>
<p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/android-msm-marlin-3.18-nougat-mr2-pixel">Kernel source for Pixel and Pixel XL - Google</a> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<hr>
<h2 id="（一）、Linux-Input-子系统框架"><a href="#（一）、Linux-Input-子系统框架" class="headerlink" title="（一）、Linux Input 子系统框架"></a>（一）、Linux Input 子系统框架</h2><p>输入(Input)子系统是分层架构的，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）。</p>
<p>驱动根据CORE提供的接口，向上报告发生的按键动作。然后CORE根据驱动的类型，分派这个报告给对应的事件处理层进行处理。事件处理层把数据变化反应到设备模型的文件中（事件缓冲区）。并通知在这些设备模型文件上等待的进程。</p>
<p>input子系统框架： </p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/01-Linux-kernel-input-subsystem-framework.png" alt="Markdown"></p>
<p>(1) “硬件驱动层”负责操作具体的硬件设备，这层的代码是针对具体的驱动程序的，比如你的设备是触摸输入设备，还是鼠标输入设备，还是键盘输入设备，这些不同的设备，自然有不同的硬件操作，驱动工程师往往只需要完成这层的代码编写。</p>
<p>(2) “输入子系统核心层”是链接其他两层之间的纽带与桥梁，向下提供硬件驱动层的接口，向上提供事件处理层的接口。</p>
<p>(3) “事件处理层” 负责与用户程序打交道，将硬件驱动层传来的事件报告给用户程序。</p>
<p>各层之间通信的基本单位就是事件，任何一个输入设备的动作都可以抽象成一种事件，如键盘的按下，触摸屏的按下，鼠标的移动等。事件有三种属性：类型（type），编码(code)，值(value)， Input 子系统支持的所有事件都定义在 input.h中，包括所有支持的类型，所属类型支持的编码等。事件传送的方向是 硬件驱动层–&gt;子系统核心–&gt;事件处理层–&gt;用户空间。</p>
<h2 id="（二）、Input-主要通用数据结构"><a href="#（二）、Input-主要通用数据结构" class="headerlink" title="（二）、Input 主要通用数据结构"></a>（二）、Input 主要通用数据结构</h2><h2 id="2-1、input-dev"><a href="#2-1、input-dev" class="headerlink" title="2.1、input_dev"></a>2.1、input_dev</h2><p>输入设备 input_dev，这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//输入设备的名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;    <span class="comment">//输入设备节点名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *uniq;    <span class="comment">//指定唯一的ID号，就像MAC地址一样</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//输入设备标识ID，用于和事件处理层进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[BITS_TO_LONGS(EV_CNT)];    <span class="comment">//位图，记录设备支持的事件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，记录设备支持的按键类型      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[BITS_TO_LONGS(REL_CNT)];    <span class="comment">//位图，记录设备支持的相对坐标  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];    <span class="comment">//位图，记录设备支持的绝对坐标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];    <span class="comment">//位图，记录设备支持的其他功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，记录设备支持的指示灯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];   <span class="comment">//位图，记录设备支持的声音或警报</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];     <span class="comment">//位图，记录设备支持的作用力功能  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swbit[BITS_TO_LONGS(SW_CNT)];     <span class="comment">//位图，记录设备支持的开关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodemax;      <span class="comment">//设备支持的最大按键值个数  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodesize;    <span class="comment">//每个按键的字节大小</span></span><br><span class="line">    <span class="keyword">void</span> *keycode;      <span class="comment">//指向按键池，即指向按键值数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">              <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode);    <span class="comment">//修改按键值</span></span><br><span class="line">    <span class="keyword">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">              struct input_keymap_entry *ke);   <span class="comment">//获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span>     <span class="comment">//用于强制更新输入设备的部分内容  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat_key;    <span class="comment">//重复按键的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>   <span class="comment">//设置当有连击时的延时定时器  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，按键的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> led[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，led的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> snd[BITS_TO_LONGS(SND_CNT)];    <span class="comment">//位图，声音的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sw[BITS_TO_LONGS(SW_CNT)];   <span class="comment">//位图，开关的状态  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">    <span class="keyword">int</span> (*event)(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span> <span class="comment">//类似私有指针，可以直接访问到事件处理接口event  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> users;</span><br><span class="line">    <span class="keyword">bool</span> going_away;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">//该链表头用于链接此设备所关联的input_handle   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span> <span class="comment">//用于将此设备链接到input_dev_list(链接了所有注册到内核的事件处理器)  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_vals;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_vals;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-1、input-handler"><a href="#2-1、input-handler" class="headerlink" title="2.1、input_handler"></a>2.1、input_handler</h2><p>input_handler 这是事件处理器的数据结构，代表一个事件处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/* 当事件处理器接收到来自Input设备传来的事件时调用的处理函数,</span></span><br><span class="line"><span class="comment">        event、events用于处理事件 */</span>  </span><br><span class="line">    <span class="keyword">void</span> (*event)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*events)(struct input_handle *handle,</span><br><span class="line">               <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">bool</span> (*filter)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="comment">/* 比较 device&#x27;s id with handler&#x27;s id_table ，匹配device and handler*/</span></span><br><span class="line">    <span class="keyword">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    <span class="comment">/* connect用于建立intput_handler和input_dev的联系,</span></span><br><span class="line"><span class="comment">       当一个Input设备注册到内核的时候被调用,将输入设备与事件处理器联结起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">    <span class="comment">/* disconnect用于解除handler和device的联系 */</span></span><br><span class="line">    <span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> legacy_minors;</span><br><span class="line">    <span class="keyword">int</span> minor;    <span class="comment">//次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span>    <span class="comment">//用于和device匹配 ,这个是事件处理器所支持的input设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3、input-handle"><a href="#2-3、input-handle" class="headerlink" title="2.3、input_handle"></a>2.3、input_handle</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，</span></span><br><span class="line"><span class="comment">    注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开标志，每个input_handle 打开后才能操作，</span></span><br><span class="line"><span class="comment">    这个一般通过事件处理器的open方法间接设置  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> open;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">/* 指向Input_dev结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/* 指向Input_Hander结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过d_node连接到了input_dev上的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过h_node连接到了input_handler的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4、三个数据结构之间的关系"><a href="#2-4、三个数据结构之间的关系" class="headerlink" title="2.4、三个数据结构之间的关系"></a>2.4、三个数据结构之间的关系</h2><blockquote>
<p>input_dev: 是硬件驱动层，代表一个input设备。 input_handler: 是事件处理层，代表一个事件处理器。 input_handle: 属于核心层，代表一个配对的input_dev与input_handler</p>
</blockquote>
<p>input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。注：（稍后详细分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）注：（稍后详细分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    ......</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。通过input_dev 和input_handler就可以找到input_handle在设备注册和事件处理器，注册的时候都要进行配对工作**(input_match_device)<strong>，配对后就会实现链接</strong>(handler-&gt;connect)**通过input_handle也可以找到input_dev和input_handler。注：（稍后详细分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，input_device和input_handler中都有一个h_list,而input_handle拥有指向input_dev和input_handler的指针，也就是说input_handle是用来关联input_dev和input_handler的。 那么为什么一个input_device和input_handler中拥有的是h_list而不是一个handle呢？因为一个device可能对应多个handler,而一个handler也不能只处理一个device,比如说一个鼠标，它可以对应even handler，也可以对应mouse handler,因此当其注册时与系统中的handler进行匹配，就有可能产生两个实例，一个是evdev,另一个是mousedev,而任何一个实例中都只有一个handle。至于以何种方式来传递事件，就由用户程序打开哪个实例来决定。后面一个情况很容易理解，一个事件驱动不能只为一个甚至一种设备服务，系统中可能有多种设备都能使用这类handler,比如event handler就可以匹配所有的设备。在input子系统中，有8种事件驱动，每种事件驱动最多可以对应32个设备，因此dev实例总数最多可以达到256个。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/02-Linux-kernel-input-dev-handler.png" alt="Markdown"></p>
<h2 id="（三）、Input-核心层（Input-c）"><a href="#（三）、Input-核心层（Input-c）" class="headerlink" title="（三）、Input 核心层（Input.c）"></a>（三）、Input 核心层（Input.c）</h2><p>这一节主要介绍核心层的初始化，input_device、input_handle、input_handler之间的关系(稍后回头看更佳)。 总体概览图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/03-Linux-kernel-input-core-h_list.png" alt="Markdown"></p>
<h2 id="3-1、输入核心层：初始化"><a href="#3-1、输入核心层：初始化" class="headerlink" title="3.1、输入核心层：初始化"></a>3.1、输入核心层：初始化</h2><p>首先从驱动”入口函数”开始查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//注册input类，可在/sys/class下看到对应节点文件</span></span><br><span class="line">    err = class_register(&amp;input_class);</span><br><span class="line">    ......</span><br><span class="line">    err = input_proc_init();<span class="comment">/*创建/proc中的项，查看/proc/bus/input  */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*注册设备/dev/input，主设备号为INPUT_MAJOR，就是13，后面注册的输入设备都使用该主设备号*/</span></span><br><span class="line">    err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">                     INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在入口函数里面创建了一个input_class类，其实就在/sys/class下创建了一个目录input.当然对于一个新设备，可以注册进一个class也可以不注册进去，如果存在对应class的话注册进去更好，另外在/proc创建了入口项,这样就可以/proc目录看到input的信息，然后就注册设备，可以看出输入子系统的主设备号是13，在这里并没有生成设备文件。只是在/dev/目录下创建了input目录，以后所有注册进系统的输入设备文件都放在这个目录下。</p>
<p>相应的对应关系可以使用adb 命令进入文件系统之后，cat /proc/bus/input/devices ，查看各个设备对应的event多少，比如Google Pixel 手机：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0000</span> Vendor=<span class="number">0000</span> Product=<span class="number">0003</span> Version=<span class="number">2066</span></span><br><span class="line">N: Name=<span class="string">&quot;synaptics_dsxv26&quot;</span></span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=<span class="number">2</span></span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=<span class="number">8000</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">B: ABS=<span class="number">663800000000000</span></span><br></pre></td></tr></table></figure>

<p>event3 就是事件序号， 我们在调试的时候直接 adb shell getevent /dev/input/event3，来实时捕捉 event3 中储存的数据。</p>
<p>那么接下来看看怎么注册input设备的.我们需要在设备驱动层中完成输入设备的注册，通过调用input_register_device()函数来完成，该函数的一个重要任务就是完成设备与事件驱动的匹配</p>
<h2 id="3-2、输入核心层：注册设备input-dev"><a href="#3-2、输入核心层：注册设备input-dev" class="headerlink" title="3.2、输入核心层：注册设备input_dev"></a>3.2、输入核心层：注册设备input_dev</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">                      <span class="keyword">sizeof</span>(struct input_devres), GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">        devres-&gt;input = dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EN_SYN这个是设备都要支持的事件类型，所以要设置   </span></span><br><span class="line">    <span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">    packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">        dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">    dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">    dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">     * is handled by the driver itself and we don&#x27;t do it in input.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 这个定时器是为了重复按键而设置的</span></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">        dev-&gt;timer.data = (<span class="keyword">long</span>) dev;</span><br><span class="line">        dev-&gt;timer.function = input_repeat_key;</span><br><span class="line">        dev-&gt;rep[REP_DELAY] = <span class="number">250</span>;</span><br><span class="line">        dev-&gt;rep[REP_PERIOD] = <span class="number">33</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有设置自己的获取键值的函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有指定按键重置函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">    pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">        dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">        path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">    kfree(path);</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将新分配的input设备连接到input_dev_list链表上  </span></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">    <span class="comment">/* 核心重点，input设备在增加到input_dev_list链表上之后，会查找</span></span><br><span class="line"><span class="comment">     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配</span></span><br><span class="line"><span class="comment">     * 方式与设备模型的device和driver匹配过程很相似，所有的input</span></span><br><span class="line"><span class="comment">     * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list</span></span><br><span class="line"><span class="comment">     * 上，进行“匹配相亲”，list_for_each_entry就是个for循环，跳出条件遍历了一遍，又回到链表头 */</span>  </span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">            __func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">        devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p>
<p>1、进一步初始化输入设备，例如连击事件 2、注册输入设备到input类中，把输入设备挂到输入设备链表input_dev_list中 3、查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p>
<p>我们需要再分析下这个匹配的过程，input_attach_handler()匹配过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* input_dev 和 input_handler 进行匹配,返回匹配的id，类型是struct input_device_id  */</span>  </span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 匹配成功，调用handler里面的connect函数,这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构 */</span>  </span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看下input_match_device（）函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype) <span class="comment">//匹配总线id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)  <span class="comment">//匹配生产商id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)  <span class="comment">//匹配产品id  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version) <span class="comment">//匹配版本  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配id的evbit和input_dev中evbit的各个位，如果不匹配则continue，数组中下一个设备  </span></span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            <span class="keyword">return</span> id;<span class="comment">//匹配成功,返回id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>input_match_device() 到最合适的事件处理层驱动时，便执行handler-&gt;connect() 函数进行连接了，看下面这部分代码（以evdev类型驱动为例，在input/evdev.c中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">int</span> dev_no;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev */</span></span><br><span class="line">    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 开始给evdev事件层驱动分配空间了 */</span></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化client_list列表和evdev_wait队列，后面介绍 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">    evdev-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */</span></span><br><span class="line">    dev_no = minor;</span><br><span class="line">    <span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">    <span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)</span><br><span class="line">        dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);</span><br><span class="line">    <span class="comment">/*这里就将handle的dev指针指向了input_dev*/</span></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler = handler;<span class="comment">/*这里将handle的handler指向了当前的input_handler.注意本函数evdev_connect,可能是在在输入设备注册的时候</span></span><br><span class="line"><span class="comment">38     在input_register_device函数中调用input_attach_handler的时候调用;也可能是在输入设备的处理方法input_handler时在input_register_handler</span></span><br><span class="line"><span class="comment">39     函数中也会用到input_attach_handler函数,就会调用本函数.这里就很明显了,本函数就将input_handler和input_dev都放在input_handle中统一管理*/</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化evdev中的内嵌device*/</span></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class;</span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;</span><br><span class="line">    evdev-&gt;dev.release = evdev_free;</span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line">   <span class="comment">/* input_dev设备驱动层和input_handler事件处理层的关联，由input_handle完成(不要和handler搞混淆了，这不是一个概念～) */</span>  </span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line">    evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj;</span><br><span class="line">    error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    error = device_add(&amp;evdev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、输入核心层：注册input-handler"><a href="#3-3、输入核心层：注册input-handler" class="headerlink" title="3.3、输入核心层：注册input_handler"></a>3.3、输入核心层：注册input_handler</h2><p>为了逻辑更清新，我们稍后再来看input_register_handle() 程，先来了解input_handler的注册过程。 要了解input_handler的注册过程，又需要先了解evdev初始化过程（以evdev为例）： /kernel/drivers/input下众多事件处理器handler其中的一个，可以看下源码/kernel/drivers/input/evdev.c中的模块init</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">evdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化就是往input核心中注册一个input_handler类型的evdev_handler，调用的是input.c提供的接口，input_handler结构前面有介绍，看下evdev_handler的赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> = &#123;</span></span><br><span class="line">    .event        = evdev_event,</span><br><span class="line">    .events        = evdev_events,</span><br><span class="line">    .connect    = evdev_connect,</span><br><span class="line">    .disconnect    = evdev_disconnect,</span><br><span class="line">    .legacy_minors    = <span class="literal">true</span>,</span><br><span class="line">    .minor        = EVDEV_MINOR_BASE,</span><br><span class="line">    .name        = <span class="string">&quot;evdev&quot;</span>,</span><br><span class="line">    .id_table    = evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以注意的是evdev是匹配所有设备的，因为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] = &#123;</span></span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,    <span class="comment">/* Matches all devices */</span></span><br><span class="line">    &#123; &#125;,            <span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">    <span class="comment">//添加进input_handler_list全局链表</span></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">    <span class="comment">//同样遍历input_dev这个链表，依次调用下面的input_attach_handler去匹配input_dev,这个跟input_dev注册的时候的情形类似  </span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）"><a href="#3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）" class="headerlink" title="3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）"></a>3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）</h2><p>input_handle关联匹配input_dev和input_handler 继续分析input_dev和input_handler 是如何关联上的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上</span></span><br><span class="line"><span class="comment">    * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以</span></span><br><span class="line"><span class="comment">    * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个handle的d_node 加到对应input_dev的h_list链表里面  </span></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把这个handle的h_node 加到对应input_handler的h_list链表里面</span></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注册是把handle 本身的链表加入到它自己的input_dev 以及 input_handler的h_list链表中，这样以后就可以通过h_list遍历到这个handle，这样就实现了三者的绑定联系。</p>
<p>以上是输入设备驱动注册的全过程，纵观整个过程，输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件被谁去处理呢？知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。 整个关联注册的过程：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/04-Linux-kernel-input-reg-device.png" alt="Markdown"></p>
<h2 id="（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）"><a href="#（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）" class="headerlink" title="（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）"></a>（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/05-Linux-kernel-input-event-hardware.png" alt="Markdown"></p>
<h2 id="4-1、主要数据结构"><a href="#4-1、主要数据结构" class="headerlink" title="4.1、主要数据结构"></a>4.1、主要数据结构</h2><p><strong>（1） evdev设备结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> exist;   </span><br><span class="line">    <span class="keyword">int</span> open;                     <span class="comment">//打开标志   </span></span><br><span class="line">    <span class="keyword">int</span> minor;                    <span class="comment">//次设备号   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span>   <span class="comment">//关联的input_handle   </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;       <span class="comment">//等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">grab</span>;</span>    <span class="comment">//强制绑定的evdev_client结构，这个结构后面再分析   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span> <span class="comment">//evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备   </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> client_lock;       <span class="comment">/* protects client_list */</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>            <span class="comment">//device结构，说明这是一个设备结构   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)，如触摸屏驱动的event3，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input3。这个设备结构生成之后保存在evdev_table中，索引值是minor。 <strong>（2）evdev用户端结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> head;  <span class="comment">//buffer数组的索引头  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail;   <span class="comment">//buffer数组的索引尾  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wake_lock</span> <span class="title">wake_lock</span>;</span>  </span><br><span class="line">    <span class="keyword">bool</span> use_wake_lock;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">28</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span>    <span class="comment">//异步通知函数  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span>  <span class="comment">//包含一个evdev变量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>  <span class="comment">//链表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span>   <span class="comment">//input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构在进程打开event3设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。 <strong>（3）input_event结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    <span class="comment">//事件发生的时间   </span></span><br><span class="line">    __u16 type;             <span class="comment">//事件类型   </span></span><br><span class="line">    __u16 code;             <span class="comment">//子事件   </span></span><br><span class="line">    __s32 value;            <span class="comment">//事件的value  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、事件处理层evdev"><a href="#4-2、事件处理层evdev" class="headerlink" title="4.2、事件处理层evdev"></a>4.2、事件处理层evdev</h2><p>事件处理层与用户程序和输入子系统核心打交道，是他们两层的桥梁。一般内核有好几个事件处理器，像evdev mousedev jotdev。evdev事件处理器可以处理所有的事件，触摸屏驱动就是用的这个，所以下面分析这个事件处理器的实现。它也是作为模块注册到内核中的,前面已经分析过它的模块初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> = &#123;</span></span><br><span class="line">    .owner        = THIS_MODULE,</span><br><span class="line">    .read        = evdev_read,</span><br><span class="line">    .write        = evdev_write,</span><br><span class="line">    .poll        = evdev_poll,</span><br><span class="line">    .open        = evdev_open,</span><br><span class="line">    .release    = evdev_release,</span><br><span class="line">    .unlocked_ioctl    = evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl    = evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">    .fasync        = evdev_fasync,</span><br><span class="line">    .flush        = evdev_flush,</span><br><span class="line">    .llseek        = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果匹配上了就会创建一个evdev，它里边封装了一个handle，会把input_dev和input_handler关联到一起。关系如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/06-Linux-kernel-input-evdev-connect.png" alt="Markdown"></p>
<h2 id="4-3、evdev设备结点的open-操作"><a href="#4-3、evdev设备结点的open-操作" class="headerlink" title="4.3、evdev设备结点的open()操作"></a>4.3、evdev设备结点的open()操作</h2><p>我们知道.对主设备号为INPUT_MAJOR的设备节点进行操作，会将操作集转换成handler的操作集。在evdev中，这个操作集就是evdev_fops。对应的open函数如下示：</p>
<p>首先来看打开event(x)设备文件，evdev_open函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">container_of</span>(<span class="title">inode</span>-&gt;<span class="title">i_cdev</span>, <span class="title">struct</span> <span class="title">evdev</span>, <span class="title">cdev</span>);</span></span><br><span class="line">    <span class="comment">//evdev_client的buffer大小  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct evdev_client) +</span><br><span class="line">                    bufsize * <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//打开的时候创建一个evdev_client</span></span><br><span class="line">    client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    client-&gt;bufsize = bufsize;</span><br><span class="line">    spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="built_in">snprintf</span>(client-&gt;name, <span class="keyword">sizeof</span>(client-&gt;name), <span class="string">&quot;%s-%d&quot;</span>,</span><br><span class="line">            dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">    client-&gt;evdev = evdev;</span><br><span class="line">    evdev_attach_client(evdev, client);</span><br><span class="line">    <span class="comment">//调用打开真正的底层设备函数  </span></span><br><span class="line">    error = evdev_open_device(evdev);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    file-&gt;private_data = client;</span><br><span class="line">    nonseekable_open(inode, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open_device</span><span class="params">(struct evdev *evdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (retval)<span class="comment">/*如果设备不存在，返回错误*/</span>  </span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!evdev-&gt;exist)</span><br><span class="line">        retval = -ENODEV;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;<span class="comment">//递增打开计数  </span></span><br><span class="line">        retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">//如果是被第一次打开，则调用input_open_device</span></span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            evdev-&gt;open--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_open_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span><span class="comment">//根据input_handle找到对应的input_dev设备  </span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    handle-&gt;open++;<span class="comment">//递增handle的打开计数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;users++ &amp;&amp; dev-&gt;open)</span><br><span class="line">        retval = dev-&gt;open(dev);<span class="comment">//如果是第一次打开.则调用input device的open()函数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        dev-&gt;users--;</span><br><span class="line">        <span class="keyword">if</span> (!--handle-&gt;open) &#123;</span><br><span class="line">            synchronize_rcu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4、用户进程读取event的底层实现"><a href="#4-4、用户进程读取event的底层实现" class="headerlink" title="4.4、用户进程读取event的底层实现"></a>4.4、用户进程读取event的底层实现</h2><p>至于具体的如何初始化input_dev，这个是具体的输入设备去实现的，稍后具体实例再分析，现在来看看，对于一个event(x)设备文件的，应用程序来读，最终会导致”handler”里面的的”读函数”被调用。</p>
<p>evdev_fops 结 构 体 是 一 个 file_operations 的 类 型 。 当 用 户 层 调 用 类 似 代 码open(“/dev/input/event3” , O_RDONLY) 函 数 打 开 设 备 结 点 时 , 会 调 用 evdev_fops 中 的evdev_read()函数,该函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">evdev_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span><span class="comment">//就是刚才在open函数中保存的evdev_client  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//如果获得了数据则取出来，调用evdev_fetch_next_event  </span></span><br><span class="line">        <span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">               evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//input_event_to_user调用copy_to_user传入用户程序中，这样读取完成  </span></span><br><span class="line">            <span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            read += input_event_size();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/*如果是可阻塞状态的话,则等待在wait队列上.直到有数据要被处理,当前进程才被唤醒.这很好理解,既然是</span></span><br><span class="line"><span class="comment">         输入设备,读的话比如读按键,那么必须要有硬件设备有按键按下才会返回按键值,这里还是处于事件处理层,应用程序在这里休眠,那么谁来唤醒?</span></span><br><span class="line"><span class="comment">         当然是有按键按下才去唤醒,因此这个工作就交给了设备驱动层,那么找到这个唤醒呢,直接去找不好找,那么可以直接搜索evdev-&gt;wait,搜索结果</span></span><br><span class="line"><span class="comment">         可知evdev-&gt;wait在evdev_event()函数中被唤醒*/</span></span><br><span class="line">        <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">            error = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">                    client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">                    !evdev-&gt;exist || client-&gt;revoked);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_fetch_next_event</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> have_event;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="comment">/*先判断一下是否有数据*/</span>   </span><br><span class="line">    have_event = client-&gt;packet_head != client-&gt;tail;</span><br><span class="line">    <span class="comment">/*如果有就从环形缓冲区的取出来，记得是从head存储，tail取出*/</span></span><br><span class="line">    <span class="keyword">if</span> (have_event) &#123;</span><br><span class="line">        *event = client-&gt;buffer[client-&gt;tail++];</span><br><span class="line">        client-&gt;tail &amp;= client-&gt;bufsize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (client-&gt;use_wake_lock &amp;&amp;</span><br><span class="line">            client-&gt;packet_head == client-&gt;tail)</span><br><span class="line">            wake_unlock(&amp;client-&gt;wake_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> have_event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_event_to_user</span><span class="params">(<span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果设置了标志INPUT_COMPAT_TEST就将事件event包装成结构体compat_event*/</span></span><br><span class="line">    <span class="keyword">if</span> (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event_compat</span> <span class="title">compat_event</span>;</span></span><br><span class="line"></span><br><span class="line">        compat_event.time.tv_sec = event-&gt;time.tv_sec;</span><br><span class="line">        compat_event.time.tv_usec = event-&gt;time.tv_usec;</span><br><span class="line">        compat_event.type = event-&gt;type;</span><br><span class="line">        compat_event.code = event-&gt;code;</span><br><span class="line">        compat_event.value = event-&gt;value;</span><br><span class="line">         <span class="comment">/*将包装成的compat_event拷贝到用户空间*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, &amp;compat_event,</span><br><span class="line">                 <span class="keyword">sizeof</span>(struct input_event_compat)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/*否则，将event拷贝到用户空间*/</span>   </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是可阻塞状态的话，则等待在wait队列上。直到有数据要被处理，当前进程才被唤醒。这很好理解，既然是输入设备，读的话比如读按键，那么必须要有硬件设备有按键按下才会返回按键值，这里还是处于事件处理层，应用程序在这里休眠，那么谁来唤醒?</p>
<p>当然是有按键按下才去唤醒，因此这个工作就交给了设备驱动层。那么找到这个唤醒呢，直接去找不好找。那么可以直接搜索evdev-&gt;wait，搜索结果可知evdev-&gt;wait在evdev_event()函数中被唤醒</p>
<p>注释中说的很清楚，evdev_event()会唤醒此处的读按键进程。那么evdev_event()又是被谁调用?显然是设备驱动层，现在看一个设备层例子，内核中有个按键的例子，gpiokey.c，这只是个例子不针对任何设备，在gpio_keys.c终端处理函数里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;gpio_keys.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">gpio_keys_irq_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!bdata-&gt;key_pressed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        input_event(input, EV_KEY, button-&gt;code, <span class="number">1</span>);</span><br><span class="line">        input_sync(input);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此可以看出 在设备的中断服务程序里面，确定事件是什么，然后调用相应的input_handler的event处理函数 实际上这就是我们的核心 input_event()是用来上报事件的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        input_handle_event(dev, type, code, value);</span><br><span class="line">        spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_handle_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">            input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;</span><br><span class="line">        dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_values</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">            <span class="keyword">if</span> (handle-&gt;open)</span><br><span class="line">                count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_to_handler</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> = <span class="title">vals</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">        handler-&gt;events(handle, vals, count);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line">        <span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">            handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最终调用handler-&gt;event()来处理，此处handler即对应evdev。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value)</span><br></pre></td></tr></table></figure>

<p>所以会调用evdev_event()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_pass_values</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">ktime_t</span> mono, <span class="keyword">ktime_t</span> real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ?</span><br><span class="line">                      mono : real);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">        event.type = v-&gt;type;</span><br><span class="line">        event.code = v-&gt;code;</span><br><span class="line">        event.value = v-&gt;value;</span><br><span class="line">        __pass_event(client, &amp;event);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT)</span><br><span class="line">            wakeup = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeup)</span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_events</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">handle</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (client)</span><br><span class="line">        evdev_pass_values(client, vals, count, time_mono, time_real);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">            evdev_pass_values(client, vals, count,</span><br><span class="line">                      time_mono, time_real);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_event</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] = &#123;</span> &#123; type, code, value &#125; &#125;;</span><br><span class="line">    evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终唤醒evdev_read()将数据拷贝到用户空间。</p>
<h2 id="（五）、Input-事件上报过程"><a href="#（五）、Input-事件上报过程" class="headerlink" title="（五）、Input 事件上报过程"></a>（五）、Input 事件上报过程</h2><h2 id="5-1、Input-事件产生"><a href="#5-1、Input-事件产生" class="headerlink" title="5.1、Input 事件产生"></a>5.1、Input 事件产生</h2><p>当按下触摸屏时，进入触摸屏按下中断，开始ad转换，ad转换完成进入ad完成中断，在这个终端中将事件发送出去，会调用以下函数上报事件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> input_report_key(input_dev,</span><br><span class="line">         BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_X, x);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_Y, y);</span><br><span class="line"></span><br><span class="line">input_sync(input_dev);</span><br></pre></td></tr></table></figure>

<p>这两个函数调用了 input_event(dev, EV_ABS, code, value) 所有的事件报告函数都调用这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_ABS, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2、Input-事件报告"><a href="#5-2、Input-事件报告" class="headerlink" title="5.2、Input 事件报告"></a>5.2、Input 事件报告</h2><p>input_event 函数前面已经分析过，这里不再分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c:input_pass_values]</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">    handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br></pre></td></tr></table></figure>

<p>最终会调用handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 来将数据 传递给用户空间等待读取数据的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event))</span><br></pre></td></tr></table></figure>

<h2 id="（六）、Android-Input子系统"><a href="#（六）、Android-Input子系统" class="headerlink" title="（六）、Android Input子系统"></a>（六）、Android Input子系统</h2><p>输入子系统的系统架构如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/07-Linux-kernel-android-input-system.png" alt="Markdown"></p>
<p>详细分析请参考：Android 7.1.2 (Android N) Android 输入子系统-Input System 分析</p>
<h2 id="（七）、Input-设备驱动层实例（Synaptics）"><a href="#（七）、Input-设备驱动层实例（Synaptics）" class="headerlink" title="（七）、Input 设备驱动层实例（Synaptics）"></a>（七）、Input 设备驱动层实例（Synaptics）</h2><p>触摸屏也是用上面这一套框架来操作的。右边需要一个”evdev.c”文件。左边要分配一个”input_dev”结构。接着就看上图的硬件设备左边的过程：分配一个”input_dev”结构体 –&gt; 设置这个”input_dev”结构体 –&gt; 注册这个”input_dev”结构体 –&gt; 硬件相关的操作。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/linux.input/08-Linux-kernel-input-drivers-fw.png" alt="Markdown"></p>
<p>编写Input驱动一般框架:</p>
<p>Google Pixel、Pixel XL 触控驱动模块型号为Synaptics（ClearPad S3708），源码：<a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin/tree/2f567606935d601f1391ad9575b103f35737a438/drivers/input/touchscreen/synaptics_dsx_htc_2.6">Synaptics 触摸屏驱动源码</a></p>
<p>Makefile：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2<span class="number">.6</span>/Makefile]</span><br><span class="line">#</span><br><span class="line"># Makefile <span class="keyword">for</span> the Synaptics DSX touchscreen driver.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Each configuration option enables a <span class="built_in">list</span> of files.</span><br><span class="line"></span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>抓取kernel log：可知input 驱动名为synaptics_dsxv26，全局搜索可知synaptics_rmi4_f12_init在[-&gt;synaptics_dsx_core.c]中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1.362728</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init: Function <span class="number">12</span> max x = <span class="number">1079</span> max y = <span class="number">1919</span> Rx: <span class="number">16</span> Tx: <span class="number">28</span></span><br><span class="line">[    <span class="number">1.363344</span>] c3      <span class="number">1</span> [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (<span class="number">0</span>,<span class="number">0</span>) -&gt; (<span class="number">1079</span>,<span class="number">1919</span>)</span><br><span class="line">[    <span class="number">1.363623</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init report data init done</span><br><span class="line">[    <span class="number">1.371945</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: chip_id:<span class="number">3708</span>, firmware_id:<span class="number">2433782</span></span><br><span class="line">[    <span class="number">1.372865</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: config_version: <span class="number">5331763200190000000000000000000000000000000000000000000000000000</span></span><br><span class="line">[    <span class="number">1.373249</span>] c3      <span class="number">1</span> input: synaptics_dsxv26 as /devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br></pre></td></tr></table></figure>

<p>查看input设备：adb shell cat /proc/bus/input/devices</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0000</span> Vendor=<span class="number">0000</span> Product=<span class="number">0003</span> Version=<span class="number">2066</span></span><br><span class="line">N: Name=<span class="string">&quot;synaptics_dsxv26&quot;</span></span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=<span class="number">2</span></span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=<span class="number">8000</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">B: ABS=<span class="number">663800000000000</span></span><br><span class="line"></span><br><span class="line">对应：/dev/input/event3</span><br></pre></td></tr></table></figure>

<h2 id="7-1、分配Input-dev结构体"><a href="#7-1、分配Input-dev结构体" class="headerlink" title="7.1、分配Input_dev结构体"></a>7.1、分配Input_dev结构体</h2><h2 id="7-1-1、synaptics-rmi4-f12-init"><a href="#7-1-1、synaptics-rmi4-f12-init" class="headerlink" title="7.1.1、synaptics_rmi4_f12_init()"></a>7.1.1、synaptics_rmi4_f12_init()</h2><p>首先看一下初始化过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">synaptics_rmi4_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = PLATFORM_DRIVER_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">        .pm = &amp;synaptics_rmi4_dev_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = synaptics_rmi4_probe,</span><br><span class="line">    .remove = synaptics_rmi4_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">synaptics_rmi4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_bus_init();</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;synaptics_rmi4_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(synaptics_rmi4_init);</span><br></pre></td></tr></table></figure>

<p>首先注册平台驱动，当驱动和设备匹配成功，继续看一下synaptics_rmi4_probe()函数</p>
<h2 id="7-1-2、synaptics-rmi4-probe"><a href="#7-1-2、synaptics-rmi4-probe" class="headerlink" title="7.1.2、synaptics_rmi4_probe()"></a>7.1.2、synaptics_rmi4_probe()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval, len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> attr_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_hw_interface</span> *<span class="title">hw_if</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="comment">//初始化platform_data、board_data、rmi4_data</span></span><br><span class="line">    hw_if = pdev-&gt;dev.platform_data;</span><br><span class="line">    bdata = hw_if-&gt;board_data;</span><br><span class="line">    rmi4_data = kzalloc(<span class="keyword">sizeof</span>(*rmi4_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;pdev = pdev;</span><br><span class="line">    rmi4_data-&gt;current_page = MASK_8BIT;</span><br><span class="line">    rmi4_data-&gt;hw_if = hw_if;</span><br><span class="line">    rmi4_data-&gt;touch_stopped = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;sensor_sleep = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;irq_enabled = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fw_updating = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;update_coords = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN,</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable;</span><br><span class="line">    rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex));</span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex));</span><br><span class="line"></span><br><span class="line">    retval = synaptics_dsx_regulator_configure(rmi4_data);</span><br><span class="line">    retval = synaptics_dsx_regulator_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    platform_set_drvdata(pdev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;gpio_config) &#123;</span><br><span class="line">        retval = synaptics_rmi4_set_gpio(rmi4_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = synaptics_dsx_pinctrl_init(rmi4_data);</span><br><span class="line">        <span class="keyword">if</span> (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123;</span><br><span class="line">            retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl,</span><br><span class="line">                    rmi4_data-&gt;pinctrl_state_active);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval = synaptics_dsx_gpio_configure(rmi4_data, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;fw_name) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(bdata-&gt;fw_name);</span><br><span class="line"></span><br><span class="line">        strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配Input_dev结构体，设置，注册</span></span><br><span class="line">    retval = synaptics_rmi4_set_input_dev(rmi4_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio);</span><br><span class="line">    <span class="comment">//请求中断，并设置中断处理函数synaptics_rmi4_irq</span></span><br><span class="line">    retval = synaptics_rmi4_irq_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!exp_data.initialized) &#123;</span><br><span class="line">        mutex_init(&amp;exp_data.mutex);</span><br><span class="line">        INIT_LIST_HEAD(&amp;exp_data.<span class="built_in">list</span>);</span><br><span class="line">        exp_data.initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exp_data.workqueue = create_singlethread_workqueue(<span class="string">&quot;dsx_exp_workqueue&quot;</span>);</span><br><span class="line">    INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work);</span><br><span class="line">    exp_data.rmi4_data = rmi4_data;</span><br><span class="line">    exp_data.queue_work = <span class="literal">true</span>;</span><br><span class="line">    queue_delayed_work(exp_data.workqueue,</span><br><span class="line">            &amp;exp_data.work,</span><br><span class="line">            msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (attr_count = <span class="number">0</span>; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123;</span><br><span class="line">        retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj,</span><br><span class="line">                &amp;attrs[attr_count].attr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synaptics_secure_touch_init(rmi4_data);</span><br><span class="line">    synaptics_secure_touch_stop(rmi4_data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-1-3、分配Input-dev结构体"><a href="#7-1-3、分配Input-dev结构体" class="headerlink" title="7.1.3、分配Input_dev结构体"></a>7.1.3、分配Input_dev结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……"><a href="#7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……" class="headerlink" title="7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……"></a>7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME &quot;synaptics_dsxv26&quot;(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3、注册设备input-register-device"><a href="#7-3、注册设备input-register-device" class="headerlink" title="7.3、注册设备input_register_device()"></a>7.3、注册设备input_register_device()</h2><p>此处即与前面kernel log呼应：注册名为 synaptics_dsxv26 的输入设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME &quot;synaptics_dsxv26&quot;(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">    retval = input_register_device(rmi4_data-&gt;input_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4、硬件相关操作"><a href="#7-4、硬件相关操作" class="headerlink" title="7.4、硬件相关操作"></a>7.4、硬件相关操作</h2><p>当触摸屏按下，会产生中断，进而调用中断处理函数synaptics_rmi4_irq():</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">synaptics_rmi4_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">            <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IRQ_HANDLED == synaptics_filter_interrupt(data))</span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_sensor_report(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步调用synaptics_rmi4_sensor_report(rmi4_data, true)处理数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_sensor_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> report)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[MAX_INTR_REGISTERS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *intr = &amp;data[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> was_in_bl_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f01_device_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_fn</span> *<span class="title">fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_exp_fhandler</span> *<span class="title">exp_fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_device_info</span> *<span class="title">rmi</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi = &amp;(rmi4_data-&gt;rmi4_mod_info);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">            data,</span><br><span class="line">            rmi4_data-&gt;num_of_intr_regs + <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//读取寄存器数据</span></span><br><span class="line">    status.data[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (status.status_code == STATUS_CRC_IN_PROGRESS) &#123;</span><br><span class="line">        retval = synaptics_rmi4_check_status(rmi4_data,</span><br><span class="line">                &amp;was_in_bl_mode);</span><br><span class="line">        ....</span><br><span class="line">        retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">                rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">                status.data,</span><br><span class="line">                <span class="keyword">sizeof</span>(status.data));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.unconfigured &amp;&amp; !status.flash_prog) &#123;</span><br><span class="line">        pr_notice(<span class="string">&quot;%s: spontaneous reset detected\n&quot;</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//synaptics_rmi4_report_touch()上报数据</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123;</span><br><span class="line">        list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fhandler-&gt;num_of_data_sources) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fhandler-&gt;intr_mask &amp;</span><br><span class="line">                        intr[fhandler-&gt;intr_reg_num]) &#123;</span><br><span class="line">                    synaptics_rmi4_report_touch(rmi4_data,</span><br><span class="line">                            fhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;exp_data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;exp_data.<span class="built_in">list</span>)) &#123;</span><br><span class="line">        list_for_each_entry(exp_fhandler, &amp;exp_data.<span class="built_in">list</span>, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exp_fhandler-&gt;insert &amp;&amp;</span><br><span class="line">                    !exp_fhandler-&gt;remove &amp;&amp;</span><br><span class="line">                    (exp_fhandler-&gt;exp_fn-&gt;attn != <span class="literal">NULL</span>))</span><br><span class="line">                exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;exp_data.mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-1、Input数据上报："><a href="#7-4-1、Input数据上报：" class="headerlink" title="7.4.1、Input数据上报："></a>7.4.1、Input数据上报：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_report_touch</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (fhandler-&gt;fn_number) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> SYNAPTICS_RMI4_F12:</span><br><span class="line">        touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,</span><br><span class="line">                fhandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (touch_count_2d)</span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_f12_abs_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> touch_count = <span class="number">0</span>; <span class="comment">/* number of touch points */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fingers_to_process;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_status;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> size_of_2d_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gesture_type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> data_addr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> wx;</span><br><span class="line">    <span class="keyword">int</span> wy;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_extra_data</span> *<span class="title">extra_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">finger_data</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_presence;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> stylus_presence;</span><br><span class="line"></span><br><span class="line">    fingers_to_process = fhandler-&gt;num_of_data_points;</span><br><span class="line">    data_addr = fhandler-&gt;full_addr.data_base;</span><br><span class="line">    extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra;</span><br><span class="line">    size_of_2d_data = <span class="keyword">sizeof</span>(struct synaptics_rmi4_f12_finger_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            data_addr + extra_data-&gt;data1_offset,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fhandler-&gt;data,</span><br><span class="line">            fingers_to_process * size_of_2d_data);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line">    <span class="comment">//根据触摸点数量循环上报input数据</span></span><br><span class="line">    <span class="keyword">for</span> (finger = <span class="number">0</span>; finger &lt; fingers_to_process; finger++) &#123;</span><br><span class="line">        finger_data = data + finger;</span><br><span class="line">        finger_status = finger_data-&gt;object_type_and_status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        x = (finger_data-&gt;x_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;x_lsb);</span><br><span class="line">        y = (finger_data-&gt;y_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;y_lsb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123;</span><br><span class="line">            temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">            temp = wx;</span><br><span class="line">            wx = wy;</span><br><span class="line">            wy = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip)</span><br><span class="line">            x = rmi4_data-&gt;sensor_max_x - x;</span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip)</span><br><span class="line">            y = rmi4_data-&gt;sensor_max_y - y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (finger_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> F12_FINGER_STATUS:</span><br><span class="line">        <span class="keyword">case</span> F12_GLOVED_FINGER_STATUS:</span><br><span class="line"></span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOOL_FINGER, <span class="number">1</span>);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_X, x);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_Y, y);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(rmi4_data-&gt;input_dev);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> touch_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用input_report_key()、input_report_abs()、input_sync() 上报、同步数据。</p>
<h2 id="（八）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考文档(特别感谢各位前辈的分析和图示)："></a>（八）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/input.html">Linux/Android—-Input系统</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiantangniaochao/article/details/50497353">Android Input子系统浅谈</a><br><a target="_blank" rel="noopener" href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/">Android(Linux) 输入子系统解析</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jason-lu/p/3156411.html">input子系统分析之三:驱动模块</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fanwenjieok/article/details/38503027">Linux驱动框架之—-Input子系统</a><br><a target="_blank" rel="noopener" href="https://www.zybuluo.com/zifehng/note/718523">input子系统事件处理层(evdev)的环形缓冲区</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ielife/article/details/7814108">linux input输入子系统分析《四》：input子系统整体流程全面分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yueqian_scut/article/details/48792939">Linux input子系统分析之二：深入剖析input_handler、input_core、input_device</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20180208/">https://zhoujinjian.com/posts/20180208/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Input/">Input</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20180308/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20180108/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.08.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android N 基础（6）：Android 7.1.2 Android WindowManagerService 窗口管理服务分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20180308/" title="Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-03-08</div><div class="title">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Linux-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">（一）、Linux Input 子系统框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Input-%E4%B8%BB%E8%A6%81%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">（二）、Input 主要通用数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81input-dev"><span class="toc-number">3.</span> <span class="toc-text">2.1、input_dev</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81input-handler"><span class="toc-number">4.</span> <span class="toc-text">2.1、input_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81input-handle"><span class="toc-number">5.</span> <span class="toc-text">2.3、input_handle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E4%B8%89%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.</span> <span class="toc-text">2.4、三个数据结构之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Input-%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%88Input-c%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">（三）、Input 核心层（Input.c）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E8%BE%93%E5%85%A5%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">3.1、输入核心层：初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E8%BE%93%E5%85%A5%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%9A%E6%B3%A8%E5%86%8C%E8%AE%BE%E5%A4%87input-dev"><span class="toc-number">9.</span> <span class="toc-text">3.2、输入核心层：注册设备input_dev</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E8%BE%93%E5%85%A5%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%9A%E6%B3%A8%E5%86%8Cinput-handler"><span class="toc-number">10.</span> <span class="toc-text">3.3、输入核心层：注册input_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E8%BE%93%E5%85%A5%E6%A0%B8%E5%BF%83%E5%B1%82%EF%BC%9A%E6%B3%A8%E5%86%8Cinput-handle%EF%BC%88%E4%B8%8D%E8%A6%81%E5%92%8Chandler%E6%90%9E%E6%B7%B7%E6%B7%86%E4%BA%86%E5%93%A6%EF%BC%8C%E8%BF%99%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BD%9E%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Input-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%B1%82-Event-handler-%EF%BC%88%E4%BB%A5evdev%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">13.</span> <span class="toc-text">4.1、主要数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%B1%82evdev"><span class="toc-number">14.</span> <span class="toc-text">4.2、事件处理层evdev</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E3%80%81evdev%E8%AE%BE%E5%A4%87%E7%BB%93%E7%82%B9%E7%9A%84open-%E6%93%8D%E4%BD%9C"><span class="toc-number">15.</span> <span class="toc-text">4.3、evdev设备结点的open()操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E3%80%81%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%8F%96event%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">16.</span> <span class="toc-text">4.4、用户进程读取event的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81Input-%E4%BA%8B%E4%BB%B6%E4%B8%8A%E6%8A%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">（五）、Input 事件上报过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81Input-%E4%BA%8B%E4%BB%B6%E4%BA%A7%E7%94%9F"><span class="toc-number">18.</span> <span class="toc-text">5.1、Input 事件产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81Input-%E4%BA%8B%E4%BB%B6%E6%8A%A5%E5%91%8A"><span class="toc-number">19.</span> <span class="toc-text">5.2、Input 事件报告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Android-Input%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.</span> <span class="toc-text">（六）、Android Input子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81Input-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%B1%82%E5%AE%9E%E4%BE%8B%EF%BC%88Synaptics%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">（七）、Input 设备驱动层实例（Synaptics）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E5%88%86%E9%85%8DInput-dev%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">22.</span> <span class="toc-text">7.1、分配Input_dev结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-1%E3%80%81synaptics-rmi4-f12-init"><span class="toc-number">23.</span> <span class="toc-text">7.1.1、synaptics_rmi4_f12_init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-2%E3%80%81synaptics-rmi4-probe"><span class="toc-number">24.</span> <span class="toc-text">7.1.2、synaptics_rmi4_probe()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-3%E3%80%81%E5%88%86%E9%85%8DInput-dev%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">25.</span> <span class="toc-text">7.1.3、分配Input_dev结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E8%AE%BE%E7%BD%AE%E6%94%AF%E6%8C%81%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B-set-bit-EV-SYN-evbit-%E3%80%81set-bit-EV-KEY-evbit-%E3%80%81set-bit-EV-ABS-evbit-%E2%80%A6%E2%80%A6"><span class="toc-number">26.</span> <span class="toc-text">7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E6%B3%A8%E5%86%8C%E8%AE%BE%E5%A4%87input-register-device"><span class="toc-number">27.</span> <span class="toc-text">7.3、注册设备input_register_device()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">28.</span> <span class="toc-text">7.4、硬件相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-1%E3%80%81Input%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5%EF%BC%9A"><span class="toc-number">29.</span> <span class="toc-text">7.4.1、Input数据上报：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">30.</span> <span class="toc-text">（八）、参考文档(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>