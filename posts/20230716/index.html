<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux学习系列1：clk子系统 | zhoujinjian</title><meta name="keywords" content="Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习系列1：clk子系统">
<meta property="og:url" content="https://zhoujinjian.com/posts/20230716/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.53.jpg">
<meta property="article:published_time" content="2023-07-15T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.972Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.53.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20230716/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.53.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Linux学习系列1：clk子系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-15T16:00:00.000Z" title="发表于 2023-07-16 00:00:00">2023-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.972Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Kernel-4.19</strong>==）&amp;&amp;（==<strong>文章基于 Android 11.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://shop.allnetchina.cn/collections/frontpage/products/rock-pi-4-model-b-board-only-2-4-5ghz-wlan-bluetooth-5-0">【开发板 RockPi4bPlusV1.6】</a></p>
<p>[【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）源码链接】](repo init -u <a target="_blank" rel="noopener" href="https://github.com/radxa/manifests.git">https://github.com/radxa/manifests.git</a> -b Android11_Radxa_rk11.1 -m rockchip-r-release.xml)</p>
<p>正是由于前人（各位大神）的分析和总结，帮助我节约了大量的时间和精力，特别感谢，由于不喜欢图片水印，去除了水印，敬请谅解！！！</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16777851/category_7923311.html">【linux中common clock framework】</a>    </p>
<p> <a target="_blank" rel="noopener" href="http://www.mysixue.com/?p=129">【CLOCK子系统】</a>    </p>
<h1 id="1-系统概述"><a href="#1-系统概述" class="headerlink" title="1.系统概述"></a>1.系统概述</h1><p>Clock子系统是Linux内核中专门管理时钟的子系统。时钟在嵌入式系统中很重要，它就像人的脉搏一样，驱动器件工作。</p>
<p>任何一个CPU， 都需要给它提供一个外部晶振， 这个晶振就是用来提供时钟的；任何一个CPU内部的片上外设， 也需要工作时钟： 例如GPIO控制器， 首先得给它提供工作时钟， 然后才能访问它的寄存器。</p>
<h2 id="1-1-clk的种类说明"><a href="#1-1-clk的种类说明" class="headerlink" title="1.1 clk的种类说明"></a>1.1 clk的种类说明</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/clk_source.png"></p>
<p>如上图所示，时钟源大概可分为如下几种：</p>
<ul>
<li><p>提供基础时钟源的晶振（可分为有源晶振、无源晶振两种）；</p>
</li>
<li><p>用于倍频的锁相环；</p>
</li>
<li><p>用于分频的divider；</p>
</li>
<li><p>用于多路时钟源选择的mux；</p>
</li>
<li><p>用于时钟使能的与门电路等。</p>
</li>
</ul>
<p>而在CCF(Common Clock Framework，以下简称CCF)子系统的抽象中，这五种均抽象为clk。</p>
<p>但是针对这5种类型的时钟也提供了单独的时钟注册函数（也就是对clk_register函数的封装，并针对不同的时钟类型定义了不同的结构体）。</p>
<ol>
<li>fixed-clock：clk_register_fixed_rate（\kernel\drivers\clk\clk-fixed-clock.c）</li>
<li>pll：clk_register(\kernel\drivers\clk\clk.c)</li>
<li>divider：clk_register_divider（\kernel\drivers\clk\clk-divider.c）</li>
<li>mux：clk_register_mux（\kernel\drivers\clk\clk-mux.c）</li>
<li>gate：clk_register_gate（\kernel\drivers\clk\clk-gate.c）</li>
</ol>
<p>在CCF子系统中，针对硬件时钟的操作接口，也抽象了对应的结构体struct clk_ops。</p>
<p>包含时钟的使能接口、时钟频率的修改接口等等。而针对上述所说的不同种类的时钟源，其并不需要实现所有struct clk_ops中定义的接口。如下图所示，针对“时钟使能的与门电路”而言，仅需要实现enabel、disable、is_enable接口即可；针对多路时钟源选择的mux而言，则需要实现父时钟源的设置及获取的接口set_parent、get_parent等；对于倍频、分频而言，则需要实现时钟频率相关的接口set_rate、recalc_rate等。</p>
<blockquote>
<p>图来源：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/driver-api/clk.html">https://www.kernel.org/doc/html/latest/driver-api/clk.html</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/clk_char.png"></p>
<h2 id="1-2-CCF子系统的框架说明"><a href="#1-2-CCF子系统的框架说明" class="headerlink" title="1.2 CCF子系统的框架说明"></a>1.2 CCF子系统的框架说明</h2><p> Linux内核的clock子系统, 按照其职能, 可以大致分为3部分:</p>
<ol>
<li>向下提供注册接口, 以便各个clocks能注册进clock子系统</li>
<li>在核心层维护池子, 管理所有注册进来的clocks. 这一部分实现的是通用逻辑, 与具体硬件无关</li>
<li>向上, 也就是像各个消费clocks的模块的device driver, 提供获取/使能/配置/关闭clock的通用API</li>
</ol>
<p>如图所示，是CCF子系统的软件框架，其对各设备驱动子系统提供统一时钟源操作的接口，实现为具体的硬件设备获取其对应的输入时钟源，并可通过统一的接口实现对时钟源的配置（如时钟的使能、时钟频率的配置等等）；在CCF内部，针对每一个时钟源，抽象结构体struct clk_hw，该结构体中包含每一个硬件时钟源的操作接口（struct clk_ops），当时钟源驱动程序完成时钟操作接口的定义，并调用clk_register完成注册后，则CCF即可借助clk_hw的clk_ops完成对时钟源的参数配置等操作。</p>
<hr>
<h1 id="2-Clock-Provider-—-如何注册Clocks"><a href="#2-Clock-Provider-—-如何注册Clocks" class="headerlink" title="2.Clock Provider — 如何注册Clocks"></a>2.Clock Provider — 如何注册Clocks</h1><h2 id="2-1-编写clock-driver的大致步骤"><a href="#2-1-编写clock-driver的大致步骤" class="headerlink" title="2.1 编写clock driver的大致步骤"></a>2.1 编写clock driver的大致步骤</h2><p>首先你得准备一个platform_device, 引入device tree的机制后, platform_device被dts替代了, 因此我们就需要在dts里面描述时钟树。</p>
<p><strong>编写platform_device(DTS node)</strong></p>
<p>将时钟树中所有的clock，抽象为一个虚拟的设备，用一个DTS node表示.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\u-boot\arch\arm\dts\rk3399.dtsi</span><br><span class="line">pmucru: pmu-clock-controller@ff750000 &#123;</span><br><span class="line">        compatible &#x3D; &quot;rockchip,rk3399-pmucru&quot;;</span><br><span class="line">        reg &#x3D; &lt;0x0 0xff750000 0x0 0x1000&gt;;</span><br><span class="line">        rockchip,grf &#x3D; &lt;&amp;pmugrf&gt;;</span><br><span class="line">        #clock-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        #reset-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        assigned-clocks &#x3D; &lt;&amp;pmucru PLL_PPLL&gt;;</span><br><span class="line">        assigned-clock-rates &#x3D; &lt;676000000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cru: clock-controller@ff760000 &#123;</span><br><span class="line">        compatible &#x3D; &quot;rockchip,rk3399-cru&quot;;</span><br><span class="line">        reg &#x3D; &lt;0x0 0xff760000 0x0 0x1000&gt;;</span><br><span class="line">        rockchip,grf &#x3D; &lt;&amp;grf&gt;;</span><br><span class="line">        #clock-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        #reset-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        assigned-clocks &#x3D;</span><br><span class="line">            &lt;&amp;cru PLL_GPLL&gt;, &lt;&amp;cru PLL_CPLL&gt;,</span><br><span class="line">            &lt;&amp;cru PLL_NPLL&gt;,</span><br><span class="line">            &lt;&amp;cru ACLK_PERIHP&gt;, &lt;&amp;cru HCLK_PERIHP&gt;,</span><br><span class="line">            &lt;&amp;cru PCLK_PERIHP&gt;,</span><br><span class="line">            &lt;&amp;cru ACLK_PERILP0&gt;, &lt;&amp;cru HCLK_PERILP0&gt;,</span><br><span class="line">            &lt;&amp;cru PCLK_PERILP0&gt;, &lt;&amp;cru ACLK_CCI&gt;,</span><br><span class="line">            &lt;&amp;cru HCLK_PERILP1&gt;, &lt;&amp;cru PCLK_PERILP1&gt;;</span><br><span class="line">        assigned-clock-rates &#x3D;</span><br><span class="line">             &lt;594000000&gt;,  &lt;800000000&gt;,</span><br><span class="line">            &lt;1000000000&gt;,</span><br><span class="line">             &lt;150000000&gt;,   &lt;75000000&gt;,</span><br><span class="line">              &lt;37500000&gt;,</span><br><span class="line">             &lt;100000000&gt;,  &lt;100000000&gt;,</span><br><span class="line">              &lt;50000000&gt;, &lt;600000000&gt;,</span><br><span class="line">             &lt;100000000&gt;,   &lt;50000000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式跟编写一个普通的片上外设的DTS很类似, 比如GPIO控制器的DTS, 对比一下, 是不是很类似.</p>
<p>从这个例子里面, 我们可以看出一个clock的DTS node的基本语法:</p>
<ul>
<li><p>compatible , 决定了与这个node匹配的driver</p>
</li>
<li><p>reg就是用来描述PCM的寄存器</p>
</li>
<li><p>#clock-cells, 这个是clock provider node独有的, 表明在引用此clock时, 需要用几个32位来描述. 什么意思呢?</p>
</li>
</ul>
<p>假设这个clock有多个输出时钟, 那么这个时候#clock–cells 应该为 &lt;1&gt;, 因为我们在引用此clock的时候, 需要指明到底用哪一个输出时钟.在引用此clock, 就得这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\u-boot\arch\arm\dts\rk3399.dtsi</span><br><span class="line">i2c0: i2c@ff3c0000 &#123;</span><br><span class="line">        compatible &#x3D; &quot;rockchip,rk3399-i2c&quot;;</span><br><span class="line">        reg &#x3D; &lt;0x0 0xff3c0000 0x0 0x1000&gt;;</span><br><span class="line">        assigned-clocks &#x3D; &lt;&amp;pmucru SCLK_I2C0_PMU&gt;;</span><br><span class="line">        assigned-clock-rates &#x3D; &lt;200000000&gt;;</span><br><span class="line">        clocks &#x3D; &lt;&amp;pmucru SCLK_I2C0_PMU&gt;, &lt;&amp;pmucru PCLK_I2C0_PMU&gt;;</span><br><span class="line">        &#x2F;* 指明引用pmucru clock,SCLK_I2C0_PMU&#x2F;PCLK_I2C0_PMU是一个32位的整数, 表明到底用哪一个输出clock *&#x2F;</span><br><span class="line">        clock-names &#x3D; &quot;i2c&quot;, &quot;pclk&quot;;</span><br><span class="line">        interrupts &#x3D; &lt;GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH 0&gt;;</span><br><span class="line">        pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">        pinctrl-0 &#x3D; &lt;&amp;i2c0_xfer&gt;;</span><br><span class="line">        #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">        #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        status &#x3D; &quot;disabled&quot;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-编写platform-driver"><a href="#2-2-编写platform-driver" class="headerlink" title="2.2 编写platform_driver"></a>2.2 编写platform_driver</h2><p>有了platform_device之后, 接下来就得编写platform_driver, 在driver里面最重要的事情就是向clock子系统注册.</p>
<p>如何注册呢?</p>
<p>clock子系统定义了clock driver需要实现的数据结构, 同时提供了注册的函数. 我们只需要准备好相关的数据结构, 然后调用注册函数进行注册即可.</p>
<p>这些数据结构和接口函数的定义是在: include/linux/clk-provider.h</p>
<p>需要实现的数据结构是 struct clk_hw, 需要调用的注册函数是struct clk *clk_register(struct device *dev, struct clk_hw *hw). 数据结构和注册函数的细节我们在后文说明.</p>
<p>注册函数会返回给你一个struct clk类型的指针, 在Linux的clock子系统中, 用一个struct clk代表一个clock. 你的CPU的时钟树里有多少个clock, 就会有多少个对应的struct clk.</p>
<p>当你拿到返回结果之后, 你需要调用另外一个API : of_clk_add_provider, 把刚刚拿到的返回结果通过此API丢到池子里面, 好让consumer从这个池子里获取某一个clock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\rockchip\clk.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rockchip_clk_of_add_provider</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct rockchip_clk_provider *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (of_clk_add_provider(np, of_clk_src_onecell_get,</span><br><span class="line">                &amp;ctx-&gt;clk_data))</span><br><span class="line">        pr_err(<span class="string">&quot;%s: could not register clk provider\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>池子的概念我们在前文讲述过, 除了上述方法, 你还可以用另外一种方法把struct clk添加到池子里面.</p>
<p>如果你要用这种方法, 你会用到clock子系统提供给你的另外几个API, 这些API的定义在: include/linux/clkdev.h</p>
<p>其中最主要的一个API是int clk_register_clkdev(struct clk *, const char *, const char *, …), 你可以在你的clock driver里面调用这个API, 把刚刚拿到的返回结果通过此API丢到池子里面.</p>
<p>为什么会存在这两种方式呢? 得从consumer的角度来解答这个问题.</p>
<p>我们用GPIO来举个例子, GPIO控制器需要工作时钟, 这个时钟假设叫gpio_clk, 它是一个provider. 你需要把这个provider注册进clock子系统, 并把用于描述这个gpio_clk的struct clk添加到池子里面.</p>
<p>在GPIO控制器的driver代码里, 我们需要获取到gpio_clk这个时钟并使能它, 获取的过程就是向池子查询.</p>
<p>怎么查询? 你可以直接给定一个name, 然后通过这个name向池子查询; 你也可以在GPIO的DTS node里面用clocks = &lt;&amp;theclock&gt;;方式指明使用哪一个clock, 然后通过这种方式向池子查询.</p>
<p>如果consumer是通过name查询, 则对应的添加到池子的API就是clk_register_clkdev</p>
<p>如果consumer是通过DTS查询, 则对应的添加到池子的API就是of_clk_add_provider</p>
<p>那么我在我的clock driver里面到底应该用哪个API向池子添加clk呢?</p>
<p>两者你都应该同时使用, 这样consumer端不管用哪种查询方式都能工作.</p>
<p>读到这里, 建议你回头看看clock子系统的系统框图, 结合框图在琢磨琢磨.</p>
<p>接下来, 我们就会详细介绍这些数据结构和相关的API了.</p>
<h2 id="2-3-主要数据结构"><a href="#2-3-主要数据结构" class="headerlink" title="2.3  主要数据结构"></a><strong>2.3</strong>  <strong>主要数据结构</strong></h2><p>通过前文, 我们知道了clock driver需要实现的一个主要的数据结构struct clk_hw.</p>
<p>与之相关的还有另外几个重要数据结构: struct clk_init_data和struct clk_ops.</p>
<p>下面我们看看这几个数据结构.</p>
<h3 id="struct-clk-hw"><a href="#struct-clk-hw" class="headerlink" title="struct clk_hw"></a><strong>struct</strong> clk_hw</h3><blockquote>
<p>include/linux/clk-provider.h</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210824162026412.png" alt="image-20210824162026412"></p>
<h3 id="struct-clk-init-data"><a href="#struct-clk-init-data" class="headerlink" title="struct clk_init_data"></a><strong>struct</strong> clk_init_data</h3><blockquote>
<p>include/linux/clk-provider.h</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210824162137515.png" alt="image-20210824162137515"></p>
<h3 id="struct-clk-ops"><a href="#struct-clk-ops" class="headerlink" title="struct  clk_ops"></a><strong>struct</strong>  clk_ops</h3><blockquote>
<p>include/linux/clk-provider.h</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/struct_clk_ops-16297933295211.png"></p>
<h2 id="2-4-主要-API-说明"><a href="#2-4-主要-API-说明" class="headerlink" title="2.4 主要 API 说明"></a><strong>2.4</strong> 主要 API 说明</h2><p>Linux clock子系统向下提供几个重要的API, 下面我挨个看下这些API的细节.</p>
<h3 id="clk-register-devm-clk-register"><a href="#clk-register-devm-clk-register" class="headerlink" title="clk_register /devm_clk_register"></a>clk_register /devm_clk_register</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line">实现文件: drivers/clk/clk.c</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clk_register - allocate a new clock, register it and return an opaque cookie</span></span><br><span class="line"><span class="comment"> * @dev: device that is registering this clock</span></span><br><span class="line"><span class="comment"> * @hw: link to hardware-specific clock data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * clk_register is the primary interface for populating the clock tree with new</span></span><br><span class="line"><span class="comment"> * clock nodes.  It returns a pointer to the newly allocated struct clk which</span></span><br><span class="line"><span class="comment"> * cannot be dereferenced by driver code but may be used in conjuction with the</span></span><br><span class="line"><span class="comment"> * rest of the clock API.  In the event of an error clk_register will return an</span></span><br><span class="line"><span class="comment"> * error code; drivers must test for an error code after calling clk_register.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register</span><span class="params">(struct device *dev, struct clk_hw *hw)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">devm_clk_register</span><span class="params">(struct device *dev, struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">devm_clk_unregister</span><span class="params">(struct device *dev, struct clk *clk)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clk_register是clock子系统提供的注册clock的最基础的API函数, 后文描述的其它APIs都是对它的封装.</p>
<p>devm_clk_register是clk_register的devm版本, devm机制在《设备模型》一文中有详述.</p>
<p>要向系统注册一个clock也很简单, 准备好clk_hw结构体, 然后调用clk_register接口即可.</p>
<p>不过, clock framework所做的远比这周到, 它基于clk_register, 又封装了其它接口, 在向clock子系统注册时, 连struct clk_hw都不需要关心, 而是直接使用类似人类语言的方式.</p>
<p>也就是说, 实际在编写clock driver的时候, 我们不会直接使用clk_register接口, 只需要调用下面的某个API即可.</p>
<p>下文我们一一介绍这些API.</p>
<h3 id="clk-register-fixed-rate"><a href="#clk-register-fixed-rate" class="headerlink" title="clk_register_fixed_rate"></a><strong>clk_register_fixed_rate</strong></h3><p>clock有不同的类型, 有的clock频率是固定的, 不可调整的, 例如外部晶振, 频率就是固定的(24M / 25M). 这种类型的clock就是fixed_rate clock.</p>
<p>fixed_rate clock具有固定的频率, 不能开关、不能调整频率、不能选择parent、不需要提供任何的clk_ops回调函数, 是最简单的一类clock.</p>
<p>如果要注册这种类型的clock, 直接调用本API, 传递相应的参数给本API即可. API的细节如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-fixed-rate.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DOC: Basic clock implementations common to many platforms</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each basic clock hardware type is comprised of a structure describing the</span></span><br><span class="line"><span class="comment"> * clock hardware, implementations of the relevant callbacks in struct clk_ops,</span></span><br><span class="line"><span class="comment"> * unique flags for that hardware type, a registration function and an</span></span><br><span class="line"><span class="comment"> * alternative macro for static initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct clk_fixed_rate - fixed-rate clock</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @fixed_rate:    constant frequency of clock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_fixed_rate</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>        <span class="title">clk_hw</span> <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>    fixed_rate;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>    fixed_accuracy;</span><br><span class="line">    u8        flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_fixed_rate(_hw) container_of(_hw, struct clk_fixed_rate, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_fixed_rate_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_fixed_rate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_rate)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_fixed_rate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_rate)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_fixed_rate_with_accuracy</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_accuracy)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_fixed_rate</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_fixed_rate_with_accuracy</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> fixed_accuracy)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_fixed_rate</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">of_fixed_clk_setup</span><span class="params">(struct device_node *np)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若想注册一个fixed rate clock, 除了你可以在自己的clock driver里面手动调用clk_register_fixed_rate之外, 还有一种更简单的方式, 那就是用DTS.</p>
<p>你可以在DTS里面用如下方式描述一个fixed rate clock:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\u-boot\arch\arm\dts\rk3399.dtsi</span><br><span class="line">xin24m: xin24m &#123;</span><br><span class="line">        compatible &#x3D; &quot;fixed-clock&quot;;</span><br><span class="line">        clock-frequency &#x3D; &lt;24000000&gt;;</span><br><span class="line">        clock-output-names &#x3D; &quot;xin24m&quot;;</span><br><span class="line">        #clock-cells &#x3D; &lt;0&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关键地方在于compatible一定要是”fixed-clock”</p>
</li>
<li><p>“drivers/clk/clk-fixed-rate.c”中的of_fixed_clk_setup会负责匹配这个compatible, 这个C文件是clock子系统实现的.</p>
</li>
<li><p>of_fixed_clk_setup会解析3个参数: clock-frequency, clock-accuracy, clock-output-names</p>
</li>
</ul>
<p>clock-frequency是必须的, 另外2个参数可选.</p>
<p>参数解析完毕之后, 会调用clk_register_fixed_rate_with_accuracy向系统注册一个clock.</p>
<h3 id="clk-register-gate"><a href="#clk-register-gate" class="headerlink" title="clk_register_gate"></a><strong>clk_register_gate</strong></h3><p>这一类clock只可开关（会提供.enable/.disable回调）, 可使用下面接口注册:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-gate.c</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct clk_gate - gating clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @reg:    register controlling gate</span></span><br><span class="line"><span class="comment"> * @bit_idx:    single bit controlling gate</span></span><br><span class="line"><span class="comment"> * @flags:    hardware-specific flags</span></span><br><span class="line"><span class="comment"> * @lock:    register lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clock which can gate its output.  Implements .enable &amp; .disable</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Flags:</span></span><br><span class="line"><span class="comment"> * CLK_GATE_SET_TO_DISABLE - by default this clock sets the bit at bit_idx to</span></span><br><span class="line"><span class="comment"> *    enable the clock.  Setting this flag does the opposite: setting the bit</span></span><br><span class="line"><span class="comment"> *    disable the clock and clearing it enables the clock</span></span><br><span class="line"><span class="comment"> * CLK_GATE_HIWORD_MASK - The gate settings are only in lower 16-bit</span></span><br><span class="line"><span class="comment"> *    of this register, and mask of gate bits are in higher 16-bit of this</span></span><br><span class="line"><span class="comment"> *    register.  While setting the gate bits, higher 16-bit should also be</span></span><br><span class="line"><span class="comment"> *    updated to indicate changing gate bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_gate</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span> <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem    *reg;</span><br><span class="line">    u8        bit_idx;</span><br><span class="line">    u8        flags;</span><br><span class="line">    <span class="keyword">spinlock_t</span>    *lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_gate(_hw) container_of(_hw, struct clk_gate, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_GATE_SET_TO_DISABLE        BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_GATE_HIWORD_MASK        BIT(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_gate_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_gate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 bit_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_gate_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_gate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 bit_idx,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_gate_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_gate</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_gate</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_gate_is_enabled</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>clk_register_gate</strong>, 它的参数列表如下:</p>
<ul>
<li><p>name: clock的名称</p>
</li>
<li><p>parent_name: parent clock的名称, 没有的话可留空</p>
</li>
<li><p>flags : flags描述</p>
</li>
<li><p>reg: 控制该clock开关的寄存器地址（虚拟地址）</p>
</li>
<li><p>bit_idx: reg中, 第几个bit是控制clock开/关的</p>
</li>
<li><p>clk_gate_flags: gate clock特有的参数. 其中一个可选值是CLK_GATE_SET_TO_DISABLE, 它的意思是1表示开还是0表示开, 类似于翻转位.</p>
</li>
<li><p>lock: 如果clock开关时需要互斥, 可提供一个spinlock.</p>
</li>
</ul>
<h3 id="clk-register-divider-clk-register-divider-table"><a href="#clk-register-divider-clk-register-divider-table" class="headerlink" title="clk_register_divider/clk_register_divider_table"></a>clk_register_divider/clk_register_divider_table</h3><p>这一类clock可以设置分频值（因而会提供.recalc_rate/.set_rate/.round_rate回调）, 可通过下面两个接口注册：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line">实现文件: drivers/clk/clk-divider.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_divider</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem    *reg;</span><br><span class="line">    u8        shift;</span><br><span class="line">    u8        width;</span><br><span class="line">    u8        flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>    max_prate;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_div_table</span>    *<span class="title">table</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>    *lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clk_div_mask(width)    ((1 &lt;&lt; (width)) - 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_divider(_hw) container_of(_hw, struct clk_divider, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_ONE_BASED        BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_POWER_OF_TWO    BIT(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_ALLOW_ZERO        BIT(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_HIWORD_MASK        BIT(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_ROUND_CLOSEST    BIT(4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_READ_ONLY        BIT(5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_DIVIDER_MAX_AT_ZERO        BIT(6)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_divider_ops</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_divider_ro_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">divider_recalc_rate</span><span class="params">(struct clk_hw *hw, <span class="keyword">unsigned</span> <span class="keyword">long</span> parent_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> val, <span class="keyword">const</span> struct clk_div_table *table,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">divider_round_rate_parent</span><span class="params">(struct clk_hw *hw, struct clk_hw *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *prate,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> struct clk_div_table *table,</span></span></span><br><span class="line"><span class="function"><span class="params">                   u8 width, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">divider_ro_round_rate_parent</span><span class="params">(struct clk_hw *hw, struct clk_hw *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *prate,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct clk_div_table *table, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divider_get_val</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> parent_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct clk_div_table *table, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_divider</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_divider</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_divider_table</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">const</span> struct clk_div_table *table,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_divider_table</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">const</span> struct clk_div_table *table,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_divider</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_divider</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>lk_register_divider</strong> : 该接口用于注册分频比规则的clock</p>
<ul>
<li><p>reg: 控制clock分频比的寄存器</p>
</li>
<li><p>shift: 控制分频比的bit在寄存器中的偏移</p>
</li>
<li><p>width: 控制分频比的bit位数, 默认情况下, 实际的divider值是寄存器值加1.</p>
</li>
</ul>
<p>如果有其它例外, 可使用下面的的flag指示。</p>
<ul>
<li>clk_divider_flags: divider clock特有的flag, 包括:<br>CLK_DIVIDER_ONE_BASED:</li>
</ul>
<p>实际的divider值就是寄存器值（0是无效的，除非设置CLK_DIVIDER_ALLOW_ZERO flag）</p>
<p>CLK_DIVIDER_POWER_OF_TWO:</p>
<p>实际的divider值是寄存器值得2次方</p>
<p>CLK_DIVIDER_ALLOW_ZERO:</p>
<p>divider值可以为0（不改变，视硬件支持而定）</p>
<p><strong>clk_register_divider_table</strong> : 该接口用于注册分频比不规则的clock，和上面接口比较，差别在于divider值和寄存器值得对应关系由一个table决定. table的原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_div_table</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  div;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>val代表寄存器值, div代表对应的分频值.</p>
<p>同样, clock子系统并没有实现DTS相关接口, 不过你可以自己编写driver去解析DTS并调用API注册.</p>
<h3 id="clk-register-mux"><a href="#clk-register-mux" class="headerlink" title="clk_register_mux"></a><strong>clk_register_mux</strong></h3><p>这一类clock可以选择多个parent, 因为会实现.get_parent/.set_parent/.recalc_rate回调, 可通过下面两个接口注册:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-mux.c</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_mux</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem    *reg;</span><br><span class="line">    u32        *table;</span><br><span class="line">    u32        mask;</span><br><span class="line">    u8        shift;</span><br><span class="line">    u8        flags;</span><br><span class="line">    <span class="keyword">spinlock_t</span>    *lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_MUX_INDEX_ONE        BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_MUX_INDEX_BIT        BIT(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_MUX_HIWORD_MASK        BIT(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_MUX_READ_ONLY        BIT(3) <span class="comment">/* mux can&#x27;t be changed */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLK_MUX_ROUND_CLOSEST        BIT(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_mux_ops</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_mux_ro_ops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_mux</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_mux_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_mux</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u8 width,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_mux_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_mux_table</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u32 mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_mux_flags, u32 *table, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_mux_table</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 shift, u32 mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_mux_flags, u32 *table, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_mux_val_to_index</span><span class="params">(struct clk_hw *hw, u32 *table, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">unsigned</span> <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">clk_mux_index_to_val</span><span class="params">(u32 *table, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, u8 index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_mux</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_mux</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>clk_register_mux</strong> : 该接口可注册mux控制比较规则的clock（类似divider clock）</p>
<ul>
<li><p>parent_names: 一个字符串数组，用于描述所有可能的parent clock</p>
</li>
<li><p>num_parents: parent clock的个数</p>
</li>
<li><p>reg、shift、width: 选择parent的寄存器、偏移、宽度</p>
</li>
<li><p>clk_mux_flags: mux clock特有的flag</p>
</li>
</ul>
<p>CLK_MUX_INDEX_ONE : 寄存器值不是从0开始，而是从1开始</p>
<p>CLK_MUX_INDEX_BIT : 寄存器值为2的幂</p>
<p><strong>clk_register_mux_table</strong> : 该接口通过一个table, 注册mux控制不规则的clock, 原理和divider clock类似, 不再详细介绍</p>
<p>同样, clock子系统并没有实现DTS相关接口, 不过你可以自己编写driver去解析DTS并调用API注册.</p>
<h3 id="clk-register-fixed-factor"><a href="#clk-register-fixed-factor" class="headerlink" title="clk_register_fixed_factor"></a><strong>clk_register_fixed_factor</strong></h3><p>这一类clock具有固定的factor（即multiplier和divider）, clock的频率是由parent clock的频率, 乘以mul, 除以div, 多用于一些具有固定分频系数的clock.</p>
<p>由于parent clock的频率可以改变, 因而fix factor clock也可以改变频率, 因此也会提供.recalc_rate/.set_rate/.round_rate等回调.</p>
<p>可通过下面接口注册:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-fixed-factor.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">of_fixed_factor_clk_setup</span><span class="params">(struct device_node *node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct clk_fixed_factor - fixed multiplier and divider clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @mult:    multiplier</span></span><br><span class="line"><span class="comment"> * @div:    divider</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clock with a fixed multiplier and divider. The output frequency is the</span></span><br><span class="line"><span class="comment"> * parent clock rate divided by div and multiplied by mult.</span></span><br><span class="line"><span class="comment"> * Implements .recalc_rate, .set_rate and .round_rate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_fixed_factor</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    mult;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_fixed_factor(_hw) container_of(_hw, struct clk_fixed_factor, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_fixed_factor_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_fixed_factor</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> mult, <span class="keyword">unsigned</span> <span class="keyword">int</span> div)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_fixed_factor</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_fixed_factor</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> mult, <span class="keyword">unsigned</span> <span class="keyword">int</span> div)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_fixed_factor</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>API 参数比较简单, 不多说了.</p>
<p>另外, clock子系统还提供了此种类型clock的DTS接口.</p>
<p>clk-fixed-factor.c中的of_fixed_factor_clk_setup函数会负责解析DTS. 关于DTS的匹配规则和相关参数, 自己看看源码吧.</p>
<h3 id="clk-register-fractional-divider"><a href="#clk-register-fractional-divider" class="headerlink" title="clk_register_fractional_divider"></a><strong>clk_register_fractional_divider</strong></h3><p>这一类和divider clock很像, 唯一的不同在于它可支持到更细的粒度 (可用小数表示分频因子) . 例如 clk = parent / 1.5</p>
<p>API说明如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-fractional-divider.c</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct clk_fractional_divider - adjustable fractional divider clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @reg:    register containing the divider</span></span><br><span class="line"><span class="comment"> * @mshift:    shift to the numerator bit field</span></span><br><span class="line"><span class="comment"> * @mwidth:    width of the numerator bit field</span></span><br><span class="line"><span class="comment"> * @nshift:    shift to the denominator bit field</span></span><br><span class="line"><span class="comment"> * @nwidth:    width of the denominator bit field</span></span><br><span class="line"><span class="comment"> * @max_parent:    the maximum frequency of fractional divider parent clock</span></span><br><span class="line"><span class="comment"> * @lock:    register lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clock with adjustable fractional divider affecting its output frequency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_fractional_divider</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem    *reg;</span><br><span class="line">    u8        mshift;</span><br><span class="line">    u8        mwidth;</span><br><span class="line">    u32        mmask;</span><br><span class="line">    u8        nshift;</span><br><span class="line">    u8        nwidth;</span><br><span class="line">    u32        nmask;</span><br><span class="line">    u8        flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>    max_prate;</span><br><span class="line">    <span class="keyword">void</span>        (*approximation)(struct clk_hw *hw,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> rate, <span class="keyword">unsigned</span> <span class="keyword">long</span> *parent_rate,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> *m, <span class="keyword">unsigned</span> <span class="keyword">long</span> *n);</span><br><span class="line">    <span class="keyword">spinlock_t</span>    *lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_fd(_hw) container_of(_hw, struct clk_fractional_divider, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_fractional_divider_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_fractional_divider</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_fractional_divider</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        u8 clk_divider_flags, <span class="keyword">spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_fractional_divider</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="clk-register-composite"><a href="#clk-register-composite" class="headerlink" title="clk_register_composite"></a><strong>clk_register_composite</strong></h3><p>顾名思义, 就是mux、divider、gate等clock的组合, 可通过下面接口注册:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-composite.c</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * struct clk_composite - aggregate clock of mux, divider and gate clocks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @mux_hw:    handle between composite and hardware-specific mux clock</span></span><br><span class="line"><span class="comment"> * @rate_hw:    handle between composite and hardware-specific rate clock</span></span><br><span class="line"><span class="comment"> * @gate_hw:    handle between composite and hardware-specific gate clock</span></span><br><span class="line"><span class="comment"> * @brother_hw: a member of clk_composite who has the common parent clocks</span></span><br><span class="line"><span class="comment"> *              with another clk_composite, and it&#x27;s also a handle between</span></span><br><span class="line"><span class="comment"> *              common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @mux_ops:    clock ops for mux</span></span><br><span class="line"><span class="comment"> * @rate_ops:    clock ops for rate</span></span><br><span class="line"><span class="comment"> * @gate_ops:    clock ops for gate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_composite</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span>    <span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    *<span class="title">mux_hw</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    *<span class="title">rate_hw</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    *<span class="title">gate_hw</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    *<span class="title">brother_hw</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span>    *<span class="title">mux_ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span>    *<span class="title">rate_ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span>    *<span class="title">gate_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_composite(_hw) container_of(_hw, struct clk_composite, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_composite</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, <span class="keyword">int</span> num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *mux_hw, <span class="keyword">const</span> struct clk_ops *mux_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *rate_hw, <span class="keyword">const</span> struct clk_ops *rate_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *gate_hw, <span class="keyword">const</span> struct clk_ops *gate_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unregister_composite</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_composite</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, <span class="keyword">int</span> num_parents,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *mux_hw, <span class="keyword">const</span> struct clk_ops *mux_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *rate_hw, <span class="keyword">const</span> struct clk_ops *rate_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct clk_hw *gate_hw, <span class="keyword">const</span> struct clk_ops *gate_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_composite</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="clk-register-gpio-gate"><a href="#clk-register-gpio-gate" class="headerlink" title="clk_register_gpio_gate"></a><strong>clk_register_gpio_gate</strong></h3><p>把某个gpio当做一个gate clock. 也就是说可以通过clock子系统来控制这个gpio 开/关, 也就是控制这个GPIO输出高/低电平.</p>
<p>某些情况下, 有的模块需要通过某个GPIO来控制其使能/禁止, 例如蓝牙模块. 而且你也不需要向此模块提供时钟, 模板本身就有晶振存在, 可以自己给自己供时钟.</p>
<p>这个时候我们就可以把该GPIO抽象成gpio gate clock, 借助clock子系统, 来控制模块的enable/disable.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk-gpio-gate.c</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * struct clk_gpio_gate - gpio gated clock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        handle between common and hardware-specific interfaces</span></span><br><span class="line"><span class="comment"> * @gpiod:    gpio descriptor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clock with a gpio control for enabling and disabling the parent clock.</span></span><br><span class="line"><span class="comment"> * Implements .enable, .disable and .is_enabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk_gpio</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_hw</span>    <span class="title">hw</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_clk_gpio(_hw) container_of(_hw, struct clk_gpio, hw)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_gpio_gate_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_gpio_gate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, struct gpio_desc *gpiod,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_gpio_gate</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parent_name, struct gpio_desc *gpiod,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_gpio_gate</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct clk_gpio_mux - gpio controlled clock multiplexer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @hw:        see struct clk_gpio</span></span><br><span class="line"><span class="comment"> * @gpiod:    gpio descriptor to select the parent of this clock multiplexer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Clock with a gpio control for selecting the parent clock.</span></span><br><span class="line"><span class="comment"> * Implements .get_parent, .set_parent and .determine_rate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">clk_ops</span> <span class="title">clk_gpio_mux_ops</span>;</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register_gpio_mux</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents, struct gpio_desc *gpiod,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function">struct clk_hw *<span class="title">clk_hw_register_gpio_mux</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *parent_names, u8 num_parents, struct gpio_desc *gpiod,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_hw_unregister_gpio_mux</span><span class="params">(struct clk_hw *hw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>API 参数比较简单, 不多说了.</p>
<p>另外, clock子系统还提供了此种类型clock的DTS接口.</p>
<h3 id="xxx-unregister"><a href="#xxx-unregister" class="headerlink" title="xxx_unregister"></a>xxx_unregister</h3><p>上述xxx_register函数都有对应的xxx_unregister.</p>
<p>unregister的函数原型在上述代码中都有提及, 这里不多说了, 有兴趣可以自行阅读源代码.</p>
<h3 id="clk-register-clkdev"><a href="#clk-register-clkdev" class="headerlink" title="clk_register_clkdev"></a><strong>clk_register_clkdev</strong></h3><p>头文件: include/linux/clkdev.h</p>
<p>实现文件: drivers/clk/clkdev.c</p>
<p>原型: int clk_register_clkdev*<em>(**struct clk **</em>,** const char <strong>*,** const char *</strong>,** <strong>…);</strong></p>
<p>上述的clk_register_xxx接口会向clock子系统注册一个clock, 并返回一个代表该clock的struct clk结构体.</p>
<p>clk_register_clkdev的作用就是把返回的这个struct clk添加到某个池子里面.</p>
<p>这个池子其实就是个链表啦, 链表定义在clkdev.c里面.</p>
<p>池子里面主要是用name做为关键字, 区分不同的clk.</p>
<p>当consumer端想要查询某个clk的时候, 就会尝试从这个链表里面通过clock name去检索.</p>
<h3 id="of-clk-add-provider"><a href="#of-clk-add-provider" class="headerlink" title="of_clk_add_provider"></a><strong>of_clk_add_provider</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk-provider.h</span><br><span class="line">实现文件: drivers/clk/clk.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_clk_add_provider</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct clk *(*clk_src_get)(struct of_phandle_args *args,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此API的主要目的也是把得到的struct clk结构体添加到某个池子里面.</p>
<p>这个池子也是个链表, 定义在clk.c里面.</p>
<p>与上面那个池子的不同之处在于, 这里是用device_node做为关键字来区分不同的clk.</p>
<p>当consumer端想要查询某个clk的时候, 会在DTS node里面通过clocks = &lt;&amp;xxxx&gt;来引用某个clock.</p>
<p>通过引用的这个clock的phandle, 就能找到对应的device_node. 然后通过device_node就能从池子里面检索出需要的clk.</p>
<p>其实, 这两种池子对应了我们的consumer端的两种方式: 一种是通过name获取clk, 不需要DTS; 另外一种就是通过DTS.</p>
<p>随着Linux内核大力推行DTS, 方式二会逐渐成为主流.</p>
<h1 id="3-clock-core-—-如何管理Clocks"><a href="#3-clock-core-—-如何管理Clocks" class="headerlink" title="3.  clock core — 如何管理Clocks"></a><strong>3.</strong>  <strong>clock</strong> <strong>core —</strong> 如何管理Clocks</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1       简介"></a><strong>3.1</strong>       <strong>简介</strong></h2><p>第2章我们描述了clock子系统的功能之一 : 向底层的clock driver提供注册接口.</p>
<p>本章我们描述clock子系统的功能之二 : 如何管理这些clocks.</p>
<p>当clock driver向子系统注册某一个clock的时候, 子系统内部会创建一个数据结构来表示这个clock. 这个数据结构在前文提过, 就是struct clk.</p>
<p>一个struct clk就对应一个clock. 到目前为止, 我们还没见过这个数据结构的庐山真面目呢! 本章会围绕这个数据结构展开, 充分理解它, 你就里面本章了.</p>
<h2 id="3-2-主要数据结构"><a href="#3-2-主要数据结构" class="headerlink" title="3.2       主要数据结构"></a><strong>3.2</strong>       <strong>主要数据结构</strong></h2><h3 id="struct-clk"><a href="#struct-clk" class="headerlink" title="struct clk"></a><strong>struct</strong> <strong>clk</strong></h3><p>结构体定义在一个C文件里面 : drivers/clk/clk.c</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/struct_clk.png"></p>
<h3 id="struct-clk-core"><a href="#struct-clk-core" class="headerlink" title="struct clk_core"></a><strong>struct</strong> <strong>clk_core</strong></h3><p>前文我们说过, 一个struct clk就代表一个clock. 一个clk_core与clock也是一一对应的关系. 那它俩有什么区别呢?</p>
<p>struct clk更像是对外的接口, 例如当provider向clock子系统注册时, 它会得到一个struct clk<em>的返回结果; 当consumer想要使用某个clock时, 也会首先获取struct clk</em>这个结构体.</p>
<p>struct clk_core则是clock子系统核心层的一个私有数据结构, 在核心层代描述某个具体的clock. provider或consumer不会触碰这个数据结构.</p>
<p>结构体定义在一个C文件里面 : drivers/clk/clk.c</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210824164801849.png" alt="image-20210824164801849"></p>
<h2 id="3-3-关键代码分析"><a href="#3-3-关键代码分析" class="headerlink" title="3.3 关键代码分析"></a><strong>3.3</strong> <strong>关键代码分析</strong></h2><h3 id="clk-register"><a href="#clk-register" class="headerlink" title="clk_register"></a><strong>clk_register</strong></h3><p>我们在2.4节介绍了clock子系统提供给provider端的总多clk_register_xxx函数. 这些函数都是对clk_register的封装, 基础都是clk_register.</p>
<p>因此我们本章只重点讲解这一个API, 其它API有兴趣可以自己阅读源码.</p>
<p>在开始分析之前, 结合之前讲解的内容, 你能猜到clk_register会做哪些事情吗?</p>
<p>首先, 它得创建struct clk和struct clk_core这两个数据结构.</p>
<p>然后, 它得维护clk_core的树形关系, 就像时钟数的硬件形态那样:</p>
<p>有一个或多个ROOT_CLOCK, ROOT_CLOCK没有parent, 下面挂载的是children, children下面在挂载children.</p>
<p>为什么要维护这样的树形结构呢? 因为我们在操作某个clk时, 往往会跟它的parent有关: 例如要使能某个clk, 必须保证它的parent也使能; 或者parent的rate改变了, 那它的children的rate都有可能改变. 因此clock子系统必须维护好树形结构, 才能方便的处理这些相关性.</p>
<p>下面我们来看看代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">实现文件: drivers/clk/clk.c</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clk_register - allocate a new clock, register it and return an opaque cookie</span></span><br><span class="line"><span class="comment"> * @dev: device that is registering this clock</span></span><br><span class="line"><span class="comment"> * @hw: link to hardware-specific clock data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * clk_register is the primary interface for populating the clock tree with new</span></span><br><span class="line"><span class="comment"> * clock nodes.  It returns a pointer to the newly allocated struct clk which</span></span><br><span class="line"><span class="comment"> * cannot be dereferenced by driver code but may be used in conjunction with the</span></span><br><span class="line"><span class="comment"> * rest of the clock API.  In the event of an error clk_register will return an</span></span><br><span class="line"><span class="comment"> * error code; drivers must test for an error code after calling clk_register.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_register</span><span class="params">(struct device *dev, struct clk_hw *hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_core</span> *<span class="title">core</span>;</span></span><br><span class="line"></span><br><span class="line">    core = kzalloc(<span class="keyword">sizeof</span>(*core), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    core-&gt;name = kstrdup_const(hw-&gt;init-&gt;name, GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    core-&gt;ops = hw-&gt;init-&gt;ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev &amp;&amp; pm_runtime_enabled(dev))</span><br><span class="line">        core-&gt;rpm_enabled = <span class="literal">true</span>;</span><br><span class="line">    core-&gt;dev = dev;</span><br><span class="line">    <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;driver)</span><br><span class="line">        core-&gt;owner = dev-&gt;driver-&gt;owner;</span><br><span class="line">    core-&gt;hw = hw;</span><br><span class="line">    core-&gt;flags = hw-&gt;init-&gt;flags;</span><br><span class="line">    core-&gt;num_parents = hw-&gt;init-&gt;num_parents;</span><br><span class="line">    core-&gt;min_rate = <span class="number">0</span>;</span><br><span class="line">    core-&gt;max_rate = ULONG_MAX;</span><br><span class="line">    hw-&gt;core = core;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate local copy in case parent_names is __initdata */</span></span><br><span class="line">    core-&gt;parent_names = kcalloc(core-&gt;num_parents, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *),</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy each string name in case parent_names is __initdata */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; core-&gt;num_parents; i++) &#123;</span><br><span class="line">        core-&gt;parent_names[i] = kstrdup_const(hw-&gt;init-&gt;parent_names[i],</span><br><span class="line">                        GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* avoid unnecessary string look-ups of clk_core&#x27;s possible parents. */</span></span><br><span class="line">    core-&gt;parents = kcalloc(core-&gt;num_parents, <span class="keyword">sizeof</span>(*core-&gt;parents),</span><br><span class="line">                GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    INIT_HLIST_HEAD(&amp;core-&gt;clks);</span><br><span class="line"></span><br><span class="line">    hw-&gt;clk = clk_hw_create_clk(hw, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ret = __clk_core_init(core);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    __clk_free_clk(hw-&gt;clk);</span><br><span class="line">    hw-&gt;clk = <span class="literal">NULL</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(clk_register);</span><br></pre></td></tr></table></figure>

<p>上面这段代码的逻辑比较简单:</p>
<ul>
<li><p>首先, 创建了clk_core结构体, 然后用provider提供的clk_hw, 填充clk_core中的各个字段.</p>
</li>
<li><p>然后, 调用 clk_hw_create_clk, 在clk_hw_create_clk里面会创建struct clk这个结构体并初始化其相关字段. clk_register会返回给provider一个struct clk<em>的结构体指针, 这个clk</em>就是这里创建的.</p>
</li>
</ul>
<p>下文我们会单独介绍clk_hw_create_clk这个函数.</p>
<ul>
<li>最后, 会调用__clk_core_init, 在__clk_core_init里面会处理clk_core之间的树形结构关系.</li>
</ul>
<p>下文我们会单独介绍__clk_init这个函数.</p>
<p>这个API会创建一个struct clk结构体.</p>
<p>要理解此API的细节, 首先得理清楚struct clk和struct clk_core的关系.</p>
<p>我们在3.2节《struct clk_core》中已经初步介绍了clk和clk_core的关系, 可以回头看看.</p>
<p>这里我们在做进一步的说明.clk和clk_core的关系与上面很类型, clk_core代表一个硬件上的clock, 一个clock对应唯一一个clk_core; 而clk则代表被使用的clock, 例如GPIO driver想要获取某个clock, 它会得到一个struct clk, SPI driver想要获取同一个clock, 它也会得到一个struct clk, 另外, 当此clock的provider向clock子系统注册时, provider也会得到一个struct clk.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct clk *<span class="title">clk_hw_create_clk</span><span class="params">(struct clk_hw *hw, <span class="keyword">const</span> <span class="keyword">char</span> *dev_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">char</span> *con_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    clk = kzalloc(<span class="keyword">sizeof</span>(*clk), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!clk)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    clk-&gt;core = hw-&gt;core;</span><br><span class="line">    clk-&gt;dev_id = dev_id;</span><br><span class="line">    clk-&gt;con_id = kstrdup_const(con_id, GFP_KERNEL);</span><br><span class="line">    clk-&gt;max_rate = ULONG_MAX;</span><br><span class="line"></span><br><span class="line">    clk_prepare_lock();</span><br><span class="line">    hlist_add_head(&amp;clk-&gt;clks_node, &amp;hw-&gt;core-&gt;clks);</span><br><span class="line">    clk_prepare_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>逻辑比较简单:</p>
<ul>
<li>首先创建struct clk结构体, 然后初始化结构体的相关参数, 最后把这个struct clk挂载到clk_core的clks链表头下面.</li>
</ul>
<h3 id="clk-core-init"><a href="#clk-core-init" class="headerlink" title="__clk_core_init"></a><strong>__clk_core_init</strong></h3><p>这个API主要是处理clock之间的树形关系.</p>
<p>当任何一个clock调用clk_register接口进行注册时, __clk_init都会负责把这个clock放在树形结构的恰当位置.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __clk_core_init - initialize the data structures in a struct clk_core</span></span><br><span class="line"><span class="comment"> * @core:    clk_core being initialized</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes the lists in struct clk_core, queries the hardware for the</span></span><br><span class="line"><span class="comment"> * parent and rate and sets them both.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __clk_core_init(struct clk_core *core)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_core</span> *<span class="title">orphan</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp2</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!core)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    clk_prepare_lock();</span><br><span class="line"></span><br><span class="line">    ret = clk_pm_runtime_get(core);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check to see if a clock with this name is already registered */</span></span><br><span class="line">    <span class="keyword">if</span> (clk_core_lookup(core-&gt;name)) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: clk %s already initialized\n&quot;</span>,</span><br><span class="line">                __func__, core-&gt;name);</span><br><span class="line">        ret = -EEXIST;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check that clk_ops are sane.  See Documentation/driver-api/clk.rst */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;set_rate &amp;&amp;</span><br><span class="line">        !((core-&gt;ops-&gt;round_rate || core-&gt;ops-&gt;determine_rate) &amp;&amp;</span><br><span class="line">          core-&gt;ops-&gt;recalc_rate)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: %s must implement .round_rate or .determine_rate in addition to .recalc_rate\n&quot;</span>,</span><br><span class="line">               __func__, core-&gt;name);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;set_parent &amp;&amp; !core-&gt;ops-&gt;get_parent) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: %s must implement .get_parent &amp; .set_parent\n&quot;</span>,</span><br><span class="line">               __func__, core-&gt;name);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;num_parents &gt; <span class="number">1</span> &amp;&amp; !core-&gt;ops-&gt;get_parent) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: %s must implement .get_parent as it has multi parents\n&quot;</span>,</span><br><span class="line">               __func__, core-&gt;name);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;set_rate_and_parent &amp;&amp;</span><br><span class="line">            !(core-&gt;ops-&gt;set_parent &amp;&amp; core-&gt;ops-&gt;set_rate)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: %s must implement .set_parent &amp; .set_rate\n&quot;</span>,</span><br><span class="line">                __func__, core-&gt;name);</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* throw a WARN if any entries in parent_names are NULL */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; core-&gt;num_parents; i++)</span><br><span class="line">        WARN(!core-&gt;parent_names[i],</span><br><span class="line">                <span class="string">&quot;%s: invalid NULL in %s&#x27;s .parent_names\n&quot;</span>,</span><br><span class="line">                __func__, core-&gt;name);</span><br><span class="line"></span><br><span class="line">    core-&gt;parent = __clk_init_parent(core);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Populate core-&gt;parent if parent has already been clk_core_init&#x27;d. If</span></span><br><span class="line"><span class="comment">     * parent has not yet been clk_core_init&#x27;d then place clk in the orphan</span></span><br><span class="line"><span class="comment">     * list.  If clk doesn&#x27;t have any parents then place it in the root</span></span><br><span class="line"><span class="comment">     * clk list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Every time a new clk is clk_init&#x27;d then we walk the list of orphan</span></span><br><span class="line"><span class="comment">     * clocks and re-parent any that are children of the clock currently</span></span><br><span class="line"><span class="comment">     * being clk_init&#x27;d.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;parent) &#123;</span><br><span class="line">        hlist_add_head(&amp;core-&gt;child_node,</span><br><span class="line">                &amp;core-&gt;parent-&gt;children);</span><br><span class="line">        core-&gt;orphan = core-&gt;parent-&gt;orphan;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!core-&gt;num_parents) &#123;</span><br><span class="line">        hlist_add_head(&amp;core-&gt;child_node, &amp;clk_root_list);</span><br><span class="line">        core-&gt;orphan = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hlist_add_head(&amp;core-&gt;child_node, &amp;clk_orphan_list);</span><br><span class="line">        core-&gt;orphan = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * optional platform-specific magic</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The .init callback is not used by any of the basic clock types, but</span></span><br><span class="line"><span class="comment">     * exists for weird hardware that must perform initialization magic.</span></span><br><span class="line"><span class="comment">     * Please consider other ways of solving initialization problems before</span></span><br><span class="line"><span class="comment">     * using this callback, as its use is discouraged.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;init)</span><br><span class="line">        core-&gt;ops-&gt;init(core-&gt;hw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set clk&#x27;s accuracy.  The preferred method is to use</span></span><br><span class="line"><span class="comment">     * .recalc_accuracy. For simple clocks and lazy developers the default</span></span><br><span class="line"><span class="comment">     * fallback is to use the parent&#x27;s accuracy.  If a clock doesn&#x27;t have a</span></span><br><span class="line"><span class="comment">     * parent (or is orphaned) then accuracy is set to zero (perfect</span></span><br><span class="line"><span class="comment">     * clock).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;recalc_accuracy)</span><br><span class="line">        core-&gt;accuracy = core-&gt;ops-&gt;recalc_accuracy(core-&gt;hw,</span><br><span class="line">                    __clk_get_accuracy(core-&gt;parent));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (core-&gt;parent)</span><br><span class="line">        core-&gt;accuracy = core-&gt;parent-&gt;accuracy;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        core-&gt;accuracy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set clk&#x27;s phase.</span></span><br><span class="line"><span class="comment">     * Since a phase is by definition relative to its parent, just</span></span><br><span class="line"><span class="comment">     * query the current clock phase, or just assume it&#x27;s in phase.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;get_phase)</span><br><span class="line">        core-&gt;phase = core-&gt;ops-&gt;get_phase(core-&gt;hw);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        core-&gt;phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set clk&#x27;s duty cycle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clk_core_update_duty_cycle_nolock(core);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set clk&#x27;s rate.  The preferred method is to use .recalc_rate.  For</span></span><br><span class="line"><span class="comment">     * simple clocks and lazy developers the default fallback is to use the</span></span><br><span class="line"><span class="comment">     * parent&#x27;s rate.  If a clock doesn&#x27;t have a parent (or is orphaned)</span></span><br><span class="line"><span class="comment">     * then rate is set to zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;ops-&gt;recalc_rate)</span><br><span class="line">        rate = core-&gt;ops-&gt;recalc_rate(core-&gt;hw,</span><br><span class="line">                clk_core_get_rate_nolock(core-&gt;parent));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (core-&gt;parent)</span><br><span class="line">        rate = core-&gt;parent-&gt;rate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rate = <span class="number">0</span>;</span><br><span class="line">    core-&gt;rate = core-&gt;req_rate = rate;</span><br><span class="line"></span><br><span class="line">    core-&gt;boot_enabled = clk_core_is_enabled(core);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Enable CLK_IS_CRITICAL clocks so newly added critical clocks</span></span><br><span class="line"><span class="comment">     * don&#x27;t get accidentally disabled when walking the orphan tree and</span></span><br><span class="line"><span class="comment">     * reparenting clocks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (core-&gt;flags &amp; CLK_IS_CRITICAL) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">        ret = clk_core_prepare(core);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        flags = clk_enable_lock();</span><br><span class="line">        ret = clk_core_enable(core);</span><br><span class="line">        clk_enable_unlock(flags);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            clk_core_unprepare(core);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clk_core_hold_state(core);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * walk the list of orphan clocks and reparent any that newly finds a</span></span><br><span class="line"><span class="comment">     * parent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    hlist_for_each_entry_safe(orphan, tmp2, &amp;clk_orphan_list, child_node) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">clk_core</span> *<span class="title">parent</span> = __<span class="title">clk_init_parent</span>(<span class="title">orphan</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We need to use __clk_set_parent_before() and _after() to</span></span><br><span class="line"><span class="comment">         * to properly migrate any prepare/enable count of the orphan</span></span><br><span class="line"><span class="comment">         * clock. This is important for CLK_IS_CRITICAL clocks, which</span></span><br><span class="line"><span class="comment">         * are enabled during init but might not have a parent yet.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">            <span class="comment">/* update the clk tree topology */</span></span><br><span class="line">            __clk_set_parent_before(orphan, parent);</span><br><span class="line">            __clk_set_parent_after(orphan, parent, <span class="literal">NULL</span>);</span><br><span class="line">            __clk_recalc_accuracies(orphan);</span><br><span class="line">            __clk_recalc_rates(orphan, <span class="number">0</span>);</span><br><span class="line">            __clk_core_update_orphan_hold_state(orphan);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kref_init(&amp;core-&gt;ref);</span><br><span class="line">out:</span><br><span class="line">    clk_pm_runtime_put(core);</span><br><span class="line">unlock:</span><br><span class="line">    clk_prepare_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        clk_debug_register(core);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-clock-consumer-—-如何使用Clocks"><a href="#4-clock-consumer-—-如何使用Clocks" class="headerlink" title="4.  clock consumer — 如何使用Clocks"></a><strong>4.</strong>  <strong>clock</strong> consumer — 如何使用Clocks</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1    简介"></a><strong>4.1</strong>    <strong>简介</strong></h2><p>clock 子系统管理clocks的最终目的, 是让device driver可以方便的获取并使用这些clocks.</p>
<p>我们知道clock子系统用一个struct clk结构体来抽象某一个clock.</p>
<p>当device driver要操作某个clock时, 它需要做两件事情:</p>
<ul>
<li><p>首先, 获取clock. 也叫clk_get.</p>
</li>
<li><p>然后, 操作这个clock. 如 clk_prepare/ clk_enable/ clk_disable/ clk_set_rate/ …</p>
</li>
</ul>
<h2 id="4-2-APIs-–-获取clk"><a href="#4-2-APIs-–-获取clk" class="headerlink" title="4.2    APIs – 获取clk"></a><strong>4.2</strong>    <strong>APIs</strong> <strong>–</strong> 获取clk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clkdev.c</span><br><span class="line"></span><br><span class="line">最主要的两个API:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clk_get - lookup and obtain a reference to a clock producer.</span></span><br><span class="line"><span class="comment"> * @dev: device for clock &quot;consumer&quot;</span></span><br><span class="line"><span class="comment"> * @id: clock consumer ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a struct clk corresponding to the clock producer, or</span></span><br><span class="line"><span class="comment"> * valid IS_ERR() condition containing errno.  The implementation</span></span><br><span class="line"><span class="comment"> * uses @dev and @id to determine the clock consumer, and thereby</span></span><br><span class="line"><span class="comment"> * the clock producer.  (IOW, @id may be identical strings, but</span></span><br><span class="line"><span class="comment"> * clk_get may return different clock producers depending on @dev.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Drivers must assume that the clock source is not enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * clk_get should not be called from within interrupt context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *id)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_clk_get - lookup and obtain a managed reference to a clock producer.</span></span><br><span class="line"><span class="comment"> * @dev: device for clock &quot;consumer&quot;</span></span><br><span class="line"><span class="comment"> * @id: clock consumer ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a struct clk corresponding to the clock producer, or</span></span><br><span class="line"><span class="comment"> * valid IS_ERR() condition containing errno.  The implementation</span></span><br><span class="line"><span class="comment"> * uses @dev and @id to determine the clock consumer, and thereby</span></span><br><span class="line"><span class="comment"> * the clock producer.  (IOW, @id may be identical strings, but</span></span><br><span class="line"><span class="comment"> * clk_get may return different clock producers depending on @dev.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Drivers must assume that the clock source is not enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * devm_clk_get should not be called from within interrupt context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The clock will automatically be freed when the device is unbound</span></span><br><span class="line"><span class="comment"> * from the bus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct clk *<span class="title">devm_clk_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *id)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>devm_clk_get是devm版本的clk_get. 用于自动释放资源。</p>
<p>除了这两个用的最多的API之外, 还有一些其他的API, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_put</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">devm_clk_put</span><span class="params">(struct device *dev, struct clk *clk)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">clk_get_sys</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dev_id, <span class="keyword">const</span> <span class="keyword">char</span> *con_id)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">of_clk_get</span><span class="params">(struct device_node *np, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">of_clk_get_by_name</span><span class="params">(struct device_node *np, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct clk *<span class="title">of_clk_get_from_provider</span><span class="params">(struct of_phandle_args *clkspec)</span></span>;</span><br></pre></td></tr></table></figure>

<p>clk_get相当于一个总逻辑, 它会根据不同的情况调用上述这些API, 在实际代码中, 基本上我们只会用到clk_get或者devm_clk_get.</p>
<p>接下来, 我们会仔细看看clk_get的内部逻辑.</p>
<h3 id="clk-get-devm-clk-get"><a href="#clk-get-devm-clk-get" class="headerlink" title="clk_get / devm_clk_get"></a><strong>clk_get / devm_clk_get</strong></h3><p>该API的主要作用就是根据参数, 从clock子系统中获取一个clk给到consumer, 然后consumer就可以操作该clk了. 因此该API的返回值就是用于描述某个clock的数据结构: struct clk.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clkdev.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">clk_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *con_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_id = dev ? dev_name(dev) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        clk = of_clk_get_by_name(dev-&gt;of_node, con_id);        <span class="comment">/* 从设备树节点得到clk */</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(clk))            <span class="comment">/* 注意这里对错误判断取反了,即没错的话会直接返回clk */</span></span><br><span class="line">            <span class="keyword">return</span> clk;</span><br><span class="line">        <span class="keyword">if</span> (PTR_ERR(clk) == -EPROBE_DEFER)    <span class="comment">/* 重新获取 */</span></span><br><span class="line">            <span class="keyword">return</span> clk;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> clk_get_sys(dev_id, con_id);    <span class="comment">/* 设备树节点没找到,从系统注册链表中搜索得到 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct clk *<span class="title">clk_get_sys</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dev_id, <span class="keyword">const</span> <span class="keyword">char</span> *con_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_lookup</span> *<span class="title">cl</span>;</span></span><br><span class="line"> </span><br><span class="line">    mutex_lock(&amp;clocks_mutex);</span><br><span class="line">    cl = clk_find(dev_id, con_id);        <span class="comment">/* 根据设备名或链接名在clock链表中查找到对应的cl*/</span></span><br><span class="line">    <span class="keyword">if</span> (cl &amp;&amp; !__clk_get(cl-&gt;clk))        <span class="comment">/* 这里对找到的时钟的引用计数+1 */</span></span><br><span class="line">        cl = <span class="literal">NULL</span>;</span><br><span class="line">    mutex_unlock(&amp;clocks_mutex);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cl ? cl-&gt;clk : ERR_PTR(-ENOENT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the correct struct clk for the device and connection ID.</span></span><br><span class="line"><span class="comment"> * We do slightly fuzzy matching here:</span></span><br><span class="line"><span class="comment"> *  An entry with a NULL ID is assumed to be a wildcard.</span></span><br><span class="line"><span class="comment"> *  If an entry has a device ID, it must match</span></span><br><span class="line"><span class="comment"> *  If an entry has a connection ID, it must match</span></span><br><span class="line"><span class="comment"> * Then we take the most specific entry - with the following</span></span><br><span class="line"><span class="comment"> * order of precedence: dev+con &gt; dev only &gt; con only. 这是重点,即匹配优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct clk_lookup *<span class="title">clk_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dev_id, <span class="keyword">const</span> <span class="keyword">char</span> *con_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_lookup</span> *<span class="title">p</span>, *<span class="title">cl</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> match, best_found = <span class="number">0</span>, best_possible = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dev_id)        <span class="comment">/* 设备名称 */</span></span><br><span class="line">        best_possible += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (con_id)        <span class="comment">/* 连接名称(可以是pclk,uart_clk,phy,pci,总是一般都是总线的时钟名称) */</span></span><br><span class="line">        best_possible += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    list_for_each_entry(p, &amp;clocks, node) &#123;    <span class="comment">/* clocks链表中查找,根据dev+con &gt; dev only &gt; con优先级来匹配 */</span></span><br><span class="line">        match = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;dev_id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dev_id || <span class="built_in">strcmp</span>(p-&gt;dev_id, dev_id))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            match += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;con_id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!con_id || <span class="built_in">strcmp</span>(p-&gt;con_id, con_id))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            match += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (match &gt; best_found) &#123;</span><br><span class="line">            cl = p;</span><br><span class="line">            <span class="keyword">if</span> (match != best_possible)</span><br><span class="line">                best_found = match;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果你已经充分理解了1.2节的那个系统框图, 那么此处的逻辑就很简单了:</p>
<ul>
<li>如果dev不为空, 那么就以dev-&gt;of_node为参数, 调用of_XXX那一套, 从LIST_HEAD(<strong>of_clk_providers</strong>)这个池子里面查询某个clk.</li>
</ul>
<p>如果查询到了, 则返回该clk. 这种情况其实对应5.1节中描述的DTS node方式.</p>
<ul>
<li>如果上面没有获取到clk, 则调用clk_get_sys, 从LIST_HEAD(clocks)这个池子里面查询clk. 查询的关键字是con_id, 其实就是clock的name.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct clk *<span class="title">devm_clk_get</span><span class="params">(struct device *dev, <span class="keyword">const</span> <span class="keyword">char</span> *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> **<span class="title">ptr</span>, *<span class="title">clk</span>;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/* 设备资源自动管理,卸载设备时会调用devm_clk_release,做清理工作 */</span></span><br><span class="line">    ptr = devres_alloc(devm_clk_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);   </span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"> </span><br><span class="line">    clk = clk_get(dev, id);        <span class="comment">/* 这里的核心和就是clk_get */</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(clk)) &#123;</span><br><span class="line">        *ptr = clk;</span><br><span class="line">        devres_add(dev, ptr);        <span class="comment">/* 资源绑定到这设备资源链表上  */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        devres_free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> clk;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-3-APIs-–-操作clk"><a href="#4-3-APIs-–-操作clk" class="headerlink" title="4.3    APIs – 操作clk"></a><strong>4.3</strong>    <strong>APIs</strong> <strong>–</strong> <strong>操作</strong>clk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_prepare</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_unprepare</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_enable</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clk_disable</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">clk_get_rate</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_set_rate</span><span class="params">(struct clk *clk, <span class="keyword">unsigned</span> <span class="keyword">long</span> rate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">clk_round_rate</span><span class="params">(struct clk *clk, <span class="keyword">unsigned</span> <span class="keyword">long</span> rate)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct clk *<span class="title">clk_get_parent</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_set_parent</span><span class="params">(struct clk *clk, struct clk *parent)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">clk_prepare_enable</span><span class="params">(struct clk *clk)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clk_disable_unprepare</span><span class="params">(struct clk *clk)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>clk_enable/clk_disable: 启动/停止clock. 不会睡眠</p>
</li>
<li><p>clk_prepare/clk_unprepare: 启动clock前的准备工作/停止clock后的善后工作. 可能会睡眠</p>
</li>
<li><p>clk_get_rate/clk_set_rate/clk_round_rate: clock频率的获取和设置, 其中clk_set_rate可能会不成功（例如没有对应的分频比）, 此时会返回错误. 如果要确保设置成功, 则需要先调用clk_round_rate接口, 得到和需要设置的rate比较接近的那个值</p>
</li>
<li><p>clk_set_parent / clk_get_parent: 获取/选择clock的parent clock</p>
</li>
<li><p>clk_prepare_enable: 将clk_prepare和clk_enable组合起来，一起调用</p>
</li>
<li><p>clk_disable_unprepare: 将clk_disable和clk_unprepare组合起来，一起调用</p>
</li>
</ul>
<p><strong>prepare/unprepare，enable/disable</strong>的说明:</p>
<p>这两套API的本质，是把clock的启动/停止分为atomic和non-atomic两个阶段，以方便实现和调用。</p>
<p>因此上面所说的“不会睡眠/可能会睡眠”，有两个角度的含义：</p>
<p>一是告诉底层的clock driver，请把可能引起睡眠的操作，放到prepare/unprepare中实现，一定不能放到enable/disable中</p>
<p>二是提醒上层使用clock的driver，调用prepare/unprepare接口时可能会睡眠哦，千万不能在atomic上下文（例如中断处理中）调用哦，而调用enable/disable接口则可放心。</p>
<p>另外，clock的开关为什么需要睡眠呢？这里举个例子，例如enable PLL clk，在启动PLL后，需要等待它稳定。而PLL的稳定时间是很长的，这段时间要把CPU交出（进程睡眠），不然就会浪费CPU。</p>
<p>最后，为什么会有合在一起的clk_prepare_enable/clk_disable_unprepare接口呢？如果调用者能确保是在non-atomic上下文中调用，就可以顺序调用prepare/enable、disable/unprepared，为了简单，framework就帮忙封装了这两个接口。</p>
<h2 id="4-4-其它APIs"><a href="#4-4-其它APIs" class="headerlink" title="4.4 其它APIs"></a><strong>4.4</strong> 其它APIs</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">头文件: include/linux/clk.h</span><br><span class="line"></span><br><span class="line">实现文件: drivers/clk/clk.c</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clk_notifier_register: register a clock rate-change notifier callback</span></span><br><span class="line"><span class="comment"> * @clk: clock whose rate we are interested in</span></span><br><span class="line"><span class="comment"> * @nb: notifier block with callback function pointer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ProTip: debugging across notifier chains can be frustrating. Make sure that</span></span><br><span class="line"><span class="comment"> * your notifier callback function prints a nice big warning in case of</span></span><br><span class="line"><span class="comment"> * failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_notifier_register</span><span class="params">(struct clk *clk, struct notifier_block *nb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clk_notifier_unregister: unregister a clock rate-change notifier callback</span></span><br><span class="line"><span class="comment"> * @clk: clock whose rate we are no longer interested in</span></span><br><span class="line"><span class="comment"> * @nb: notifier block which will be unregistered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clk_notifier_unregister</span><span class="params">(struct clk *clk, struct notifier_block *nb)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个API与内核提供的通知链机制有关.</p>
<p>这两个notify接口, 用于注册/注销 clock rate改变的通知.</p>
<p>例如某个driver关心某个clock, 期望这个clock的rate改变时, 通知到自己, 就可以注册一个notify.</p>
<h1 id="5-RK3399-Clk分析"><a href="#5-RK3399-Clk分析" class="headerlink" title="5.  RK3399 Clk分析"></a><strong>5.</strong>  RK3399 Clk分析</h1><p>代码结构 CLOCK 的软件框架由 CLK 的 clk-rk3399.c（clk 的寄存器描述、clk 之间的树状关系等）、 Device driver 的 CLK 配置和 CLK API 三部分构成。这三部分的功能、CLK 代码路径如表 1-1 所 示。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>功能</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>Clk-rk3399.c Rk3399-cru.h</td>
<td>.c 中主要是 clk 的寄存器描述、 clk 之间的树状关系描述等。 .h 中是 clk 的 ID 定义，通过 ID 匹配 clk name。</td>
<td>Drivers/clk/rockchip/clk-rk3399.c Include/dt-bindings/clock/rk3399-cru.h</td>
</tr>
<tr>
<td>RK 特别的处理</td>
<td>1、处理 RK 的 PLL 时钟 2、处理 RK 的 CPU 时钟等</td>
<td>Drivers/clk/rockchip/clk-xxx.c</td>
</tr>
<tr>
<td>CLK API</td>
<td>提供 linux环境下供 driver 调用 的接口</td>
<td>Drivers/clk/clk-xxx.c</td>
</tr>
</tbody></table>
<h2 id="5-1-时钟的相关概念"><a href="#5-1-时钟的相关概念" class="headerlink" title="5.1 时钟的相关概念"></a><strong>5.1</strong> <strong>时钟的相关概念</strong></h2><p><strong>1，PLL</strong> 锁相环，是由 24M 的晶振输入，然后内部锁相环锁出相应的频率。这个是 SOC 所有 CLOCK 的时钟的源。SOC 的所有总线及设备的时钟都是从 PLL 分频下来的。RK 平台主要 PLL 有:</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826102009375.png" alt="image-20210826102009375"></p>
<p><strong>2，ACLK、PCLK、HCLK</strong></p>
<p>ACLK 是设备的总线的 CLK，PCLK 跟 HCLK 一般是用于寄存器读写的。而像 CLK_GPU 是 GPU 的控制器的时钟。 我们 SOC 的总线有 ACLK_PERI、HCLK_PERI、PCLK_PERI、ACLK_BUS、HCLK_BUS、 PCLK_BUS.各个设备的总线时钟会挂在上面这些时钟下面，如下图结构：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826102204721.png" alt="image-20210826102204721"></p>
<p>（如：EMMC 想提高自己设备的总线频率以实现其快速的数据拷贝或者搬移，可以提高 ACLK_PERI 来实现）</p>
<p>RK3399 上设计将高速和低速总线彻底分开，分成高速：ACLK_PERIHP、HCLK_PERIHP、 PCLK_PERIHP；低速：ACLK_PERILP0、HCLK_PERILP0、PCLK_PERILP0、 HCLK_PERILP1、PCLK_PERILP1。这样做是为了功耗最优，根据不同的需求可以设置不同的总 线频率。（具体每个设备在哪条总线下详细见时钟图） 可以参考如下（EMMC、GMAC、USB 等有自己的 ACLK）：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826102226714.png" alt="image-20210826102226714"></p>
<p><strong>3，GATING</strong> Clock 的框架中有很多的 Gating，这个主要是为了降低功耗使用，在一些设备关闭，Clock 不 需要维持的时候就可以关闭 Gating，来节省功耗。 我们 Clock 的框架的 Gating 是按照树的结构，有父子属性。Gating 的开关是有一个引用计数 机制的，使用这个计数来实现 Clock 打开时，会遍历打开其父 Clock。在子 Clock 关闭时，父 Clock 会遍历所有的子 Clock，在所有的子都关闭的时候才会关闭父 Clock。 （如：I²S2 在使用的时候，必须要打开下面这三个 Gating，但是软件上只需要开最后一级的 Gating，我们的时钟结构会自动的打开其 Parent 的 Gating）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826102344032.png" alt="image-20210826102344032"></p>
<h2 id="5-2-时钟配置"><a href="#5-2-时钟配置" class="headerlink" title="5.2 时钟配置"></a><strong>5.2</strong> 时钟配置</h2><p><strong>1，时钟初始化配置</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\u-boot\arch\arm\dts\rk3399.dtsi</span><br><span class="line">    pmucru: pmu-clock-controller@ff750000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-pmucru&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xff750000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        rockchip,grf = &lt;&amp;pmugrf&gt;;</span><br><span class="line">        <span class="meta">#clock-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">        <span class="meta">#reset-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">        assigned-clocks = &lt;&amp;pmucru PLL_PPLL&gt;;</span><br><span class="line">        assigned-clock-rates = &lt;<span class="number">676000000</span>&gt;; <span class="comment">//CLOCK TREE 初始化时设置的频率：</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    cru: clock-controller@ff760000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-cru&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xff760000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        rockchip,grf = &lt;&amp;grf&gt;;</span><br><span class="line">        <span class="meta">#clock-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">        <span class="meta">#reset-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">        assigned-clocks =</span><br><span class="line">            &lt;&amp;cru PLL_GPLL&gt;, &lt;&amp;cru PLL_CPLL&gt;,</span><br><span class="line">            &lt;&amp;cru PLL_NPLL&gt;,</span><br><span class="line">            &lt;&amp;cru ACLK_PERIHP&gt;, &lt;&amp;cru HCLK_PERIHP&gt;,</span><br><span class="line">            &lt;&amp;cru PCLK_PERIHP&gt;,</span><br><span class="line">            &lt;&amp;cru ACLK_PERILP0&gt;, &lt;&amp;cru HCLK_PERILP0&gt;,</span><br><span class="line">            &lt;&amp;cru PCLK_PERILP0&gt;, &lt;&amp;cru ACLK_CCI&gt;,</span><br><span class="line">            &lt;&amp;cru HCLK_PERILP1&gt;, &lt;&amp;cru PCLK_PERILP1&gt;;</span><br><span class="line">        assigned-clock-rates = <span class="comment">//CLOCK TREE 初始化时设置的频率：</span></span><br><span class="line">             &lt;<span class="number">594000000</span>&gt;,  &lt;<span class="number">800000000</span>&gt;,</span><br><span class="line">            &lt;<span class="number">1000000000</span>&gt;,</span><br><span class="line">             &lt;<span class="number">150000000</span>&gt;,   &lt;<span class="number">75000000</span>&gt;,</span><br><span class="line">              &lt;<span class="number">37500000</span>&gt;,</span><br><span class="line">             &lt;<span class="number">100000000</span>&gt;,  &lt;<span class="number">100000000</span>&gt;,</span><br><span class="line">              &lt;<span class="number">50000000</span>&gt;, &lt;<span class="number">600000000</span>&gt;,</span><br><span class="line">             &lt;<span class="number">100000000</span>&gt;,   &lt;<span class="number">50000000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2，Gating CLOCK TREE</strong> </p>
<p>初始化时是否默认 enable： （1） 需要在 clk-rk3399.c 中增加 critical 配置，主要在 rk3399_cru_critical_clocks 中 增加需要默认打开的 CLK name，一旦增加 CLK 的计数被加 1，后面这个 CLK 将不能被 关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> rk3399_cru_critical_clocks[] __initconst = &#123;</span><br><span class="line">    <span class="string">&quot;aclk_usb3_noc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;aclk_gmac_noc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pclk_gmac_noc&quot;</span>,</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">&quot;aclk_perihp_noc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hclk_perihp_noc&quot;</span>,</span><br><span class="line">    .......</span><br><span class="line">    <span class="string">&quot;hclk_sdioaudio_noc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pclk_perilp1_noc&quot;</span>,</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> rk3399_pmucru_critical_clocks[] __initconst = &#123;</span><br><span class="line">    <span class="string">&quot;pclk_noc_pmu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hclk_noc_pmu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ppll&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pclk_pmu_src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fclk_cm0s_src_pmu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clk_timer_src_pmu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pclk_rkpwm_pmu&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2） CLK 的定义时候增加 flag 属性 CLK_IGNORE_UNUSED，这样即使这个 CLK 没有使 用，在最后 CLK 关闭没有用的 CLK 时也不会关闭这个。但是在 CLK TREE 上看到的 enable  cnt 还是 0，但是 CLK 是开启的。 GATE(PCLK_PMUGRF_PMU, “pclk_pmugrf_pmu”, “pclk_pmu_src”, CLK_IGNORE_UNUSED, RK3399_PMU_CLKGATE_CON(1), 1, GFLAGS)</p>
<p><strong>3，主要的 CLK 注册类型函数</strong> </p>
<p>常用的有如下几种： </p>
<ul>
<li><p>GATE：描述 GATING，主要包括 CLK ID、类型、GATING 的寄存器偏移地址、BIT 位等。 </p>
</li>
<li><p>MUX：描述 SLECT，主要包括 CLK ID、类型、MUX 的寄存器偏移地址、BIT 位等。 </p>
</li>
<li><p>COMPOSITE：描述有 MUX、DIV、GATING 的 CLK，主要包括 CLK ID、类型、MUX、 DIV、GARING 的寄存器偏移地址、BIT 位等。</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826110739981.png" alt="image-20210826110739981"></p>
<p>Clk-rk3xxx.c 中的使用，使用这些 CLK 的注册函数，描述此 CLK 的类型，寄存器及父子关系 等。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/kernel.clk/image-20210826110855862.png" alt="image-20210826110855862"></p>
<h2 id="5-3-CLK-OF-DECLARE-解析"><a href="#5-3-CLK-OF-DECLARE-解析" class="headerlink" title="5.3 CLK_OF_DECLARE 解析"></a><strong>5.3</strong> CLK_OF_DECLARE 解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\init\main.c</span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    time_init();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">F:\Rock4Plus_Android10\kernel\arch\arm\kernel\time.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">time_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (machine_desc-&gt;init_time) &#123;</span><br><span class="line">        machine_desc-&gt;init_time();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#ifdef CONFIG_COMMON_CLK</span><br><span class="line">        of_clk_init(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        timer_probe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\clk.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">of_clk_init</span><span class="params">(<span class="keyword">const</span> struct of_device_id *matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.......</span><br><span class="line">    <span class="keyword">if</span> (!matches)</span><br><span class="line">        matches = &amp;__clk_of_table;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line">_OF_DECLARE 的定义：</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Struct used for matching a device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    type[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span>    compatible[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF                                        <span class="comment">//CONFIG_OF的定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)            \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_</span>##<span class="title">name</span>        \</span></span><br><span class="line"><span class="class">        __<span class="title">used</span> __<span class="title">section</span>(__##<span class="title">table</span>##_<span class="title">of_table</span>)            \</span></span><br><span class="line"><span class="class">         = &#123;</span> .compatible = compat,                \</span><br><span class="line">             .data = (fn == (fn_type)<span class="literal">NULL</span>) ? fn : fn  &#125;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">#define _OF_DECLARE(table, name, compat, fn, fn_type)            \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> struct of_device_id __of_table_##name        \</span><br><span class="line">        __attribute__((unused))                    \</span><br><span class="line">         = &#123; .compatible = compat,                \</span><br><span class="line">             .data = (fn == (fn_type)<span class="literal">NULL</span>) ? fn : fn &#125;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">定义了一个 struct of_device_id 的结构体变量</span><br><span class="line">如果定义CONFIG_OF，就将 struct of_device_id 变量放到 __clk_of_table 下；</span><br></pre></td></tr></table></figure>

<p>Linux下系统时钟在初始化时经常用到 CLK_OF_DECLARE 这个宏，现在以RK3399为例做分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\rockchip\clk-rk3399.c</span><br><span class="line">CLK_OF_DECLARE(rk3399_cru, <span class="string">&quot;rockchip,rk3399-cru&quot;</span>, rk3399_clk_init);</span><br><span class="line">CLK_OF_DECLARE(rk3399_cru_pmu, <span class="string">&quot;rockchip,rk3399-pmucru&quot;</span>, rk3399_pmu_clk_init);</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>] Call trace:</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  dump_backtrace+<span class="number">0x0</span>/<span class="number">0x178</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  show_stack+<span class="number">0x14</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  dump_stack+<span class="number">0x94</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  rk3399_pmu_clk_init+<span class="number">0x60</span>/<span class="number">0x120</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  of_clk_init+<span class="number">0x194</span>/<span class="number">0x25c</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  time_init+<span class="number">0x10</span>/<span class="number">0x44</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  start_kernel+<span class="number">0x390</span>/<span class="number">0x4ec</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>] Call trace:</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  dump_backtrace+<span class="number">0x0</span>/<span class="number">0x178</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  show_stack+<span class="number">0x14</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  dump_stack+<span class="number">0x94</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  rk3399_clk_init+<span class="number">0x5c</span>/<span class="number">0x1c4</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  of_clk_init+<span class="number">0x194</span>/<span class="number">0x25c</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  time_init+<span class="number">0x10</span>/<span class="number">0x44</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">34</span>] [    <span class="number">0.000000</span>]  start_kernel+<span class="number">0x390</span>/<span class="number">0x4ec</span></span><br></pre></td></tr></table></figure>



<h2 id="5-4-rk3399-pmu-clk-init分析"><a href="#5-4-rk3399-pmu-clk-init分析" class="headerlink" title="5.4 rk3399_pmu_clk_init分析"></a><strong>5.4</strong> rk3399_pmu_clk_init分析</h2><blockquote>
<p>[2021/8/23 14:22:34] [    0.000000] regs phy start(0xff750000) name(pmu-clock-controller@ff750000)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\rockchip\clk-rk3399.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">rk3399_pmu_clk_init</span><span class="params">(struct device_node *np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_clk_provider</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem *reg_base;</span><br><span class="line"></span><br><span class="line">    reg_base = of_iomap(np, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rk3399_pmucru_base = reg_base;</span><br><span class="line">    printk(<span class="string">&quot;rk3399_pmucru_base regs map(0x%p)\n&quot;</span>, rk3399_cru_base);</span><br><span class="line">    dump_stack();</span><br><span class="line"></span><br><span class="line">    ctx = rockchip_clk_init(np, reg_base, CLKPMU_NR_CLKS);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_plls(ctx, rk3399_pmu_pll_clks,</span><br><span class="line">                   ARRAY_SIZE(rk3399_pmu_pll_clks), <span class="number">-1</span>);<span class="comment">//rk3399_pmu_pll_clks注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_branches(ctx, rk3399_clk_pmu_branches,</span><br><span class="line">                  ARRAY_SIZE(rk3399_clk_pmu_branches));<span class="comment">//rk3399_clk_pmu_branches注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_clk_protect_critical(rk3399_pmucru_critical_clocks,</span><br><span class="line">                  ARRAY_SIZE(rk3399_pmucru_critical_clocks));<span class="comment">//rk3399_pmucru_critical_clocks注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_register_softrst(np, <span class="number">2</span>, reg_base + RK3399_PMU_SOFTRST_CON(<span class="number">0</span>),</span><br><span class="line">                  ROCKCHIP_SOFTRST_HIWORD_MASK);</span><br><span class="line"></span><br><span class="line">    rockchip_clk_of_add_provider(np, ctx);</span><br><span class="line"></span><br><span class="line">    atomic_notifier_chain_register(&amp;panic_notifier_list,</span><br><span class="line">                       &amp;rk3399_clk_panic_block);</span><br><span class="line">&#125;</span><br><span class="line">CLK_OF_DECLARE(rk3399_cru_pmu, <span class="string">&quot;rockchip,rk3399-pmucru&quot;</span>, rk3399_pmu_clk_init);</span><br></pre></td></tr></table></figure>

<h2 id="5-5-rk3399-pmu-clk-init分析"><a href="#5-5-rk3399-pmu-clk-init分析" class="headerlink" title="5.5 rk3399_pmu_clk_init分析"></a><strong>5.5</strong> rk3399_pmu_clk_init分析</h2><blockquote>
<p>[2021/8/23 14:22:34] [    0.000000] regs phy start(0xff760000) name(clock-controller@ff760000)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">rk3399_clk_init</span><span class="params">(struct device_node *np)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_clk_provider</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __iomem *reg_base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    reg_base = of_iomap(np, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rk3399_cru_base = reg_base;</span><br><span class="line">    printk(<span class="string">&quot;rk3399_cru_base regs map(0x%p)\n&quot;</span>, rk3399_cru_base);</span><br><span class="line">    dump_stack();</span><br><span class="line"></span><br><span class="line">    ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Watchdog pclk is controlled by RK3399 SECURE_GRF_SOC_CON3[8]. */</span></span><br><span class="line">    clk = clk_register_fixed_factor(<span class="literal">NULL</span>, <span class="string">&quot;pclk_wdt&quot;</span>, <span class="string">&quot;pclk_alive&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(clk))</span><br><span class="line">        pr_warn(<span class="string">&quot;%s: could not register clock pclk_wdt: %ld\n&quot;</span>,</span><br><span class="line">            __func__, PTR_ERR(clk));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rockchip_clk_add_lookup(ctx, clk, PCLK_WDT);</span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_plls(ctx, rk3399_pll_clks,</span><br><span class="line">                   ARRAY_SIZE(rk3399_pll_clks), <span class="number">-1</span>); <span class="comment">//rk3399_pll_clks注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_branches(ctx, rk3399_clk_branches,</span><br><span class="line">                  ARRAY_SIZE(rk3399_clk_branches));<span class="comment">//rk3399_clk_branches注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_clk_protect_critical(rk3399_cru_critical_clocks,</span><br><span class="line">                      ARRAY_SIZE(rk3399_cru_critical_clocks));<span class="comment">//rk3399_cru_critical_clocks注册</span></span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_armclk(ctx, ARMCLKL, <span class="string">&quot;armclkl&quot;</span>,</span><br><span class="line">            mux_armclkl_p, ARRAY_SIZE(mux_armclkl_p),</span><br><span class="line">            &amp;rk3399_cpuclkl_data, rk3399_cpuclkl_rates,</span><br><span class="line">            ARRAY_SIZE(rk3399_cpuclkl_rates));</span><br><span class="line"></span><br><span class="line">    rockchip_clk_register_armclk(ctx, ARMCLKB, <span class="string">&quot;armclkb&quot;</span>,</span><br><span class="line">            mux_armclkb_p, ARRAY_SIZE(mux_armclkb_p),</span><br><span class="line">            &amp;rk3399_cpuclkb_data, rk3399_cpuclkb_rates,</span><br><span class="line">            ARRAY_SIZE(rk3399_cpuclkb_rates));</span><br><span class="line"></span><br><span class="line">    rockchip_register_softrst(np, <span class="number">21</span>, reg_base + RK3399_SOFTRST_CON(<span class="number">0</span>),</span><br><span class="line">                  ROCKCHIP_SOFTRST_HIWORD_MASK);</span><br><span class="line"></span><br><span class="line">    rockchip_register_restart_notifier(ctx, RK3399_GLB_SRST_FST, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    rockchip_clk_of_add_provider(np, ctx);</span><br><span class="line">&#125;</span><br><span class="line">CLK_OF_DECLARE(rk3399_cru, <span class="string">&quot;rockchip,rk3399-cru&quot;</span>, rk3399_clk_init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-6-rockchip-clk-of-add-provider分析"><a href="#5-6-rockchip-clk-of-add-provider分析" class="headerlink" title="5.6 rockchip_clk_of_add_provider分析"></a><strong>5.6</strong> rockchip_clk_of_add_provider分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\rockchip\clk.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">rockchip_clk_of_add_provider</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct rockchip_clk_provider *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (of_clk_add_provider(np, of_clk_src_onecell_get,</span><br><span class="line">                &amp;ctx-&gt;clk_data))</span><br><span class="line">        pr_err(<span class="string">&quot;%s: could not register clk provider\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\clk.c</span><br><span class="line"><span class="function">struct clk *<span class="title">of_clk_src_onecell_get</span><span class="params">(struct of_phandle_args *clkspec, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk_onecell_data</span> *<span class="title">clk_data</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = clkspec-&gt;args[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//F:\Rock4Plus_Android10\kernel\include\dt-bindings\clock\rk3399-cru.h</span></span><br><span class="line">    <span class="comment">//#define SCLK_I2C0_PMU            9</span></span><br><span class="line">    <span class="comment">//#define PCLK_I2C0_PMU            27</span></span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">9</span> || idx == <span class="number">27</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;of_clk_src_onecell_get clock index %u\n&quot;</span>, idx);</span><br><span class="line">        dump_stack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= clk_data-&gt;clk_num) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;%s: invalid clock index %u\n&quot;</span>, __func__, idx);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clk_data-&gt;clks[idx];</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(of_clk_src_onecell_get);</span><br></pre></td></tr></table></figure>

<h2 id="5-7-of-clk-add-provider分析"><a href="#5-7-of-clk-add-provider分析" class="headerlink" title="5.7 of_clk_add_provider分析"></a><strong>5.7</strong> of_clk_add_provider分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\clk\clk.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_clk_add_provider() - Register a clock provider for a node</span></span><br><span class="line"><span class="comment"> * @np: Device node pointer associated with clock provider</span></span><br><span class="line"><span class="comment"> * @clk_src_get: callback for decoding clock</span></span><br><span class="line"><span class="comment"> * @data: context pointer for @clk_src_get callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_clk_add_provider</span><span class="params">(struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct clk *(*clk_src_get)(struct of_phandle_args *clkspec,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">of_clk_provider</span> *<span class="title">cp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    cp = kzalloc(<span class="keyword">sizeof</span>(*cp), GFP_KERNEL);<span class="comment">//创建of_clk_provider对象</span></span><br><span class="line">    <span class="keyword">if</span> (!cp)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    cp-&gt;node = of_node_get(np);</span><br><span class="line">    cp-&gt;data = data;<span class="comment">//初始化data，即rk3399所有clk</span></span><br><span class="line">    cp-&gt;get = clk_src_get;<span class="comment">//clk_src_get即of_clk_src_onecell_get</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;of_clk_mutex);</span><br><span class="line">    list_add(&amp;cp-&gt;link, &amp;of_clk_providers);<span class="comment">//加入of_clk_providers列表</span></span><br><span class="line">    mutex_unlock(&amp;of_clk_mutex);</span><br><span class="line">    pr_debug(<span class="string">&quot;Added clock from %pOF\n&quot;</span>, np);</span><br><span class="line"></span><br><span class="line">    ret = of_clk_set_defaults(np, <span class="literal">true</span>);<span class="comment">//默认clk设置</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        of_clk_del_provider(np);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(of_clk_add_provider);</span><br></pre></td></tr></table></figure>

<h2 id="5-8-of-clk-set-defaults分析"><a href="#5-8-of-clk-set-defaults分析" class="headerlink" title="5.8 of_clk_set_defaults分析"></a><strong>5.8</strong> of_clk_set_defaults分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_clk_set_defaults() - parse and set assigned clocks configuration</span></span><br><span class="line"><span class="comment"> * @node: device node to apply clock settings for</span></span><br><span class="line"><span class="comment"> * @clk_supplier: true if clocks supplied by @node should also be considered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function parses &#x27;assigned-&#123;clocks/clock-parents/clock-rates&#125;&#x27; properties</span></span><br><span class="line"><span class="comment"> * and sets any specified clock parents and rates. The @clk_supplier argument</span></span><br><span class="line"><span class="comment"> * should be set to true if @node may be also a clock supplier of any clock</span></span><br><span class="line"><span class="comment"> * listed in its &#x27;assigned-clocks&#x27; or &#x27;assigned-clock-parents&#x27; properties.</span></span><br><span class="line"><span class="comment"> * If @clk_supplier is false the function exits returning 0 as soon as it</span></span><br><span class="line"><span class="comment"> * determines the @node is also a supplier of any of the clocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_clk_set_defaults</span><span class="params">(struct device_node *node, <span class="keyword">bool</span> clk_supplier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rc = __set_clk_parents(node, clk_supplier);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __set_clk_rates(node, clk_supplier);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(of_clk_set_defaults);</span><br><span class="line"><span class="comment">//解析“assigned-&#123;clocks/clock-parents/clock-rates&#125;”属性,并设置任何指定的时钟父级和速率。</span></span><br></pre></td></tr></table></figure>

<h1 id="6-RK3399-User-Driver-i2c0-使用Clk分析"><a href="#6-RK3399-User-Driver-i2c0-使用Clk分析" class="headerlink" title="6.  RK3399 User Driver(i2c0)使用Clk分析"></a><strong>6.</strong>  RK3399 User Driver(i2c0)使用Clk分析</h1><h2 id="1-获取-CLK-指针"><a href="#1-获取-CLK-指针" class="headerlink" title="1,获取 CLK 指针"></a>1,获取 CLK 指针</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">F:\Rock4Plus_Android10\kernel\drivers\i2c\busses\i2c-rk3399.c</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rk3x_i2c_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    i2c-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line">    i2c-&gt;pclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081112</span>] Call trace:</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081127</span>]  dump_backtrace+<span class="number">0x0</span>/<span class="number">0x178</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081138</span>]  show_stack+<span class="number">0x14</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081149</span>]  dump_stack+<span class="number">0x94</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081161</span>]  of_clk_src_onecell_get+<span class="number">0x54</span>/<span class="number">0x80</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081175</span>]  __of_clk_get_from_provider.part<span class="number">.31</span>+<span class="number">0x118</span>/<span class="number">0x138</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081186</span>]  __of_clk_get_from_provider+<span class="number">0x1c</span>/<span class="number">0x28</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081197</span>]  __of_clk_get_by_name+<span class="number">0xa8</span>/<span class="number">0x148</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081207</span>]  clk_get+<span class="number">0x30</span>/<span class="number">0x80</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081220</span>]  devm_clk_get+<span class="number">0x48</span>/<span class="number">0xa0</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081234</span>]  rk3x_i2c_probe+<span class="number">0x164</span>/<span class="number">0x1e0</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081247</span>]  platform_drv_probe+<span class="number">0x50</span>/<span class="number">0xa8</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081259</span>]  really_probe+<span class="number">0x200</span>/<span class="number">0x2b0</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081271</span>]  driver_probe_device+<span class="number">0x58</span>/<span class="number">0x100</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081283</span>]  device_driver_attach+<span class="number">0x6c</span>/<span class="number">0x78</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081294</span>]  __driver_attach+<span class="number">0xb0</span>/<span class="number">0xf0</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081306</span>]  bus_for_each_dev+<span class="number">0x68</span>/<span class="number">0xc8</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081318</span>]  driver_attach+<span class="number">0x20</span>/<span class="number">0x28</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081327</span>]  bus_add_driver+<span class="number">0xf8</span>/<span class="number">0x1f0</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081339</span>]  driver_register+<span class="number">0x60</span>/<span class="number">0x110</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081352</span>]  __platform_driver_register+<span class="number">0x40</span>/<span class="number">0x48</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081365</span>]  rk3x_i2c_driver_init+<span class="number">0x18</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081378</span>]  do_one_initcall+<span class="number">0x48</span>/<span class="number">0x240</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081391</span>]  kernel_init_freeable+<span class="number">0x210</span>/<span class="number">0x37c</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081404</span>]  kernel_init+<span class="number">0x10</span>/<span class="number">0x108</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081416</span>]  ret_from_fork+<span class="number">0x10</span>/<span class="number">0x18</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">36</span>] [    <span class="number">1.081444</span>] <span class="function">__of_clk_get_from_provider <span class="title">dev_id</span><span class="params">(ff3c0000.i2c)</span> <span class="title">con_id</span><span class="params">(pclk)</span> <span class="title">idx</span><span class="params">(<span class="number">27</span>)</span> </span></span><br><span class="line">[2021/8/23 14:22:36] [    1.081458] of_clk_src_onecell_get clock index 27</span><br></pre></td></tr></table></figure>

<h2 id="2-clk-enable"><a href="#2-clk-enable" class="headerlink" title="2,clk_enable"></a>2,clk_enable</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.389825</span>] Call trace:</span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397107</span>]  dump_stack+<span class="number">0x94</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397117</span>]  clk_gate_endisable+<span class="number">0x78</span>/<span class="number">0xc8</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397136</span>]  clk_gate_enable+<span class="number">0x10</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397148</span>]  clk_core_enable+<span class="number">0x78</span>/<span class="number">0x280</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397163</span>]  clk_core_enable_lock+<span class="number">0x20</span>/<span class="number">0x40</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397176</span>]  clk_enable+<span class="number">0x14</span>/<span class="number">0x28</span></span><br><span class="line">[<span class="number">2021</span>/<span class="number">8</span>/<span class="number">23</span> <span class="number">9</span>:<span class="number">50</span>:<span class="number">17</span>] [    <span class="number">1.397189</span>]  rk3x_i2c_xfer+<span class="number">0x64</span>/<span class="number">0x460</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20230716/">https://zhoujinjian.com/posts/20230716/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.53.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20230816/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.54.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux学习系列2：i2c子系统</div></div></a></div><div class="next-post pull-right"><a href="/posts/20230616/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.52.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux学习系列0：裸机</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-clk%E7%9A%84%E7%A7%8D%E7%B1%BB%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 clk的种类说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-CCF%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%86%E6%9E%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 CCF子系统的框架说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Clock-Provider-%E2%80%94-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8CClocks"><span class="toc-number">2.</span> <span class="toc-text">2.Clock Provider — 如何注册Clocks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BC%96%E5%86%99clock-driver%E7%9A%84%E5%A4%A7%E8%87%B4%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 编写clock driver的大致步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BC%96%E5%86%99platform-driver"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 编写platform_driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3  主要数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-clk-hw"><span class="toc-number">2.3.1.</span> <span class="toc-text">struct clk_hw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-clk-init-data"><span class="toc-number">2.3.2.</span> <span class="toc-text">struct clk_init_data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-clk-ops"><span class="toc-number">2.3.3.</span> <span class="toc-text">struct  clk_ops</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%BB%E8%A6%81-API-%E8%AF%B4%E6%98%8E"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 主要 API 说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-devm-clk-register"><span class="toc-number">2.4.1.</span> <span class="toc-text">clk_register &#x2F;devm_clk_register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-fixed-rate"><span class="toc-number">2.4.2.</span> <span class="toc-text">clk_register_fixed_rate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-gate"><span class="toc-number">2.4.3.</span> <span class="toc-text">clk_register_gate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-divider-clk-register-divider-table"><span class="toc-number">2.4.4.</span> <span class="toc-text">clk_register_divider&#x2F;clk_register_divider_table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-mux"><span class="toc-number">2.4.5.</span> <span class="toc-text">clk_register_mux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-fixed-factor"><span class="toc-number">2.4.6.</span> <span class="toc-text">clk_register_fixed_factor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-fractional-divider"><span class="toc-number">2.4.7.</span> <span class="toc-text">clk_register_fractional_divider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-composite"><span class="toc-number">2.4.8.</span> <span class="toc-text">clk_register_composite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-gpio-gate"><span class="toc-number">2.4.9.</span> <span class="toc-text">clk_register_gpio_gate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xxx-unregister"><span class="toc-number">2.4.10.</span> <span class="toc-text">xxx_unregister</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register-clkdev"><span class="toc-number">2.4.11.</span> <span class="toc-text">clk_register_clkdev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#of-clk-add-provider"><span class="toc-number">2.4.12.</span> <span class="toc-text">of_clk_add_provider</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-clock-core-%E2%80%94-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86Clocks"><span class="toc-number">3.</span> <span class="toc-text">3.  clock core — 如何管理Clocks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1       简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2       主要数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-clk"><span class="toc-number">3.2.1.</span> <span class="toc-text">struct clk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-clk-core"><span class="toc-number">3.2.2.</span> <span class="toc-text">struct clk_core</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 关键代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-register"><span class="toc-number">3.3.1.</span> <span class="toc-text">clk_register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-core-init"><span class="toc-number">3.3.2.</span> <span class="toc-text">__clk_core_init</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-clock-consumer-%E2%80%94-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Clocks"><span class="toc-number">4.</span> <span class="toc-text">4.  clock consumer — 如何使用Clocks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1    简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-APIs-%E2%80%93-%E8%8E%B7%E5%8F%96clk"><span class="toc-number">4.2.</span> <span class="toc-text">4.2    APIs – 获取clk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#clk-get-devm-clk-get"><span class="toc-number">4.2.1.</span> <span class="toc-text">clk_get &#x2F; devm_clk_get</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-APIs-%E2%80%93-%E6%93%8D%E4%BD%9Cclk"><span class="toc-number">4.3.</span> <span class="toc-text">4.3    APIs – 操作clk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%85%B6%E5%AE%83APIs"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 其它APIs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-RK3399-Clk%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">5.  RK3399 Clk分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%97%B6%E9%92%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 时钟的相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 时钟配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-CLK-OF-DECLARE-%E8%A7%A3%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 CLK_OF_DECLARE 解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-rk3399-pmu-clk-init%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 rk3399_pmu_clk_init分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-rk3399-pmu-clk-init%E5%88%86%E6%9E%90"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 rk3399_pmu_clk_init分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-rockchip-clk-of-add-provider%E5%88%86%E6%9E%90"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 rockchip_clk_of_add_provider分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-of-clk-add-provider%E5%88%86%E6%9E%90"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 of_clk_add_provider分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-of-clk-set-defaults%E5%88%86%E6%9E%90"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 of_clk_set_defaults分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-RK3399-User-Driver-i2c0-%E4%BD%BF%E7%94%A8Clk%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">6.  RK3399 User Driver(i2c0)使用Clk分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96-CLK-%E6%8C%87%E9%92%88"><span class="toc-number">6.1.</span> <span class="toc-text">1,获取 CLK 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-clk-enable"><span class="toc-number">6.2.</span> <span class="toc-text">2,clk_enable</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>