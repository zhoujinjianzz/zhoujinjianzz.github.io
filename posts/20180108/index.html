<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android N 基础（6）：Android 7.1.2 Android WindowManagerService 窗口管理服务分析 | zhoujinjian</title><meta name="keywords" content="Android"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等">
<meta property="og:type" content="article">
<meta property="og:title" content="Android N 基础（6）：Android 7.1.2 Android WindowManagerService 窗口管理服务分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20180108/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.08.jpg">
<meta property="article:published_time" content="2018-01-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.960Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.08.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20180108/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.08.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android N 基础（6）：Android 7.1.2 Android WindowManagerService 窗口管理服务分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-01-08T01:25:00.000Z" title="发表于 2018-01-08 09:25:00">2018-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.960Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。</p>
<a id="more"></a>



<h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/base/services/core/java/com/android/server/am/</strong></p>
<ul>
<li>ActivityStack.java</li>
<li>ActivityManagerService.java</li>
<li>ActivityStackSupervisor.java</li>
<li>ActivityStarter.java</li>
<li>ActivityRecord.java</li>
</ul>
<p><strong>/frameworks/base/core/java/android/view/</strong></p>
<ul>
<li>WindowManagerImpl.java</li>
<li>ViewManager.java</li>
<li>WindowManagerGlobal.java</li>
<li>ViewRootImpl.java</li>
<li>Choreographer.java</li>
<li>IWindowSession.aidl</li>
<li>DisplayEventReceiver.java</li>
<li>SurfaceControl.java</li>
<li>Surface.java</li>
<li>SurfaceSession.java</li>
</ul>
<p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p>
<ul>
<li>WindowManagerService.java</li>
<li>AppWindowAnimator.java</li>
<li>AppTransition.java</li>
<li>AppWindowToken.java</li>
<li>Session.java</li>
<li>WindowState.java</li>
<li>WindowAnimator.java</li>
<li>WindowStateAnimator.java</li>
<li>WindowSurfacePlacer.java</li>
<li>WindowSurfaceController.java</li>
</ul>
<p>我们先看一下窗口启动、退出过程动态图，之后再详细分析：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/01-Android-WMS-ezgif.com-gif-maker-WindowManagerService-resize.gif" alt="Markdown"></p>
<h2 id="（一）、Window-组织方式"><a href="#（一）、Window-组织方式" class="headerlink" title="（一）、Window 组织方式"></a>（一）、Window 组织方式</h2><p>ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。 窗口管理系统主要框架：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/02-Android-WMS-AMS-SurfaceFlinger-Conn.png" alt="Markdown"></p>
<blockquote>
<p>主要对象功能介绍：</p>
</blockquote>
<blockquote>
<p>WindowManagerService负责完成窗口的管理工作</p>
</blockquote>
<blockquote>
<p>WindowState和应用端窗口一一对应，应用调用WMS添加窗口时，最终会在WindowManagerService.addWindow()创建一个WindowState与之一一对应</p>
</blockquote>
<blockquote>
<p>WindowToken是一个句柄，保存了所有具有同一个token的WindowState。应用请求WindowManagerService添加窗口的时候，提供了一个token，该token标识了被添加窗口的归属，WindowManagerService为该token生成一个WindowToken对象，所有token相同的WindowState被关联到同一个WindowToken，如输入法添加窗口时，会传递一个IBinder mCurToken，墙纸服务添加窗口时，会传递一个WallpaperConnection::final Binder mToken。</p>
</blockquote>
<blockquote>
<p>AppWindowToken继承于WindowToken，专门用于标识一个Activity。AppWindowToken里的token实际上就是指向了一个Activity。ActivityManagerService通知应用启动的时候，在服务端生成一个token用于标识该Activity，并且把该token传递到应用客户端，客户端的Activity在申请添加窗口时，以该token作为标识传递到WindowManagerService。同一个Activity中的主窗口、对话框窗口、菜单窗口都关联到同一个AppWindowToken。</p>
</blockquote>
<blockquote>
<p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p>
</blockquote>
<h3 id="1-1、Android-Token介绍"><a href="#1-1、Android-Token介绍" class="headerlink" title="1.1、Android Token介绍"></a>1.1、Android Token介绍</h3><p>Token是ActivityRecord的内部静态类，我们先来看下Token的继承关系，Token extends IApplicationToken.Stub，从IApplicationToken.Stub类进行继承，根据Binder的机制可以知道Token是一个匿名Binder实体类，这个匿名Binder实体会传递给其他进程，其他进程会拿到Token的代理端。 我们知道匿名Binder有两个比较重要的用途，一个是拿到Binder代理端后可跨Binder调用实体端的函数接口，另一个作用便是在多个进程中标识同一个对象。往往这两个作用是同时存在的，比如我们这里研究的Token就同时存在这两个作用，但最重要的便是后者，Token标识了一个ActivityRecord对象，即间接标识了一个Activity。</p>
<p>Token梳理： 分析源码，我们发现，大多数 token 的对象，都表示一个 IBinder 对象。提到 IBinder，大家一点也不陌生，就是 Android 的 IPC 通信机制。在创建窗口过程中，涉及到的 IPC 通信，无非包含两方面，一个是 WmS 用来跟应用所在的进程进行通信的 ViewRootImpl.W 类的对象，另一个是指向一个 ActivityRecord 的对象，自然应该是WMS用来跟 AMS进行通信的了。我们梳理了一下，token 以下几处的定义，分别来讲讲这里的 token 代表什么。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/03-Android-WMS-Token-Detail.png" alt="Markdown"></p>
<p>分析一下 View 的 AttachInfo 的赋值。ViewRootImpl 在构建方法里，会初始化一个 AttachInfo 实例，把它的 Session，以及 W类对象赋值给 AttachInfo。分析可以看到，AttachInfo 中的 mWindowToken，与mWindow 都是指向 ViewRootImpl 中的 mWindow(W类实例)。当一个 View attach 到窗口后，ViewRootImpl会执行performTraversals，如果发现是首次调用会，会把自己的 mAttachInfo 传递给根 View（通过dispatchAttachedToWindow），告诉 View 树现在已经 attch to Window 了，马上可以显示了。根 View（一般是 ViewGroup）会把这个信息，遍历地传递给 View 树中的每一个子 View，这样每个 View 的 mAttachInfo 都被赋值为 ViewRootImp 的 mAttachInfo了。</p>
<h3 id="1-1-1、Token对象的创建"><a href="#1-1-1、Token对象的创建" class="headerlink" title="1.1.1、Token对象的创建"></a>1.1.1、Token对象的创建</h3><p>下面这个图是Token的传递，首先会传递到WMS中，接着会传递到应用进程ActivityThread中，下面来具体分析这个传递流程。 总体流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/04-Android-WMS-Token.png" alt="Markdown"></p>
<p>我们之前分析：【Android 7.1.2 (Android N) Activity启动流程分析】 在启动Activity过程中会调用ActivityStarter.startActivityLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">            requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, container,</span><br><span class="line">            options, sourceRecord);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="keyword">true</span>, options, inTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在startActivityLocked()中创建了一个ActivityRecord对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="keyword">final</span> IApplicationToken.Stub appToken; <span class="comment">// window manager token</span></span><br><span class="line"></span><br><span class="line">ActivityRecord(ActivityManagerService _service, ProcessRecord _caller,</span><br><span class="line">        <span class="keyword">int</span> _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType,</span><br><span class="line">        ActivityInfo aInfo, Configuration _configuration,</span><br><span class="line">        ActivityRecord _resultTo, String _resultWho, <span class="keyword">int</span> _reqCode,</span><br><span class="line">        <span class="keyword">boolean</span> _componentSpecified, <span class="keyword">boolean</span> _rootVoiceInteraction,</span><br><span class="line">        ActivityStackSupervisor supervisor,</span><br><span class="line">        ActivityContainer container, ActivityOptions options, ActivityRecord sourceRecord) &#123;</span><br><span class="line">    service = _service;</span><br><span class="line">    appToken = <span class="keyword">new</span> Token(<span class="keyword">this</span>, service);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ActivityRecord的构造函数中创建，标识着当前这个ActivityRecord，即间接代表着一个Activity。</p>
<h3 id="1-1-2、AMS调用WMS的addAPPToken-接口"><a href="#1-1-2、AMS调用WMS的addAPPToken-接口" class="headerlink" title="1.1.2、AMS调用WMS的addAPPToken()接口"></a>1.1.2、AMS调用WMS的addAPPToken()接口</h3><p>在启动一个Activity时，会调用startActivityLocked()来在WMS中添加一个AppWindowToken对象 startActivityLocked()创建ActivityRecord对象后会继续调用startActivityUnchecked()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            ......</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addConfigOverride</span><span class="params">(ActivityRecord r, TaskRecord task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = task.updateOverrideConfigurationFromLaunchBounds();</span><br><span class="line">        <span class="comment">// 跳转到WMS</span></span><br><span class="line">        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != <span class="number">0</span>, r.userId, r.info.configChanges,</span><br><span class="line">                task.voiceSession != <span class="keyword">null</span>, r.mLaunchTaskBehind, bounds, task.mOverrideConfig,</span><br><span class="line">                task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(),</span><br><span class="line">                r.appInfo.targetSdkVersion, r.mRotationAnimationHint);</span><br><span class="line">        r.taskConfigOverride = task.mOverrideConfig;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续看下WindowManager.addAppToken()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppToken</span><span class="params">(<span class="keyword">int</span> addPos, IApplicationToken token, <span class="keyword">int</span> taskId, <span class="keyword">int</span> stackId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedOrientation, <span class="keyword">boolean</span> fullscreen, <span class="keyword">boolean</span> showForAllUsers, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> voiceInteraction, <span class="keyword">boolean</span> launchTaskBehind,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect taskBounds, Configuration config, <span class="keyword">int</span> taskResizeMode, <span class="keyword">boolean</span> alwaysFocusable,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> homeTask, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">int</span> rotationAnimationHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            AppWindowToken atoken = findAppWindowToken(token.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">&quot;Attempted to add existing app token: &quot;</span> + token);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据ActivityRecord中IApplicationToken.Stub的代理，创建AppWindowToken</span></span><br><span class="line">            atoken = <span class="keyword">new</span> AppWindowToken(<span class="keyword">this</span>, token, voiceInteraction);</span><br><span class="line">            atoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos;</span><br><span class="line">            atoken.appFullscreen = fullscreen;</span><br><span class="line">            atoken.showForAllUsers = showForAllUsers;</span><br><span class="line">            atoken.targetSdk = targetSdkVersion;</span><br><span class="line">            atoken.requestedOrientation = requestedOrientation;</span><br><span class="line">            atoken.layoutConfigChanges = (configChanges &amp;</span><br><span class="line">                    (ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_ORIENTATION)) != <span class="number">0</span>;</span><br><span class="line">            atoken.mLaunchTaskBehind = launchTaskBehind;</span><br><span class="line">            atoken.mAlwaysFocusable = alwaysFocusable;</span><br><span class="line">            atoken.mRotationAnimationHint = rotationAnimationHint;</span><br><span class="line"></span><br><span class="line">            Task task = mTaskIdToTask.get(taskId);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                task = createTaskLocked(taskId, stackId, userId, atoken, taskBounds, config);</span><br><span class="line">            &#125;</span><br><span class="line">            task.addAppToken(addPos, atoken, taskResizeMode, homeTask);</span><br><span class="line">            <span class="comment">//将atoken放入到mTokenMap中，等应用程序addWindow时，进行身份验证</span></span><br><span class="line">            <span class="comment">//其中token.asBinder()是IApplicationToken.Stub的代理，atoken就是根据代理，得到对应AppWindowToken</span></span><br><span class="line">            mTokenMap.put(token.asBinder(), atoken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Application tokens start out hidden.</span></span><br><span class="line">            atoken.hidden = <span class="keyword">true</span>;</span><br><span class="line">            atoken.hiddenRequested = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程"><a href="#1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程" class="headerlink" title="1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程"></a>1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程</h3><p>当框架通过ApplicationThread的代理回调到ActivityThread的时候，将对应的步骤一种生成的token代理传入。 ActivityStackSupervisor.realStartActivityLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity()方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java :ApplicationThread]</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">            <span class="comment">//传递给了ActivityThread的token，这个token就是IApplicationToken.Stub的代理</span></span><br><span class="line">            r.token = token;</span><br><span class="line">            ......</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4、Activity窗口添加过程"><a href="#1-1-4、Activity窗口添加过程" class="headerlink" title="1.1.4、Activity窗口添加过程"></a>1.1.4、Activity窗口添加过程</h3><p>详细过程请查看：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java]</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而层层调用到：ViewRootImpl.setView()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">WindowManager.LayoutParams l = r.window.getAttributes();</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl.setView()函数中添加Activity窗口时在参数mWindowAttributes中携带Token代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,  </span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,  </span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="comment">//attrs这个是应用程序ActivityClientRecord中传递过来的参数，其中的attrs.token就是步骤三种的r.token</span></span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);  </span><br><span class="line">        ......  </span><br><span class="line">        win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,  </span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);  </span><br><span class="line"></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);  </span><br><span class="line">        ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Binder机制可以知道从上层应用传递过来的Token代理对象会转换成SystemServer进程中的Token本地对象，后者与第2步中从Token对象是同一个对象，所以上面调用mTokenMap.get(attrs.token)时便能返回正确返回一个WindowToken（这个WindowToken其实是一个APPWindowToken），这样添加的窗口也就跟Activity关联上了。</p>
<h3 id="1-2、WMS组织方式"><a href="#1-2、WMS组织方式" class="headerlink" title="1.2、WMS组织方式"></a>1.2、WMS组织方式</h3><p>Activity管理服务ActivityManagerService中每一个ActivityRecord对象在Window管理服务WindowManagerService中都对应有一个AppWindowToken对象。</p>
<p>此外，在输入法管理服务InputMethodManagerService中，每一个输入法窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService又对应有一个WindowToken对象。</p>
<p>与输入法窗口类似，在壁纸管理服务WallpaperManagerService中，每一个壁纸窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService也对应有一个WindowToken对象。</p>
<p>在Window管理服务WindowManagerService中，无论是AppWindowToken对象，还是WindowToken对象，它们都是用来描述一组有着相同令牌的窗口的，每一个窗口都是通过一个WindowState对象来描述的。例如，一个Activity组件窗口可能有一个启动窗口（Starting Window），还有若干个子窗口，那么这些窗口就会组成一组，并且都是以Activity组件在Window管理服务WindowManagerService中所对应的AppWindowToken对象为令牌的。从抽象的角度来看，就是在Window管理服务WindowManagerService中，每一个令牌（AppWindowToken或者WindowToken）都是用来描述一组窗口（WindowState）的，并且每一个窗口的子窗口也是与它同属于一个组，即都有着相同的令牌。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/05-Android-WMS-AppWindowToken.png" alt="Markdown"><br>其中，Activity Stack是在ActivityManagerService服务中创建的，Token List和Window Stack是在WindowManagerService中创建的，而Binder for IM和Binder for WP分别是在InputMethodManagerService服务和WallpaperManagerService服务中创建的，用来描述一个输入法窗口和一个壁纸窗口。</p>
<h3 id="1-3、WMS窗口类型"><a href="#1-3、WMS窗口类型" class="headerlink" title="1.3、WMS窗口类型"></a>1.3、WMS窗口类型</h3><p>添加一个窗口是通过 WindowManagerGlobal.addView()来完成的，分析 addView 方法的参数，有三个参数是必不可少的，view，params，以及 display。而 display 一般直接取 WindowMnagerImpl 中的 mDisplay，表示要输出的显示设备。view 自然表示要显示的 View，而 params 是 WindowManager.LayoutParams，用来描述这个 view 的些窗口属性，其中一个重要的参数 type，用来描述窗口的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerGlobal]</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;display must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开WindowManager类，看到静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManager]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">LayoutParams</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">可以看到在LayoutParams中，有<span class="number">2</span>个比较重要的参数: flags,type。 我们简要的分析一下flags,该参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性，这里主要介绍几个比较常用的选项。</span><br><span class="line"></span><br><span class="line">FLAG_NOT_FOCUSABLE 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层具有焦点的Window。</span><br><span class="line"></span><br><span class="line">FLAG_NOT_TOUCH_MODAL 系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理，这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法接收到单击事件。</span><br><span class="line"></span><br><span class="line">FLAG_SHOW_WHEN_LOCKED 开启此模式可以让Window显示在锁屏的界面上。</span><br><span class="line"></span><br><span class="line">&gt; Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window、系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的PopupWindow就是一个子Window。有些系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。</span><br><span class="line"></span><br><span class="line">### 1.3.1、应用窗口</span><br><span class="line"></span><br><span class="line">Activity 对应的窗口类型是应用窗口， 所有 Activity 默认的窗口类型是 TYPE_BASE_APPLICATION。 WindowManager 的 LayoutParams 的默认类型是 TYPE_APPLICATION。 Dialog 并没有设置type，所以也是默认的窗口类型即 TYPE_APPLICATION。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">[-&gt;WindowManager.LayoutParams]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">    type = TYPE_APPLICATION;</span><br><span class="line">    format = PixelFormat.OPAQUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">type层级</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FIRST_APPLICATION_WINDOW=1</td>
<td align="left">开始应用程序窗口，第一个普通应用窗口</td>
</tr>
<tr>
<td align="left">TYPE_BASE_APPLICATION=1</td>
<td align="left">所有程序窗口的base窗口，其他应用程序窗口都显示在它上面</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION=2</td>
<td align="left">普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_STARTING=3</td>
<td align="left">应用程序启动时先显示此窗口，当真正的窗口配置完成后，关闭此窗口</td>
</tr>
<tr>
<td align="left">LAST_APPLICATION_WINDOW=99</td>
<td align="left">最后一个应用窗口</td>
</tr>
</tbody></table>
<h3 id="1-3-2、子窗口"><a href="#1-3-2、子窗口" class="headerlink" title="1.3.2、子窗口"></a>1.3.2、子窗口</h3><p>子窗口不能单独存在，它需要附属在特定的父Window之中，例如开篇第一张图，绿色框框即为popupWindow，它就是子窗口，类型一般为TYPE_APPLICATION_PANEL。之所以称为子窗口，即它的父窗口显示时，子窗口才显示。父窗口不显示，它也不显示。追随父窗口。</p>
<table>
<thead>
<tr>
<th align="left">type层级</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FIRST_SUB_WINDOW=1000</td>
<td align="left">第一个子窗口</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_PANEL=1000</td>
<td align="left">应用窗口的子窗口,popupWindow的默认类型</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_MEDIA=1001</td>
<td align="left">媒体窗口</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_SUB_PANEL=1002</td>
<td align="left">TYPE_APPLICATION_PANE的子窗口</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_ATTACHED_DIALOG=1003</td>
<td align="left">对话框，类似于面板窗口(OptionMenu,ContextMenu)</td>
</tr>
<tr>
<td align="left">TYPE_APPLICATION_MEDIA_OVERLAY=1004</td>
<td align="left">媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果</td>
</tr>
<tr>
<td align="left">LAST_SUB_WINDOW=1999</td>
<td align="left">最后一个子窗口</td>
</tr>
</tbody></table>
<h3 id="1-3-3、系统窗口"><a href="#1-3-3、系统窗口" class="headerlink" title="1.3.3、系统窗口"></a>1.3.3、系统窗口</h3><p>系统窗口跟应用窗口不同，不需要对应 Activity。跟子窗口不同，不需要有父窗口。一般来讲，系统窗口应该由系统来创建的，例如发生异常，ANR时的提示框，又如系统状态栏，屏保等。但是，Framework 还是定义了一些，可以被应用所创建的系统窗口，如 TYPE _TOAST，TYPE <em>INPUT</em> METHOD，TYPE _WALLPAPTER 等等。</p>
<table>
<thead>
<tr>
<th align="left">type层级</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FIRST_SYSTEM_WINDOW=2000</td>
<td align="left">第一个系统窗口</td>
</tr>
<tr>
<td align="left">TYPE_STATUS_BAR=2000</td>
<td align="left">状态栏，只能有一个状态栏，位于屏幕顶端</td>
</tr>
<tr>
<td align="left">TYPE_SEARCH_BAR =2001</td>
<td align="left">搜索栏</td>
</tr>
<tr>
<td align="left">TYPE_PHONE=2002</td>
<td align="left">电话窗口，它用于电话交互</td>
</tr>
<tr>
<td align="left">TYPE_SYSTEM_ALERT=2003</td>
<td align="left">系统警告，出现在应用程序窗口之上</td>
</tr>
<tr>
<td align="left">TYPE_KEYGUARD=2004</td>
<td align="left">锁屏窗口</td>
</tr>
<tr>
<td align="left">TYPE_TOAST=2005</td>
<td align="left">信息窗口，用于显示Toast</td>
</tr>
<tr>
<td align="left">TYPE_SYSTEM_OVERLAY=2006</td>
<td align="left">系统顶层窗口，显示在其他内容之上，此窗口不能获得输入焦点，否则影响锁屏</td>
</tr>
<tr>
<td align="left">TYPE_PRIORITY_PHONE=2007</td>
<td align="left">当锁屏时显示的来电显示窗口</td>
</tr>
<tr>
<td align="left">TYPE_SYSTEM_DIALOG=2008</td>
<td align="left">系统对话框</td>
</tr>
<tr>
<td align="left">TYPE_KEYGUARD_DIALOG=2009</td>
<td align="left">锁屏时显示的对话框</td>
</tr>
<tr>
<td align="left">TYPE_SYSTEM_ERROR=2010</td>
<td align="left">系统内部错误提示</td>
</tr>
<tr>
<td align="left">TYPE_INPUT_METHOD=2011</td>
<td align="left">输入法窗口，显示于普通应用/子窗口之上</td>
</tr>
<tr>
<td align="left">TYPE_INPUT_METHOD_DIALOG=2012</td>
<td align="left">输入法中备选框对应的窗口</td>
</tr>
<tr>
<td align="left">TYPE_WALLPAPER=2013</td>
<td align="left">墙纸窗口</td>
</tr>
<tr>
<td align="left">TYPE_STATUS_BAR_PANEL=2014</td>
<td align="left">滑动状态条后出现的窗口</td>
</tr>
<tr>
<td align="left">TYPE_SECURE_SYSTEM_OVERLAY=2015</td>
<td align="left">安全系统覆盖窗口</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left">……</td>
</tr>
<tr>
<td align="left">LAST_SYSTEM_WINDOW=2999</td>
<td align="left">最后一个系统窗口</td>
</tr>
</tbody></table>
<p>那么，这个type层级到底有什么作用呢？ Window是分层的，每个Window都有对应的z-ordered，（z轴，从1层层叠加到2999，你可以将屏幕想成三维坐标模式）层级大的会覆盖在层级小的Window上面。</p>
<p>在三类Window中，应用Window的层级范围是1<del>99。子Window的层级范围是1000</del>1999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。另外有些系统层级的使用是需要声明权限的。</p>
<h2 id="（二）、Window-Size（大小）和-Window-Position（位置）-计算过程"><a href="#（二）、Window-Size（大小）和-Window-Position（位置）-计算过程" class="headerlink" title="（二）、Window Size（大小）和 Window Position（位置） 计算过程"></a>（二）、Window Size（大小）和 Window Position（位置） 计算过程</h2><p>之前在【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】分析过，当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。为了分析的连贯性，这里重新贴一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performTraversals()函数相当复杂，其主要实现以下几个重要步骤：</p>
<p>1.执行窗口测量；</p>
<p>2.执行窗口注册；</p>
<p>3.执行窗口布局；</p>
<p>4.执行窗口绘图；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1、-Android-屏幕区域介绍"><a href="#2-1、-Android-屏幕区域介绍" class="headerlink" title="2.1、 Android 屏幕区域介绍"></a>2.1、 Android 屏幕区域介绍</h3><p>首先来看relayoutWindow()。relayoutWindow() 是Window Manager Service 重要工作之一，它的流程如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/06-Android-WMS-relayoutWindow-flow.png.png" alt="Markdown"></p>
<p>每个View将期望窗口尺寸交给WMS（WindowManager Service). WMS 将所有的窗口大小以及当前的Overscan区域传给WPM （WindowManager Policy). WPM根据用户配置确定每个Window在最终Display输出上的位置以及需要分配的Surface大小。 返回这些信息给每个View，他们将在给会的区域空间里绘图。 Android里定义了很多区域,如下图所示<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/07-Android-WMS-OverSan-area.png" alt="Markdown"></p>
<p><strong>Overscan:</strong> Overscan 是电视特有的概念，上图中黄色部分就是Overscan区域，指的是电视机屏幕四周某些不可见的区域（因为电视特性，这部分区域的buffer内容显示时被丢弃），也意味着如果窗口的某些内容画在这个区域里，它在某些电视上就会看不到。为了避免这种情况发生，通常要求UI不要画在屏幕的边角上，而是预留一定的空间。因为Overscan的区域大小随着电视不 同而不同，它一般由终端用户通过UI指定，（比如说GoogleTV里就有确定Overscan大小的应用）。</p>
<p><strong>OverscanScreen, Screen:</strong> OverscanScreen 是包含Overscan区域的屏幕大小,而Screen则为去除Overscan区域后的屏幕区域, OverscanScreen &gt; Screen.</p>
<p><strong>Restricted and Unrestricted:</strong> 某些区域是被系统保留的，比如说手机屏幕上方的状态栏(如图纸绿色区域）和下方的导航栏，根据是否包括这些预留的区域，Android把区域分为Unrestricted Area 和 Resctrited Aread, 前者包括这部分预留区域，后者则不包含, Unrestricted area &gt; Rectricted area。</p>
<p><strong>mFrame, mDisplayFrame, mContainingFrame</strong> Frame指的是一片内存区域, 对应于屏幕上的一块矩形区域. mFrame的大小就是Surface的大小, 如上上图中的蓝色区域. mDisplayFrame 和 mContainingFrame 一般和mFrame 大小一致. mXXX 是Window(ViewRootImpl, Windowstate) 里面定义的成员变量.</p>
<p><strong>mContentFrame, mVisibleFrame</strong> 一个Surface的所有内容不一定在屏幕上都得到显示, 与Overscan重叠的部分会被截掉, 系统的其他窗口也会遮挡掉部分区域 (比如短信窗口，ContentFrame是800x600(没有Status Bar), 但当输入法窗口弹出是，变成了800x352), 剩下的区域称为Visible Frame, UI内容只有画在这个区域里才能确保可见. 所以也称为Content Frame. mXXX也是Window(ViewRootImpl, WindowState) 里面定义的成员变量.<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/08-Android-WMS-Content-Insets.png" alt="Markdown"></p>
<p><strong>Insets</strong> insets的定义如上图所示, 用了表示某个Frame的边缘大小.</p>
<h3 id="2-2、-Window-大小位置计算过程"><a href="#2-2、-Window-大小位置计算过程" class="headerlink" title="2.2、 Window 大小位置计算过程"></a>2.2、 Window 大小位置计算过程</h3><p>在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。 一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下Activity窗口的区域是如何划分的。 我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/09-Android-WMS-Content-Visible-Frame.png" alt="Markdown"></p>
<p>从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。 我们还知道，Activity窗口有时候需要显示输入法窗口，如图。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/10-Android-WMS-InputMethod-Content-Frame.png" alt="Markdown"></p>
<p>这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区域与窗口区域的左右上下边界距离。</p>
<p>在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里面的UI元素进行测量、布局以及绘制等操作了。 总体流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/11-Android-WMS-relayoutWindow-time-diagram.png" alt="Markdown"></p>
<p>这个过程可以分为13个步骤，接下来我们就详细分析每一个步骤。</p>
<h3 id="2-2-1、ViewRootImpl-performTraversals"><a href="#2-2-1、ViewRootImpl-performTraversals" class="headerlink" title="2.2.1、ViewRootImpl.performTraversals()"></a>2.2.1、ViewRootImpl.performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">    ......</span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//第一次被请求执行测量、布局和绘制操作，desiredWindowWidth和desiredWindowHeight等于Display Size，否则mWinFrame保存的宽度和高度值。</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">            Point size = <span class="keyword">new</span> Point();</span><br><span class="line">            mDisplay.getRealSize(size);</span><br><span class="line">            desiredWindowWidth = size.x;</span><br><span class="line">            desiredWindowHeight = size.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">            desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是第一次请求，当desiredWindowWidth != mWidth || desiredWindowHeight != mHeight，说明Activity窗口的大小发生了变化，这时候windowSizeMayChange = true，以便接下来对Activity窗口大小变化进行处理</span></span><br><span class="line">        desiredWindowWidth = frame.width();</span><br><span class="line">        desiredWindowHeight = frame.height();</span><br><span class="line">        <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。</p>
<p>继续阅读代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//AttachInfo对象用来描述Activity窗口的属性,mContentInsets和mVisibleInsets分别用来描述Activity窗口的当前内容边衬大小和可见边衬大小。</span></span><br><span class="line">        <span class="comment">//判断Activity窗口的OverscanInsets、ContentInsets、StableInsets、VisibleInsets大小是否发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">            insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//WRAP_CONTENT表明Activity窗口的大小要等于内容区域的大小，同时等于Display size</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">    <span class="comment">//知道了顶层Activity窗口大小从而计算Activity内各个子View的大小</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。</p>
<p>继续阅读代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">        viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//relayoutWindow来请求WMS计算Activity窗口的大小以及xxxInsets大小，并保存在PendingxxxInsets中</span></span><br><span class="line">        relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (contentInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (visibleInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop</span></span><br><span class="line">    mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">    mAttachInfo.mWindowTop = frame.top;</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的宽度和高度保存在ViewRootImpl类的成员变量mWidth和mHeight中</span></span><br><span class="line">    <span class="keyword">if</span> (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">        mWidth = frame.width();</span><br><span class="line">        mHeight = frame.height();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要调用relayoutWindow()来请求WMS计算Activity窗口的大小以及边忖xxxInsets大小。计算完毕之后，分别保存在mPendingXXXInsets中。</p>
<p>继续阅读代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                    updatedConfiguration) &#123;</span><br><span class="line">                <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用来检查是否需要重新测量Activity窗口的大小。</p>
<p>经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局 performLayout(lp, mWidth, mHeight)和进行绘画了，performDraw()，由于主要关注Activity窗口大小计算过程，在此不做继续分析。</p>
<h3 id="2-2-2、ViewRootImpl-relayoutWindow"><a href="#2-2-2、ViewRootImpl-relayoutWindow" class="headerlink" title="2.2.2、ViewRootImpl.relayoutWindow()"></a>2.2.2、ViewRootImpl.relayoutWindow()</h3><p>通过调用这个Session对象的成员函数relayout()来请求WindowManagerService服务计算Activity窗口的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数说明： 1、mWindow 用来标志要计算的是哪一个Activity窗口的大小p 2、Activity窗口的顶层视图经过测量后得到的宽度和高度 3、Activity窗口的可见状态，即viewVisibility 4、Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending 5、mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大小 6、mPendingOverscanInsets用来保存Overscan边衬，mPendingContentInsets用来保存内容区域边衬，mPendingVisibleInsets用来保存可见区域边衬，mPendingStableInsets用来保存可能被系统UI元素部分或完全遮蔽的全屏窗口区域 7、mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的配置信息 8、mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表面</p>
<h3 id="2-2-3、Session-relayout"><a href="#2-2-3、Session-relayout" class="headerlink" title="2.2.3、Session.relayout()"></a>2.2.3、Session.relayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Session.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算参数window所描述的一个Activity窗品的大小</p>
<h3 id="2-2-4、WindowManagerService-relayoutWindow"><a href="#2-2-4、WindowManagerService-relayoutWindow" class="headerlink" title="2.2.4、WindowManagerService.relayoutWindow()"></a>2.2.4、WindowManagerService.relayoutWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility != View.GONE) &#123;</span><br><span class="line">            win.setRequestedSize(requestedWidth, requestedHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPolicy.adjustWindowParamsLw(attrs);</span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line">        win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            win.adjustStartingWindowFlags();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">        ......</span><br><span class="line">        outFrame.set(win.mCompatFrame);</span><br><span class="line">        outOverscanInsets.set(win.mOverscanInsets);</span><br><span class="line">        outContentInsets.set(win.mContentInsets);</span><br><span class="line">        outVisibleInsets.set(win.mVisibleInsets);</span><br><span class="line">        outStableInsets.set(win.mStableInsets);</span><br><span class="line">        outOutsets.set(win.mOutsets);</span><br><span class="line">        outBackdropFrame.set(win.getBackdropFrame(win.mFrame));</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只关注relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示： 1、参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中 2、WindowState对象win的成员变量mAttrs，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局参数 3、调用WindowSurfacePlacer.performSurfacePlacement()来计算Activity窗口的大小。计算完成之后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets中 4、 将WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets拷贝赋值对应变量中，以便可以返回给应用程序进程</p>
<p>经过上述4个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowSurfacePlacer.performSurfacePlacement()的实现，以便可以详细了解Activity窗口的大小计算过程</p>
<h3 id="2-2-5、WindowSurfacePlacer-performSurfacePlacement"><a href="#2-2-5、WindowSurfacePlacer-performSurfacePlacement" class="headerlink" title="2.2.5、WindowSurfacePlacer.performSurfacePlacement()"></a>2.2.5、WindowSurfacePlacer.performSurfacePlacement()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSurfacePlacement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeferDepth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        performSurfacePlacementLoop();</span><br><span class="line">        mService.mH.removeMessages(DO_TRAVERSAL);</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mTraversalScheduled &amp;&amp; loopCount &gt; <span class="number">0</span>);</span><br><span class="line">    mWallpaperActionPending = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop"><a href="#2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop" class="headerlink" title="2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()"></a>2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> recoveringMemory = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">            recoveringMemory = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">                WindowState ws = mService.mForceRemoves.remove(<span class="number">0</span>);</span><br><span class="line">                mService.removeWindowInnerLocked(ws);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        performSurfacePlacementInner(recoveringMemory);</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.needsLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++mLayoutRepeatCount &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                requestTraversal();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">&quot;Performed 6 layouts in a row. Skipping&quot;</span>);</span><br><span class="line">                mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;</span><br><span class="line">            mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);</span><br><span class="line">            mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用成员函数performSurfacePlacementInner()刷新系统UI的前后 1、检查系统中是否存在强制删除的窗口 2、检查系统中是否有窗口需要移除</p>
<h3 id="2-2-7、WindowSurfacePlacer-performSurfacePlacementInner"><a href="#2-2-7、WindowSurfacePlacer-performSurfacePlacementInner" class="headerlink" title="2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()"></a>2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()</h3><p>继续分析的performSurfacePlacementInner()实现，以便可以了解Activity窗口的大小计算过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementInner</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_WINDOW_TRACE) Slog.v(TAG, <span class="string">&quot;performSurfacePlacementInner: entry. Called by &quot;</span></span><br><span class="line">            + Debug.getCallers(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayContent defaultDisplay = mService.getDefaultDisplayContentLocked();</span><br><span class="line">    <span class="keyword">final</span> DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDw = defaultInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDh = defaultInfo.logicalHeight;</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applySurfaceChangesTransaction(recoveringMemory, numDisplays, defaultDw, defaultDh);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;Unhandled exception in Window Manager&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList defaultWindows = defaultDisplay.getWindowList();</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = mService.mPendingRemove.size();</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mPendingRemoveTmp.length &lt; N) &#123;</span><br><span class="line">                mService.mPendingRemoveTmp = <span class="keyword">new</span> WindowState[N+<span class="number">10</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            mService.mPendingRemove.toArray(mService.mPendingRemoveTmp);</span><br><span class="line">            mService.mPendingRemove.clear();</span><br><span class="line">            DisplayContentList displayList = <span class="keyword">new</span> DisplayContentList();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                WindowState w = mService.mPendingRemoveTmp[i];</span><br><span class="line">                mService.removeWindowInnerLocked(w);</span><br><span class="line">                <span class="keyword">final</span> DisplayContent displayContent = w.getDisplayContent();</span><br><span class="line">                <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; !displayList.contains(displayContent)) &#123;</span><br><span class="line">                    displayList.add(displayContent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DisplayContent displayContent : displayList) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mService.scheduleAnimationLocked();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到进一步调用applySurfaceChangesTransaction()方法进行进一步计算</p>
<h3 id="2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applySurfaceChangesTransaction</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory, <span class="keyword">int</span> numDisplays,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defaultDw, <span class="keyword">int</span> defaultDh)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> focusDisplayed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">boolean</span> updateAllDrawn = <span class="keyword">false</span>;</span><br><span class="line">        WindowList windows = displayContent.getWindowList();</span><br><span class="line">        DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = displayContent.getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDw = displayInfo.appWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDh = displayInfo.appHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset for each display.</span></span><br><span class="line">        mDisplayHasContent = <span class="keyword">false</span>;</span><br><span class="line">        mPreferredRefreshRate = <span class="number">0</span>;</span><br><span class="line">        mPreferredModeId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            repeats++;</span><br><span class="line">            <span class="keyword">if</span> (repeats &gt; <span class="number">6</span>) &#123;<span class="comment">//最多执行7次的while循环</span></span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知SurfaceFlinger服务了，也就是让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲区中去</span></span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    mWallpaperControllerLocked.adjustWallpaperWindows()) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(windows);</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST LOOP: Perform a layout, if needed.</span></span><br><span class="line">            <span class="comment">//计算各个窗品的大小</span></span><br><span class="line">            <span class="keyword">if</span> (repeats &lt; LAYOUT_REPEAT_THRESHOLD) &#123;</span><br><span class="line">                performLayoutLockedInner(displayContent, repeats == <span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* updateInputWindows */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think</span></span><br><span class="line">            <span class="comment">// it is animating.</span></span><br><span class="line">            displayContent.pendingLayoutChanges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">                mService.mPolicy.beginPostLayoutPolicyLw(dw, dh);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    WindowState w = windows.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (w.mHasSurface) &#123;</span><br><span class="line">                        mService.mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs,</span><br><span class="line">                                w.mAttachedWindow);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                displayContent.pendingLayoutChanges |=</span><br><span class="line">                        mService.mPolicy.finishPostLayoutPolicyLw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (displayContent.pendingLayoutChanges != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performLayoutLockedInner</span><span class="params">(<span class="keyword">final</span> DisplayContent displayContent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> initial, <span class="keyword">boolean</span> updateInputWindows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">    WindowList windows = displayContent.getWindowList();</span><br><span class="line">    <span class="keyword">boolean</span> isDefaultDisplay = displayContent.isDefaultDisplay;</span><br><span class="line"></span><br><span class="line">    DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mService.mRotation,</span><br><span class="line">            mService.mCurConfiguration.uiMode);</span><br><span class="line">    ......</span><br><span class="line">    displayContent.resize(mTmpContentRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq = mService.mLayoutSeq+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (seq &lt; <span class="number">0</span>) seq = <span class="number">0</span>;</span><br><span class="line">    mService.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> behindDream = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topAttached = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = N-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> gone = (behindDream &amp;&amp; mService.mPolicy.canBeForceHidden(win, win.mAttrs))</span><br><span class="line">                || win.isGoneForLayoutLw();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!gone || !win.mHaveFrame || win.mLayoutNeeded</span><br><span class="line">                || ((win.isConfigChanged() || win.setReportResizeHints())</span><br><span class="line">                        &amp;&amp; !win.isGoneForLayoutLw() &amp;&amp;</span><br><span class="line">                        ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != <span class="number">0</span> ||</span><br><span class="line">                        (win.mHasSurface &amp;&amp; win.mAppToken != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        win.mAppToken.layoutConfigChanges)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!win.mLayoutAttached) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, <span class="keyword">null</span>);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Window frames may have changed. Update dim layer with the new bounds.</span></span><br><span class="line">                <span class="keyword">final</span> Task task = win.getTask();</span><br><span class="line">                <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    displayContent.mDimLayerController.updateDimLayer(task);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> attachedBehindDream = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (i = topAttached; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        <span class="keyword">if</span> (win.mLayoutAttached) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled)</span><br><span class="line">                    || !win.mHaveFrame || win.mLayoutNeeded) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, win.mAttachedWindow);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (win.mAttrs.type == TYPE_DREAM) &#123;</span><br><span class="line">            attachedBehindDream = behindDream;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window frames may have changed. Tell the input dispatcher about it.</span></span><br><span class="line">    mService.mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">    <span class="keyword">if</span> (updateInputWindows) &#123;</span><br><span class="line">        mService.mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.mPolicy.finishLayoutLw();</span><br><span class="line">    mService.mH.sendEmptyMessage(UPDATE_DOCKED_STACK_DIVIDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、mPolicy指向的是一个窗口管理策略类，即PhoneWindowManager对象，主要是用来制定窗口的大小计算策略 2、准备阶段：调用PhoneWindowManager.beginLayoutLw()来设置屏幕的大小。包括NavigationBar、StatusBar大小计算 3、计算阶段：调用PhoneWindowManager.layoutWindowLw()来计算各个窗口的大小、内容区域边衬大小以及可见区域边衬大小。 4、结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw()来执行一些清理工作。</p>
<h3 id="2-2-10、PhoneWindowManager-beginLayoutLw"><a href="#2-2-10、PhoneWindowManager-beginLayoutLw" class="headerlink" title="2.2.10、PhoneWindowManager.beginLayoutLw()"></a>2.2.10、PhoneWindowManager.beginLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginLayoutLw</span><span class="params">(<span class="keyword">boolean</span> isDefaultDisplay, <span class="keyword">int</span> displayWidth, <span class="keyword">int</span> displayHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> displayRotation, <span class="keyword">int</span> uiMode)</span> </span>&#123;</span><br><span class="line">    mDisplayRotation = displayRotation;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> overscanLeft, overscanTop, overscanRight, overscanBottom;</span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (displayRotation) &#123;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">                overscanLeft = mOverscanTop;</span><br><span class="line">                overscanTop = mOverscanRight;</span><br><span class="line">                overscanRight = mOverscanBottom;</span><br><span class="line">                overscanBottom = mOverscanLeft;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        overscanLeft = <span class="number">0</span>;</span><br><span class="line">        overscanTop = <span class="number">0</span>;</span><br><span class="line">        overscanRight = <span class="number">0</span>;</span><br><span class="line">        overscanBottom = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenTop = mRestrictedOverscanScreenTop = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;</span><br><span class="line">    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;</span><br><span class="line">    mSystemLeft = <span class="number">0</span>;</span><br><span class="line">    mSystemTop = <span class="number">0</span>;</span><br><span class="line">    mSystemRight = displayWidth;</span><br><span class="line">    mSystemBottom = displayHeight;</span><br><span class="line">    mUnrestrictedScreenLeft = overscanLeft;</span><br><span class="line">    mUnrestrictedScreenTop = overscanTop;</span><br><span class="line">    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;</span><br><span class="line">    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;</span><br><span class="line">    mRestrictedScreenLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mRestrictedScreenTop = mUnrestrictedScreenTop;</span><br><span class="line">    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;</span><br><span class="line">    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;</span><br><span class="line">    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft</span><br><span class="line">            = mCurLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop</span><br><span class="line">            = mCurTop = mUnrestrictedScreenTop;</span><br><span class="line">    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight</span><br><span class="line">            = mCurRight = displayWidth - overscanRight;</span><br><span class="line">    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom</span><br><span class="line">            = mCurBottom = displayHeight - overscanBottom;</span><br><span class="line">    mDockLayer = <span class="number">0x10000000</span>;</span><br><span class="line">    mStatusBarLayer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with the current dock rect, which will be (0,0,displayWidth,displayHeight)</span></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    pf.left = df.left = of.left = vf.left = mDockLeft;</span><br><span class="line">    pf.top = df.top = of.top = vf.top = mDockTop;</span><br><span class="line">    pf.right = df.right = of.right = vf.right = mDockRight;</span><br><span class="line">    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;</span><br><span class="line">    dcf.setEmpty();  <span class="comment">// Decor frame N/A for system bars.</span></span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        navVisible |= !canHideNavigationBar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight,</span><br><span class="line">                displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent,navAllowedHidden, statusBarExpandedNotKeyguard);</span><br><span class="line">        updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (updateSysUiVisibility) &#123;</span><br><span class="line">            updateSystemUiVisibilityLw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、初始化Overscan、UnrestrictedScreen、RestrictedScreen等屏幕区域变量 2、计算NavigationBar和StatusBar大小</p>
<h3 id="2-2-11、PhoneWindowManager-layoutWindowLw"><a href="#2-2-11、PhoneWindowManager-layoutWindowLw" class="headerlink" title="2.2.11、PhoneWindowManager.layoutWindowLw()"></a>2.2.11、PhoneWindowManager.layoutWindowLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutWindowLw</span><span class="params">(WindowState win, WindowState attached)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fl = PolicyControl.getWindowFlags(win, attrs);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pfl = attrs.privateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sim = attrs.softInputMode;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sysUiFl = PolicyControl.getSystemUiVisibility(win, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect cf = mTmpContentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect sf = mTmpStableFrame;</span><br><span class="line">    Rect osf = <span class="keyword">null</span>;</span><br><span class="line">    dcf.setEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasNavBar = (isDefaultDisplay &amp;&amp; mHasNavigationBar</span><br><span class="line">            &amp;&amp; mNavigationBar != <span class="keyword">null</span> &amp;&amp; mNavigationBar.isVisibleLw());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> adjust = sim &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If this window is attached to another, our display</span></span><br><span class="line">            <span class="comment">// frame is the same as the one we are attached to.</span></span><br><span class="line">            setAttachedWindowFrames(win, fl, adjust, attached, <span class="keyword">true</span>, pf, df, of, cf, vf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Give the window full screen.</span></span><br><span class="line">            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;</span><br><span class="line">            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;</span><br><span class="line">            pf.right = df.right = of.right = cf.right</span><br><span class="line">                    = mOverscanScreenLeft + mOverscanScreenWidth;</span><br><span class="line">            pf.bottom = df.bottom = of.bottom = cf.bottom</span><br><span class="line">                    = mOverscanScreenTop + mOverscanScreenHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用WindowState.computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。</p>
<h3 id="2-2-12、WindowState-computeFrameLw"><a href="#2-2-12、WindowState-computeFrameLw" class="headerlink" title="2.2.12、WindowState.computeFrameLw()"></a>2.2.12、WindowState.computeFrameLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowState.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeFrameLw</span><span class="params">(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect osf)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullscreenTask = !isInMultiWindowMode();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> windowsAreFloating = task != <span class="keyword">null</span> &amp;&amp; task.isFloating();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Rect layoutContainingFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect layoutDisplayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The offset from the layout containing frame to the actual containing frame.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutXDiff;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutYDiff;</span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask || layoutInParentFrame()) &#123;</span><br><span class="line">        <span class="comment">// We use the parent frame as the containing frame for fullscreen and child windows</span></span><br><span class="line">        mContainingFrame.set(pf);</span><br><span class="line">        mDisplayFrame.set(df);</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutContainingFrame = pf;</span><br><span class="line">        layoutXDiff = <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task.getBounds(mContainingFrame);</span><br><span class="line">        ......</span><br><span class="line">        mDisplayFrame.set(mContainingFrame);</span><br><span class="line">        layoutXDiff = !mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = !mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : <span class="number">0</span>;</span><br><span class="line">        layoutContainingFrame = !mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;</span><br><span class="line">        mTmpRect.set(<span class="number">0</span>, <span class="number">0</span>, mDisplayContent.getDisplayInfo().logicalWidth,</span><br><span class="line">                mDisplayContent.getDisplayInfo().logicalHeight);</span><br><span class="line">        subtractInsets(mDisplayFrame, layoutContainingFrame, df, mTmpRect);</span><br><span class="line">        ......</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutDisplayFrame.intersect(layoutContainingFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pw = mContainingFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ph = mContainingFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    mOverscanFrame.set(of);</span><br><span class="line">    mContentFrame.set(cf);</span><br><span class="line">    mVisibleFrame.set(vf);</span><br><span class="line">    mDecorFrame.set(dcf);</span><br><span class="line">    mStableFrame.set(sf);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasOutsets = osf != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fw = mFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fh = mFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (windowsAreFloating &amp;&amp; !mFrame.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> height = Math.min(mFrame.height(), mContentFrame.height());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = Math.min(mContentFrame.width(), mFrame.width());</span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics displayMetrics = getDisplayContent().getDisplayMetrics();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleHeight = Math.min(height, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_HEIGHT_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleWidth = Math.min(width, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_WIDTH_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = Math.max(mContentFrame.top,</span><br><span class="line">                Math.min(mFrame.top, mContentFrame.bottom - minVisibleHeight));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = Math.max(mContentFrame.left + minVisibleWidth - width,</span><br><span class="line">                Math.min(mFrame.left, mContentFrame.right - minVisibleWidth));</span><br><span class="line">        mFrame.set(left, top, left + width, top + height);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">        mVisibleFrame.set(mContentFrame);</span><br><span class="line">        mStableFrame.set(mContentFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mContentFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mStableFrame.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask &amp;&amp; !windowsAreFloating) &#123;</span><br><span class="line">        <span class="comment">// Windows that are not fullscreen can be positioned outside of the display frame,</span></span><br><span class="line">        mOverscanInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">        mContentInsets.setEmpty();</span><br><span class="line">        mVisibleInsets.setEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getDisplayContent().getLogicalDisplayRect(mTmpRect);</span><br><span class="line">        <span class="keyword">boolean</span> overrideRightInset = !fullscreenTask &amp;&amp; mFrame.right &gt; mTmpRect.right;</span><br><span class="line">        <span class="keyword">boolean</span> overrideBottomInset = !fullscreenTask &amp;&amp; mFrame.bottom &gt; mTmpRect.bottom;</span><br><span class="line">        mContentInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Offset the actual frame by the amount layout frame is off.</span></span><br><span class="line">    mFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mCompatFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mContentFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mVisibleFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mStableFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line"></span><br><span class="line">    mCompatFrame.set(mFrame);</span><br><span class="line">    <span class="keyword">if</span> (mEnforceSizeCompat) &#123;</span><br><span class="line">        mOverscanInsets.scale(mInvGlobalScale);</span><br><span class="line">        mContentInsets.scale(mInvGlobalScale);</span><br><span class="line">        mVisibleInsets.scale(mInvGlobalScale);</span><br><span class="line">        mStableInsets.scale(mInvGlobalScale);</span><br><span class="line">        mOutsets.scale(mInvGlobalScale);</span><br><span class="line">        mCompatFrame.scale(mInvGlobalScale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个窗口大小保存在WindowState类的成员变量mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中</p>
<h3 id="2-2-13、PhoneWindowManager-finishLayoutLw"><a href="#2-2-13、PhoneWindowManager-finishLayoutLw" class="headerlink" title="2.2.13、PhoneWindowManager.finishLayoutLw()"></a>2.2.13、PhoneWindowManager.finishLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishLayoutLw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（三）、Window-Z-Order-计算和调整过程"><a href="#（三）、Window-Z-Order-计算和调整过程" class="headerlink" title="（三）、Window Z-Order 计算和调整过程"></a>（三）、Window Z-Order 计算和调整过程</h2><p>口的UI最终是需要通过SurfaceFlinger服务来统一渲染的，而SurfaceFlinger服务在渲染窗口的UI之前，需要计算基于各个窗口的Z轴位置来计算它们的可见区域。因此，WindowManagerService服务计算好每一个窗口的Z轴位置之后，还需要将它们设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以正确地渲染每一个窗口的UI。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/12-Android-WMS-Z-Order.png" alt="Markdown"></p>
<h3 id="3-1、需要重新计算窗口Z轴位置的情景"><a href="#3-1、需要重新计算窗口Z轴位置的情景" class="headerlink" title="3.1、需要重新计算窗口Z轴位置的情景"></a>3.1、需要重新计算窗口Z轴位置的情景</h3><p>在【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】中已经详细介绍Window添加过程，这里直接从 WMS.addWindow开始分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">            win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">            mInputMethodWindow = win;</span><br><span class="line">            addInputMethodWindowToListLocked(win);</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">            mInputMethodDialogs.add(win);</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//重新计算系统中所有窗口的Z轴位置</span></span><br><span class="line">        mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WMS.relayoutWindow()也会调用WindowLayersController.assignLayersLocked()重新计算、调整系统中所有窗口的Z轴位置，由于原理类似这里不做解释。</p>
<h3 id="3-2、计算系统中所有窗口的Z轴位置"><a href="#3-2、计算系统中所有窗口的Z轴位置" class="headerlink" title="3.2、计算系统中所有窗口的Z轴位置"></a>3.2、计算系统中所有窗口的Z轴位置</h3><p>接下来我们就通过WindowState类的构造函数来分析一个窗口的BaseLayer值是如何确定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">       WindowState attachedWindow, <span class="keyword">int</span> appOp, <span class="keyword">int</span> seq, WindowManager.LayoutParams a,</span><br><span class="line">       <span class="keyword">int</span> viewVisibility, <span class="keyword">final</span> DisplayContent displayContent) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">            mAttrs.type &lt;= LAST_SUB_WINDOW)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//windowTypeToLayerLw的返回值并且不是一个窗口的最终的BaseLayer值，而是要将它的返回值乘以一个常量TYPE_LAYER_MULTIPLIER，再加上另外一个常量TYPE_LAYER_OFFSET之后，才得到最终的BaseLayer值</span></span><br><span class="line">        mBaseLayer = mPolicy.windowTypeToLayerLw(</span><br><span class="line">                attachedWindow.mAttrs.type) * WindowManagerService.TYPE_LAYER_MULTIPLIER</span><br><span class="line">                + WindowManagerService.TYPE_LAYER_OFFSET;</span><br><span class="line">        mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个窗口除了有一个BaseLayer值之外，还有一个SubLayer值，分别保存在一个对应的WindowState对象的成员变量mBaseLayer和mSubLayer。SubLayer值是用来描述一个窗口是否是另外一个窗口的子窗口的。 在继续分析WindowLayersController.assignLayersLocked()之前，我们首先分析PhoneWindowManager.windowTypeToLayerLw()和subWindowTypeToLayerLw()的实现，以便可以了解一个窗口的BaseLayer值和SubLayer值是如何确定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">windowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_TOAST:</span><br><span class="line">        <span class="comment">// toasts and the plugged-in battery thing</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_ALERT:</span><br><span class="line">        <span class="comment">// like the ANR / app crashed dialogs</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_KEYGUARD_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR:</span><br><span class="line">        <span class="comment">// the navigation bar, if available, shows atop most things</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR_PANEL:</span><br><span class="line">        <span class="comment">// some panels (e.g. search) need to show on top of the navigation bar</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subWindowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_PANEL:</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ATTACHED_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_PANEL_SUBLAYER;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ABOVE_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要根据不同的Window Type返回不一样的数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_MULTIPLIER = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_OFFSET = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以用adb shell dumpsys window -a 命令查看一下Layer的数值，可以看到StatusBar的数值计算： mBaseLayer = 16 <em>WindowManagerService.TYPE_LAYER_MULTIPLIER+ WindowManagerService.TYPE_LAYER_OFFSET StatusBar.mBaseLayer = 16</em> 10000 + 1000 = 161000 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window #4 Window&#123;3c1f1fb u0 StatusBar&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">161000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">161000</span>+<span class="number">0</span>=<span class="number">161000</span> mLastLayer=<span class="number">161000</span></span><br><span class="line">Window #3 Window&#123;fe4aae2 u0 KeyguardScrim&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">141000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">141000</span>+<span class="number">0</span>=<span class="number">141000</span> mLastLayer=<span class="number">141000</span></span><br><span class="line">Window #2 Window&#123;173ee76 u0 DockedStackDivider&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21010</span>+<span class="number">0</span>=<span class="number">21010</span> mLastLayer=<span class="number">0</span></span><br><span class="line">Window #1 Window&#123;3a83a4a u0 com.android.launcher&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21005</span>+<span class="number">0</span>=<span class="number">21005</span> mLastLayer=<span class="number">21005</span></span><br><span class="line">Window #0 Window&#123;aefb7bc u0 com.android.systemui.ImageWallpaper&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21000</span>+<span class="number">0</span>=<span class="number">21000</span> mLastLayer=<span class="number">21000</span></span><br></pre></td></tr></table></figure>

<p>理解了窗口的BaseLayer值和SubLayer值的计算过程之外，接下来我们就可以分析WindowManagerService类的成员函数assignLayersLocked()的实现了</p>
<h3 id="3-2-1、WindowLayersController-assignLayersLocked"><a href="#3-2-1、WindowLayersController-assignLayersLocked" class="headerlink" title="3.2.1、WindowLayersController.assignLayersLocked()"></a>3.2.1、WindowLayersController.assignLayersLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">assignLayersLocked</span><span class="params">(WindowList windows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LAYERS) Slog.v(TAG_WM, <span class="string">&quot;Assigning layers based on windows=&quot;</span> + windows,</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">&quot;here&quot;</span>).fillInStackTrace());</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">int</span> curBaseLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> anyLayerChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, windowCount = windows.size(); i &lt; windowCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState w = windows.get(i);</span><br><span class="line">        <span class="keyword">boolean</span> layerChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldLayer = w.mLayer;</span><br><span class="line">        <span class="keyword">if</span> (w.mBaseLayer == curBaseLayer || w.mIsImWindow || (i &gt; <span class="number">0</span> &amp;&amp; w.mIsWallpaper)) &#123;</span><br><span class="line">            curLayer += WINDOW_LAYER_MULTIPLIER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curBaseLayer = curLayer = w.mBaseLayer;</span><br><span class="line">        &#125;</span><br><span class="line">        assignAnimLayer(w, curLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Preserved old behavior of code here but not sure comparing</span></span><br><span class="line">        <span class="comment">// oldLayer to mAnimLayer and mLayer makes sense...though the</span></span><br><span class="line">        <span class="comment">// worst case would be unintentionalp layer reassignment.</span></span><br><span class="line">        <span class="keyword">if</span> (w.mLayer != oldLayer || w.mWinAnimator.mAnimLayer != oldLayer) &#123;</span><br><span class="line">            layerChanged = <span class="keyword">true</span>;</span><br><span class="line">            anyLayerChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHighestApplicationLayer = Math.max(mHighestApplicationLayer,</span><br><span class="line">                    w.mWinAnimator.mAnimLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        collectSpecialWindows(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layerChanged) &#123;</span><br><span class="line">            w.scheduleAnimationIfDimming();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adjustSpecialWindows();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 assignAnimLayer() 进行Layer调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignAnimLayer</span><span class="params">(WindowState w, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">        w.mLayer = layer;</span><br><span class="line">        w.mWinAnimator.mAnimLayer = w.mLayer + w.getAnimLayerAdjustment() +</span><br><span class="line">                    getSpecialWindowAnimLayerAdjustment(w);</span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span> &amp;&amp; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; w.mWinAnimator.mAnimLayer &gt; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer) &#123;</span><br><span class="line">            w.mAppToken.mAppAnimator.thumbnailForceAboveLayer = w.mWinAnimator.mAnimLayer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去"><a href="#3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去" class="headerlink" title="3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去"></a>3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去</h3><p>WindowManagerService服务在刷新系统的UI的时候，就会将系统中已经计算好了的窗口Z轴位置设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以对系统中的窗口进行可见性计算以及合成和渲染等操作 首先看一下堆栈信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WindowSurfaceController.showSurface()添加打印Log</span><br><span class="line">Slog.i(<span class="string">&quot;charlesvincent&quot;</span>, <span class="string">&quot;charlesvincent&quot;</span>,<span class="keyword">new</span> RuntimeException(<span class="string">&quot;here&quot;</span>).fillInStackTrace());</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>): charlesvincent</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>): java.lang.RuntimeException: here</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showSurface(WindowSurfaceController.java:<span class="number">414</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.updateVisibility(WindowSurfaceController.java:<span class="number">402</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showRobustlyInTransaction(WindowSurfaceController.java:<span class="number">391</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.showSurfaceRobustlyLocked(WindowStateAnimator.java:<span class="number">1814</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.prepareSurfaceLocked(WindowStateAnimator.java:<span class="number">1609</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:<span class="number">791</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.-wrap0(WindowAnimator.java)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator$<span class="number">1.d</span>oFrame(WindowAnimator.java:<span class="number">166</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:<span class="number">879</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.view.Choreographer.doCallbacks(Choreographer.java:<span class="number">693</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.view.Choreographer.doFrame(Choreographer.java:<span class="number">625</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:<span class="number">867</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.os.Handler.handleCallback(Handler.java:<span class="number">751</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.os.Handler.dispatchMessage(Handler.java:<span class="number">95</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.os.Looper.loop(Looper.java:<span class="number">154</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at android.os.HandlerThread.run(HandlerThread.java:<span class="number">61</span>)</span><br><span class="line"><span class="number">03</span>-<span class="number">01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/charlesvincent(<span class="number">1424</span>):     at com.android.server.ServiceThread.run(ServiceThread.java:<span class="number">46</span>)</span><br></pre></td></tr></table></figure>

<p>为了了解WMS是如何将Z轴位置设置到SurfaceFlinger服务中去，首先看一下WMS构造方法中关键对象WindowAnimator的创建</p>
<h3 id="3-3-1、Vsync刷新UI回调过程"><a href="#3-3-1、Vsync刷新UI回调过程" class="headerlink" title="3.3.1、Vsync刷新UI回调过程"></a>3.3.1、Vsync刷新UI回调过程</h3><p>开机启动时会初始化WMS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用WindowAnimator构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">WindowAnimator(<span class="keyword">final</span> WindowManagerService service) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mContext = service.mContext;</span><br><span class="line">    mPolicy = service.mPolicy;</span><br><span class="line">    mWindowPlacerLocked = service.mWindowPlacerLocked;</span><br><span class="line"></span><br><span class="line">    mAnimationFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mWindowMap) &#123;</span><br><span class="line">                mService.mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">                animateLocked(frameTimeNs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到创建了Choreographer.FrameCallback()，前面在【Android-7-1-2-Android-N-Activity-Window加载显示流程】分析过，FrameDisplayEventReceiver（在Choreographer构造方法中初始化）对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run()方法，再回调函数中执行doFrame()实现屏幕刷新，doFrame()会顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调，从而会执行CallbackRecord.run()，在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Choreographer.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此种情况下会执行FrameCallback对象的doFrame()函数（原因稍后再分析动画时详细分析），由WindowAnimator构造函数中可知接着就会执行WindowAnimator.animateLocked()</p>
<h3 id="3-3-2、准备刷新UI"><a href="#3-3-2、准备刷新UI" class="headerlink" title="3.3.2、准备刷新UI"></a>3.3.2、准备刷新UI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">&quot;&gt;&gt;&gt; OPEN TRANSACTION animateLocked&quot;</span>);</span><br><span class="line">        SurfaceControl.openTransaction();</span><br><span class="line">        SurfaceControl.setAnimationTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">                updateAppWindowsLocked(displayId);</span><br><span class="line">                DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line">                ......</span><br><span class="line">                updateWindowsLocked(displayId);</span><br><span class="line">                updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">                <span class="comment">//通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            SurfaceControl.closeTransaction();</span><br><span class="line">            <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                    TAG, <span class="string">&quot;&lt;&lt;&lt; CLOSE TRANSACTION animateLocked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取windows列表，然后循环调用windows.get(j).mWinAnimator.prepareSurfaceLocked(true)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareSurfaceLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowState w = mWin;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> displayed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">    computeShownFrameLocked();</span><br><span class="line"></span><br><span class="line">    setSurfaceBoundariesLocked(recoveringMemory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWallpaper &amp;&amp; !mWin.mWallpaperVisible) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.mAttachedHidden || !w.isOnScreen()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLastLayer != mAnimLayer</span><br><span class="line">            || mLastAlpha != mShownAlpha</span><br><span class="line">            || mLastDsDx != mDsDx</span><br><span class="line">            || mLastDtDx != mDtDx</span><br><span class="line">            || mLastDsDy != mDsDy</span><br><span class="line">            || mLastDtDy != mDtDy</span><br><span class="line">            || w.mLastHScale != w.mHScale</span><br><span class="line">            || w.mLastVScale != w.mVScale</span><br><span class="line">            || mLastHidden) &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">        mLastAlpha = mShownAlpha;</span><br><span class="line">        mLastLayer = mAnimLayer;</span><br><span class="line">        mLastDsDx = mDsDx;</span><br><span class="line">        mLastDtDx = mDtDx;</span><br><span class="line">        mLastDsDy = mDsDy;</span><br><span class="line">        mLastDtDy = mDtDy;</span><br><span class="line">        w.mLastHScale = w.mHScale;</span><br><span class="line">        w.mLastVScale = w.mVScale;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> prepared =</span><br><span class="line">            mSurfaceController.prepareToShowInTransaction(mShownAlpha, mAnimLayer,</span><br><span class="line">                    mDsDx * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDx * w.mVScale * mExtraVScale,</span><br><span class="line">                    mDsDy * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDy * w.mVScale * mExtraVScale,</span><br><span class="line">                    recoveringMemory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (showSurfaceRobustlyLocked()) &#123;</span><br><span class="line">                markPreservedSurfaceForDestroy();</span><br><span class="line">                mAnimator.requestRemovalOfReplacedWindows(w);</span><br><span class="line">                mLastHidden = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mIsWallpaper) &#123;</span><br><span class="line">                    mWallpaperControllerLocked.dispatchWallpaperVisibility(w, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                mAnimator.setPendingLayoutChanges(w.getDisplayId(),</span><br><span class="line">                        WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w.mOrientationChanging = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasSurface()) &#123;</span><br><span class="line">            w.mToken.hasVisible = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用prepareToShowInTransaction()将alph、alayer、setMatrix设置到mSurfaceControl中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">prepareToShowInTransaction</span><span class="params">(<span class="keyword">float</span> alpha, <span class="keyword">int</span> layer, <span class="keyword">float</span> dsdx, <span class="keyword">float</span> dtdx, <span class="keyword">float</span> dsdy,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">float</span> dtdy, <span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mSurfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mSurfaceAlpha = alpha;</span><br><span class="line">               mSurfaceControl.setAlpha(alpha);</span><br><span class="line">               mSurfaceLayer = layer;</span><br><span class="line">               mSurfaceControl.setLayer(layer);</span><br><span class="line">               mSurfaceControl.setMatrix(</span><br><span class="line">                       dsdx, dtdx, dsdy, dtdy);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">               .......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>setSurfaceBoundariesLocked()方法中会调用SurfaceControl.setPosition()等等方法将计算好的数值设置到mSurfaceControl中。 说明：一个窗口的显示和隐藏，以及大小、X轴和Y轴位置、Z轴位置、Alpha通道和变换矩阵设置，是通过调用Java层的SurfaceControl类的成员函数show、hide、setSize、setPosition、setLayer、setAlpha和setMatrix来实现的，它们最终都是通过调用JNI方法实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl.java</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">float</span> alpha)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetAlpha(mNativeObject, alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMatrix</span><span class="params">(<span class="keyword">float</span> dsdx, <span class="keyword">float</span> dtdx, <span class="keyword">float</span> dsdy, <span class="keyword">float</span> dtdy)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetMatrix(mNativeObject, dsdx, dtdx, dsdy, dtdy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinalCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3、告知SurfaceFlinger显示UI"><a href="#3-3-3、告知SurfaceFlinger显示UI" class="headerlink" title="3.3.3、告知SurfaceFlinger显示UI"></a>3.3.3、告知SurfaceFlinger显示UI</h3><p>如果WindowState对象w所描述的窗口满足条件：prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN 那么就说明现在是时候要将WindowState对象w所描述的窗口显示出来了，通过调用showSurfaceRobustlyLocked实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurfaceRobustlyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Task task = mWin.getTask();</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; StackId.windowsAreScaleable(task.mStack.mStackId)) &#123;</span><br><span class="line">        mSurfaceController.forceScaleableInTransaction(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> shown = mSurfaceController.showRobustlyInTransaction();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mWin.mTurnOnScreen) &#123;</span><br><span class="line">        ......</span><br><span class="line">        mWin.mTurnOnScreen = <span class="keyword">false</span>;</span><br><span class="line">        mAnimator.mBulkUpdateParams |= SET_TURN_ON_SCREEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用WindowSurfaceController.showRobustlyInTransaction() –&gt; updateVisibility()–&gt;showSurface()-&gt;SurfaceControl.show()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfaceController.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">showRobustlyInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mHiddenForOtherReasons = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> updateVisibility();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHiddenForCrop || mHiddenForOtherReasons) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSurfaceShown) &#123;hideSurface();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSurfaceShown) &#123;<span class="keyword">return</span> showSurface();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSurfaceShown = <span class="keyword">true</span>;</span><br><span class="line">            mSurfaceControl.show();</span><br><span class="line">             Slog.i(<span class="string">&quot;charlesvincent&quot;</span>, <span class="string">&quot;charlesvincent&quot;</span>,<span class="keyword">new</span> RuntimeException(<span class="string">&quot;here&quot;</span>).fillInStackTrace());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现异常,回收系统内存资源</span></span><br><span class="line">        mAnimator.reclaimSomeSurfaceMemory(<span class="string">&quot;show&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetFlags(mNativeObject, <span class="number">0</span>, SURFACE_HIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过JNI调用android_view_SurfaceControl.cpp的nativeSetFlags函数，可以看到flags == 0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;android_view_SurfaceControl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFlags</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jint flags, jint mask)</span> </span>&#123;</span><br><span class="line">    SurfaceControl* <span class="keyword">const</span> ctrl = <span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    <span class="keyword">status_t</span> err = ctrl-&gt;setFlags(flags, mask);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; err != NO_INIT) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用SurfaceControl.cpp的setFlags()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceControl::setFlags</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">uint32_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = validate();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> mClient-&gt;setFlags(mHandle, flags, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步通过Binder IPC机制，SurfaceComposerClient.cpp-&gt;Composer::setFlags()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceComposerClient.cpp]</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Composer::setFlags</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> mask)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">layer_state_t</span>* s = getLayerStateLocked(client, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; <span class="keyword">layer_state_t</span>::eLayerOpaque) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerHidden) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerSecure)) &#123;</span><br><span class="line">        s-&gt;what |= <span class="keyword">layer_state_t</span>::eFlagsChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;flags &amp;= ~mask;</span><br><span class="line">    s-&gt;flags |= (flags &amp; mask);</span><br><span class="line">    s-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体数值就不详细计算了，前面分析【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】可知，SurfaceFlinger接收Vsync信号与App有一个offset间隔时间，当SurfaceFlinger接收Vsync信号时，就可以根据flags是否显示 和 上面设置的一系列数值进行渲染合成，最终显示到屏幕上。</p>
<h2 id="（四）、Activity启动窗口-Starting-Window-添加过程"><a href="#（四）、Activity启动窗口-Starting-Window-添加过程" class="headerlink" title="（四）、Activity启动窗口(Starting Window)添加过程"></a>（四）、Activity启动窗口(Starting Window)添加过程</h2><h3 id="4-1、Activity组件的启动窗口-Starting-Window-的添加过程"><a href="#4-1、Activity组件的启动窗口-Starting-Window-的添加过程" class="headerlink" title="4.1、Activity组件的启动窗口(Starting Window)的添加过程"></a>4.1、Activity组件的启动窗口(Starting Window)的添加过程</h3><p>时序图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/13-Android-WMS-Starting-Window-addview.png" alt="Markdown"></p>
<h3 id="4-1-1、-ActivityStack-startActivityLocked"><a href="#4-1-1、-ActivityStack-startActivityLocked" class="headerlink" title="4.1.1、 ActivityStack.startActivityLocked()"></a>4.1.1、 ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">                    <span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != <span class="number">0</span>) &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.add(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(newTask</span><br><span class="line">                        ? r.mLaunchTaskBehind</span><br><span class="line">                                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                : TRANSIT_TASK_OPEN</span><br><span class="line">                        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.remove(r);</span><br><span class="line">            &#125;</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            <span class="keyword">boolean</span> doShow = <span class="keyword">true</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">                .......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">                ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked();</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We don&#x27;t want to reuse the previous starting preview if:</span></span><br><span class="line">                    <span class="comment">// (1) The current activity is in a different task.</span></span><br><span class="line">                    <span class="keyword">if</span> (prev.task != r.task) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// (2) The current activity is already displayed.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (prev.nowVisible) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.showStartingWindow(prev, showStartingIcon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到直接调用ActivityRecord.showStartingWindow()进一步添加启动窗口</p>
<h3 id="4-1-2、-ActivityRecord-showStartingWindow"><a href="#4-1-2、-ActivityRecord-showStartingWindow" class="headerlink" title="4.1.2、 ActivityRecord.showStartingWindow()"></a>4.1.2、 ActivityRecord.showStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">            service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shown = service.mWindowManager.setAppStartingWindow(</span><br><span class="line">            appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon,</span><br><span class="line">            logo, windowFlags, prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, createIfNeeded);</span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2、ActivityRecord-setAppStartingWindow"><a href="#4-1-2、ActivityRecord-setAppStartingWindow" class="headerlink" title="4.1.2、ActivityRecord.setAppStartingWindow()"></a>4.1.2、ActivityRecord.setAppStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setAppStartingWindow</span><span class="params">(IBinder token, String pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> windowFlags, IBinder transferFrom, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">  <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">   AppWindowToken wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (transferStartingWindow(transferFrom, wtoken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        wtoken.startingData = <span class="keyword">new</span> StartingData(pkg, theme, compatInfo, nonLocalizedLabel,</span><br><span class="line">                labelRes, icon, logo, windowFlags);</span><br><span class="line">        Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);</span><br><span class="line">        mH.sendMessageAtFrontOfQueue(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果参数transferFrom所描述的Activity组件没有启动窗口或者启动窗口数据转移给参数token所描述的Activity组件，那么接下来就可能需要为参数token所描述的Activity组件创建一个新的启动窗口</p>
<h3 id="4-1-3、-H-handleMessage"><a href="#4-1-3、-H-handleMessage" class="headerlink" title="4.1.3、 H.handleMessage()"></a>4.1.3、 H.handleMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java::H]</span><br><span class="line"><span class="keyword">case</span> ADD_STARTING: &#123;</span><br><span class="line">    <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</span><br><span class="line">    <span class="keyword">final</span> StartingData sd = wtoken.startingData;</span><br><span class="line">    ......</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration overrideConfig = wtoken != <span class="keyword">null</span> &amp;&amp; wtoken.mTask != <span class="keyword">null</span></span><br><span class="line">                ? wtoken.mTask.mOverrideConfig : <span class="keyword">null</span>;</span><br><span class="line">        view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme,</span><br><span class="line">            sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo,</span><br><span class="line">            sd.windowFlags, overrideConfig);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> abort = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wtoken.removed || wtoken.startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    wtoken.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">                    wtoken.startingData = <span class="keyword">null</span>;</span><br><span class="line">                    abort = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wtoken.startingView = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mPolicy.removeStartingWindow(wtoken.token, view);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>PhoneWindowManager实现WindowManagerPolicy，所以会调用PhoneWindowManager中的方法 继续分析PhoneWindowManager.addStartingWindow()</p>
<h3 id="4-1-4、PhoneWindowManager-addStartingWindow"><a href="#4-1-4、PhoneWindowManager-addStartingWindow" class="headerlink" title="4.1.4、PhoneWindowManager.addStartingWindow()"></a>4.1.4、PhoneWindowManager.addStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">addStartingWindow</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Context context = mContext;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">        win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line">        ......</span><br><span class="line">        win.setType(</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line">        ......</span><br><span class="line">        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = win.getAttributes();</span><br><span class="line">        params.token = appToken;</span><br><span class="line">        params.packageName = packageName;</span><br><span class="line">        params.windowAnimations = win.getWindowStyle().getResourceId(</span><br><span class="line">                com.android.internal.R.styleable.Window_windowAnimationStyle, <span class="number">0</span>);</span><br><span class="line">        ......</span><br><span class="line">        params.setTitle(<span class="string">&quot;Starting &quot;</span> + packageName);</span><br><span class="line">        wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        view = win.getDecorView();</span><br><span class="line">       ......</span><br><span class="line">        wm.addView(view, params);</span><br><span class="line">        <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm.removeViewImmediate(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建PhoneWindow对象，接下来继续设置所创建的窗口win的以下属性： 1、窗口类型：设置为WindowManager.LayoutParams.TYPE_APPLICATION_STARTING，即设置为启动窗口类型；</p>
<p>2、窗口标题：由参数labelRes、nonLocalizedLabel，以及窗口的运行上下文context来确定；</p>
<p>3、窗口标志：分别将indowManager.LayoutParams.FLAG_NOT_TOUCHABLE、WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE和WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位设置为1，即不可接受触摸事件和不可获得焦点，但是可以接受输入法窗口；</p>
<p>4、窗口大小：设置为WindowManager.LayoutParams.MATCH_PARENT，即与父窗口一样大，但是由于这是一个顶层窗口，因此实际上是指与屏幕一样大；</p>
<p>5、布局参数：包括窗口所对应的窗口令牌（token）和包名（packageName），以及窗口所使用的动画类型（windowAnimations）和标题（title）。</p>
<p>wm.addView(view, params)，一个新创建的Activity组件的启动窗口就增加到WindowManagerService服务中去了，这样，WindowManagerService服务就可以下次刷新系统UI时，将该启动窗口显示出来</p>
<h2 id="（五）、WMS切换Activity窗口（App-Transition）过程"><a href="#（五）、WMS切换Activity窗口（App-Transition）过程" class="headerlink" title="（五）、WMS切换Activity窗口（App Transition）过程"></a>（五）、WMS切换Activity窗口（App Transition）过程</h2><p>WindowManagerService服务在执行Activity窗口的切换操作的时候，会给参与切换操作的Activity组件的设置一个动画，以便可以向用户展现一个Activity组件切换效果，从而提高用户体验。 首先看一下App Transition动态图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/14-Android-WMS-ezgif.com-video-to-gif-WMS-App-Transition.gif" alt="Markdown"></p>
<p>时序图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/15-Android-WMS-executeAppTransition.png" alt="Markdown"></p>
<p>我们直接分析App Transition过程的prepareAppTransition、executeAppTransition 关于Activity启动过程请参考：【Android-7-1-2-Android-N-Activity启动流程分析】</p>
<h3 id="5-1、prepareAppTransition-过程"><a href="#5-1、prepareAppTransition-过程" class="headerlink" title="5.1、prepareAppTransition()过程"></a>5.1、prepareAppTransition()过程</h3><h3 id="5-1-1、ActivityStack-startActivityLocked"><a href="#5-1-1、ActivityStack-startActivityLocked" class="headerlink" title="5.1.1、ActivityStack.startActivityLocked()"></a>5.1.1、ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">......</span><br><span class="line">mWindowManager.prepareAppTransition(newTask</span><br><span class="line">        ? r.mLaunchTaskBehind</span><br><span class="line">                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                : TRANSIT_TASK_OPEN</span><br><span class="line">        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2、WindowManagerService-prepareAppTransition"><a href="#5-1-2、WindowManagerService-prepareAppTransition" class="headerlink" title="5.1.2、WindowManagerService.prepareAppTransition()"></a>5.1.2、WindowManagerService.prepareAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareAppTransition</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> alwaysKeepCurrent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> prepared = mAppTransition.prepareAppTransitionLocked(</span><br><span class="line">                transit, alwaysKeepCurrent);</span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; okToDisplay()) &#123;</span><br><span class="line">            mSkipAppTransitionAnimation = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现是直接调用AppTransition.prepareAppTransitionLocked()实现的。</p>
<h3 id="5-1-3、AppTransition-prepareAppTransitionLocked"><a href="#5-1-3、AppTransition-prepareAppTransitionLocked" class="headerlink" title="5.1.3、AppTransition.prepareAppTransitionLocked()"></a>5.1.3、AppTransition.prepareAppTransitionLocked()</h3><p>进一步调用setAppTransition()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAppTransition</span><span class="params">(<span class="keyword">int</span> transit)</span> </span>&#123;</span><br><span class="line">    mNextAppTransition = transit;</span><br><span class="line">    setLastAppTransition(TRANSIT_UNSET, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现只是将transit（即AppTransition动画类型）赋值给变量mNextAppTransition</p>
<h3 id="5-2、AppTransition-animation设置过程"><a href="#5-2、AppTransition-animation设置过程" class="headerlink" title="5.2、AppTransition animation设置过程"></a>5.2、AppTransition animation设置过程</h3><p>继续分析ActivityStackSupervisor.realStartActivityLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会通知WindowManagerService服务将参数r.appToken所描述的Activity组件的可见性设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppVisibility</span><span class="params">(IBinder token, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    AppWindowToken wtoken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        mOpeningApps.remove(wtoken);</span><br><span class="line">        mClosingApps.remove(wtoken);</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            wtoken.inPendingTransaction = <span class="keyword">false</span>;</span><br><span class="line">            setTokenVisibilityLocked(wtoken, <span class="keyword">null</span>, visible, AppTransition.TRANSIT_UNSET,</span><br><span class="line">                    <span class="keyword">true</span>, wtoken.voiceInteraction);</span><br><span class="line">            wtoken.updateReportedVisibilityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用WindowManagerService.setTokenVisibilityLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setTokenVisibilityLocked</span><span class="params">(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> visible, <span class="keyword">int</span> transit, <span class="keyword">boolean</span> performLayout, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用WindowManagerService.applyAnimationLocked()设置AppTransition动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(AppWindowToken atoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> transit, <span class="keyword">boolean</span> enter, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (okToDisplay()) &#123;</span><br><span class="line">        Animation a = mAppTransition.loadAnimation(lp, transit, enter, mCurConfiguration.uiMode,</span><br><span class="line">        mCurConfiguration.orientation, frame, displayFrame, insets, surfaceInsets,</span><br><span class="line">        isVoiceInteraction, freeform, atoken.mTask.mTaskId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于到了AppTransition真正设置过程了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppTransition.java]</span><br><span class="line"><span class="function">Animation <span class="title">loadAnimation</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> transit, <span class="keyword">boolean</span> enter, <span class="keyword">int</span> uiMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> orientation, Rect frame, Rect displayFrame, Rect insets,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> Rect surfaceInsets, <span class="keyword">boolean</span> isVoiceInteraction, <span class="keyword">boolean</span> freeform,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> taskId)</span> </span>&#123;</span><br><span class="line">        Animation a;</span><br><span class="line">      <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line">      ......</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> animAttr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (transit) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_ACTIVITY_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityOpenExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_ACTIVITY_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityCloseExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_DOCK_TASK_FROM_RECENTS:</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_TASK_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskOpenExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_TASK_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskCloseExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_TASK_TO_FRONT:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToFrontEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToFrontExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSIT_TASK_TO_BACK:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToBackEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToBackExitAnimation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        a = animAttr != <span class="number">0</span> ? loadAnimationAttr(lp, animAttr) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过<strong>loadAnimationAttr</strong>加载xml文件加载动画，动画xml文件的存放路径（/frameworks/base/core/res/res/anim/）<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/16-Android-WMS-executeAppTransition-xml.png" alt="Markdown"></p>
<h3 id="5-3、executeAppTransition过程"><a href="#5-3、executeAppTransition过程" class="headerlink" title="5.3、executeAppTransition过程"></a>5.3、executeAppTransition过程</h3><blockquote>
<p>ActivityStackSupervisor.realStartActivityLocked()</p>
</blockquote>
<blockquote>
<blockquote>
<p>ActivityStack.minimalResumeActivityLocked() ActivityStack.completeResumeLocked() ActivityStackSupervisor.reportResumedActivityLocked()</p>
</blockquote>
</blockquote>
<p>继续分析ActivityStackSupervisor.reportResumedActivityLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">reportResumedActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">        mWindowManager.executeAppTransition();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是Activity组件的可见性设置，然后执行executeAppTransition()</p>
<h3 id="5-3-1-WindowManagerService-executeAppTransition"><a href="#5-3-1-WindowManagerService-executeAppTransition" class="headerlink" title="5.3.1.WindowManagerService.executeAppTransition()"></a>5.3.1.WindowManagerService.executeAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAppTransition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAppTransition.isTransitionSet()) &#123;</span><br><span class="line">                mAppTransition.setReady();</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而WindowSurfacePlacer.performSurfacePlacement()请看前面第二节分析</p>
<h2 id="（六）、Activity-Window-动画显示过程"><a href="#（六）、Activity-Window-动画显示过程" class="headerlink" title="（六）、Activity Window 动画显示过程"></a>（六）、Activity Window 动画显示过程</h2><h3 id="6-1、动画的设置过程"><a href="#6-1、动画的设置过程" class="headerlink" title="6.1、动画的设置过程"></a>6.1、动画的设置过程</h3><p>在Android系统中，窗口动画的本质就是对原始窗口施加一个变换（Transformation）。在线性数学中，对物体的形状进行变换是通过乘以一个矩阵（Matrix）来实现，目的就是对物体进行偏移、旋转、缩放、切变、反射和投影等。因此，给窗口设置动画实际上就给窗口设置一个变换矩阵（Transformation Matrix）。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/17-Android-WMS-Transformation-matrix.png" alt="Markdown"></p>
<p>窗口被设置的动画虽然可以达到三个，但是这三个动画可以归结为两类，一类是普通动画，例如，窗口在打开过程中被设置的进入动画和在关闭过程中被设置的退出动画，另一类是切换动画。其中，Self Transformation和Attached Transformation都是属于普通动画，而App Transformation属于切换动画。前面已经分析过App Transformation的设置过程 接下来分析普通动画的设置过程。</p>
<h3 id="6-1、普通动画的设置过程"><a href="#6-1、普通动画的设置过程" class="headerlink" title="6.1、普通动画的设置过程"></a>6.1、普通动画的设置过程</h3><p>普通动画的设置过程也是通过setTokenVisibilityLocked()设置的</p>
<h3 id="6-1-1、WindowManagerService-setTokenVisibilityLocked"><a href="#6-1-1、WindowManagerService-setTokenVisibilityLocked" class="headerlink" title="6.1.1、WindowManagerService.setTokenVisibilityLocked()"></a>6.1.1、WindowManagerService.setTokenVisibilityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setTokenVisibilityLocked</span><span class="params">(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> visible, <span class="keyword">int</span> transit, <span class="keyword">boolean</span> performLayout, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> windowsCount = wtoken.allAppWindows.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; windowsCount; i++) &#123;</span><br><span class="line">                WindowState win = wtoken.allAppWindows.get(i);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (visible) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!win.isVisibleNow()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!runningAppAnimation) &#123;</span><br><span class="line">                            win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                    WindowManagerPolicy.TRANSIT_ENTER, <span class="keyword">true</span>);</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                        changed = <span class="keyword">true</span>;</span><br><span class="line">                        win.setDisplayLayoutNeeded();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (win.isVisibleNow()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!runningAppAnimation) &#123;</span><br><span class="line">                        win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                WindowManagerPolicy.TRANSIT_EXIT, <span class="keyword">false</span>);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                    win.setDisplayLayoutNeeded();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wtoken.hidden = wtoken.hiddenRequested = !visible;</span><br><span class="line">            visibilityChanged = <span class="keyword">true</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">                <span class="keyword">if</span> (performLayout) &#123;</span><br><span class="line">                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125;</span><br><span class="line">                mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到普通动画是通过win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER, true)</p>
<h3 id="6-1-1-WindowStateAnimator-applyAnimationLocked"><a href="#6-1-1-WindowStateAnimator-applyAnimationLocked" class="headerlink" title="6.1.1.WindowStateAnimator.applyAnimationLocked()"></a>6.1.1.WindowStateAnimator.applyAnimationLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> isEntrance)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">        <span class="keyword">int</span> anim = mPolicy.selectAnimationLw(mWin, transit);</span><br><span class="line">        <span class="keyword">int</span> attr = -<span class="number">1</span>;</span><br><span class="line">        Animation a = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (anim != <span class="number">0</span>) &#123;</span><br><span class="line">            a = anim != -<span class="number">1</span> ? AnimationUtils.loadAnimation(mContext, anim) : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (transit) &#123;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_ENTER:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_EXIT:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_SHOW:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_HIDE:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (attr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setAnimation(a);</span><br><span class="line">            mAnimationIsEntrance = isEntrance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mAnimation != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到也是根据动画类型从而通过AppTransition.loadAnimationAttr(mWin.mAttrs, attr)加载不同的anim xml文件。</p>
<h3 id="6-2、窗口动画的显示框架"><a href="#6-2、窗口动画的显示框架" class="headerlink" title="6.2、窗口动画的显示框架"></a>6.2、窗口动画的显示框架</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/19-Android-WMS-animationLocked.png" alt="Markdown"><br>通过堆栈信息可以看到，由Vsync信号驱动，然后调用Choreographer.doFrame完成动画的相关操作，关于Vsync这部分之前文章已经分析过，这里不再分析了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="comment">/** Locked on mService.mWindowMap. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mCurrentTime = frameTimeNs / TimeUtils.NANOS_PER_MS;</span><br><span class="line">    mBulkUpdateParams = SET_ORIENTATION_CHANGE_COMPLETE;</span><br><span class="line">    <span class="keyword">boolean</span> wasAnimating = mAnimating;</span><br><span class="line">    setAnimating(<span class="keyword">false</span>);</span><br><span class="line">    mAppWindowAnimating = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">            TAG, <span class="string">&quot;&gt;&gt;&gt; OPEN TRANSACTION animateLocked&quot;</span>);</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    SurfaceControl.setAnimationTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">            <span class="comment">//1、Activity组件切换动画的推进过程</span></span><br><span class="line">            updateAppWindowsLocked(displayId);</span><br><span class="line">            DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span> &amp;&amp; screenRotationAnimation.isAnimating()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) &#123;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBulkUpdateParams |= SET_UPDATE_ROTATION;</span><br><span class="line">                    screenRotationAnimation.kill();</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//TODO (multidisplay): Accessibility supported only for the default display.</span></span><br><span class="line">                    <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                        <span class="comment">// We just finished rotation animation which means we did not</span></span><br><span class="line">                        <span class="comment">// anounce the rotation and waited for it to end, announce now.</span></span><br><span class="line">                        mService.mAccessibilityController.onRotationChangedLocked(</span><br><span class="line">                                mService.getDefaultDisplayContentLocked(), mService.mRotation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update animations of all applications, including those</span></span><br><span class="line">            <span class="comment">// associated with exiting/removed apps</span></span><br><span class="line">            <span class="comment">//2、窗口动画的推进过程</span></span><br><span class="line">            updateWindowsLocked(displayId);</span><br><span class="line">            <span class="comment">//壁纸动画的推进过程</span></span><br><span class="line">            updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">            <span class="comment">//3、通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">            <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line"></span><br><span class="line">            testTokenMayBeDrawnLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                screenRotationAnimation.updateSurfacesInTransaction();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).animateDimLayers());</span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).getDockedDividerController()</span><br><span class="line">                    .animate(mCurrentTime));</span><br><span class="line">            <span class="comment">//TODO (multidisplay): Magnification is supported only for the default display.</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                mService.mAccessibilityController.drawMagnifiedRegionBorderIfNeededLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//4、触发下一帧动画逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">            mService.scheduleAnimationLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.mWatermark != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.mWatermark.drawIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">&quot;&lt;&lt;&lt; CLOSE TRANSACTION animateLocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasPendingLayoutChanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mService.mDisplayContents.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pendingChanges = getPendingLayoutChanges(displayContent.getDisplayId());</span><br><span class="line">        <span class="keyword">if</span> ((pendingChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">            mBulkUpdateParams |= SET_WALLPAPER_ACTION_PENDING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingChanges != <span class="number">0</span>) &#123;</span><br><span class="line">            hasPendingLayoutChanges = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doRequest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mBulkUpdateParams != <span class="number">0</span>) &#123;</span><br><span class="line">        doRequest = mWindowPlacerLocked.copyAnimToLayoutParamsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、刷新系统UI</span></span><br><span class="line">    <span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">        mWindowPlacerLocked.requestTraversal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mRemoveReplacedWindows) &#123;</span><br><span class="line">        removeReplacedWindowsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.stopUsingSavedSurfaceLocked();</span><br><span class="line">    mService.destroyPreservedSurfaceLocked();</span><br><span class="line">    mService.mWindowPlacerLocked.destroyPendingSurfaces();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、Activity组件切换动画的推进、 2、窗口动画的推进、壁纸动画推进 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 4、触发下一帧动画逻辑 5、刷新系统UI 其中第3点 prepareSurfaceLocked在3.3.小节已经分析过了、第5点最终会调用mWindowPlacerLocked.performSurfacePlacement来刷新UI，也已经分析过了。 接下来分析Activity组件切换动画、窗口动画的推进过程。</p>
<h3 id="6-3、Activity组件切换动画"><a href="#6-3、Activity组件切换动画" class="headerlink" title="6.3、Activity组件切换动画"></a>6.3、Activity组件切换动画</h3><p>AppWindowAnimator:属于AppWindowToken，它的成员变量mAppAnimator代表了此应用程序所属的AppWindowAnimator WindowStateAnimator:WMS记录了所有窗口的WindowState，其中WindowState.mWinAnimator是一个WindowStateAnimator对象，它和上面AppWindowAnimator一样可以由开发人员定制</p>
<p>WindowAnimator.updateAppWindowsLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAppWindowsLocked</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;TaskStack&gt; stacks = mService.getDisplayContentLocked(displayId).getStacks();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> TaskStack stack = stacks.get(stackNdx);</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Task&gt; tasks = stack.getTasks();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = tasks.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppTokenList tokens = tasks.get(taskNdx).mAppTokens;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> tokenNdx = tokens.size() - <span class="number">1</span>; tokenNdx &gt;= <span class="number">0</span>; --tokenNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowAnimator appAnimator = tokens.get(tokenNdx).mAppAnimator;</span><br><span class="line">                appAnimator.wasAnimating = appAnimator.animating;</span><br><span class="line">                <span class="keyword">if</span> (appAnimator.stepAnimationLocked(mCurrentTime, displayId)) &#123;</span><br><span class="line">                    appAnimator.animating = <span class="keyword">true</span>;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                    mAppWindowAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appAnimator.wasAnimating) &#123;</span><br><span class="line">                    <span class="comment">// stopped animating, do one more pass through the layout</span></span><br><span class="line">                    setAppLayoutChanges(appAnimator,</span><br><span class="line">                            WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER,</span><br><span class="line">                            <span class="string">&quot;appToken &quot;</span> + appAnimator.mAppToken + <span class="string">&quot; done&quot;</span>, displayId);</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用stepAnimationLocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line">    <span class="comment">// This must be called while inside a transaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed)</span><br><span class="line">                    &amp;&amp; animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                    <span class="comment">// animation isn&#x27;t over, step any thumbnail and that&#x27;s</span></span><br><span class="line">                    <span class="comment">// it for now.</span></span><br><span class="line">                    <span class="keyword">if</span> (thumbnail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stepThumbnailAnimation(currentTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            animating = <span class="keyword">true</span>;</span><br><span class="line">            animation = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用stepAnimation()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    transformation.clear();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> animationFrameTime = getAnimationFrameTime(animation, currentTime);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasMoreFrames = animation.getTransformation(animationFrameTime, transformation);</span><br><span class="line">    <span class="keyword">if</span> (!hasMoreFrames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferThumbnailDestruction &amp;&amp; !deferFinalFrameCleanup) &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">true</span>;</span><br><span class="line">            hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mProlongAnimation == PROLONG_ANIMATION_AT_END) &#123;</span><br><span class="line">                hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setNullAnimation();</span><br><span class="line">                clearThumbnail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hasTransformation = hasMoreFrames;</span><br><span class="line">    <span class="keyword">return</span> hasMoreFrames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.将成员变量transformation所描述的变换矩阵的数据清空 2.调用Animation.getTransformation()来计算Activity组件切换动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量transformation</p>
<h3 id="6-4、窗口动画的推进过程"><a href="#6-4、窗口动画的推进过程" class="headerlink" title="6.4、窗口动画的推进过程"></a>6.4、窗口动画的推进过程</h3><p>继续分析WindowAnimator.animateLocked()的updateWindowsLocked()</p>
<h3 id="6-4-1、WindowAnimator-updateWindowsLocked"><a href="#6-4-1、WindowAnimator-updateWindowsLocked" class="headerlink" title="6.4.1、WindowAnimator.updateWindowsLocked()"></a>6.4.1、WindowAnimator.updateWindowsLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWindowsLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ++mAnimTransactionSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        WindowState win = windows.get(i);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = win.mAttrs.flags;</span><br><span class="line">        <span class="keyword">boolean</span> canBeForceHidden = mPolicy.canBeForceHidden(win, win.mAttrs);</span><br><span class="line">        <span class="keyword">boolean</span> shouldBeForceHidden = shouldForceHide(win);</span><br><span class="line">        <span class="keyword">if</span> (winAnimator.hasSurface()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasAnimating = winAnimator.mWasAnimating;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> nowAnimating = winAnimator.stepAnimationLocked(mCurrentTime);</span><br><span class="line">            winAnimator.mWasAnimating = nowAnimating;</span><br><span class="line">            orAnimating(nowAnimating);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowStateAnimator.stepAnimationLocked() 如果窗口的动画尚未结束显示，那么stepAnimationLocked()会返回一个true值给调用者，否则的话，就会返回一个false值给调用者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Save the animation state as it was before this step so WindowManagerService can tell if</span></span><br><span class="line">        <span class="comment">// we just started or just stopped animating by comparing mWasAnimating with isAnimationSet().</span></span><br><span class="line">        mWasAnimating = mAnimating;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mWin.getDisplayContent();</span><br><span class="line">        <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; mService.okToDisplay()) &#123;</span><br><span class="line">            <span class="comment">// We will run animations as long as the display isn&#x27;t frozen.</span></span><br><span class="line">            <span class="keyword">if</span> (mWin.isDrawnLw() &amp;&amp; mAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHasTransformation = <span class="keyword">true</span>;</span><br><span class="line">                mHasLocalTransformation = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mLocalAnimating) &#123;</span><br><span class="line">                    <span class="keyword">final</span> DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">                    <span class="keyword">if</span> (mAnimateMove) &#123;</span><br><span class="line">                        mAnimateMove = <span class="keyword">false</span>;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                mAnimDx, mAnimDy);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                displayInfo.appWidth, displayInfo.appHeight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mAnimDx = displayInfo.appWidth;</span><br><span class="line">                    mAnimDy = displayInfo.appHeight;</span><br><span class="line">                    mAnimation.setStartTime(mAnimationStartTime != -<span class="number">1</span></span><br><span class="line">                            ? mAnimationStartTime</span><br><span class="line">                            : currentTime);</span><br><span class="line">                    mLocalAnimating = <span class="keyword">true</span>;</span><br><span class="line">                    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((mAnimation != <span class="keyword">null</span>) &amp;&amp; mLocalAnimating) &#123;</span><br><span class="line">                    mLastAnimationTime = currentTime;</span><br><span class="line">                    <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    currentTime = getAnimationFrameTime(mAnimation, currentTime);</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    mTransformation.clear();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> more = mAnimation.getTransformation(currentTime, mTransformation);</span><br><span class="line">    <span class="keyword">if</span> (mAnimationStartDelayed &amp;&amp; mAnimationIsEntrance) &#123;</span><br><span class="line">        mTransformation.setAlpha(<span class="number">0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、将成员变量mTransformation所描述的变换矩阵的数据清空。 2、调用mAnimation.getTransformation()来计算窗口动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量mTransformation。</p>
<p>然后就是动画过后，窗口大小计算、渲染合成等等显示步骤了，由于之前已经分析过了，不再分析了： 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、触发下一帧动画逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">    mService.scheduleAnimationLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、刷新系统UI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">    mWindowPlacerLocked.requestTraversal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终经过SurfaceFlinger合成显示到屏幕上。 总体流程图(…)：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.wms/20-Android-WMS-animation_Locked-time-diagram.png" alt="Markdown"></p>
<h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/n2d9gjgJDv/">浅析 Android 的窗口</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2faedc664d11">WMS:窗口大小的计算</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/luozirong/article/details/70256809">Android 窗口的计算过程</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qian520ao/article/details/78555397">Android Window 机制探索</a><br><a target="_blank" rel="noopener" href="https://calvinlee.github.io/blog/2012/04/21/android-window-management-architecture/">Android 窗口管理 - 且听风吟</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/all-for-fiona/p/4054527.html">Android 关于Window Overscan</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guoqifa29/article/details/49273065">WindowManagerService动画分析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/guoqifa29/article/details/46819377">深入理解Activity—-Token之旅 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinzhuojun/article/details/37737439">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2e48b3e33a0">Android窗口系统第四篇—Activity动画的设置过程</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lin20044140410/article/details/78798048">Android 7.1 GUI系统-窗口管理WMS-Surface管理（四）</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/samchen2009/p/3367496.html">Android 的窗口管理系统 (View, Canvas, WindowManager)</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2017/01/15/wms_starting_window/">WMS–启动窗口(StartingWindow) - Gityuan博客 | 袁辉辉博客</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a65861e946cb">View绘制流程及源码解析(一)—-performTraversals()源码分析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/u013263323/article/details/78482141">Android窗口系统第三篇—WindowManagerService中窗口的组织方式</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/58c899bea22b9d006411241c">google 进入分屏后在横屏模式按 home 键界面错乱 (二) - Android - 掘金</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yanbober/article/details/46361191">Android应用Activity、Dialog、PopWindow、Toast窗口添加机制及源码分析</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/8462738">Android窗口管理服务WindowManagerService的简要介绍和学习计划 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40776c123adb">Android窗口管理分析（2）：WindowManagerService窗口管理之Window添加流程</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/8611754">Android窗口管理服务WindowManagerService显示窗口动画的原理分析 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/kc58236582/article/details/53782138">Android6.0 WMS（五） WMS计算Activity窗口大小的过程分析（二）WMS的relayoutWindow</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20180108/">https://zhoujinjian.com/posts/20180108/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.08.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20180208/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20171208/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.04.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android N 基础（5）：Android 7.1.2 Activity - Window 加载显示流程（AMS &amp;&amp; WMS）分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">源码（部分）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Window-%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">（一）、Window 组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81Android-Token%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">1.1、Android Token介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1%E3%80%81Token%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">1.1.1、Token对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2%E3%80%81AMS%E8%B0%83%E7%94%A8WMS%E7%9A%84addAPPToken-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">1.1.2、AMS调用WMS的addAPPToken()接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3%E3%80%81AMS%E8%B7%A8Binder%E8%B0%83%E7%94%A8%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E7%9A%84scheduleLaunchActivity-%E5%B0%86Token%E4%BC%A0%E9%80%92%E7%BB%99%E4%B8%8A%E5%B1%82%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4%E3%80%81Activity%E7%AA%97%E5%8F%A3%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">1.1.4、Activity窗口添加过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81WMS%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">1.2、WMS组织方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81WMS%E7%AA%97%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">1.3、WMS窗口类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2%E3%80%81%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="toc-number">2.8.</span> <span class="toc-text">1.3.2、子窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3%E3%80%81%E7%B3%BB%E7%BB%9F%E7%AA%97%E5%8F%A3"><span class="toc-number">2.9.</span> <span class="toc-text">1.3.3、系统窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Window-Size%EF%BC%88%E5%A4%A7%E5%B0%8F%EF%BC%89%E5%92%8C-Window-Position%EF%BC%88%E4%BD%8D%E7%BD%AE%EF%BC%89-%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">（二）、Window Size（大小）和 Window Position（位置） 计算过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81-Android-%E5%B1%8F%E5%B9%95%E5%8C%BA%E5%9F%9F%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">2.1、 Android 屏幕区域介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81-Window-%E5%A4%A7%E5%B0%8F%E4%BD%8D%E7%BD%AE%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2、 Window 大小位置计算过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E3%80%81ViewRootImpl-performTraversals"><span class="toc-number">3.3.</span> <span class="toc-text">2.2.1、ViewRootImpl.performTraversals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E3%80%81ViewRootImpl-relayoutWindow"><span class="toc-number">3.4.</span> <span class="toc-text">2.2.2、ViewRootImpl.relayoutWindow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E3%80%81Session-relayout"><span class="toc-number">3.5.</span> <span class="toc-text">2.2.3、Session.relayout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4%E3%80%81WindowManagerService-relayoutWindow"><span class="toc-number">3.6.</span> <span class="toc-text">2.2.4、WindowManagerService.relayoutWindow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5%E3%80%81WindowSurfacePlacer-performSurfacePlacement"><span class="toc-number">3.7.</span> <span class="toc-text">2.2.5、WindowSurfacePlacer.performSurfacePlacement()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop"><span class="toc-number">3.8.</span> <span class="toc-text">2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7%E3%80%81WindowSurfacePlacer-performSurfacePlacementInner"><span class="toc-number">3.9.</span> <span class="toc-text">2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-8%E3%80%81WindowSurfacePlacer-applySurfaceChangesTransaction"><span class="toc-number">3.10.</span> <span class="toc-text">2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-9%E3%80%81WindowSurfacePlacer-applySurfaceChangesTransaction"><span class="toc-number">3.11.</span> <span class="toc-text">2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-10%E3%80%81PhoneWindowManager-beginLayoutLw"><span class="toc-number">3.12.</span> <span class="toc-text">2.2.10、PhoneWindowManager.beginLayoutLw()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-11%E3%80%81PhoneWindowManager-layoutWindowLw"><span class="toc-number">3.13.</span> <span class="toc-text">2.2.11、PhoneWindowManager.layoutWindowLw()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-12%E3%80%81WindowState-computeFrameLw"><span class="toc-number">3.14.</span> <span class="toc-text">2.2.12、WindowState.computeFrameLw()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-13%E3%80%81PhoneWindowManager-finishLayoutLw"><span class="toc-number">3.15.</span> <span class="toc-text">2.2.13、PhoneWindowManager.finishLayoutLw()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Window-Z-Order-%E8%AE%A1%E7%AE%97%E5%92%8C%E8%B0%83%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">（三）、Window Z-Order 计算和调整过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E7%AA%97%E5%8F%A3Z%E8%BD%B4%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%83%85%E6%99%AF"><span class="toc-number">4.1.</span> <span class="toc-text">3.1、需要重新计算窗口Z轴位置的情景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%89%80%E6%9C%89%E7%AA%97%E5%8F%A3%E7%9A%84Z%E8%BD%B4%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">3.2、计算系统中所有窗口的Z轴位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81WindowLayersController-assignLayersLocked"><span class="toc-number">4.3.</span> <span class="toc-text">3.2.1、WindowLayersController.assignLayersLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E7%9A%84Z%E8%BD%B4%E4%BD%8D%E7%BD%AE%E5%88%B0SurfaceFlinger%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%8E%BB"><span class="toc-number">4.4.</span> <span class="toc-text">3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1%E3%80%81Vsync%E5%88%B7%E6%96%B0UI%E5%9B%9E%E8%B0%83%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">3.3.1、Vsync刷新UI回调过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E3%80%81%E5%87%86%E5%A4%87%E5%88%B7%E6%96%B0UI"><span class="toc-number">4.6.</span> <span class="toc-text">3.3.2、准备刷新UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3%E3%80%81%E5%91%8A%E7%9F%A5SurfaceFlinger%E6%98%BE%E7%A4%BAUI"><span class="toc-number">4.7.</span> <span class="toc-text">3.3.3、告知SurfaceFlinger显示UI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Activity%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3-Starting-Window-%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">（四）、Activity启动窗口(Starting Window)添加过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81Activity%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3-Starting-Window-%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">4.1、Activity组件的启动窗口(Starting Window)的添加过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1%E3%80%81-ActivityStack-startActivityLocked"><span class="toc-number">5.2.</span> <span class="toc-text">4.1.1、 ActivityStack.startActivityLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2%E3%80%81-ActivityRecord-showStartingWindow"><span class="toc-number">5.3.</span> <span class="toc-text">4.1.2、 ActivityRecord.showStartingWindow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2%E3%80%81ActivityRecord-setAppStartingWindow"><span class="toc-number">5.4.</span> <span class="toc-text">4.1.2、ActivityRecord.setAppStartingWindow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3%E3%80%81-H-handleMessage"><span class="toc-number">5.5.</span> <span class="toc-text">4.1.3、 H.handleMessage()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4%E3%80%81PhoneWindowManager-addStartingWindow"><span class="toc-number">5.6.</span> <span class="toc-text">4.1.4、PhoneWindowManager.addStartingWindow()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81WMS%E5%88%87%E6%8D%A2Activity%E7%AA%97%E5%8F%A3%EF%BC%88App-Transition%EF%BC%89%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">（五）、WMS切换Activity窗口（App Transition）过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81prepareAppTransition-%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">5.1、prepareAppTransition()过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E3%80%81ActivityStack-startActivityLocked"><span class="toc-number">6.2.</span> <span class="toc-text">5.1.1、ActivityStack.startActivityLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2%E3%80%81WindowManagerService-prepareAppTransition"><span class="toc-number">6.3.</span> <span class="toc-text">5.1.2、WindowManagerService.prepareAppTransition()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3%E3%80%81AppTransition-prepareAppTransitionLocked"><span class="toc-number">6.4.</span> <span class="toc-text">5.1.3、AppTransition.prepareAppTransitionLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81AppTransition-animation%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">5.2、AppTransition animation设置过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81executeAppTransition%E8%BF%87%E7%A8%8B"><span class="toc-number">6.6.</span> <span class="toc-text">5.3、executeAppTransition过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-WindowManagerService-executeAppTransition"><span class="toc-number">6.7.</span> <span class="toc-text">5.3.1.WindowManagerService.executeAppTransition()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81Activity-Window-%E5%8A%A8%E7%94%BB%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">（六）、Activity Window 动画显示过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E5%8A%A8%E7%94%BB%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">6.1、动画的设置过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E6%99%AE%E9%80%9A%E5%8A%A8%E7%94%BB%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">6.1、普通动画的设置过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E3%80%81WindowManagerService-setTokenVisibilityLocked"><span class="toc-number">7.3.</span> <span class="toc-text">6.1.1、WindowManagerService.setTokenVisibilityLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-WindowStateAnimator-applyAnimationLocked"><span class="toc-number">7.4.</span> <span class="toc-text">6.1.1.WindowStateAnimator.applyAnimationLocked()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB%E7%9A%84%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6"><span class="toc-number">7.5.</span> <span class="toc-text">6.2、窗口动画的显示框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81Activity%E7%BB%84%E4%BB%B6%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB"><span class="toc-number">7.6.</span> <span class="toc-text">6.3、Activity组件切换动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB%E7%9A%84%E6%8E%A8%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">6.4、窗口动画的推进过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1%E3%80%81WindowAnimator-updateWindowsLocked"><span class="toc-number">7.8.</span> <span class="toc-text">6.4.1、WindowAnimator.updateWindowsLocked()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">（七）、参考文档(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>