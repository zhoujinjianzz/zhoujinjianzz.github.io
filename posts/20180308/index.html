<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析 | zhoujinjian</title><meta name="keywords" content="Android,Input"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Android 输入子系统概述:● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在&#x2F;dev&#x2F;input&#x2F;下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20180308/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="Android 输入子系统概述:● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在&#x2F;dev&#x2F;input&#x2F;下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg">
<meta property="article:published_time" content="2018-03-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.956Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Input">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20180308/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-03-08T01:25:00.000Z" title="发表于 2018-03-08 09:25:00">2018-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.956Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Input/">Input</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Android 输入子系统概述:<br>● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在/dev/input/下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。<br>● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通过read()函数读取事件数据了。<br>● Android输入系统会监控/dev/input/下的所有设备节点，当某个结点有数据可读时，将数据读出并进行一系列处理，然后在当前系统中的所有窗口（Window）中寻找合适的接收者，并把事件派发给它。<br>● 具体来说，Linux Kernel将raw input event写入到设备节点后，InputReader会通过EventHub将原始事件读取出来并翻译加工为Android输入事件，而后把它交给InputDispatcher。InputDispatcher根据WMS（WindowManagerService）提供的窗口信息将事件传递给合适的窗口，若窗口为壁纸/SurfaceView等，则到了终点；否则会由该Window的ViewRoot继续分发到合适的View。</p>
<a id="more"></a>

<p>本章涉及的源代码文件名及位置：</p>
<p><strong>frameworks/base/services/java/com/android/server/</strong><br>● SystemServer.java</p>
<p><strong>frameworks/base/services/java/com/android/server/input/</strong><br>● InputManagerService.java</p>
<p><strong>frameworks/base/services/java/com/android/server/wm/</strong><br>● WindowManagerService.java<br>● WindowState.java<br>● InputMonitor.java</p>
<p><strong>frameworks/base/core/java/android/view/</strong><br>● View.java<br>● ViewGroup.java<br>● InputEventReceiver.java<br>● ViewRootImpl.java<br>● IWindowSession.aidl<br>● InputChannel.java</p>
<p><strong>frameworks/base/core/java/android/app/</strong><br>● Activity.java</p>
<p><strong>frameworks/base/services/jni/</strong><br>● android_view_InputChannel.cpp<br>● android_view_InputEventReceiver.cpp<br>● com_android_server_input_InputManagerService.cpp</p>
<p><strong>frameworks/native/services/inputflinger/</strong><br>● InputManager.cpp<br>● EventHub.h<br>● EventHub.cpp<br>● InputReader.h<br>● InputReader.cpp<br>● InputListener.h<br>● InputListener.cpp<br>● InputDispatcher.h<br>● InputDispatcher.cpp</p>
<p><strong>frameworks/native/libs/input/</strong><br>● InputTransport.cpp</p>
<p><strong>/frameworks/native/include/input/</strong><br>● InputTransport.h</p>
<h2 id="一、Input系统必备Linux知识"><a href="#一、Input系统必备Linux知识" class="headerlink" title="一、Input系统必备Linux知识"></a>一、Input系统必备Linux知识</h2><p>注：必备知识可稍后遇到实际使用的地方再做详细了解。</p>
<h2 id="（一）、必备的Linux知识-inotify和epoll"><a href="#（一）、必备的Linux知识-inotify和epoll" class="headerlink" title="（一）、必备的Linux知识 inotify和epoll"></a>（一）、必备的Linux知识 inotify和epoll</h2><h3 id="1、INotify介绍与使用"><a href="#1、INotify介绍与使用" class="headerlink" title="1、INotify介绍与使用"></a>1、INotify介绍与使用</h3><p>INotify是一个Linux内核所提供的一种文件系统变化通知机制。它可以为应用程序监控文件系统的变化，如文件的新建、删除、读写等。INotify机制有两个基本对象，分别为inotify对象与watch对象，都使用文件描述符表示。 inotify对象对应了一个队列，应用程序可以向inotify对象添加多个监听。当被监听的事件发生时，可以通过read()函数从inotify对象中将事件信息读取出来。Inotify对象可以通过以下方式创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inotifyFd = inotify_init();</span><br></pre></td></tr></table></figure>

<p>而watch对象则用来描述文件系统的变化事件的监听。它是一个二元组，包括监听目标和事件掩码两个元素。监听目标是文件系统的一个路径，可以是文件也可以是文件夹。而事件掩码则表示了需要需要监听的事件类型，掩码中的每一位代表一种事件。可以监听的事件种类很多，其中就包括文件的创建(IN_CREATE)与删除(IN_DELETE)。读者可以参阅相关资料以了解其他可监听的事件种类。以下代码即可将一个用于监听输入设备节点的创建与删除的watch对象添加到inotify对象中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wd = inotify_add_watch (inotifyFd, “/dev/input”,IN_CREATE | IN_DELETE);</span><br></pre></td></tr></table></figure>

<p>完成上述watch对象的添加后，当/dev/input/下的设备节点发生创建与删除操作时，都会将相应的事件信息写入到inotifyFd所描述的inotify对象中，此时可以通过read()函数从inotifyFd描述符中将事件信息读取出来。 事件信息使用结构体inotify_event进行描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">   __s32           wd;             <span class="comment">/* 事件对应的Watch对象的描述符 */</span></span><br><span class="line">   __u32           mask;           <span class="comment">/* 事件类型，例如文件被删除，此处值为IN_DELETE */</span></span><br><span class="line">   __u32           cookie;</span><br><span class="line">   __u32           len;            <span class="comment">/* name字段的长度 */</span></span><br><span class="line">   <span class="keyword">char</span>            name[<span class="number">0</span>];        <span class="comment">/* 可变长的字段，用于存储产生此事件的文件路径*/</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>当没有监听事件发生时，可以通过如下方式将一个或多个未读取的事件信息读取出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len = read (inotifyFd, events_buf,BUF_LEN);</span><br></pre></td></tr></table></figure>

<p>其中events_buf是inotify_event的数组指针，能够读取的事件数量由取决于数组的长度。成功读取事件信息后，便可根据inotify_event结构体的字段判断事件类型以及产生事件的文件路径了。</p>
<p>总结一下INotify机制的使用过程：</p>
<p>· 通过inotify_init()创建一个inotify对象。</p>
<p>· 通过inotify_add_watch将一个或多个监听添加到inotify对象中。</p>
<p>· 通过read()函数从inotify对象中读取监听事件。当没有新事件发生时，inotify对象中无任何可读数据。</p>
<p>通过INotify机制避免了轮询文件系统的麻烦，但是还有一个问题，INotify机制并不是通过回调的方式通知事件，而需要使用者主动从inotify对象中进行事件读取。那么何时才是读取的最佳时机呢？这就需要借助Linux的另一个优秀的机制Epoll了。</p>
<p>使用inotify监听目录实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">//参考: frameworks\native\services\inputflinger\EventHub.cpp</span></span><br><span class="line"><span class="comment">//Usage: inotify &lt;dir&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_process_inotify_fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">char</span> event_buf[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">int</span> event_size;</span><br><span class="line"><span class="keyword">int</span> event_pos = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> *<span class="title">event</span>;</span></span><br><span class="line"><span class="comment">/* read */</span>    </span><br><span class="line">res = read(fd, event_buf, <span class="keyword">sizeof</span>(event_buf));</span><br><span class="line"><span class="keyword">if</span>(res &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;could not get event, %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读到的数据是1个或多个inotify_event,它们的长度不一样,逐个处理</span></span><br><span class="line"><span class="keyword">while</span>(res &gt;= (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">    event = (struct inotify_event *)(event_buf + event_pos);</span><br><span class="line">    <span class="comment">//printf(&quot;%d: %08x \&quot;%s\&quot;\n&quot;, event-&gt;wd, event-&gt;mask, event-&gt;len ? event-&gt;name : &quot;&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;mask &amp; IN_CREATE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create file: %s\n&quot;</span>, event-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;delete file: %s\n&quot;</span>, event-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    event_size = <span class="keyword">sizeof</span>(*event) + event-&gt;len;</span><br><span class="line">    res -= event_size;</span><br><span class="line">    event_pos += event_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mINotifyFd;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dir&gt;\n&quot;</span>, argv[<span class="number">0</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* inotify_init */</span></span><br><span class="line">mINotifyFd = inotify_init();</span><br><span class="line"><span class="comment">/* add watch */</span></span><br><span class="line">result = inotify_add_watch(mINotifyFd, argv[<span class="number">1</span>], IN_DELETE | IN_CREATE);</span><br><span class="line"><span class="comment">/* read */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    read_process_inotify_fd(mINotifyFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译与验证：</strong> gcc -o inotify inotify.c //GCC编译 mkdir tmp //创建tmp文件夹 ./inotify tmp &amp; //后台监测tmp文件夹</p>
<p>echo &gt; tmp/1 //tmp文件夹新建文件1 echo &gt; tmp/2 //tmp文件夹新建文件2 rm tmp/1 tmp/2 //移除tmp文件1/2</p>
<p>测试结果可以看到，inotify 成功的监测了tmp文件夹。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N1-Android-Input-System-Inotify-Test.jpg" alt="Markdown"></p>
<h3 id="2、Epoll介绍与使用"><a href="#2、Epoll介绍与使用" class="headerlink" title="2、Epoll介绍与使用"></a>2、Epoll介绍与使用</h3><p>无论是从设备节点中获取原始输入事件还是从inotify对象中读取文件系统事件，都面临一个问题，就是这些事件都是偶发的。也就是说，大部分情况下设备节点、inotify对象这些文件描述符中都是无数据可读的，同时又希望有事件到来时可以尽快地对事件作出反应。为解决这个问题，我们不希望不断地轮询这些描述符，也不希望为每个描述符创建一个单独的线程进行阻塞时的读取，因为这都将会导致资源的极大浪费。</p>
<p>此时最佳的办法是使用Epoll机制。Epoll可以使用一次等待监听多个描述符的可读/可写状态。等待返回时携带了可读的描述符或自定义的数据，使用者可以据此读取所需的数据后可以再次进入等待。因此不需要为每个描述符创建独立的线程进行阻塞读取，避免了资源浪费的同时又可以获得较快的响应速度。</p>
<p>Epoll机制的接口只有三个函数，十分简单。</p>
<p>· epoll_create(int max_fds)：创建一个epoll对象的描述符，之后对epoll的操作均使用这个描述符完成。max_fds参数表示了此epoll对象可以监听的描述符的最大数量。</p>
<p>· epoll_ctl (int epfd, int op,int fd, struct epoll_event *event)：用于管理注册事件的函数。这个函数可以增加/删除/修改事件的注册。</p>
<p>· int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout)：用于等待事件的到来。当此函数返回时，events数组参数中将会包含产生事件的文件描述符。</p>
<p>接下来以监控若干描述符可读事件为例介绍一下epoll的用法。</p>
<p>（1） 创建epoll对象</p>
<p>首先通过epoll_create()函数创建一个epoll对象：</p>
<p>Int epfd = epoll_create(MAX_FDS)</p>
<p>（2） 填充epoll_event结构体</p>
<p>接着为每一个需监控的描述符填充epoll_event结构体，以描述监控事件，并通过epoll_ctl()函数将此描述符与epoll_event结构体注册进epoll对象。epoll_event结构体的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">__uint32_tevents; <span class="comment">/* 事件掩码，指明了需要监听的事件种类*/</span></span><br><span class="line"> <span class="keyword">epoll_data_t</span> data; <span class="comment">/* 使用者自定义的数据，当此事件发生时该数据将原封不动地返回给使用者 */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>epoll_data_t联合体的定义如下，当然，同一时间使用者只能使用一个字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"><span class="keyword">void</span>*ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">__uint32_t</span> u32;</span><br><span class="line"><span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_event结构中的events字段是一个事件掩码，用以指明需要监听的事件种类，同INotify一样，掩码的每一位代表了一种事件。常用的事件有EPOLLIN（可读），EPOLLOUT（可写），EPOLLERR（描述符发生错误），EPOLLHUP（描述符被挂起）等。更多支持的事件读者可参考相关资料。</p>
<p>data字段是一个联合体，它让使用者可以将一些自定义数据加入到事件通知中，当此事件发生时，用户设置的data字段将会返回给使用者。在实际使用中常设置epoll_event.data.fd为需要监听的文件描述符，事件发生时便可以根据epoll_event.data.fd得知引发事件的描述符。当然也可以设置epoll_event.data.fd为其他便于识别的数据。</p>
<p>填充epoll_event的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structepoll_event eventItem;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line"></span><br><span class="line">eventItem.events = EPOLLIN | EPOLLERR | EPOLLHUP; <span class="comment">// 监听描述符可读以及出错的事件</span></span><br><span class="line"></span><br><span class="line">eventItem.data.fd= listeningFd; <span class="comment">// 填写自定义数据为需要监听的描述符</span></span><br></pre></td></tr></table></figure>

<p>接下来就可以使用epoll_ctl()将事件注册进epoll对象了。epoll_ctl()的参数有四个：</p>
<p>· epfd是由epoll_create()函数所创建的epoll对象的描述符。</p>
<p>· op表示了何种操作，包括EPOLL_CTL_ADD/DEL/MOD三种，分别表示增加/删除/修改注册事件。</p>
<p>· fd表示了需要监听的描述符。</p>
<p>· event参数是描述了监听事件的详细信息的epoll_event结构体。</p>
<p>注册方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将事件监听添加到epoll对象中去</span></span><br><span class="line"></span><br><span class="line">result =epoll_ctl(epfd, EPOLL_CTL_ADD, listeningFd, &amp;eventItem);</span><br></pre></td></tr></table></figure>

<p>重复这个步骤可以将多个文件描述符的多种事件监听注册到epoll对象中。完成了监听的注册之后，便可以通过epoll_wait()函数等待事件的到来了。</p>
<p>（3） 使用epoll_wait()函数等待事件</p>
<p>epoll_wait()函数将会使调用者陷入等待状态，直到其注册的事件之一发生之后才会返回，并且携带了刚刚发生的事件的详细信息。其签名如下：</p>
<p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p>
<p>· epfd是由epoll_create()函数所创建的epoll对象描述符。</p>
<p>· events是一个epoll_event的数组，此函数返回时，事件的信息将被填充至此。</p>
<p>· maxevents表示此次调用最多可以获取多少个事件，当然，events参数必须能够足够容纳这么多事件。</p>
<p>· timeout表示等待超时的事件。</p>
<p>epoll_wait()函数返回值表示获取了多少个事件。</p>
<p>（4） 处理事件</p>
<p>epoll_wait返回后，便可以根据events数组中所保存的所有epoll_event结构体的events字段与data字段识别事件的类型与来源。</p>
<p>Epoll的使用步骤总结如下：</p>
<p>· 通过epoll_create()创建一个epoll对象。</p>
<p>· 为需要监听的描述符填充epoll_events结构体，并使用epoll_ctl()注册到epoll对象中。</p>
<p>· 使用epoll_wait()等待事件的发生。</p>
<p>· 根据epoll_wait()返回的epoll_events结构体数组判断事件的类型与来源并进行处理。</p>
<p>· 继续使用epoll_wait()等待新事件的发生。</p>
<p>使用inotify监听目录实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"><span class="keyword">void</span>        *ptr;</span><br><span class="line"> <span class="keyword">int</span>          fd;</span><br><span class="line">  <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">   <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">   &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_MAX_LEN 500</span></span><br><span class="line"><span class="comment">/* usage: epoll &lt;file1&gt; [file2] [file3] ... */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_to_epoll</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epollFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">eventItem.events = EPOLLIN;</span><br><span class="line">eventItem.data.fd = fd;</span><br><span class="line">result = epoll_ctl(epollFd, EPOLL_CTL_ADD, fd, &amp;eventItem);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rm_from_epoll</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epollFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_ctl(epollFd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mEpollFd;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[DATA_MAX_LEN];</span><br><span class="line"><span class="comment">// Maximum number of signalled FDs to handle at a time.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> EPOLL_MAX_EVENTS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// The array of pending epoll events and the index of the next event to be handled.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">mPendingEventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;file1&gt; [file2] [file3] ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll_create */</span></span><br><span class="line">mEpollFd = epoll_create(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each file:* open it</span></span><br><span class="line"><span class="comment">// add it to epoll: epoll_ctl(...EPOLL_CTL_ADD...)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)     </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int tmpFd = open(argv[i], O_RDONLY|O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> tmpFd = open(argv[i], O_RDWR);</span><br><span class="line">    add_to_epoll(tmpFd, mEpollFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* epoll_wait */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pollResult; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Reason: 0x%x\n&quot;</span>, mPendingEventItems[i].events);</span><br><span class="line">        <span class="keyword">int</span> len = read(mPendingEventItems[i].data.fd, buf, DATA_MAX_LEN);</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get data: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="comment">//sleep(3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll , fifo : <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/15055065/o-rdwr-on-named-pipes-with-poll">o-rdwr-on-named-pipes-with-poll</a></p>
<p>使用fifo是, 我们的epoll程序是reader echo aa &gt; tmp/1 是writer a. 如果reader以 O_RDONLY|O_NONBLOCK打开FIFO文件, 当writer写入数据时, epoll_wait会立刻返回; 当writer关闭FIFO之后, reader再次调用epoll_wait, 它也会立刻返回(原因是EPPLLHUP, 描述符被挂断) b. 如果reader以 O_RDWR打开FIFO文件 当writer写入数据时, epoll_wait会立刻返回; 当writer关闭FIFO之后, reader再次调用epoll_wait, 它并不会立刻返回, 而是继续等待有数据</p>
<p><strong>编译与验证：</strong> gcc -o epoll epoll.c //GCC编译 mkdir tmp //创建tmp文件夹 mkfifo tmp/1 tmp/2 tmp/3 //创建文件1、2、3 ./epoll tmp/1 tmp/2 tmp/3 &amp; //epoll后台监测文件1、2、3 echo aaa &gt; tmp/1 //写人aaa到1 echo bbb &gt; tmp/2 //写入bbb到2</p>
<p>测试结果可以看到，epoll成功的监测了文件内容的改变。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N2-Android-Input-System-epoll-test.jpg" alt="Markdown"></p>
<h3 id="3、INotify与Epoll的小结"><a href="#3、INotify与Epoll的小结" class="headerlink" title="3、INotify与Epoll的小结"></a>3、INotify与Epoll的小结</h3><p>INotify与Epoll这两套由Linux提供的事件监听机制以最小的开销解决了文件系统变化以及文件描述符可读可写状态变化的监听问题。它们是Reader子系统运行的基石，了解了这两个机制的使用方法之后便为对Reader子系统的分析学习铺平了道路。 参考：<a target="_blank" rel="noopener" href="https://github.com/weidongshan/APP_0006_inotify_epoll">https://github.com/weidongshan/APP_0006_inotify_epoll</a> inotify_epoll.c, 用它来监测tmp/目录: 有文件被创建/删除, 有文件可读出数据 a. 当在tmp/下创建文件时, 会立刻监测到，并且使用epoll监测该文件 b. 当文件有数据时，读出数据 c. 当tmp/下文件被删除时，会立刻监测到，并且把它从epoll中移除不再监测</p>
<p>inotify_epoll.c <strong>编译与验证：</strong></p>
<p>gcc -o inotify_epoll inotify_epoll.c mkdir tmp ./inotify_epoll tmp/ &amp; mkfifo tmp/1 tmp/2 tmp/3 echo aaa &gt; tmp/1 echo bbb &gt; tmp/2 rm tmp/3</p>
<p>由实例可知，使用inotify 和 epoll 结合就可以监测文件增加和移除 ，还能监测文件内容的改变。</p>
<p>用途简介[稍后进行input system详细分析]： /dev/input 下有多个event文件,对应多个输入设备，如:/dev/input/event0, /dev/input/mouse0, /dev/input/misc 使用inotify 和 epoll 就可以监听输入设备的变化、如Android新连接一个鼠标可检测到改变。同时可监听是否有输入事件。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859">Lnux IO模式及 select、poll、epoll详解</a></p>
<h2 id="（二）、必备Linux知识-双向通信-scoketpair"><a href="#（二）、必备Linux知识-双向通信-scoketpair" class="headerlink" title="（二）、必备Linux知识_双向通信(scoketpair)"></a>（二）、必备Linux知识_双向通信(scoketpair)</h2><h3 id="1、进程和APP通信"><a href="#1、进程和APP通信" class="headerlink" title="1、进程和APP通信"></a>1、进程和APP通信</h3><p>· 创建进程 · 读取、分发 · 进程发送输入事件给APP · 进程读取APP回应的事件 · 输入系统涉及双向的进程间通信</p>
<h3 id="2、回顾Binder系统"><a href="#2、回顾Binder系统" class="headerlink" title="2、回顾Binder系统"></a>2、回顾Binder系统</h3><p>· Server– 单向发出请求 · Client – 单向回复请求 · 每次请求只可以单方发出</p>
<h3 id="3、引入Socketpair"><a href="#3、引入Socketpair" class="headerlink" title="3、引入Socketpair"></a>3、引入Socketpair</h3><p>原因：如果创建两组进程（Client，Server）进行双向通信，实现十分复杂 引入Socketpair： Socketpair();两次，获得两个fd，在内核获得缓冲区，一个作为sendbuf区一个作为receivebuf区 APP通过fd1将数据写入fd1的sendbuf区中，通过内核当中的socket机制就会写到fd2中receivebuf区，同理fd2也是如此 socketpair缺点：只适用于线程间、父子进程通信 解决方法：通过Binder机制通信可以访问任意进程，就解决了sockpair缺点</p>
<h3 id="4、socketpair具体使用"><a href="#4、socketpair具体使用" class="headerlink" title="4、socketpair具体使用"></a>4、socketpair具体使用</h3><p>创建一个线程–pthread_create(); 创建socketpair–socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets); 线程处理函数–往socket[1]写入数据，读取socket[0]读取数据 主函数–从socket[1]读取数据，往socket[0]写入数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_BUFFER_SIZE      (32768U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 512</span></span><br><span class="line"><span class="comment">/* 参考:frameworks/native/libs/input/InputTransport.cpp</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">/* 线程执行函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">function_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> thread1_fd = (<span class="keyword">int</span>)arg;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[MAX];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/* 向 main线程发出: Hello, main thread   */</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,<span class="string">&quot;Hello , main thread , cnt = %d&quot;</span>,cnt++);</span><br><span class="line">    write(thread1_fd,buf,len);</span><br><span class="line">    <span class="comment">/* 读取数据(main线程发回的数据) */</span></span><br><span class="line">    len = read(thread1_fd,buf,MAX);</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 read : %s\n&quot;</span>,buf);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(thread1_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> threadID;</span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">socketpair(AF_UNIX,SOCK_SEQPACKET,<span class="number">0</span>,sockets);  <span class="comment">//创建socketpair</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">pthread_create(threadID,<span class="literal">NULL</span>,function_thread,(<span class="keyword">void</span> *)sockets[<span class="number">1</span>]);  <span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">int</span> mainThread_fd = sockets[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[MAX];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/* 读数据: 线程1发出的数据 */</span></span><br><span class="line">    len = read(mainThread_fd,buf,MAX);</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread read : %s\n&quot;</span>,buf);</span><br><span class="line">    <span class="comment">/* main thread向thread1 发出: Hello, thread1 */</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,<span class="string">&quot;Hello , thread1 , cnt = %d&quot;</span>,cnt++);</span><br><span class="line">    write(mainThread_fd,buf,len);       </span><br><span class="line">&#125;</span><br><span class="line">close(mainThread_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法： gcc socketpair.c -o socketpair -pthread 注：出现少量警告，可以忽略 ./socketpair 可以看到main线程 和 thread1双向通信。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N3-Android-Input-System-socketpair.jpg" alt="Markdown"></p>
<p>main 和 thread1属于两个线程：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N4-Android-Input-System-socketpair-thread.jpg" alt="Markdown"></p>
<p>父子进程通信： 利用socketpair创建一对无名管道，然后通过sendmsg由服务器进程发送文件的fd给客户端进程，客户端进程通过recvmsg接收服务器进程发来的fd <a target="_blank" rel="noopener" href="http://blog.csdn.net/yankai0219/article/details/8453377">socketpair实现父子进程通信</a> <strong>图示：</strong><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N5-Android-Input-System-socketpair-father-son.jpg" alt="Markdown"></p>
<h2 id="（三）、必备Linux知识-实现任意进程间双向通信-scoketpair-binder"><a href="#（三）、必备Linux知识-实现任意进程间双向通信-scoketpair-binder" class="headerlink" title="（三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)"></a>（三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)</h2><p>代码实例，由于代码较多，请往GitHub上查看。 <a target="_blank" rel="noopener" href="https://github.com/weidongshan/APP_0004_Binder_CPP_App">实现任意进程间双向通信(scoketpair+binder)</a></p>
<p>由第二节最后可知socketpair可实现父子进程通信，图中父进程和子进程可双向通信，假如此时通过binder通信将文件句柄Fd[1]传给另外一个独立进程，我们知道Linux一切皆文件，那个独立进程就可以对Fd[1]读写了，也就是说父进程 就可以和 那个独立进程双向通信了，具体实现请研究上面的代码。</p>
<p>测试：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N6-Android-Input-System-socketpair-binder.jpg" alt="Markdown"></p>
<p>可以看到两个没有任何关系的进程使用socketpair实现了双向通信。</p>
<p>用途简介[稍后进行input system详细分析]： InputManagerService获取事件后需要发送给App，假如App进程关掉了，需要告知IMS，就不需要接受事件了。可以看到需要进程间相互通信，这就是scoketpair+binder实际作用。</p>
<hr>
<h2 id="二、输入系统的总体架构"><a href="#二、输入系统的总体架构" class="headerlink" title="二、输入系统的总体架构"></a>二、输入系统的总体架构</h2><h3 id="（一）、输入子系统分层解析"><a href="#（一）、输入子系统分层解析" class="headerlink" title="（一）、输入子系统分层解析"></a>（一）、输入子系统分层解析</h3><p>输入子系统的系统架构如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N7-Android-Input-System--all-arc.png" alt="Markdown"></p>
<p>Android输入系统系统综述： Linux内核会在/dev/input/下创建对应的名为event0~n或其他名称的设备节点。而当输入设备不可用时，则会将对应的节点删除。在用户空间可以通过ioctl的方式从这些设备节点中获取其对应的输入设备的类型、厂商、描述等信息。</p>
<p>当用户操作输入设备时，Linux内核接收到相应的硬件中断，然后将中断加工成原始的输入事件数据并写入其对应的设备节点中，在用户空间可以通过read()函数将事件数据读出。</p>
<p>Android输入系统的工作原理概括来说，就是监控/dev/input/下的所有设备节点，当某个节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中寻找合适的事件接收者，并派发给它。</p>
<h4 id="1、输入子系统分层解析"><a href="#1、输入子系统分层解析" class="headerlink" title="1、输入子系统分层解析"></a>1、输入子系统分层解析</h4><p>● Hardware层 硬件层主要就是按键、触摸屏、Sensor等各种输入设备。</p>
<p>● Kernel层</p>
<p>Kernel 层对Input相关处理只做简单的介绍。 Kernel 层主要分为三层，如下：</p>
<p>Input 设备驱动层: 采集输入设备的数据信息，通过 Input Core 的 API 上报数据。</p>
<p>Input Core（核心层）：为事件处理层和设备驱动层提供接口API。 Event Handler（事件处理层）：通过核心层的API获取输入事件上报的数据，定义API与应用层交互。</p>
<p>Event Handler： Event Handler 层以通用的 evdev.c 为例来解析，上层和 Kernel 层的交互在此文件完成。</p>
<p>● Framework 层 Android系统中Framework 层负责管理输入事件的主要是InputManagerService（IMS）。它主要的任务就是从设备中读事件数据，然后将输入事件发送到焦点窗口中去，另外还需要让系统有机会来处理一些系统按键。显然，要完成这个工作，IMS需要与其它模块打交道，其中最主要的就是WMS和ViewRootImpl。主要的几个模块示意如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N8-Android-Input-System-framwork-arc.png" alt="Markdown"></p>
<p>● App层</p>
<hr>
<p>WindowManagerService(WMS)是窗口管理服务，核心维护了一个有序的窗口堆栈。PhoneWindowManager(PWM)里有关于手机策略的实现，和输入相关的主要是对系统按键的处理。InputManagerService是输入管理服务，主要干活的是Native层的InputManager。InputManager中的InputReader负责使用EventHub从Input driver中拿事件，然后让InputMapper解析。接着传给InputDispatcher，InputDispatcher负责一方面将事件通过InputManager，InputMonitor一路传给PhoneWindowManager来做系统输入事件的处理，另一方面将这些事件传给焦点及监视窗口。NativeInputManager实现InputReaderPolicyInterface和InputDispatcherPolicyInterface接口，在Native层的InputManager和Java层的IMS间起到一个胶水层的作用。InputMonitor实现了WindowManagerCallbacks接口，起到了IMS到WMS的连接作用。App这边，ViewRootImpl相当于App端一个顶层View的Controller。这个顶层View在WMS中对应一个窗口，用WindowState描述。WindowState中有InputWindowHandle代表一个接收输入事件的窗口句柄。InputDispatcher中的mFocusedWindowHandle指示了焦点窗口的句柄。InputDispatcher管理了一坨连接（一个连接对应一个注册到WMS的窗口），通过这些个连接InputDispatcher可以直接将输入事件发往App端的焦点窗口。输入事件从Driver开始的处理过程大致如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N9-Android-Input-System-app-arc.png" alt="Markdown"></p>
<p>事件发往App端后，就进入事件分发阶段，这里简单提下，不做详细分析。</p>
<p>附： Kernel 层生成三个路径及相关设备文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># /sys/<span class="class"><span class="keyword">class</span>/<span class="title">input</span>/</span></span><br><span class="line"><span class="class"><span class="title">event0</span>  <span class="title">event11</span> <span class="title">event4</span> <span class="title">event7</span> <span class="title">input0</span>  <span class="title">input11</span> <span class="title">input4</span> <span class="title">input7</span></span></span><br><span class="line"><span class="class"><span class="title">event1</span>  <span class="title">event2</span>  <span class="title">event5</span> <span class="title">event8</span> <span class="title">input1</span>  <span class="title">input2</span>  <span class="title">input5</span> <span class="title">input8</span></span></span><br><span class="line"><span class="class"><span class="title">event10</span> <span class="title">event3</span>  <span class="title">event6</span> <span class="title">event9</span> <span class="title">input10</span> <span class="title">input3</span>  <span class="title">input6</span> <span class="title">input9</span></span></span><br><span class="line"><span class="class"># /<span class="title">dev</span>/<span class="title">input</span></span></span><br><span class="line"><span class="class"><span class="title">event0</span> <span class="title">event10</span> <span class="title">event2</span> <span class="title">event4</span> <span class="title">event6</span> <span class="title">event8</span></span></span><br><span class="line"><span class="class"><span class="title">event1</span> <span class="title">event11</span> <span class="title">event3</span> <span class="title">event5</span> <span class="title">event7</span> <span class="title">event9</span></span></span><br><span class="line"><span class="class"># /<span class="title">proc</span>/<span class="title">bus</span>/<span class="title">input</span>  </span></span><br><span class="line"><span class="class"><span class="title">devices</span> <span class="title">handlers</span></span></span><br><span class="line"><span class="class"># <span class="title">cat</span> <span class="title">devices</span>  查看总线上的已经注册上的输入设备</span></span><br><span class="line"><span class="class"><span class="title">I</span>:</span> Bus=<span class="number">0019</span> Vendor=<span class="number">0000</span> Product=<span class="number">0000</span> Version=<span class="number">0000</span></span><br><span class="line">N: Name=<span class="string">&quot;ACCDET&quot;</span></span><br><span class="line">P: Phys=</span><br><span class="line">S: Sysfs=/devices/<span class="keyword">virtual</span>/input/input0</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=gpufreq_ib event0</span><br><span class="line">B: PROP=<span class="number">0</span></span><br><span class="line">B: EV=<span class="number">3</span></span><br><span class="line">B: KEY=<span class="number">40</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1000000000</span> c000001800000 <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">I: Bus=<span class="number">0019</span> Vendor=<span class="number">0000</span> Product=<span class="number">0000</span> Version=<span class="number">0001</span></span><br><span class="line">N: Name=<span class="string">&quot;fingerprint_key&quot;</span></span><br><span class="line">P: Phys=</span><br><span class="line">S: Sysfs=/devices/<span class="keyword">virtual</span>/input/input2</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=gpufreq_ib event2</span><br><span class="line">B: PROP=<span class="number">0</span></span><br><span class="line">B: EV=<span class="number">3</span></span><br><span class="line">B: KEY=<span class="number">2000100000000000</span> <span class="number">180001f</span> <span class="number">8000000000000000</span></span><br><span class="line">...</span><br><span class="line">cat handlers <span class="comment">// 查看注册的handler</span></span><br><span class="line">N: Number=<span class="number">0</span> Name=gpufreq_ib</span><br><span class="line">N: Number=<span class="number">1</span> Name=evdev Minor=<span class="number">64</span></span><br></pre></td></tr></table></figure>

<h4 id="2、getevent与sendevent工具"><a href="#2、getevent与sendevent工具" class="headerlink" title="2、getevent与sendevent工具"></a>2、getevent与sendevent工具</h4><p>Android系统提供了getevent与sendevent两个工具供开发者从设备节点中直接读取输入事件或写入输入事件。</p>
<p>getevent监听输入设备节点的内容，当输入事件被写入到节点中时，getevent会将其读出并打印在屏幕上。由于getevent不会对事件数据做任何加工，因此其输出的内容是由内核提供的最原始的事件。其用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getevent [-选项] [device_path]</span><br></pre></td></tr></table></figure>

<p>其中device_path是可选参数，用以指明需要监听的设备节点路径。如果省略此参数，则监听所有设备节点的事件。</p>
<p>打开模拟器，执行adb shell getevent –t（-t参数表示打印事件的时间戳），并按一下电源键（不要松手），可以得到以下一条输出，输出的部分数值会因机型的不同而有所差异，但格式一致：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1262.443489</span>] /dev/input/event0: <span class="number">0001</span> <span class="number">0074</span> <span class="number">00000001</span></span><br></pre></td></tr></table></figure>

<p>松开电源键时，又会产生以下一条输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1262.557130</span>] /dev/input/event0: <span class="number">0001</span> <span class="number">0074</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>这两条输出便是按下和抬起电源键时由内核生成的原始事件。注意其输出是十六进制的。每条数据有五项信息：产生事件时的时间戳（[ 1262.443489]），产生事件的设备节点（/dev/input/event0），事件类型（0001），事件代码（0074）以及事件的值（00000001）。其中时间戳、类型、代码、值便是原始事件的四项基本元素。除时间戳外，其他三项元素的实际意义依照设备类型及厂商的不同而有所区别。在本例中，类型0x01表示此事件为一条按键事件，代码0x74表示电源键的扫描码，值0x01表示按下，0x00则表示抬起。这两条原始数据被输入系统包装成两个KeyEvent对象，作为两个按键事件派发给Framework中感兴趣的模块或应用程序。</p>
<p>注意一条原始事件所包含的信息量是比较有限的。而在Android API中所使用的某些输入事件，如触摸屏点击/滑动，包含了很多的信息，如XY坐标，触摸点索引等，其实是输入系统整合了多个原始事件后的结果。这个过程将在5.2.4节中详细探讨。</p>
<p>为了对原始事件有一个感性的认识，读者可以在运行getevent的过程中尝试一下其他的输入操作，观察一下每种输入所对应的设备节点及四项元素的取值。</p>
<p>输入设备的节点不仅在用户空间可读，而且是可写的，因此可以将将原始事件写入到节点中，从而实现模拟用户输入的功能。sendevent工具的作用正是如此。其用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendevent &lt;节点路径&gt; &lt;类型&gt;&lt;代码&gt; &lt;值&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出，sendevent的输入参数与getevent的输出是对应的，只不过sendevent的参数为十进制。电源键的代码0x74的十进制为116，因此可以通过快速执行如下两条命令实现点击电源键的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell sendevent /dev/input/event0 <span class="number">1</span> <span class="number">116</span> <span class="number">1</span> #按下电源键</span><br><span class="line"></span><br><span class="line">adb shell sendevent /dev/input/event0 <span class="number">1</span> <span class="number">116</span> <span class="number">0</span> #抬起电源键</span><br></pre></td></tr></table></figure>

<p>执行完这两条命令后，可以看到设备进入了休眠或被唤醒，与按下实际的电源键的效果一模一样。另外，执行这两条命令的时间间隔便是用户按住电源键所保持的时间，所以如果执行第一条命令后迟迟不执行第二条，则会产生长按电源键的效果—-关机对话框出现了。很有趣不是么？输入设备节点在用户空间可读可写的特性为自动化测试提供了一条高效的途径。[1]</p>
<p>现在，读者对输入设备节点以及原始事件有了直观的认识，接下来看一下Android输入系统的基本原理。</p>
<h4 id="3、Input-driver模拟驱动"><a href="#3、Input-driver模拟驱动" class="headerlink" title="3、Input driver模拟驱动"></a>3、Input driver模拟驱动</h4><p>代码实例： <a target="_blank" rel="noopener" href="https://github.com/weidongshan/DRV_0004_InputEmulator/">Input driver模拟驱动-作者韦东山</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参考drivers\input\keyboard\gpio_keys.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_emulator_dev</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_emulator_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1\. 分配一个input_dev结构体 */</span></span><br><span class="line">input_emulator_dev = input_allocate_device();;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2\. 设置 */</span></span><br><span class="line"><span class="comment">/* 2.1 能产生哪类事件 */</span></span><br><span class="line">set_bit(EV_KEY, input_emulator_dev-&gt;evbit);</span><br><span class="line">set_bit(EV_REP, input_emulator_dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.2 能产生所有的按键 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BITS_TO_LONGS(KEY_CNT); i++)</span><br><span class="line">    input_emulator_dev-&gt;keybit[i] = ~<span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.3 为android构造一些设备信息 */</span></span><br><span class="line">input_emulator_dev-&gt;name = <span class="string">&quot;InputEmulatorFrom100ask.net&quot;</span>;</span><br><span class="line">input_emulator_dev-&gt;id.bustype = <span class="number">1</span>;</span><br><span class="line">input_emulator_dev-&gt;id.vendor  = <span class="number">0x1234</span>;</span><br><span class="line">input_emulator_dev-&gt;id.product = <span class="number">0x5678</span>;</span><br><span class="line">input_emulator_dev-&gt;id.version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3\. 注册 */</span></span><br><span class="line">input_register_device(input_emulator_dev);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_emulator_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">input_unregister_device(input_emulator_dev);</span><br><span class="line">input_free_device(input_emulator_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(input_emulator_init);</span><br><span class="line">module_exit(input_emulator_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>测试: insmod InputEmulator.ko</p>
<p>sendevent /dev/input/event5 1 2 1 // 1 2 1 : EV_KEY, KEY_1, down sendevent /dev/input/event5 1 2 0 // 1 2 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync</p>
<p>sendevent /dev/input/event5 1 3 1 // 1 3 1 : EV_KEY, KEY_2, down sendevent /dev/input/event5 1 3 0 // 1 3 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync 通过sendevent 最后会成功输入字符1、2。</p>
<hr>
<h1 id="三、Android-Input系统"><a href="#三、Android-Input系统" class="headerlink" title="三、Android Input系统"></a>三、Android Input系统</h1><h2 id="（一）、Android-Input-系统关键类介绍"><a href="#（一）、Android-Input-系统关键类介绍" class="headerlink" title="（一）、Android Input 系统关键类介绍"></a>（一）、Android Input 系统关键类介绍</h2><p>上一节讲述了输入事件的源头是位于/dev/input/下的设备节点，而输入系统的终点是由WMS管理的某个窗口。最初的输入事件为内核生成的原始事件，而最终交付给窗口的则是KeyEvent或MotionEvent对象。因此Android输入系统的主要工作是读取设备节点中的原始事件，将其加工封装，然后派发给一个特定的窗口以及窗口中的控件。这个过程由InputManagerService（以下简称IMS）系统服务为核心的多个参与者共同完成。</p>
<p>输入系统的总体流程和参与者如图3-1所示。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N10-Android-Input-System-framwork-arc.png" alt="Markdown"></p>
<p>上图描述了输入事件的处理流程以及输入系统中最基本的参与者。它们是：</p>
<p>· <strong>Linux内核</strong>，接受输入设备的中断，并将原始事件的数据写入到设备节点中。</p>
<p>· <strong>设备节点</strong>，作为内核与IMS的桥梁，它将原始事件的数据暴露给用户空间，以便IMS可以从中读取事件。</p>
<p>· <strong>InputManagerService</strong>，一个Android系统服务，它分为Java层和Native层两部分。Java层负责与WMS的通信。而Native层则是InputReader和InputDispatcher两个输入系统关键组件的运行容器。</p>
<p>· <strong>EventHub</strong>，直接访问所有的设备节点。并且正如其名字所描述的，它通过一个名为getEvents()的函数将所有输入系统相关的待处理的底层事件返回给使用者。这些事件包括原始输入事件、设备节点的增删等。</p>
<p>· <strong>InputReader</strong>，I是IMS中的关键组件之一。它运行于一个独立的线程中，负责管理输入设备的列表与配置，以及进行输入事件的加工处理。它通过其线程循环不断地通过getEvents()函数从EventHub中将事件取出并进行处理。对于设备节点的增删事件，它会更新输入设备列表于配置。对于原始输入事件，InputReader对其进行翻译、组装、封装为包含了更多信息、更具可读性的输入事件，然后交给InputDispatcher进行派发。</p>
<p>· <strong>InputReaderPolicy</strong>，它为InputReader的事件加工处理提供一些策略配置，例如键盘布局信息等。</p>
<p>· <strong>InputDispatcher</strong>，是IMS中的另一个关键组件。它也运行于一个独立的线程中。InputDispatcher中保管了来自WMS的所有窗口的信息，其收到来自InputReader的输入事件后，会在其保管的窗口中寻找合适的窗口，并将事件派发给此窗口。</p>
<p>· <strong>InputDispatcherPolicy</strong>，它为InputDispatcher的派发过程提供策略控制。例如截取某些特定的输入事件用作特殊用途，或者阻止将某些事件派发给目标窗口。一个典型的例子就是HOME键被InputDispatcherPolicy截取到PhoneWindowManager中进行处理，并阻止窗口收到HOME键按下的事件。</p>
<p>· <strong>WMS</strong>，虽说不是输入系统中的一员，但是它却对InputDispatcher的正常工作起到了至关重要的作用。当新建窗口时，WMS为新窗口和IMS创建了事件传递所用的通道。另外，WMS还将所有窗口的信息，包括窗口的可点击区域，焦点窗口等信息，实时地更新到IMS的InputDispatcher中，使得InputDispatcher可以正确地将事件派发到指定的窗口。</p>
<p>· <strong>ViewRootImpl</strong>，对于某些窗口，如壁纸窗口、SurfaceView的窗口来说，窗口即是输入事件派发的终点。而对于其他的如Activity、对话框等使用了Android控件系统的窗口来说，输入事件的终点是控件（View）。ViewRootImpl将窗口所接收到的输入事件沿着控件树将事件派发给感兴趣的控件。</p>
<p>简单来说，内核将原始事件写入到设备节点中，InputReader不断地通过EventHub将原始事件取出来并翻译加工成Android输入事件，然后交给InputDispatcher。InputDispatcher根据WMS提供的窗口信息将事件交给合适的窗口。窗口的ViewRootImpl对象再沿着控件树将事件派发给感兴趣的控件。控件对其收到的事件作出响应，更新自己的画面、执行特定的动作。所有这些参与者以IMS为核心，构建了Android庞大而复杂的输入体系。</p>
<p>接下来详细讨论除Linux内核以外的其他参与者的工作原理。</p>
<h2 id="（二）、IMS的创建与启动"><a href="#（二）、IMS的创建与启动" class="headerlink" title="（二）、IMS的创建与启动"></a>（二）、IMS的创建与启动</h2><p>IMS分为Java层与Native层两个部分，其启动过程是从Java部分的初始化开始，进而完成Native部分的初始化。 IMS在SystemServer.startOtherServices()方法中启动的。IMS的诞生分为两个阶段：</p>
<p>· 创建新的IMS对象。</p>
<p>· 调用IMS对象的start()函数完成启动。</p>
<p>我们先看下整个启动过程的序列图，然后根据序列图来一步步分析。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N11-Android-Input-System-input-create-thread.png" alt="Markdown"></p>
<h2 id="Step-1、-SystemServer-startOtherServices"><a href="#Step-1、-SystemServer-startOtherServices" class="headerlink" title="Step 1、 SystemServer.startOtherServices()"></a>Step 1、 SystemServer.startOtherServices()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;frameworks/base/services/java/com/android/server/SystemServer.java]</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     ......</span><br><span class="line">       <span class="comment">// ① 新建IMS对象。</span></span><br><span class="line">     traceBeginAndSlog(<span class="string">&quot;StartInputManagerService&quot;</span>);</span><br><span class="line">     inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">     traceBeginAndSlog(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">     wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">             mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">             !mFirstBoot, mOnlyCore);</span><br><span class="line">      <span class="comment">//将WindowManagerService加入到ServiceManager中</span></span><br><span class="line">     ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">     <span class="comment">//将InputManagerService加入到ServiceManager中</span></span><br><span class="line">     ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">     mActivityManagerService.setWindowManager(wm);</span><br><span class="line">      <span class="comment">// 设置向WMS发起回调的callback对象</span></span><br><span class="line">     inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">     <span class="comment">// ② 正式启动IMS</span></span><br><span class="line">     inputManager.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SystemServer中先构造了一个InputManagerService对象和一个WindowManagerService对象，然后将InputManagerService对象传给WindowManagerService对象，WindowManagerService中初始化了一个InputMonitor对象，调用InputManagerService.setWindowManagerCallbacks函数将InputMonitor传进去，后面native层回调时会调用到该InputMonitor对象。</p>
<h2 id="Step-2、-InputManagerService"><a href="#Step-2、-InputManagerService" class="headerlink" title="Step 2、 InputManagerService()"></a>Step 2、 InputManagerService()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    <span class="comment">//注意这里拿了DisplayThread的Handler，意味着IMS中的消息队列处理都是在单独的DisplayThread中进行的。</span></span><br><span class="line">    <span class="comment">//它是系统中共享的单例前台线程，主要用作输入输出的处理用。这样可以使用户体验敏感的处理少受其它工作的影响，减少延时。</span></span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line">    <span class="comment">//调用nativeInit来执行C++层的初始化操作</span></span><br><span class="line">    mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line">    LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-3、-InputManagerService-nativeInit"><a href="#Step-3、-InputManagerService-nativeInit" class="headerlink" title="Step 3、 InputManagerService.nativeInit()"></a>Step 3、 InputManagerService.nativeInit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// 新建了一个NativeInputManager对象，NativeInputManager，此对象将是Native层组件与</span></span><br><span class="line">    <span class="comment">//Java层IMS进行通信的桥梁</span></span><br><span class="line">NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">        messageQueue-&gt;getLooper());</span><br><span class="line">im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 返回了NativeInputManager对象的指针给Java层的IMS，IMS将其保存在mPtr成员变量中</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要作用是创建一个NativeInputManager实例，并将其作为返回值保存在InputManagerService.java中的mPtr字段中。</p>
<h2 id="Step-4、NativeInputManager"><a href="#Step-4、NativeInputManager" class="headerlink" title="Step 4、NativeInputManager()"></a>Step 4、NativeInputManager()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">    jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">    mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 出现重点了， NativeInputManager创建了EventHub</span></span><br><span class="line"><span class="comment">//构造一个EventHub对象,最原始的输入事件都是通过它收集并且粗加工然后给到InputReader对象</span></span><br><span class="line">sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line"><span class="comment">// 接着创建了Native层的InputManager</span></span><br><span class="line">mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NativeInputManager构造函数中创建了一个EventHub实例（稍后会详细介绍），并且将这个实例作为参数来创建一个InputManager对象，这个对象会做一些初始化的操作。</p>
<h2 id="Step-5、InputManager"><a href="#Step-5、InputManager" class="headerlink" title="Step 5、InputManager()"></a>Step 5、InputManager()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,   </span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了InputDispatcher对象用于分发按键给当前focus的窗口的，同时创建了一个InputReader用于从EventHub中读取事件。</p>
<h2 id="Step-6、InputManager-initialize"><a href="#Step-6、InputManager-initialize" class="headerlink" title="Step 6、InputManager.initialize()"></a>Step 6、InputManager.initialize()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputManager::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 创建供InputReader运行的线程InputReaderThread</span></span><br><span class="line">mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">  <span class="comment">// 创建供InputDispatcher运行的线程InputDispatcherThread</span></span><br><span class="line">mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个InputReaderThread和InputDispatcherThread对象，前面构造函数中创建的InputReader实际上是通过InputReaderThread来读取事件，而InputDispatcher实际通过InputDispatcherThread来分发事件</p>
<h3 id="图3-1："><a href="#图3-1：" class="headerlink" title="图3-1："></a>图3-1：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N12-Android-Input-System-IMS-system.png" alt="Markdown"></p>
<p>InputManager的构造函数也比较简洁，它创建了四个对象，分别为IMS的核心参与者InputReader与InputDispatcher，以及它们所在的线程InputReaderThread与InputDispatcherThread。注意InputManager的构造函数的参数readerPolicy与dispatcherPolicy，它们都是NativeInputManager。</p>
<p>至此，IMS的创建完成了。在这个过程中，输入系统的重要参与者均完成创建，并得到了如图3-1所描述的一套体系。</p>
<p>依次初始化NativeInputManager，EventHub，InputManager, InputDispatcher，InputReader，InputReaderThread, InputDispatcherThread。NativeInputManager可看作IMS和InputManager的中间层，将IMS的请求转化为对InputManager及其内部对象的操作，同时将InputManager中模块的请求通过JNI调回IMS。InputManager是输入控制中心，它有两个关键线程InputReaderThread和InputDispatcherThread，它们的主要功能部分分别在InputReader和InputDispacher。前者用于从设备中读取事件，后者将事件分发给目标窗口。EventHub是输入设备的控制中心，它直接与input driver打交道。负责处理输入设备的增减，查询，输入事件的处理并向上层提供getEvents()接口接收事件。在它的构造函数中，主要做三件事（结合之前Linux必备知识）：</p>
<ol>
<li>创建epoll对象，之后就可以把各输入设备的fd挂在上面多路等待输入事件。</li>
<li>建立用于唤醒的pipe，把读端挂到epoll上，以后如果有设备参数的变化需要处理，而getEvents()又阻塞在设备上，就可以调用wake()在pipe的写端写入，就可以让线程从等待中返回。</li>
<li>利用inotify机制监听/dev/input目录下的变更，如有则意味着设备的变化，需要处理。 因为事件的处理是流水线，需要InputReader先读事件，然后InputDispatcher才能进一步处理和分发。因此InputDispatcher需要监听InputReader。这里使用了Listener模式，InputDispacher作为InputReader构造函数的第三个参数，它实现InputListenerInterface接口。到了InputReader的构造函数中，将之包装成QueuedInputListener。QueuedInputListener中的成员变量mArgsQueue是一个缓冲队列，只有在flush()时，才会一次性通知InputDispatcher。QueuedInputListener应用了Command模式，它通过包装InputDispatcher(实现InputListenerInterface接口)，将事件的处理请求封装成NotifyArgs，使其有了缓冲执行的功能。</li>
</ol>
<h2 id="IMS的成员关系"><a href="#IMS的成员关系" class="headerlink" title="IMS的成员关系"></a>IMS的成员关系</h2><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N13-Android-Input-System-IMS-membership.png" alt="Markdown"></p>
<h2 id="（三）、IMS启动"><a href="#（三）、IMS启动" class="headerlink" title="（三）、IMS启动"></a>（三）、IMS启动</h2><p>IMS启动主要是将前面创建的InputReaderThread和InputDispatcherThread启动起来</p>
<h2 id="Step-1、InputManagerService-start"><a href="#Step-1、InputManagerService-start" class="headerlink" title="Step 1、InputManagerService.start()"></a>Step 1、InputManagerService.start()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Starting input manager&quot;</span>);</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要调用了nativeStart进入native层启动</p>
<h2 id="Step-2-InputManagerService-nativeStart"><a href="#Step-2-InputManagerService-nativeStart" class="headerlink" title="Step 2. InputManagerService.nativeStart()"></a>Step 2. InputManagerService.nativeStart()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入native层InputManager的start函数</p>
<h2 id="Step-3、InputManager-start"><a href="#Step-3、InputManager-start" class="headerlink" title="Step 3、InputManager.start()"></a>Step 3、InputManager.start()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputManager::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">&quot;InputDispatcher&quot;</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">result = mReaderThread-&gt;run(<span class="string">&quot;InputReader&quot;</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实际启动了一个InputReaderThread和InputDispatcherThread来从读取和分发键盘消息，调用它们的run方法后，就会进入threadLoop函数中，只要threadLoop函数返回true，该函数就会循环执行。</p>
<p>InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件，稍后会详细介绍。</p>
<h2 id="Step-4、InputReaderThread-threadLoop"><a href="#Step-4、InputReaderThread-threadLoop" class="headerlink" title="Step 4、InputReaderThread.threadLoop()"></a>Step 4、InputReaderThread.threadLoop()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputReaderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mReader-&gt;loopOnce();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用前面创建的InputReaderThread对象的loopOnce进行一次线程循环</p>
<h2 id="Step5、InputReaderThread-loopOnce"><a href="#Step5、InputReaderThread-loopOnce" class="headerlink" title="Step5、InputReaderThread.loopOnce()"></a>Step5、InputReaderThread.loopOnce()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数</span></span><br><span class="line"><span class="comment">   当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */</span></span><br><span class="line">size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">&#123;</span><br><span class="line">   AutoMutex _l(mLock);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span>(count) &#123;</span><br><span class="line">       <span class="comment">// ② 如果有抽得事件，则调用processEventsLocked()函数对事件进行加工处理</span></span><br><span class="line">       processEventsLocked(mEventBuffer, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ③ 发布事件。 processEventsLocked()函数在对事件进行加工处理之后，便将处理后的事件存储在</span></span><br><span class="line"><span class="comment">  mQueuedListener中。在循环的最后，通过调用flush()函数将所有事件交付给InputDispatcher */</span></span><br><span class="line">  mQueuedListener-&gt;flush();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>InputReader的一次线程循环的工作思路比较清晰，一共三步：</p>
<p>· 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。</p>
<p>· 通过processEventsLocked()对事件进行处理。对于设备事件，此函数对根据设备的可用性加载或移除设备对应的配置信息。对于原始输入事件，则在进行转译、封装与加工后将结果暂存到mQueuedListener中。</p>
<p>· 所有事件处理完毕后，调用mQueuedListener.flush()将所有暂存的输入事件一次性地交付给InputDispatcher。</p>
<p>这便是InputReader的总体工作流程。而我们接下来将详细讨论这三步的实现。</p>
<h2 id="Step-6、InputDispatcherThread-threadLoop"><a href="#Step-6、InputDispatcherThread-threadLoop" class="headerlink" title="Step 6、InputDispatcherThread.threadLoop()"></a>Step 6、InputDispatcherThread.threadLoop()</h2><p>InputDisptacher的主要任务是把收到的输入事件发送到PhoneWIndowManager或App端的焦点窗口上，稍后详细介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mDispatcher-&gt;dispatchOnce();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用前面创建的InputDispatcher对象的dispatchOnce函数进行一次按键分发</p>
<h2 id="Step-7、InputDispatcher-dispatchOnce"><a href="#Step-7、InputDispatcher-dispatchOnce" class="headerlink" title="Step 7、InputDispatcher.dispatchOnce()"></a>Step 7、InputDispatcher.dispatchOnce()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    mDispatcherIsAliveCondition.broadcast();</span><br><span class="line">    <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">        dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">        nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"><span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line"><span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"><span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis)；这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。这里mLooper-&gt;pollOnce为何会睡眠涉及到Android的Handler机制[☺再总结☺]。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>完成IMS的创建之后，InputManagerService.start()函数以启动IMS。InputManager的创建过程分别为InputReader与InputDispatcher创建了承载它们运行的线程，然而并未将这两个线程启动，因此IMS的各员大将仍处于待命状态。此时start()函数的功能就是启动这两个线程，使得InputReader于InputDispatcher开始工作。</p>
<p>当两个线程启动后，InputReader在其线程循环中不断地从EventHub中抽取原始输入事件，进行加工处理后将加工所得的事件放入InputDispatcher的派发发队列中。InputDispatcher则在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。窗口事件接收线程的Looper从管道中将事件取出，交由事件处理函数进行事件响应。整个过程共有三个线程首尾相接，像三台水泵似的一层层地将事件交付给事件处理函数。如下图所示。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N14-Android-Input-System-input-event-pop.png" alt="Markdown"></p>
<p>InputManagerService.start()函数的作用，就像为Reader线程、Dispatcher线程这两台水泵按下开关，而Looper这台水泵在窗口创建时便已经处于运行状态了。自此，输入系统动力十足地开始运转，设备节点中的输入事件将被源源不断地抽取给事件处理者。</p>
<hr>
<h1 id="四、深入理解EventHub"><a href="#四、深入理解EventHub" class="headerlink" title="四、深入理解EventHub"></a>四、深入理解EventHub</h1><p>InputReaderThread继承自C++的Thread类，Thread类封装了pthread线程工具，提供了与Java层Thread类相似的API。c的Thread类提供了一个名为threadLoop()的纯虚函数，当线程开始运行后，将会在内建的线程循环中不断地调用threadLoop()，直到此函数返回false，则退出线程循环，从而结束线程。 InputReaderThread启动后，其线程循环将不断地执行InputReader.loopOnce()函数。因此这个loopOnce()函数作为线程循环的循环体包含了InputReader的所有工作。前面一小节 Step5. InputReaderThread.loopOnce() 已经说到InputReaderThread一次线程循环。接下来详细说明EventHub。</p>
<p>· 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数</span></span><br><span class="line"><span class="comment">   当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */</span></span><br><span class="line">size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先贴一张EventHub-&gt;getEvents()工作时序图，跟着时序图一步步介绍。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N15-Android-Input-System-input-reader-thread.png" alt="Markdown"></p>
<h2 id="（1）、深入理解EventHub"><a href="#（1）、深入理解EventHub" class="headerlink" title="（1）、深入理解EventHub"></a>（1）、深入理解EventHub</h2><h3 id="1、设备节点监听的建立"><a href="#1、设备节点监听的建立" class="headerlink" title="1、设备节点监听的建立"></a>1、设备节点监听的建立</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/inputflinger/EventHub.cpp</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">    mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">    mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">    mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">    mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 首先使用epoll_create()函数创建一个epoll对象。EPOLL_SIZE_HINT指定最大监听个数为8</span></span><br><span class="line"><span class="comment">//这个epoll对象将用来监听设备节点是否有数据可读（有无事件）</span></span><br><span class="line">mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 创建一个inotify对象。这个inotify对象将被用来监听设备节点的增删事件</span></span><br><span class="line">mINotifyFd = inotify_init();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将存储设备节点的路径/dev/input作为监听对象添加到inotify对象中。当此文件夹下的设备节点</span></span><br><span class="line"> <span class="comment">//发生创建与删除事件时，都可以通过mINotifyFd读取事件的详细信息</span></span><br><span class="line"> <span class="comment">//static const char *DEVICE_PATH = &quot;/dev/input&quot;;</span></span><br><span class="line"><span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">&quot;Could not register INotify for %s.  errno=%d&quot;</span>,</span><br><span class="line">        DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">//③ 接下来将mINotifyFd作为epoll的一个监控对象。当inotify事件到来时，epoll_wait()将</span></span><br><span class="line"><span class="comment">//立刻返回，EventHub便可从mINotifyFd中读取设备节点的增删信息，并作相应处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">eventItem.events = EPOLLIN;<span class="comment">// 监听mINotifyFd可读</span></span><br><span class="line">eventItem.data.u32 = EPOLL_ID_INOTIFY; <span class="comment">// 注意这里并没有使用fd字段，而使用了自定义的值EPOLL_ID_INOTIFY</span></span><br><span class="line">result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);<span class="comment">// 将对mINotifyFd的监听注册到epoll对象中</span></span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not add INotify to epoll instance.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数剩余的代码中，EventHub创建了一个名为wakeFds的匿名管道，并将管道读取端的描述符</span></span><br><span class="line"><span class="comment">//的可读事件注册到epoll对象中。因为InputReader在执行getEvents()时会因无事件而导致其线程</span></span><br><span class="line"><span class="comment">//阻塞在epoll_wait()的调用里，然而有时希望能够立刻唤醒InputReader线程使其处理一些请求。此</span></span><br><span class="line"><span class="comment">//时只需向wakeFds管道的写入端写入任意数据，此时读取端有数据可读，使得epoll_wait()得以返回</span></span><br><span class="line"><span class="comment">//从而达到唤醒InputReader线程的目的</span></span><br><span class="line"><span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">result = pipe(wakeFds);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not create wake pipe.  errno=%d&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake read pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line">result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not make wake write pipe non-blocking.  errno=%d&quot;</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line">eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> major, minor;</span><br><span class="line">getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line"><span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventHub的构造函数初识化了Epoll对象和INotify对象，分别监听原始输入事件与设备节点增删事件。同时将INotify对象的可读性事件也注册到Epoll中，因此EventHub可以像处理原始输入事件一样监听设备节点增删事件了。</p>
<p>构造函数同时也揭示了EventHub的监听工作分为设备节点和原始输入事件两个方面，接下来将深入探讨这两方面的内容。</p>
<h3 id="2、getEvents-函数的工作方式"><a href="#2、getEvents-函数的工作方式" class="headerlink" title="2、getEvents()函数的工作方式"></a>2、getEvents()函数的工作方式</h3><p>正如前文所述，InputReaderThread的线程循环为Reader子系统提供了运转的动力，EventHub的工作也是由它驱动的。InputReader::loopOnce()函数调用EventHub::getEvents()函数获取事件列表，所以这个getEvents()是EventHub运行的动力所在，几乎包含了EventHub的所有工作内容，因此首先要将getEvents()函数的工作方式搞清楚。 getEvents()函数的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span></span></span><br></pre></td></tr></table></figure>

<p>此函数将尽可能多地读取设备增删事件与原始输入事件，将它们封装为RawEvent结构体，并放入buffer中供InputReader进行处理。RawEvent结构体的定义如下： [EventHub.h–&gt;RawEvent]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RawEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> when;             <span class="comment">/* 发生事件时的时间戳 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> deviceId;        <span class="comment">//产生事件的设备Id，它是由EventHub自行分配的，InputReader</span></span><br><span class="line">                            <span class="comment">//以根据它从EventHub中获取此设备的详细信息</span></span><br><span class="line">    <span class="keyword">int32_t</span> type;             <span class="comment">/* 事件的类型 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> code;             <span class="comment">/* 事件代码 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> value;            <span class="comment">/* 事件值 */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，RawEvent结构体与getevent工具的输出十分一致，包含了原始输入事件的四个基本元素，因此用RawEvent结构体表示原始输入事件是非常直观的。RawEvent同时也用来表示设备增删事件，为此，EventHub定义了三个特殊的事件类型DEVICE_ADD、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN，用以与原始输入事件进行区别。</p>
<p>由于getEvents()函数较为复杂，为了给后续分析铺平道路，本节不讨论其细节，先通过伪代码理解此函数的结构与工作方式，在后续深入分析时思路才会比较清晰。</p>
<p><strong>getEvents()函数的本质就是读取并处理Epoll事件与INotify事件</strong></p>
<p>参考以下代码：</p>
<p>[EventHub.cpp–&gt;EventHub::getEvents()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event指针指向了在buffer下一个可用于存储事件的RawEvent结构体。每存储一个事件，</span></span><br><span class="line"><span class="comment">// event指针都回向后偏移一个元素 */</span></span><br><span class="line">RawEvent* event = buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// capacity记录了buffer中剩余的元素数量。当capacity为0时，表示buffer已满，此时需要停</span></span><br><span class="line"><span class="comment">// 继续处理新事件，并将已处理的事件返回给调用者</span></span><br><span class="line">size_tcapacity = bufferSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来的循环是getEvents()函数的主体。在这个循环中，会先将可用事件放入到buffer中并返回。</span></span><br><span class="line"><span class="comment">// 如果没有可用事件，则进入epoll_wait()等待事件的到来，epoll_wait()返回后会重新循环将可用</span></span><br><span class="line"><span class="comment">// 将新事件放入buffer</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="comment">/* ① 首先进行与设备相关的工作。某些情况下，如EventHub创建后第一次执行getEvents()函数  */</span></span><br><span class="line">    <span class="comment">/* 时，需要扫描/dev/input文件夹下的所有设备节点并将这些设备打开。另外，当设备节点的发生增  */</span></span><br><span class="line">    <span class="comment">/*  动作生时，会将设备事件存入到buffer中 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* ② 处理未被InputReader取走的输入事件与设备事件。epoll_wait()所取出的epoll_event */</span></span><br><span class="line">    <span class="comment">/* 存储在mPendingEventItems中，mPendingEventCount指定了mPendingEventItems数组 */</span></span><br><span class="line">    <span class="comment">/* 所存储的事件个数。而mPendingEventIndex指定尚未处理的epoll_event的索引 */</span></span><br><span class="line">   <span class="keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 在这里分析每一个epoll_event，如果是表示设备节点可读，则读取原始事件并放置到buffer */</span></span><br><span class="line">       <span class="comment">/* 中。如果是表示mINotifyFd可读，则设置mPendingINotify为true，当InputReader */</span></span><br><span class="line">       <span class="comment">/* 将现有的输入事件都取出后读取mINotifyFd中的事件，并进行相应的设备加载与卸载操作。 */</span></span><br><span class="line">       <span class="comment">/* 另外，如果此epoll_event表示wakeFds的读取端有数据可读，则设置awake标志为true， */</span></span><br><span class="line">       <span class="comment">/* 无论此次getEvents()调用有无取到事件，都不会再次进行epoll_wait()进行事件等待 */</span></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ③ 如果mINotifyFd有数据可读，说明设备节点发生了增删操作</span></span><br><span class="line">    <span class="keyword">if</span>(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">       <span class="comment">/* 读取mINotifyFd中的事件，同时对输入设备进行相应的加载与卸载操作。这个操作必须当 */</span></span><br><span class="line">       <span class="comment">/* InputReader将现有输入事件读取并处理完毕后才能进行，因为现有的输入事件可能来自需要 */</span></span><br><span class="line">       <span class="comment">/* 被卸载的输入设备，InputReader处理这些事件依赖于对应的设备信息 */</span></span><br><span class="line">        ......</span><br><span class="line">        deviceChanged= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设备节点增删操作发生时，则重新执行循环体，以便将设备变化的事件放入buffer中</span></span><br><span class="line">    <span class="keyword">if</span>(deviceChanged) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果此次getEvents()调用成功获取了一些事件，或者要求唤醒InputReader，则退出循环并</span></span><br><span class="line">    <span class="comment">// 结束getEvents()的调用，使InputReader可以立刻对事件进行处理</span></span><br><span class="line">    <span class="keyword">if</span>(event != buffer || awoken) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ④ 如果此次getEvents()调用没能获取事件，说明mPendingEventItems中没有事件可用， */</span></span><br><span class="line">    <span class="comment">/* 于是执行epoll_wait()函数等待新的事件到来，将结果存储到mPendingEventItems里，并重 */</span></span><br><span class="line">    <span class="comment">/* 置mPendingEventIndex为0 */</span></span><br><span class="line">   mPendingEventIndex = <span class="number">0</span>;</span><br><span class="line">   ......</span><br><span class="line">   intpollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS,timeoutMillis);</span><br><span class="line">   ......</span><br><span class="line">    mPendingEventCount= <span class="keyword">size_t</span>(pollResult);</span><br><span class="line">    <span class="comment">// 从epoll_wait()中得到新的事件后，重新循环，对新事件进行处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回本次getEvents()调用所读取的事件数量</span></span><br><span class="line">returnevent - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>getEvents()函数使用Epoll的核心是mPendingEventItems数组，它是一个事件池。getEvents()函数会优先从这个事件池获取epoll事件进行处理，并将读取相应的原始输入事件返回给调用者。当因为事件池枯竭而导致调用者无法获得任何事件时，会调用epoll_wait()函数等待新事件的到来，将事件池重新注满，然后再重新处理事件池中的Epoll事件。从这个意义来说，getEvents()函数的调用过程，就是消费epoll_wait()所产生的Epoll事件的过程。因此可以将从epoll_wait()的调用开始，到将Epoll事件消费完毕的过程称为EventHub的一个监听周期。依据每次epoll_wait()产生的Epoll事件的数量以及设备节点中原始输入事件的数量，一个监听周期包含一次或多次getEvents()调用。周期中的第一次调用会因为事件池枯竭而直接进入epoll_wait()，而周期中的最后一次调用一定会将最后的事件取走。</p>
<p>注意getEvents()采用事件池机制的根本原因是buffer的容量限制。由于一次epoll_wait()可能返回多个设备节点的可读事件，每个设备节点又有可能读取多条原始输入事件，一段时间内原始输入事件的数量可能大于buffer的容量。因此需要一个事件池以缓存因buffer容量不够而无法处理的epoll事件，以便在下次调用时可以将这些事件优先处理。这是缓冲区操作的一个常用技巧。</p>
<p>当有INotify事件可以从mINotifyFd中读取时，会产生一个epoll事件，EventHub便得知设备节点发生了增删操作。在getEvents()将事件池中的所有事件处理完毕后，便会从mINotifyFd中读取INotify事件，进行输入设备的加载/卸载操作，然后生成对应的RawEvent结构体并返回给调用者。</p>
<p>通过上述分析可以看到，getEvents()包含了原始输入事件读取、输入设备加载/卸载等操作。这几乎是EventHub的全部工作了。如果没有geEvents()的调用，EventHub将对输入事件、设备节点增删事件置若罔闻，因此可以将一次getEvents()调用理解为一次心跳，EventHub的核心功能都会在这次心跳中完成。</p>
<p>getEvents()的代码还揭示了另外一个信息：在一个监听周期内的设备增删事件与Epoll事件的优先级。设备事件的生成逻辑位于Epoll事件的处理之前，因此getEvents()将优先生成设备增删事件，完成所有设备增删事件的生成之前不会处理Epoll事件，也就是不会生成原始输入事件。</p>
<p>接下来我们将从设备管理与原始输入事件处理两个方面深入探讨EventHub。</p>
<h3 id="3、输入设备管理"><a href="#3、输入设备管理" class="headerlink" title="3、输入设备管理"></a>3、输入设备管理</h3><p>因为输入设备是输入事件的来源，并且决定了输入事件的含义，因此首先讨论EventHub的输入设备管理机制。</p>
<p>输入设备是一个可以为接收用户操作的硬件，内核会为每一个输入设备在/dev/input/下创建一个设备节点，而当输入设备不可用时（例如被拔出），将其设备节点删除。这个设备节点包含了输入设备的所有信息，包括名称、厂商、设备类型，设备的功能等。除了设备节点，某些输入设备还包含一些自定义配置，这些配置以键值对的形式存储在某个文件中。这些信息决定了Reader子系统如何加工原始输入事件。EventHub负责在设备节点可用时加载并维护这些信息，并在设备节点被删除时将其移除。</p>
<p>EventHub通过一个定义在其内部的名为Device的私有结构体来描述一个输入设备。其定义如下：</p>
<p>[EventHub.h–&gt;EventHub::Device]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Device</span> &#123;</span></span><br><span class="line">Device* next;  <span class="comment">/* Device结构体实际上是一个单链表 */</span></span><br><span class="line"><span class="keyword">int</span> fd;         <span class="comment">/* fd表示此设备的设备节点的描述符，可以从此描述符中读取原始输入事件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> id;     <span class="comment">/* id在输入系统中唯一标识这个设备，由EventHub在加载设备时进行分配 */</span></span><br><span class="line"><span class="keyword">const</span> String8 path; <span class="comment">/* path存储了设备节点在文件系统中的路径 */</span></span><br><span class="line"><span class="keyword">const</span> InputDeviceIdentifier identifier; <span class="comment">/* 厂商信息，存储了设备的供应商、型号等信息</span></span><br><span class="line"><span class="comment">                                                   这些信息从设备节点中获得 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> classes;  <span class="comment">/* classes表示了设备的类别，键盘设备，触控设备等。一个设备可以同时属于</span></span><br><span class="line"><span class="comment">                          多个设备类别。类别决定了InputReader如何加工其原始输入事件 */</span></span><br><span class="line"><span class="comment">/* 接下来是一系列的事件位掩码，它们详细地描述了设备能够产生的事件类型。设备能够产生的事件类型</span></span><br><span class="line"><span class="comment">   决定了此设备所属的类型*/</span></span><br><span class="line"><span class="keyword">uint8_t</span> keyBitmask[(KEY_MAX + <span class="number">1</span>) / <span class="number">8</span>];</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 配置信息。以键值对的形式存储在一个文件中，其路径取决于identfier字段中的厂商信息，这些</span></span><br><span class="line"><span class="comment">   配置信息将会影响InputReader对此设备的事件的加工行为 */</span></span><br><span class="line">String8 configurationFile;</span><br><span class="line">PropertyMap* configuration;</span><br><span class="line"><span class="comment">/* 键盘映射表。对于键盘类型的设备，这些键盘映射表将原始事件中的键盘扫描码转换为Android定义的</span></span><br><span class="line"><span class="comment">  的按键值。这个映射表也是从一个文件中加载的，文件路径取决于dentifier字段中的厂商信息 */</span></span><br><span class="line">   VirtualKeyMap* virtualKeyMap;</span><br><span class="line">KeyMap keyMap;</span><br><span class="line"> sp&lt;KeyCharacterMap&gt; overlayKeyMap;</span><br><span class="line"> sp&lt;KeyCharacterMap&gt; combinedKeyMap;</span><br><span class="line"><span class="comment">// 力反馈相关的信息。有些设备如高级的游戏手柄支持力反馈功能，目前暂不考虑</span></span><br><span class="line"><span class="keyword">bool</span> ffEffectPlaying;</span><br><span class="line"><span class="keyword">int16_t</span> ffEffectId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Device结构体所存储的信息主要包括以下几个方面：</p>
<p>· 设备节点信息：保存了输入设备节点的文件描述符、文件路径等。</p>
<p>· 厂商信息：包括供应商、设备型号、名称等信息，这些信息决定了加载配置文件与键盘映射表的路径。</p>
<p>· 设备特性信息：包括设备的类别，可以上报的事件种类等。这些特性信息直接影响了InputReader对其所产生的事件的加工处理方式。</p>
<p>· 设备的配置信息：包括键盘映射表及其他自定义的信息，从特定位置的配置文件中读取。</p>
<p>另外，Device结构体还存储了力反馈所需的一些数据。在本节中暂不讨论。</p>
<p>EventHub用一个名为mDevices的字典保存当前处于打开状态的设备节点的Device结构体。字典的键为设备Id。</p>
<h3 id="（1）、输入设备的加载"><a href="#（1）、输入设备的加载" class="headerlink" title="（1）、输入设备的加载"></a>（1）、输入设备的加载</h3><p>EventHub在创建后在第一次调用getEvents()函数时完成对系统中现有输入设备的加载。</p>
<p>再看一下getEvents()函数中相关内容的实现：</p>
<p>[EventHub.cpp–&gt;EventHub::getEvents()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="comment">// 处理输入设备卸载操作</span></span><br><span class="line">   ......</span><br><span class="line">    <span class="comment">/* 在EventHub的构造函数中，mNeedToScanDevices被设置为true，因此创建后第一次调用</span></span><br><span class="line"><span class="comment">      getEvents()函数会执行scanDevicesLocked()，加载所有输入设备 */</span></span><br><span class="line">    <span class="keyword">if</span>(mNeedToScanDevices) &#123;</span><br><span class="line">       mNeedToScanDevices = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/*scanDevicesLocked()将会把/dev/input下所有可用的输入设备打开并存储到Device</span></span><br><span class="line"><span class="comment">           结构体中 */</span></span><br><span class="line">       scanDevicesLocked();</span><br><span class="line">       mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">returnevent – buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载所有输入设备由scanDevicesLocked()函数完成。看一下其实现：</p>
<p>[EventHub.cpp–&gt;EventHub::scanDevicesLocked()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventHub::scanDevicesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用scanDirLocked()函数遍历/dev/input文件夹下的所有设备节点并打开</span></span><br><span class="line">status_tres = scanDirLocked(DEVICE_PATH);</span><br><span class="line">......<span class="comment">// 错误处理</span></span><br><span class="line"><span class="comment">// 打开一个名为VIRTUAL_KEYBOARD的输入设备。这个设备时刻是打开着的。它是一个虚拟的输入设</span></span><br><span class="line">   备，没有对应的输入节点。读者先记住有这么一个输入设备存在于输入系统中 */</span><br><span class="line"><span class="keyword">if</span>(mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   createVirtualKeyboardLocked();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanDirLocked()遍历指定文件夹下的所有设备节点，分别对其执行openDeviceLocked()完成设备的打开操作。在这个函数中将为设备节点创建并加载Device结构体。参考其代码：</p>
<p>[EventHub.cpp–&gt;EventHub::openDeviceLocked()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventHub::openDeviceLocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*devicePath)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 打开设备节点的文件描述符，用于获取设备信息以及读取原始输入事件</span></span><br><span class="line"><span class="keyword">int</span> fd =open(devicePath, O_RDWR | O_CLOEXEC);</span><br><span class="line"><span class="comment">// 接下来的代码通过ioctl()函数从设备节点中获取输入设备的厂商信息</span></span><br><span class="line">InputDeviceIdentifier identifier;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 分配一个设备Id并创建Device结构体</span></span><br><span class="line">int32_tdeviceId = mNextDeviceId++;</span><br><span class="line">Device*device = <span class="keyword">new</span> Device(fd, deviceId, String8(devicePath), identifier);</span><br><span class="line"><span class="comment">// 为此设备加载配置信息。</span></span><br><span class="line"> loadConfigurationLocked(device);</span><br><span class="line"> <span class="comment">// ① 通过ioctl函数获取设备的事件位掩码。事件位掩码指定了输入设备可以产生何种类型的输入事件</span></span><br><span class="line">  ioctl(fd, EVIOCGBIT(EV_KEY, <span class="keyword">sizeof</span>(device-&gt;keyBitmask)),device-&gt;keyBitmask);</span><br><span class="line">......</span><br><span class="line"> ioctl(fd, EVIOCGPROP(<span class="keyword">sizeof</span>(device-&gt;propBitmask)),device-&gt;propBitmask);</span><br><span class="line">  <span class="comment">// 接下来的一大段内容是根据事件位掩码为设备分配类别，即设置classes字段。、</span></span><br><span class="line">......</span><br><span class="line"> <span class="comment">/* ② 将设备节点的描述符的可读事件注册到Epoll中。当此设备的输入事件到来时，Epoll会在</span></span><br><span class="line"><span class="comment">  getEvents()函数的调用中产生一条epoll事件 */</span></span><br><span class="line">   structepoll_event eventItem;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">   eventItem.events = EPOLLIN;</span><br><span class="line">   eventItem.data.u32 = deviceId; <span class="comment">/* 注意，epoll_event的自定义信息是设备的Id</span></span><br><span class="line"><span class="comment">   if(epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123;</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment">     // ③ 调用addDeviceLocked()将Device添加到mDevices字典中</span></span><br><span class="line"><span class="comment">     addDeviceLocked(device);</span></span><br><span class="line"><span class="comment">     return0;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br></pre></td></tr></table></figure>

<p>openDeviceLocked()函数打开指定路径的设备节点，为其创建并填充Device结构体，然后将设备节点的可读事件注册到Epoll中，最后将新建的Device结构体添加到mDevices字典中以供检索之需。整个过程比较清晰，但仍有以下几点需要注意：</p>
<p>· openDeviceLocked()函数从设备节点中获取了设备可能上报的事件类型，并据此为设备分配了类别。整个分配过程非常繁琐，由于它和InputReader的事件加工过程关系紧密，因此这部分内容将在5.2.4节再做详细讨论。</p>
<p>· 向Epoll注册设备节点的可读事件时，epoll_event的自定义数据被设置为设备的Id而不是fd。</p>
<p>· addDeviceLocked()将新建的Device对象添加到mDevices字典中的同时也会将其添加到一个名为mOpeningDevices的链表中。这个链表保存了刚刚被加载，但尚未通过getEvents()函数向InputReader发送DEVICE_ADD事件的设备。</p>
<p>完成输入设备的加载之后，通过getEvents()函数便可以读取到此设备所产生的输入事件了。除了在getEvents()函数中使用scanDevicesLockd()一次性加载所有输入设备，当INotify事件告知有新的输入设备节点被创建时，也会通过opendDeviceLocked()将设备加载，稍后再做讨论。</p>
<h3 id="（2）、输入设备的卸载"><a href="#（2）、输入设备的卸载" class="headerlink" title="（2）、输入设备的卸载"></a>（2）、输入设备的卸载</h3><p>输入设备的卸载由closeDeviceLocked()函数完成。由于此函数的工作内容与openDeviceLocked()函数正好相反，就不列出其代码了。设备的卸载过程为：</p>
<p>· 从Epoll中注销对描述符的监听。</p>
<p>· 关闭设备节点的描述符。</p>
<p>· 从mDevices字典中删除对应的Device对象。</p>
<p>· 将Device对象添加到mClosingDevices链表中，与mOpeningDevices类似，这个链表保存了刚刚被卸载，但尚未通过getEvents()函数向InputReader发送DEVICE_REMOVED事件的设备。</p>
<p>同加载设备一样，在getEvents()函数中有根据需要卸载所有输入设备的操作（比如当EventHub要求重新加载所有设备时，会先将所有设备卸载）。并且当INotify事件告知有设备节点删除时也会调用closeDeviceLocked()将设备卸载。</p>
<h3 id="（3）、设备增删事件"><a href="#（3）、设备增删事件" class="headerlink" title="（3）、设备增删事件"></a>（3）、设备增删事件</h3><p>在分析设备的加载与卸载时发现，新加载的设备与新卸载的设备会被分别放入mOpeningDevices与mClosingDevices链表之中。这两个链表将是在getEvents()函数中向InputReader发送设备增删事件的依据。</p>
<p>参考getEvents()函数的相关代码，以设备卸载事件为例看一下设备增删事件是如何产生的：</p>
<p>[EventHub.cpp–&gt;EventHub::getEvents()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="comment">// 遍历mClosingDevices链表，为每一个已卸载的设备生成DEVICE_REMOVED事件</span></span><br><span class="line">   <span class="keyword">while</span> (mClosingDevices) &#123;</span><br><span class="line">       Device* device = mClosingDevices;</span><br><span class="line">       mClosingDevices = device-&gt;next;</span><br><span class="line">       <span class="comment">/* 分析getEvents()函数的工作方式时介绍过，event指针指向buffer中下一个可用于填充</span></span><br><span class="line"><span class="comment">          事件的RawEvent对象 */</span></span><br><span class="line">       event-&gt;when = now; <span class="comment">// 设置产生事件的事件戳</span></span><br><span class="line">       event-&gt;deviceId =</span><br><span class="line">               device-&gt;id ==mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id;</span><br><span class="line">       event-&gt;type = DEVICE_REMOVED; <span class="comment">// 设置事件的类型为DEVICE_REMOVED</span></span><br><span class="line">       event += <span class="number">1</span>; <span class="comment">// 将event指针移动到下一个可用于填充事件的RawEvent对象</span></span><br><span class="line">       <span class="keyword">delete</span> device; <span class="comment">// 生成DEVICE_REMOVED事件之后，被卸载的Device对象就不再需要了</span></span><br><span class="line">       mNeedToSendFinishedDeviceScan = <span class="literal">true</span>; <span class="comment">// 随后发送FINISHED_DEVICE_SCAN事件</span></span><br><span class="line">        <span class="comment">/* 当buffer已满则停止继续生成事件，将已生成的事件返回给调用者。尚未生成的事件</span></span><br><span class="line"><span class="comment">          将在下次getEvents()调用时生成并返回给调用者 */</span></span><br><span class="line">       <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来进行DEVICE_ADDED事件的生成，此过程与 DEVICE_REMOVED事件的生成一致</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">returnevent – buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在一次getEvents()调用中会尝试为所有尚未发送增删事件的输入设备生成对应的事件返回给调用者。表示设备增删事件的RawEvent对象包含三个信息：产生事件的事件戳、产生事件的设备Id，以及事件类型（DEVICE_ADDED或DEVICE_REMOVED）。</p>
<p>当生成设备增删事件时，会设置mNeedToSendFinishedDeviceSan为true，这个动作的意思是完成所有DEVICE_ADDED/REMOVED事件的生成之后，需要向getEvents()的调用者发送一个FINISHED_DEVICE_SCAN事件，表示设备增删事件的上报结束。这个事件仅包括时间戳与事件类型两个信息。</p>
<p>经过以上分析可知，EventHub可以产生的设备增删事件一共有三种，而且这三种事件拥有固定的优先级，DEVICE_REMOVED事件的优先级最高，DEVICE_ADDED事件次之，FINISHED_DEVICE_SCAN事件最低。而且，getEvents()完成当前高优先级事件的生成之前，不会进行低优先级事件的生成。因此，当发生设备的加载与卸载时，EventHub所生成的完整的设备增删事件序列如图5-5所示，其中R表示DEVICE_REMOVED，A表示DEVICE_ADDED，F表示FINISHED_DEVICE_SCAN。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N16-Android-Input-System-input-device-add-del.png" alt="Markdown"></p>
<p>图：设备增删事件的完整序列</p>
<p>由于参数buffer的容量限制，这个事件序列可能需要通过多次getEvents()调用才能完整地返回给调用者。另外，根据5.2.2节的讨论，设备增删事件相对于Epoll事件拥有较高的优先级，因此从R1事件开始生成到F事件生成之前，getEvents()不会处理Epoll事件，也就是说不会生成原始输入事件。</p>
<p>总结一下设备增删事件的生成原理：</p>
<p>· 当发生设备增删时，addDeviceLocked()函数与closeDeviceLocked()函数会将相应的设备放入mOpeningDevices和mClosingDevices链表中。</p>
<p>· getEvents()函数会根据mOpeningDevices和mClosingDevices两个链表生成对应DEVICE_ADDED和DEVICE_REMOVED事件，其中后者的生成拥有高优先级。</p>
<p>· DEVICE_ADDED和DEVICE_REMOVED事件都生成完毕后，getEvents()会生成FINISHED_DEVICE_SCAN事件，标志设备增删事件序列的结束。</p>
<h3 id="（4）、通过INotify动态地加载与卸载设备"><a href="#（4）、通过INotify动态地加载与卸载设备" class="headerlink" title="（4）、通过INotify动态地加载与卸载设备"></a>（4）、通过INotify动态地加载与卸载设备</h3><p>通过前文的介绍知道了openDeviceLocked()和closeDeviceLocked()可以加载与卸载输入设备。接下来分析EventHub如何通过INotify进行设备的动态加载与卸载。在EventHub的构造函数中创建了一个名为mINotifyFd的INotify对象的描述符，用以监控/dev/input下设备节点的增删。之后将mINotifyFd的可读事件加入到Epoll中。于是可以确定动态加载与卸载设备的工作方式为：首先筛选epoll_wait()函数所取得的Epoll事件，如果Epoll事件表示了mINotifyFd可读，便从mINotifyFd中读取设备节点的增删事件，然后通过执行openDeviceLocked()或closeDeviceLocked()进行设备的加载与卸载。</p>
<p>看一下getEvents()中与INotify相关的代码：</p>
<p>[EventHub.cpp–&gt;EventHub::getEvents()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   ...... <span class="comment">// 设备增删事件处理</span></span><br><span class="line">    <span class="keyword">while</span>(mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">       <span class="comment">/* ① 通过Epoll事件的data字段确定此事件表示了mINotifyFd可读</span></span><br><span class="line"><span class="comment">          注意EPOLL_ID_INOTIFY在EventHub的构造函数中作为data字段向</span></span><br><span class="line"><span class="comment">          Epoll注册mINotifyFd的可读事件 */</span></span><br><span class="line">       <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;</span><br><span class="line">           <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">               mPendingINotify = <span class="literal">true</span>; <span class="comment">// 标记INotify事件待处理</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; ...... &#125;</span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">// 继续处理下一条Epoll事件</span></span><br><span class="line">       &#125;</span><br><span class="line">       ...... <span class="comment">// 其他Epoll事件的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果INotify事件待处理</span></span><br><span class="line">    <span class="keyword">if</span>(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">       mPendingINotify = <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">/* ② 调用readNotifyLocked()函数读取并处理存储在mINotifyFd中的INotify事件</span></span><br><span class="line"><span class="comment">          这个函数将完成设备的加载与卸载 */</span></span><br><span class="line">       readNotifyLocked();</span><br><span class="line">       deviceChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//③ 如果处理了INotify事件，则返回到循环开始处，生成设备增删事件</span></span><br><span class="line">    <span class="keyword">if</span>(deviceChanged) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getEvents()函数中与INotify相关的代码共有三处：</p>
<p>· 识别表示mINotifyFd可读的Epoll事件，并通过设置mPendingINotify为true以标记有INotify事件待处理。getEvents()并没有立刻处理INotify事件，因为此时进行设备的加载与卸载是不安全的。其他Epoll事件可能包含了来自即将被卸载的设备的输入事件，因此需要将所有Epoll事件都处理完毕后再进行加载与卸载操作。</p>
<p>· 当epoll_wait()所返回的Epoll事件都处理完毕后，调用readNotifyLocked()函数读取mINotifyFd中的事件，并进行设备的加载与卸载操作。</p>
<p>· 完成设备的动态加载与卸载后，需要返回到循环最开始处，以便设备增删事件处理代码生成设备的增删事件。</p>
<p>其中第一部分与第三部分比较容易理解。接下来看一下readNotifyLocked()是如何工作的。</p>
<p>[EventHub.cpp–&gt;EventHub::readNotifyLocked()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventHub::readNotifyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 从mINotifyFd中读取INotify事件列表</span></span><br><span class="line">    res =read(mINotifyFd, event_buf, <span class="keyword">sizeof</span>(event_buf));</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 逐个处理列表中的事件</span></span><br><span class="line">       <span class="keyword">while</span>(res &gt;= (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">       <span class="built_in">strcpy</span>(filename, event-&gt;name); <span class="comment">// 从事件中获取设备节点路径</span></span><br><span class="line">       <span class="keyword">if</span>(event-&gt;mask &amp; IN_CREATE) &#123;</span><br><span class="line">           openDeviceLocked(devname); <span class="comment">// 如果事件类型为IN_CREATE，则加载对应设备</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           closeDeviceByPathLocked(devname); <span class="comment">// 否则卸载对应设备</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">// 移动到列表中的下一个事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）、EventHub设备管理总结"><a href="#（5）、EventHub设备管理总结" class="headerlink" title="（5）、EventHub设备管理总结"></a>（5）、EventHub设备管理总结</h3><p>至此，EventHub的设备管理相关的知识便讨论完毕了。在这里进行一下总结：</p>
<p>· EventHub通过Device结构体描述输入设备的各种信息。</p>
<p>· EventHub在getEvents()函数中进行设备的加载与卸载操作。设备的加载与卸载分为按需加载或卸载以及通过INotify动态加载或卸载特定设备两种方式。</p>
<p>· getEvents()函数进行了设备的加载与卸载操作后，会生成DEVICE_ADDED、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN三种设备增删事件，并且设备增删事件拥有高于Epoll事件的优先级。 4．原始输入事件的监听与读取 本节将讨论EventHub另一个核心的功能，监听与读取原始输入事件。</p>
<p>回忆一下输入设备的加载过程，当设备加载时，openDeviceLocked()会打开设备节点的文件描述符，并将其可读事件注册进Epoll中。于是当设备的原始输入事件到来时，getEvents()函数将会获得一条Epoll事件，然后根据此Epoll事件读取文件描述符中的原始输入事件，将其填充到RawEvents结构体并放入buffer中被调用者取走。openDeviceLocked()注册了设备节点的EPOLLIN和EPOLLHUP两个事件，分别表示可读与被挂起（不可用），因此getEvents()需要分别处理这两种事件。</p>
<p>看一下getEvents()函数中的相关代码：</p>
<p>[EventHub.cpp–&gt;EventHub::getEvents()]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">EventHub::getEvents</span><span class="params">(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   ...... <span class="comment">// 设备增删事件处理</span></span><br><span class="line">    <span class="keyword">while</span>(mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">       ...... <span class="comment">// INotify与wakeFd的Epoll事件处理</span></span><br><span class="line">       <span class="comment">/* ① 通过Epoll的data.u32字段获取设备Id，进而获取对应的Device对象。如果无法找到</span></span><br><span class="line"><span class="comment">          对应的Device对象，说明此Epoll事件并不表示原始输入事件的到来，忽略之 */</span></span><br><span class="line">       <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);</span><br><span class="line">       Device* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">           <span class="comment">/* ② 如果Epoll事件为EPOLLIN，表示设备节点有原始输入事件可读。此时可以从描述符</span></span><br><span class="line"><span class="comment">              中读取。读取结果作为input_event结构体并存储在readBuffer中，注意事件的个数</span></span><br><span class="line"><span class="comment">               受到capacity的限制*/</span></span><br><span class="line">           <span class="keyword">int32_t</span> readSize = read(device-&gt;fd, readBuffer,</span><br><span class="line">                    <span class="keyword">sizeof</span>(structinput_event) * capacity);</span><br><span class="line">           <span class="keyword">if</span> (......) &#123;                    ......<span class="comment">// 一些错误处理 &#125;</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">size_t</span> count = <span class="keyword">size_t</span>(readSize) / <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">               <span class="comment">/* ② 将读取到的每一个input_event结构体中的数据转换为一个RawEvent对象，</span></span><br><span class="line"><span class="comment">                   并存储在buffer参数中以返回给调用者 */</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> structinput_event&amp; iev = readBuffer[i];</span><br><span class="line">                    ......</span><br><span class="line">                    event-&gt;when = now;</span><br><span class="line">                    event-&gt;deviceId =deviceId;</span><br><span class="line">                    event-&gt;type =iev.type;</span><br><span class="line">                    event-&gt;code =iev.code;</span><br><span class="line">                    event-&gt;value =iev.value;</span><br><span class="line">                   event += <span class="number">1</span>; <span class="comment">// 移动到buffer的下一个可用元素</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/* 接下来的一个细节需要注意，因为buffer的容量限制，可能无法完全读取设备节点</span></span><br><span class="line"><span class="comment">                   中存储的原始事件。一旦buffer满了则需要立刻返回给调用者。设备节点中剩余的</span></span><br><span class="line"><span class="comment">                   输入事件将在下次getEvents()调用时继续读取，也就是说，当前的Epoll事件</span></span><br><span class="line"><span class="comment">                   并未处理完毕。mPendingEventIndex -= 1的目的就是使下次getEvents()调用</span></span><br><span class="line"><span class="comment">                   能够继续处理这个Epoll事件 */</span></span><br><span class="line">               capacity -= count;</span><br><span class="line">               <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                    mPendingEventIndex -=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventItem.events &amp; EPOLLHUP) &#123;</span><br><span class="line">           deviceChanged = <span class="literal">true</span>; <span class="comment">// 如果设备节点的文件描述符被挂起则卸载此设备</span></span><br><span class="line">           closeDeviceLocked(device);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; ...... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...... <span class="comment">// 读取并处理INotify事件</span></span><br><span class="line">    ......<span class="comment">// 等待新的Epoll事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> event – buffer；&#125;</span><br></pre></td></tr></table></figure>

<p>getEvents()通过Epoll事件的data.u32字段在mDevices列表中查找已加载的设备，并从设备的文件描述符中读取原始输入事件列表。从文件描述符中读取的原始输入事件存储在input_event结构体中，这个结构体的四个字段存储了事件的事件戳、类型、代码与值四个元素。然后逐一将input_event的数据转存到RawEvent中并保存至buffer以返回给调用者。</p>
<p>注意为了叙述简单，上述代码使用了调用getEvents()的时间作为输入事件的时间戳。由于调用getEvents()函数的时机与用户操作的时间差的存在，会使得此时间戳与事件的真实时间有所偏差。从设备节点中读取的input_event中也包含了一个时间戳，这个时间戳消除了getEvents()调用所带来的时间差，因此可以获得更精确的时间控制。可以通过打开HAVE_POSIX_CLOCKS宏以使用input_event中的时间而不是将getEvents()调用的时间作为输入事件的时间戳。</p>
<p>需要注意的是，由于Epoll事件的处理优先级低于设备增删事件，因此当发生设备加载与卸载动作时，不会产生设备输入事件。另外还需注意，在一个监听周期中，getEvents()在将一个设备节点中的所有原始输入事件读取完毕之前，不会读取其他设备节点中的事件。</p>
<h3 id="5、EventHub总结"><a href="#5、EventHub总结" class="headerlink" title="5、EventHub总结"></a>5、EventHub总结</h3><p>本节针对EventHub的设备管理与原始输入事件的监听读取两个核心内容介绍了EventHub的工作原理。EventHub作为直接操作设备节点的输入系统组件，隐藏了INotify与Epoll以及设备节点读取等底层操作，通过一个简单的接口getEvents()向使用者提供抽取设备事件与原始输入事件的功能。EventHub的核心功能都在getEvents()函数中完成，因此深入理解getEvents()的工作原理对于深入理解EventHub至关重要。</p>
<p>getEvents()函数的本质是通过epoll_wait()获取Epoll事件到事件池，并对事件池中的事件进行消费的过程。从epoll_wait()的调用开始到事件池中最后一个事件被消费完毕的过程称之为EventHub的一个监听周期。由于buffer参数的尺寸限制，一个监听周期可能包含多个getEvents()调用。周期中的第一个getEvents()调用一定会因事件池的枯竭而直接进行epoll_wait()，而周期中的最后一个getEvents()一定会将事件池中的最后一条事件消费完毕并将事件返回给调用者。前文所讨论的事件优先级都是在同一个监听周期内而言的。</p>
<p>在本节中出现了很多种事件，有原始输入事件、设备增删事件、Epoll事件、INotify事件等，存储事件的结构体有RawEvent、epoll_event、inotify_event、input_event等。图5-6可以帮助读者理清这些事件之间的关系。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N17-Android-Input-System-epoll.png" alt="Markdown"></p>
<p>图 5-6 EventHub的事件关联</p>
<p>另外，getEvents()函数返回的事件列表依照事件的优先级拥有特定的顺序。并且在一个监听周期中，同一输入设备的输入事件在列表中是相邻的。</p>
<p>至此，相信读者对EventHub的工作原理，以及EventHub的事件监听与读取机制有了深入的了解。接下来的内容将讨论EventHub所提供的原始输入事件如何被加工为Android输入事件，这个加工者就是Reader子系统中的另一员大将：InputReader。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N18-Android-Input-System-EventHub-Kernel.png" alt="Markdown"></p>
<hr>
<h2 id="五、Input-Reader"><a href="#五、Input-Reader" class="headerlink" title="五、Input Reader"></a>五、Input Reader</h2><p>根据第四节的分析。输入设备扫描完成，并加入epoll中，监听事件。从前面的getEvents函数分析得知，当按键事件发生后，getEvents函数返回。 这里再贴一下Input 处理时间流程图，然后按步骤详细分析。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N15-Android-Input-System-input-reader-thread.png" alt="Markdown"></p>
<p>以一次键盘按键为例，得到下面的6个事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">4</span>, code=<span class="number">4</span>, value=<span class="number">458792</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">1</span>, code=<span class="number">28</span>, value=<span class="number">1</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">0</span>, code=<span class="number">0</span>, value=<span class="number">0</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">4</span>, code=<span class="number">4</span>, value=<span class="number">458792</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">1</span>, code=<span class="number">28</span>, value=<span class="number">0</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">0</span>, code=<span class="number">0</span>, value=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上面的type是linux的输入系统里的事件，具体的值可以查看 查看input.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SYN 0x00   同步事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01   按键事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02   相对坐标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03   绝对坐标</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_MSC 0x04   其它</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SW  0x05   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_LED 0x11   LED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SND 0x12   声音</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REP 0x14   Repeat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_FF  0x15   力反馈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PWR 0x16   电源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_FF_STATUS 0x17 状态</span></span><br></pre></td></tr></table></figure>

<p>上面6个事件，只有两个type为1的事件，是我们需要处理的按键事件，一个down，一个up</p>
<h2 id="Step-1、-InputReader-loopOnce"><a href="#Step-1、-InputReader-loopOnce" class="headerlink" title="Step 1、 InputReader::loopOnce()"></a>Step 1、 InputReader::loopOnce()</h2><p>返回到InputReader的loopOnce函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">// acquire lock</span></span><br><span class="line">      AutoMutex _l(mLock);</span><br><span class="line">      mReaderIsAliveCondition.broadcast();</span><br><span class="line">      <span class="comment">//当有按键事件发生时，count将不为0，以一次按键为例，这里应该是6个事件</span></span><br><span class="line">      <span class="keyword">if</span> (count) &#123;</span><br><span class="line">          processEventsLocked(mEventBuffer, count);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">// release lock</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当有按键事件发生时，count将不为0，之后会调用processEventsLocked来处理RawEvent。</p>
<h2 id="Step-2、InputReader-processEventsLocked"><a href="#Step-2、InputReader-processEventsLocked" class="headerlink" title="Step 2、InputReader.processEventsLocked()"></a>Step 2、InputReader.processEventsLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::processEventsLocked</span><span class="params">(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">  <span class="keyword">int32_t</span> type = rawEvent-&gt;type;</span><br><span class="line">  <span class="keyword">size_t</span> batchSize = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">      <span class="keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">      <span class="comment">//依次处理rawEvent</span></span><br><span class="line">      processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">  &#125;</span><br><span class="line">  count -= batchSize;</span><br><span class="line">  rawEvent += batchSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用processEventsForDeviceLocked依次处理rawEvent</p>
<h2 id="Step-3、InputReader-processEventsForDeviceLocked"><a href="#Step-3、InputReader-processEventsForDeviceLocked" class="headerlink" title="Step 3、InputReader.processEventsForDeviceLocked()"></a>Step 3、InputReader.processEventsForDeviceLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::processEventsForDeviceLocked</span><span class="params">(<span class="keyword">int32_t</span> deviceId,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">  InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">  <span class="comment">//调用InputDevice的process函数</span></span><br><span class="line">  device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据deviceId获取到InputDevice，然后调用InputDevice的process函数</p>
<h2 id="Step-4、InputDevice-process"><a href="#Step-4、InputDevice-process" class="headerlink" title="Step 4、InputDevice.process()"></a>Step 4、InputDevice.process()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDevice::process</span><span class="params">(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> numMappers = mMappers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDropUntilNextSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;    </span><br><span class="line">            InputMapper* mapper = mMappers[i];  </span><br><span class="line">            <span class="comment">// InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey，</span></span><br><span class="line">            <span class="comment">// 传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算</span></span><br><span class="line">            <span class="comment">// 每个触摸点分别属于哪条轨迹，安卓系统中每种输入设备都对应了一种Mapper,比如</span></span><br><span class="line">            <span class="comment">// SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper</span></span><br><span class="line">            mapper-&gt;process(rawEvent);           </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mMappers成员变量保存了一系列输入设备事件处理对象，例如负责处理键盘事件的KeyboardKeyMapper对象以及负责处理触摸屏事件的TouchInputMapper对象， 它们是在InputReader类的成员函数createDeviceLocked中创建的。这里查询每一个InputMapper对象是否要对当前发生的事件进行处理。由于发生的是键盘事件，真正会对该事件进行处理的只有KeyboardKeyMapper对象。</p>
<h2 id="Step-5、KeyboardInputMapper-process"><a href="#Step-5、KeyboardInputMapper-process" class="headerlink" title="Step 5、KeyboardInputMapper.process()"></a>Step 5、KeyboardInputMapper.process()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyboardInputMapper::process</span><span class="params">(<span class="keyword">const</span> RawEvent* rawEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode = rawEvent-&gt;code;</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> keyCode;</span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用EventHub中的mapKey函数进行转化</span></span><br><span class="line">            <span class="comment">// 传入参数</span></span><br><span class="line">            <span class="comment">// scanCode：驱动程序上报的扫描码；keyCode：转化之后的Android使用的按键值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123;</span><br><span class="line">                keyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">                flags = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//映射成功之后，处理该按键</span></span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, keyCode, scanCode, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_MSC: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == MSC_SCAN) &#123;</span><br><span class="line">            mCurrentHidUsage = rawEvent-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_SYN: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">            mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先调用isKeyboardOrGamepadKey来判断键盘扫描码是否正确，如果正确则调用processKey来进一步处理</p>
<h2 id="Step-6、KeyboardInputMapper-processKey"><a href="#Step-6、KeyboardInputMapper-processKey" class="headerlink" title="Step 6、KeyboardInputMapper.processKey()"></a>Step 6、KeyboardInputMapper.processKey()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KeyboardInputMapper::processKey</span><span class="params">(<span class="keyword">nsecs_t</span> when, <span class="keyword">bool</span> down, <span class="keyword">int32_t</span> keyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> scanCode, <span class="keyword">uint32_t</span> policyFlags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理    </span></span><br><span class="line">    <span class="comment">// NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function">NotifyKeyArgs <span class="title">args</span><span class="params">(when, getDeviceId(), mSource, policyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span></span></span><br><span class="line"><span class="function"><span class="params">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime)</span></span>;</span><br><span class="line">     <span class="comment">// 通知Listener处理，Dispatch线程会监听该事件，并处理，下次博文会具体分析</span></span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先对按键作一些处理，根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理</p>
<p>最后函数会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NotifyKeyArgs <span class="title">args</span><span class="params">(when, getDeviceId(), mSource, policyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span></span></span><br><span class="line"><span class="function"><span class="params">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime)</span></span>;</span><br><span class="line"></span><br><span class="line">getListener()-&gt;notifyKey(&amp;args);</span><br></pre></td></tr></table></figure>

<p>这里getListener是InputReader初始化时传入的对象，即QueuedInputListener，则会调用QueuedInputListener的notifyKey函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span> </span>&#123;</span><br><span class="line">mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">    args-&gt;notify(mInnerListener);</span><br><span class="line">    <span class="keyword">delete</span> args;</span><br><span class="line">&#125;</span><br><span class="line">mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyConfigurationChangedArgs::notify</span><span class="params">(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">listener-&gt;notifyConfigurationChanged(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以按键事件为例，由于InputDispatcher 实现了InputListenerInterface接口的notifyConfigurationChanged()函数，所以最后会调用到InputDispatcher的notifyKey()函数中。</p>
<h2 id="Step-7、-InputDispatcher-notifyKey"><a href="#Step-7、-InputDispatcher-notifyKey" class="headerlink" title="Step 7、 InputDispatcher.notifyKey()"></a>Step 7、 InputDispatcher.notifyKey()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::notifyKey</span><span class="params">(<span class="keyword">const</span> NotifyKeyArgs* args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 构造一个KeyEvent对象</span></span><br><span class="line">KeyEvent event;</span><br><span class="line">event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">        flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">        args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"><span class="comment">// 调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数</span></span><br><span class="line">mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> needWake;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    mLock.lock();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列</span></span><br><span class="line">    KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">            args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">            args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">            metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">    needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">    mLock.unlock();</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数首先调用validateKeyEvent来判断是否是有效按键事件，实际判断是否是UP/DOWN事件</p>
<p>然后构造一个KeyEvent对象，调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"></span><br><span class="line">    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br></pre></td></tr></table></figure>

<p>之后会调用构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列，如果返回true，则调用mLooper.wake函数唤醒等待的InputDispatcher，进行按键分发。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">needWake = enqueueInboundEventLocked(newEntry);</span><br></pre></td></tr></table></figure>

<h2 id="Step-8、InputDispatcher-enqueueInboundEventLocked"><a href="#Step-8、InputDispatcher-enqueueInboundEventLocked" class="headerlink" title="Step 8、InputDispatcher.enqueueInboundEventLocked()"></a>Step 8、InputDispatcher.enqueueInboundEventLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::enqueueInboundEventLocked</span><span class="params">(EventEntry* entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(entry);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchKeyEventLocked(keyEntry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;</span><br><span class="line">                mAppSwitchSawKeyDown = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAppSwitchSawKeyDown) &#123;</span><br><span class="line">                    mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT;</span><br><span class="line">                    mAppSwitchSawKeyDown = <span class="literal">false</span>;</span><br><span class="line">                    needWake = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将EventEntry加入到mInboundQueue中，该函数两种情况下会返回true,一是当加入该键盘事件到mInboundQueue之前，mInboundQueue为空，这表示InputDispatc herThread线程正在睡眠等待InputReaderThread线程的唤醒，因此，它返回true表示要唤醒InputDispatccherThread线程；二是加入该键盘事件到mInboundQueue之前，mInboundQueue不为空，但是此时用户按下的是Home键等需要切换APP的按键，我们知道，在切换App时，新的App会把它的键盘消息接收通道注册到InputDispatcher中去，并且会等待InputReader的唤醒，因此，在这种情况下，也需要返回true，表示要唤醒InputDispatccherThread线程。如果不是这两种情况，那么就说明InputDispatccherThread线程现在正在处理前面的键盘事件，不需要唤醒它。</p>
<p>至此，InputDispatcherThread被唤醒，开始进行按键分发。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件。第一次进入时会扫描/dev/input目录建立设备列表，存在mDevice成员变量中(EventHub中有设备列表KeyedVector</p>
<p>&lt;int32_t, device*=””&gt; mDevices；对应的，InputReader中也有设备列表KeyedVector&lt;int32_t, inputdevice*=””&gt; mDevices。这里先添加到前者，然后会在InputReader::addDeviceLocked()中添加到后者。)，同时将增加的fd加到epoll的等待集合中。在接下来的epoll_wait()等待时，如果有事件就会返回，同时返回可读事件数量。在这里，从Input driver读出的事件从原始的input_event结构转为RawEvent结构，放到getEvents()的输出参数buffer中。getEvents()返回后，InputReader调用processEventsLocked()处理事件，对于设备改变，会根据实际情况调用addDeviceLocked(), removeDeviceLocked()和handleConfigurationChangedLocked()。对于其它设备中来的输入事件，会调用processEventsForDeviceLocked()进一步处理。其中会根据当时注册的InputMapper对事件进行处理，然后将事件处理请求放入缓冲队列（QueuedInputListener中的mArgsQueue）。&lt;/int32_t,&gt;&lt;/int32_t,&gt;</p>
<p>InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey，传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算每个触摸点分别属于哪条轨迹，这本质上是个二分图匹配问题，这也是在InputMapper中完成的。回到流程主线上，在InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口。</p>
<p>以按键事件为例，最后会调用到InputDispatcher的notifyKey()函数中。这里先将参数封装成KeyEvent： 然后把它作为参数调用NativeInputManager的interceptKeyBeforeQueueing()函数。顾名思义，就是在放到待处理队列前看看是不是需要系统处理的系统按键，它会通过JNI调回Java世界，最终调到PhoneWindowManager的interceptKeyBeforeQueueing()。然后，基于输入事件信息创建KeyEntry对象，调用enqueueInboundEventLocked()将之放入队列等待InputDiaptcherThread线程拿出处理。</p>
<h2 id="六、Input-Dispatcher"><a href="#六、Input-Dispatcher" class="headerlink" title="六、Input Dispatcher"></a>六、Input Dispatcher</h2><p>InputDisptacher的主要任务是把前面收到的输入事件发送到PWM及App端的焦点窗口。前面提到InputReaderThread中收到事件后会调用notifyKey()来通知InputDispatcher，也就是放在mInboundQueue中，在InputDispatcher的dispatchOnce()函数中，会从这个队列拿出处理。</p>
<p>其中dispatchOnceInnerLocked()会根据拿出的EventEntry类型调用相应的处理函数，以Key事件为例会调用dispatchKeyLocked()</p>
<p>它会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。 总体流程图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N19-Android-Input-System-InputDispatcher-structure.png" alt="Markdown"></p>
<p>再贴一张详细的总体流程图，然后根据步骤详细分析；</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N20-Android-Input-System-input-dispatcher-thread.png" alt="Markdown"></p>
<h2 id="Step-1、InputDispatcher-dispatchOnce"><a href="#Step-1、InputDispatcher-dispatchOnce" class="headerlink" title="Step 1、InputDispatcher.dispatchOnce()"></a>Step 1、InputDispatcher.dispatchOnce()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">    <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">    <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">        dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">    <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">        nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line"><span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"><span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis);这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。</p>
<h2 id="Step-2、InputDispatcher-dispatchOnceInnerLocked"><a href="#Step-2、InputDispatcher-dispatchOnceInnerLocked" class="headerlink" title="Step 2、InputDispatcher.dispatchOnceInnerLocked()"></a>Step 2、InputDispatcher.dispatchOnceInnerLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don&#x27;t already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="comment">//当InputReader往队列中插入了一个读取的键盘消息后，此处的mInboundQueue就不为空</span></span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line"></span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        ...</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前文InputReader读取键盘消息过程分析 InputReader读取到一个消息后会调用KeyboardInputMapper的processKey，该函数会调用InputDispatcher的notifyKey函数，然后InputDispatcher会调用enqueueInboundEventLocked函数，将EventEntry加入到mInboundQueue中，然后调用mLooper-&gt;wake函数会唤醒InputDispatcherThread线程，InputDispatcher中把队列的第一个事件取出来，因为这里是键盘事件，所以mPendingEvent-&gt;type是EventEntry::TYPE_KEY，然后调用dispatchKeyLocked函数</p>
<p>惯例先贴出序列图，按步骤一步步介绍。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N21-Android-Input-System-dispatch-input-event.png" alt="Markdown"></p>
<h2 id="Step-3、InputDispatcher-dispatchKeyLocked"><a href="#Step-3、InputDispatcher-dispatchKeyLocked" class="headerlink" title="Step 3、InputDispatcher.dispatchKeyLocked()"></a>Step 3、InputDispatcher.dispatchKeyLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchKeyLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span></span></span><br><span class="line"><span class="function"><span class="params">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Give the policy a chance to intercept the key.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">                    &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    ......</span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    ......</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数主要做了下面三件事 A. 如果按键是第一次分发，则将命令封装为CommandEntry加入队列，后续执行doInterceptKeyBeforeDispatchingLockedInterruptible，以给java层拦截按键的机会 B. 找到当前激活的Window窗口，并将其加入到Vector中，Android ANR就是在findFocusedWindowTargetsLocked()检测的 C. 找到需要主动监听按键的InputChannel,封装成InputTarget，加入到Vector中 D. 将按键分发到上面的Vector中的InputChannel中，这里存在多个</p>
<p>下面先分析如果将按键分发给InputChannel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">    <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">    <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">      &#125; ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-5、InputDispatcher-prepareDispatchCycleLocked"><a href="#Step-5、InputDispatcher-prepareDispatchCycleLocked" class="headerlink" title="Step 5、InputDispatcher.prepareDispatchCycleLocked()"></a>Step 5、InputDispatcher.prepareDispatchCycleLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>函数前面还有一些状态检查，这里默认都是通过的。最后enqueueDispatchEntriesLocked函数进行将connection分装成DispatchEntry，加入到connection-&gt;outboundQueue的队列中</p>
<h2 id="Step-6-InputDispatcher-enqueueDispatchEntriesLocked"><a href="#Step-6-InputDispatcher-enqueueDispatchEntriesLocked" class="headerlink" title="Step 6. InputDispatcher::enqueueDispatchEntriesLocked()"></a>Step 6. InputDispatcher::enqueueDispatchEntriesLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    ......</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先获取以前的connection的outboundQueue是否为空，然后将该事件调用enqueueDispatchEntryLocked将事件加入到outboundQueue中，如果以前为空，现在不为空，则调用startDispatchCycleLocked开始分发，如果以前的outboundQueue不为空，说明当前的Activity正在处理前面的按键，则不需要再调用startDispatchCycleLocked，因为只要开始处理，会等到队列为空才会停止。</p>
<h2 id="Step-7、InputDispatcher-startDispatchCycleLocked"><a href="#Step-7、InputDispatcher-startDispatchCycleLocked" class="headerlink" title="Step 7、InputDispatcher.startDispatchCycleLocked()"></a>Step 7、InputDispatcher.startDispatchCycleLocked()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">        &#125;<span class="comment">//end of while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数从outboundQueue中取出需要处理的键盘事件，交给connection的inputPublisher去分发，之后将事件加入到connection的waitQueue中。分发事件是通过InputPublisher的publishKeyEvent来完成的。</p>
<h2 id="Step-8、InputPublisher-publishKeyEvent"><a href="#Step-8、InputPublisher-publishKeyEvent" class="headerlink" title="Step 8、InputPublisher.publishKeyEvent"></a>Step 8、InputPublisher.publishKeyEvent</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputPublisher::publishKeyEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> seq,<span class="keyword">int32_t</span> deviceId,<span class="keyword">int32_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> action,<span class="keyword">int32_t</span> flags,<span class="keyword">int32_t</span> keyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> scanCode,<span class="keyword">int32_t</span> metaState,<span class="keyword">int32_t</span> repeatCount,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> downTime,<span class="keyword">nsecs_t</span> eventTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_KEY;</span><br><span class="line">    ......</span><br><span class="line">    msg.body.key.eventTime = eventTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要是将各个参数封装到InputMessage中，然后交给mChannel对象去分发 mChannel其实是socketpair的server端，其实就是创建的服务器InputChannel，其创建过程稍后详细分析。</p>
<h2 id="Step-9、InputChannel-sendMessage"><a href="#Step-9、InputChannel-sendMessage" class="headerlink" title="Step 9、InputChannel.sendMessage()"></a>Step 9、InputChannel.sendMessage()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputChannel::sendMessage</span><span class="params">(<span class="keyword">const</span> InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要是通过send函数往socketpair的server端写入InputMessage对象，应用程序这一侧正睡眠在client端的fd上，此时client端就会收到该InputMessage，client会进行按键按键分发，应用程序这一侧的按键分发请看下一节。</p>
<h2 id="七、App注册消息监听过程分析"><a href="#七、App注册消息监听过程分析" class="headerlink" title="七、App注册消息监听过程分析"></a>七、App注册消息监听过程分析</h2><p>总体流程图 InputDispatcher会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。 在App端，新的顶层窗口需要被注册到WMS中，这是在ViewRootImpl::setView()中做的。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N22-Android-Input-System-inputchannel.png" alt="Markdown"></p>
<h2 id="Step-1、ViewRootImpl-setView"><a href="#Step-1、ViewRootImpl-setView" class="headerlink" title="Step 1、ViewRootImpl.setView()"></a>Step 1、ViewRootImpl.setView()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用requestLayout来通知InputManagerService当前的窗口是激活的窗口</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该窗口没有指定INPUT_FEATURE_NO_INPUT_CHANNEL属性，则创建消息接收通道InputChannel</span></span><br><span class="line">        mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过binder调用，调用server端的Session对象来跟WindowManagerService通信，该函数最后会调      </span></span><br><span class="line">        <span class="comment">// 用到WindowManagerService的addWindow函数，函数中会创建一对InputChannel(server/client)，</span></span><br><span class="line">        <span class="comment">// 这样在函数调用结束后，mInputChannel就变成了client端的对象。在</span></span><br><span class="line">        <span class="comment">// frameworks/base/core/java/android/view/IWindowSession.aidl的</span></span><br><span class="line">        <span class="comment">// addToDisplay函数的声明中，InputChannel指定的数据流的流向是out，因此</span></span><br><span class="line">        <span class="comment">// WindowManagerService修改了mInputChannel,客户端就能拿到这个对象的数据了。</span></span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">             getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">             mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">            mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">            <span class="comment">// 初始化WindowInputEventReceiver，按键消息会从native层传到该对象的onInputEvent函数</span></span><br><span class="line">            <span class="comment">// 中，onInputEvent函数是按键在应用端java层分发的起始端。</span></span><br><span class="line">            mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数与注册键盘消息通道的相关主要有三个功能： 一是调用requestLayout函数来通知InputManagerService，这个Activity窗口是当前被激活的窗口,同时将所有的窗口注册到InputDispatcher中 二是调用mWindowSession的add成员函数来把键盘消息接收通道的server端注册端注册到CPP层的InputManagerService中，client端注册到本应用程序的消息循环Looper中，这样当InputManagerService监控到有键盘消息的时候，就会找到当前被激活的窗口，然后找到其在InputManagerService中对应的键盘消息接收通道(InputChannel)，通过这个通道在InputManagerService的server端来通知应用程序消息循环的client端，这样就把键盘消息分发给当前激活的Activity窗口了 三是应用程序这一侧注册消息接收通道</p>
<h2 id="Step-2、ViewRootImpl-requestLayout"><a href="#Step-2、ViewRootImpl-requestLayout" class="headerlink" title="Step 2、ViewRootImpl.requestLayout()"></a>Step 2、ViewRootImpl.requestLayout()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了scheduleTraversals函数来做进一步的操作，该函数调用mChoreographer来post一个Runnable到Looper中，之后Vsycn信号到来会执行mTraversalRunnable中的run方法，即调用doTraversal函数</p>
<p>参考文档：<strong>【Android 7.1.2(Android N) Activity-Window加载显示流程】</strong></p>
<h2 id="Step-3、ViewRootImpl-doTraversal"><a href="#Step-3、ViewRootImpl-doTraversal" class="headerlink" title="Step 3、ViewRootImpl.doTraversal()"></a>Step 3、ViewRootImpl.doTraversal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要是执行performTraversals()函数，进而调用relayoutWindow函数，在该函数中又会调用mWindowSession的relayout进入到java层的WindowManagerService的relayoutWindow函数，该函数会调用mInputMonitor.updateInputWindowsLw(true /force/);mInputMonitor是InputMonitor对象。</p>
<h2 id="Step-4、InputMonitor-updateInputWindowsLw"><a href="#Step-4、InputMonitor-updateInputWindowsLw" class="headerlink" title="Step 4、InputMonitor.updateInputWindowsLw()"></a>Step 4、InputMonitor.updateInputWindowsLw()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateInputWindowsLw</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> addInputConsumerHandle = mService.mInputConsumer != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add all windows on the default display.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mService.mDisplayContents.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">    WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> winNdx = windows.size() - <span class="number">1</span>; winNdx &gt;= <span class="number">0</span>; --winNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState child = windows.get(winNdx);</span><br><span class="line">        <span class="keyword">final</span> InputChannel inputChannel = child.mInputChannel;</span><br><span class="line">        <span class="keyword">final</span> InputWindowHandle inputWindowHandle = child.mInputWindowHandle;</span><br><span class="line">        ......</span><br><span class="line">        addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus,</span><br><span class="line">                hasWallpaper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send windows to native code.</span></span><br><span class="line">mService.mInputManager.setInputWindows(mInputWindowHandles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将当前系统中带有InputChannel的Activity窗口都设置为InputManagerService的输入窗口，但是后面我们会看到，只有当前激活的窗口才会响应键盘消息。</p>
<h2 id="Step-5、InputManagerService-setInputWindows"><a href="#Step-5、InputManagerService-setInputWindows" class="headerlink" title="Step 5、InputManagerService.setInputWindows()"></a>Step 5、InputManagerService.setInputWindows()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInputWindows</span><span class="params">(InputWindowHandle[] windowHandles)</span> </span>&#123;</span><br><span class="line">    nativeSetInputWindows(mPtr, windowHandles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了本地方法nativeSetInputWindows来进一步执行操作,mPtr是native层NativeInputManager实例，在调用InputManagerService.nativeInit函数时会在native层构造NativeInputManager对象并将其保存在mPtr中。nativeSetInputWindows会调用NativeInputManager的setInputWindows函数</p>
<h2 id="Step-6、NativeInputManager-setInputWindows"><a href="#Step-6、NativeInputManager-setInputWindows" class="headerlink" title="Step 6、NativeInputManager.setInputWindows()"></a>Step 6、NativeInputManager.setInputWindows()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) &#123;</span><br><span class="line">    Vector&lt;sp&lt;InputWindowHandle&gt; &gt; windowHandles;</span><br><span class="line">    <span class="keyword">if</span> (windowHandleObjArray) &#123;</span><br><span class="line">        jsize length = env-&gt;GetArrayLength(windowHandleObjArray);</span><br><span class="line">        <span class="keyword">for</span> (jsize i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            jobject windowHandleObj = env-&gt;GetObjectArrayElement(windowHandleObjArray, i);</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;InputWindowHandle&gt; windowHandle =</span><br><span class="line">                    android_server_InputWindowHandle_getHandle(env, windowHandleObj);</span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                windowHandles.push(windowHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            env-&gt;DeleteLocalRef(windowHandleObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windowHandles);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do this after the dispatcher has updated the window handle state.</span></span><br><span class="line">    bool newPointerGesturesEnabled = <span class="keyword">true</span>;</span><br><span class="line">    size_t numWindows = windowHandles.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; numWindows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = windowHandles.itemAt(i);</span><br><span class="line">        <span class="keyword">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo &amp;&amp; windowInfo-&gt;hasFocus &amp;&amp; (windowInfo-&gt;inputFeatures</span><br><span class="line">                &amp; InputWindowInfo::INPUT_FEATURE_DISABLE_TOUCH_PAD_GESTURES)) &#123;</span><br><span class="line">            newPointerGesturesEnabled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数首先将Java层的InputWindowHandle转换成C++层的NativeInputWindowHandle，然后放在windowHandles向量中，最后将这些输入窗口设置到InputDispatcher中去。</p>
<h2 id="Step-7、InputDispatcher-setInputWindows"><a href="#Step-7、InputDispatcher-setInputWindows" class="headerlink" title="Step 7、InputDispatcher.setInputWindows()"></a>Step 7、InputDispatcher.setInputWindows()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::setInputWindows</span><span class="params">(<span class="keyword">const</span> Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles;</span><br><span class="line">        mWindowHandles = inputWindowHandles;</span><br><span class="line"></span><br><span class="line">        sp&lt;InputWindowHandle&gt; newFocusedWindowHandle;</span><br><span class="line">        <span class="keyword">bool</span> foundHoveredWindow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWindowHandles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mWindowHandles.removeAt(i--);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123;</span><br><span class="line">                newFocusedWindowHandle = windowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFocusedWindowHandle != newFocusedWindowHandle) &#123;</span><br><span class="line">            mFocusedWindowHandle = newFocusedWindowHandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake up poll loop since it may need to make new input dispatching choices.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里InputDispatcher的成员变量mFocusedWindowHandle 就代表当前激活的窗口的。这个函数遍历inputWindowHandles，获取获得焦点的窗口，并赋值给mFocusedWindowHandle 这样，InputManagerService就把当前激活的窗口保存在InputDispatcher中了，后面就可以把键盘消息分发给它来处理。</p>
<h2 id="Step-8、mWindowSession-addToDisplay"><a href="#Step-8、mWindowSession-addToDisplay" class="headerlink" title="Step 8、mWindowSession.addToDisplay()"></a>Step 8、mWindowSession.addToDisplay()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">             getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">             mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用到WindowManagerService的addWindow接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接着会调用WindowState的 openInputChannel()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/wm/WindowState.java</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openInputChannel</span><span class="params">(InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = makeInputChannelName();</span><br><span class="line">    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">    mInputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">    mClientChannel = inputChannels[<span class="number">1</span>];</span><br><span class="line">    mInputWindowHandle.inputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mClientChannel.transferTo(outInputChannel);</span><br><span class="line">        mClientChannel.dispose();</span><br><span class="line">        mClientChannel = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the window died visible, we setup a dummy input channel, so that taps</span></span><br><span class="line">        <span class="comment">// can still detected by input monitor channel, and we can relaunch the app.</span></span><br><span class="line">        <span class="comment">// Create dummy event receiver that simply reports all events as handled.</span></span><br><span class="line">        mDeadWindowEventReceiver = <span class="keyword">new</span> DeadWindowEventReceiver(mClientChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的outInputChannel即为前面创建的InputChannel，它不为NULL，因此，这里会通过InputChannel.openInputChannelPair函数来创建一对输入通道，其中一个位于WindowManagerService中，另外一个通过outInputChannel参数返回到应用程序中。</p>
<p>WindowManagerService会为每个窗口创建一个WindowState对象，然后将该InputChannel对的service端保存到WindowState中</p>
<h2 id="Step-10、InputChannel-openInputChannelPair"><a href="#Step-10、InputChannel-openInputChannelPair" class="headerlink" title="Step 10、InputChannel.openInputChannelPair()"></a>Step 10、InputChannel.openInputChannelPair()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputChannel.java]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了nativeOpenInputChannelPair函数，在native创建一个InputChannel对</p>
<h2 id="Step-11、InputChannel-nativeOpenInputChannelPair"><a href="#Step-11、InputChannel-nativeOpenInputChannelPair" class="headerlink" title="Step 11、InputChannel.nativeOpenInputChannelPair()"></a>Step 11、InputChannel.nativeOpenInputChannelPair()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputChannel.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobjectArray <span class="title">android_view_InputChannel_nativeOpenInputChannelPair</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jclass clazz, jstring nameObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nameChars = env-&gt;GetStringUTFChars(nameObj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="function">String8 <span class="title">name</span><span class="params">(nameChars)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(nameObj, nameChars);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    sp&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="keyword">status_t</span> result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> channelPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeOpenInputChannelPair函数调用InputChannel的openInputChannelPair函数创建一对InputChannel,该对象是Native层的InputChannel,跟java层是一一对应的。</p>
<h2 id="Step-12、InputChannel-openInputChannelPair"><a href="#Step-12、InputChannel-openInputChannelPair" class="headerlink" title="Step 12、InputChannel.openInputChannelPair()"></a>Step 12、InputChannel.openInputChannelPair()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputChannel::openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        ALOGE(<span class="string">&quot;channel &#x27;%s&#x27; ~ Could not create socket pair.  errno=%d&quot;</span>,</span><br><span class="line">                name.<span class="built_in">string</span>(), errno);</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    <span class="comment">//设置server端和client端的接收缓冲区和发送缓冲区</span></span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">&quot; (server)&quot;</span>);</span><br><span class="line">    outServerChannel = <span class="keyword">new</span> InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">&quot; (client)&quot;</span>);</span><br><span class="line">    outClientChannel = <span class="keyword">new</span> InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了socketpair系统调用创建了一对已经连接的UNIX租socket,这里可以把这一对socket当成pipe返回的文件描述符一样使用，pipe返回的管道是单向管道，即只能从一端写入，一端读出，但是socketpair是创建的管道是全双工的，可读可写。</p>
<p>创建好了server端和client端socketpair通道后，在WindowState.openInputChannel()方法中，一方面它把刚才创建的Client端的输入通道通过outInputChannel参数返回到应用程序中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure>

<p>WindowSession.addToDisplay()通过Binder通信与WMS通信。IWindowSession.java为编译Android 7.1.2源码得到。 在此看一下通信详细过程,可以看到outInputChannel通过_arg8.writeToParcel()写入，然后通过跨进程方式传输，App端就可以得到Client端的InputChannel 了。 [-&gt;IWindowSession.java$ Stub]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> TRANSACTION_addToDisplay:</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">android.view.InputChannel _arg8;</span><br><span class="line">_arg8 = <span class="keyword">new</span> android.view.InputChannel();</span><br><span class="line"><span class="keyword">int</span> _result = <span class="keyword">this</span>.addToDisplay(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8);</span><br><span class="line">reply.writeNoException();</span><br><span class="line">reply.writeInt(_result);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((_arg8!=null)) &#123;</span><br><span class="line">reply.writeInt(<span class="number">1</span>);</span><br><span class="line">_arg8.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[-&gt;IWindowSession.java$ Proxy]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/view/IWindowSession.java</span></span><br><span class="line"></span><br><span class="line">@Override public int addToDisplay(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int viewVisibility, int layerStackId, android.graphics.Rect outContentInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.view.InputChannel outInputChannel) throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">......</span><br><span class="line">mRemote.transact(Stub.TRANSACTION_addToDisplay, _data, _reply, <span class="number">0</span>);</span><br><span class="line">_result = _reply.readInt();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>!=_reply.readInt())) &#123;</span><br><span class="line">outInputChannel.readFromParcel(_reply);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还需要把server端的InputChannel注册到InputManagerService中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br></pre></td></tr></table></figure>

<h2 id="Step-13、InputManagerService-registerInputChannel"><a href="#Step-13、InputManagerService-registerInputChannel" class="headerlink" title="Step 13、InputManagerService.registerInputChannel()"></a>Step 13、InputManagerService.registerInputChannel()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInputChannel</span><span class="params">(InputChannel inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputWindowHandle inputWindowHandle)</span> </span>&#123;</span><br><span class="line">    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过调用nativeRegisterInputChannel来将InputChannel注册到native层</p>
<h2 id="Step-14、InputManagerService-nativeRegisterInputChannel"><a href="#Step-14、InputManagerService-nativeRegisterInputChannel" class="headerlink" title="Step 14、InputManagerService.nativeRegisterInputChannel()"></a>Step 14、InputManagerService.nativeRegisterInputChannel()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle =</span><br><span class="line">            android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(</span><br><span class="line">            env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据java层的InputWindowHandle获得native层的InputWindowHandle对象，根据java层的InputChannel获得native层的InputChannel对象，然后调用NativeInputManager的resgiterInputChannel，该函数又调用了InputDispatcher的registerInputChannel</p>
<h2 id="Step-15、InputDispatcher-registerInputChannel"><a href="#Step-15、InputDispatcher-registerInputChannel" class="headerlink" title="Step 15、InputDispatcher.registerInputChannel()"></a>Step 15、InputDispatcher.registerInputChannel()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputDispatcher::registerInputChannel</span><span class="params">(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = <span class="keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Connection，可以看到用inputChannel初始化了inputPublisher(inputChannel)，这就是之前Input dispatcher小节 Step 8. InputPublisher.publishKeyEvent()方法中的那个mChannel。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- InputDispatcher::Connection ---</span></span><br><span class="line">InputDispatcher::Connection::Connection(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) :</span><br><span class="line">    status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle),</span><br><span class="line">    monitor(monitor),</span><br><span class="line">    inputPublisher(inputChannel), inputPublisherBlocked(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将InputWindowHandle, InputChanel封装成Connection对象，然后fd作为key，Connection作为Value，保存在mConnectionsByFd中，如果传入的monitor是true，则需要将InputChannel放到mMonitoringChannels中,从上面的InputManagerService的registerInputChannel函数里传入的monitor是false，所以这里不加入到mMonitoringChannels。同时把fd加入到mLooper的监听中，并指定当该fd有内容可读时，Looper就会调用handleReceiveCallback函数。至此server端的InputChannel注册完成，InputDispatcher睡眠在监听的fds上，当有按键事件发生时，InputDispatcher就会往这些fd写入InputMessage对象，进而回调handleReceiveCallback函数。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N23-Android-Input-System-InputDispatcher-viewrootimpl.png" alt="Markdown"></p>
<p>至此，server端的InputChannel就注册完成了，再回到前面的WindowManagerService.addWindow上的第二步inputChannels[1].transferTo(outInputChannel);，这个是将创建的一对InputChannel的client端复制到传入的参数InputChannel上，当addWindow返回时，就回到ViewRootImpl.setView()方法中，执行应用程序这一侧的键盘消息接收通道。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mInputChannel != null) &#123;</span><br><span class="line">    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">        Looper.myLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowInputEventReceiver继承自InputEventReceiver类。</p>
<h2 id="Step-16、InputEventReceiver"><a href="#Step-16、InputEventReceiver" class="headerlink" title="Step 16、InputEventReceiver()"></a>Step 16、InputEventReceiver()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了nativeInit执行native层的初始化</p>
<h2 id="Step-17-、InputEventReceiver-nativeInit"><a href="#Step-17-、InputEventReceiver-nativeInit" class="headerlink" title="Step 17.、InputEventReceiver.nativeInit()"></a>Step 17.、InputEventReceiver.nativeInit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建了一个NativeInputEventReceiver对象，并调用其initialize函数</p>
<h2 id="Step-18-、NativeInputEventReceiver-initialize"><a href="#Step-18-、NativeInputEventReceiver-initialize" class="headerlink" title="Step 18.、NativeInputEventReceiver.initialize()"></a>Step 18.、NativeInputEventReceiver.initialize()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用setFdEvents函数</p>
<h2 id="Step-19、NativeInputEventReceiver-setFdEvents"><a href="#Step-19、NativeInputEventReceiver-setFdEvents" class="headerlink" title="Step 19、NativeInputEventReceiver.setFdEvents()"></a>Step 19、NativeInputEventReceiver.setFdEvents()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用传入的MessageQueue获取Looper对象，如果events是0，则表示要移除监听fd，如果events不为0，表示要监听fd，这个fd是前面WindowManagerService创建的一对InputChannel的client端，这样当Server端写入事件时，client端的looper就能被唤醒，并调用handleEvent函数（Looper::addFd函数可以指定LooperCallback对象，当fd可读时，会调用LooperCallback的handleEvent，而NativeInputEventReceiver继承自LooperCallback，所以这里会调用NativeInputEventReceiver的handleEvent函数） 贴上事件处理序列图。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N24-Android-Input-System-Process-input-event.png" alt="Markdown"></p>
<h2 id="Step-20、NativeInputEventReceiver-handleEvent"><a href="#Step-20、NativeInputEventReceiver-handleEvent" class="headerlink" title="Step 20、NativeInputEventReceiver.handleEvent()"></a>Step 20、NativeInputEventReceiver.handleEvent()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NativeInputEventReceiver::handleEvent</span><span class="params">(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">        <span class="keyword">status_t</span> status = consumeEvents(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mMessageQueue-&gt;raiseAndClearException(env, <span class="string">&quot;handleReceiveCallback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用consumeEvents函数来处理接收一个按键事件</p>
<h2 id="Step-21、NativeInputEventReceiver-consumeEvents"><a href="#Step-21、NativeInputEventReceiver-consumeEvents" class="headerlink" title="Step 21、NativeInputEventReceiver.consumeEvents()"></a>Step 21、NativeInputEventReceiver.consumeEvents()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> skipCallbacks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">// 处理接收一个按键事件</span></span><br><span class="line">        <span class="keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            jobject inputEventObj;</span><br><span class="line">            <span class="keyword">switch</span> (inputEvent-&gt;getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AINPUT_EVENT_TYPE_KEY:</span><br><span class="line">                inputEventObj = android_view_KeyEvent_fromNative(env,</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;KeyEvent*&gt;(inputEvent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">                env-&gt;DeleteLocalRef(inputEventObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipCallbacks) &#123;</span><br><span class="line">            mInputConsumer.sendFinishedSignal(seq, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先调用mInputConsumer.consume接收一个InputEvent对象,mInputConsumer在NativeInputEventReceiver构造函数中初始化</p>
<h2 id="Step-22、InputConsumer-consume"><a href="#Step-22、InputConsumer-consume" class="headerlink" title="Step 22、InputConsumer.consume()"></a>Step 22、InputConsumer.consume()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputConsumer::consume</span><span class="params">(InputEventFactoryInterface* factory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">uint32_t</span>* outSeq, InputEvent** outEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    *outSeq = <span class="number">0</span>;</span><br><span class="line">    *outEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch the next input message.</span></span><br><span class="line">    <span class="comment">// Loop until an event can be returned or no additional events are received.</span></span><br><span class="line">    <span class="keyword">while</span> (!*outEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMsgDeferred) &#123;</span><br><span class="line">            <span class="comment">// mMsg contains a valid input message from the previous call to consume</span></span><br><span class="line">            <span class="comment">// that has not yet been processed.</span></span><br><span class="line">            mMsgDeferred = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Receive a fresh message.</span></span><br><span class="line">            <span class="keyword">status_t</span> result = mChannel-&gt;receiveMessage(&amp;mMsg);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="comment">// Consume the next batched event unless batches are being held for later.</span></span><br><span class="line">                <span class="keyword">if</span> (consumeBatches || result != WOULD_BLOCK) &#123;</span><br><span class="line">                    result = consumeBatch(factory, frameTime, outSeq, outEvent);</span><br><span class="line">                    <span class="keyword">if</span> (*outEvent) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> InputMessage::TYPE_KEY: &#123;</span><br><span class="line">            KeyEvent* keyEvent = factory-&gt;createKeyEvent();</span><br><span class="line">            <span class="keyword">if</span> (!keyEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">            initializeKeyEvent(keyEvent, &amp;mMsg);</span><br><span class="line">            *outSeq = mMsg.body.key.seq;</span><br><span class="line">            *outEvent = keyEvent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先调用InputChannel的receiveMessage函数接收InputMessage对象，然后根据InputMessage对象调用initializeKeyEvent来构造KeyEvent对象。拿到可KeyEvent对象后，再对到consumeEvents中调用java层的InputEventReceiver.java的dispatchInputEvent函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br></pre></td></tr></table></figure>

<h2 id="Step-23、InputEventReceiver-dispatchInputEvent"><a href="#Step-23、InputEventReceiver-dispatchInputEvent" class="headerlink" title="Step 23、InputEventReceiver.dispatchInputEvent()"></a>Step 23、InputEventReceiver.dispatchInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line">SuppressWarnings(<span class="string">&quot;unused&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而调用onInputEvent函数。至此按键就开始了java层的分发(下一节详细介绍)。</p>
<p>回到主线，故事来没讲完。当App这端处理完输入事件调用ViewRootImpl.finishInputEvent()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (q.mReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != <span class="number">0</span>;</span><br><span class="line">        q.mReceiver.finishInputEvent(q.mEvent, handled);</span><br><span class="line">    &#125;......</span><br><span class="line">    recycleQueuedInputEvent(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层InputEventReceiver.nativeFinishInputEvent() 通过JNI 调用android_view_InputEventReceiver.finishInputEvent()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::finishInputEvent</span><span class="params">(<span class="keyword">uint32_t</span> seq, <span class="keyword">bool</span> handled)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">              ALOGD(<span class="string">&quot;channel &#x27;%s&#x27; ~ Finished input event.&quot;</span>, getInputChannelName());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">status_t</span> status = mInputConsumer.sendFinishedSignal(seq, handled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>层层跳转最后会调用到InputConsumer.sendUnchainedFinishedSignal()发送一个InputMessage::TYPE_FINISHED消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputConsumer::sendUnchainedFinishedSignal</span><span class="params">(<span class="keyword">uint32_t</span> seq, <span class="keyword">bool</span> handled)</span> </span>&#123;</span><br><span class="line">InputMessage msg;</span><br><span class="line">msg.header.type = InputMessage::TYPE_FINISHED;</span><br><span class="line">msg.body.finished.seq = seq;</span><br><span class="line">msg.body.finished.handled = handled;</span><br><span class="line"><span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在InputDispatcher.registerInputChannel()中添加了一个 handleReceiveCallback回调。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>然后通过和IMS中InputDispacher的通信管道InputChannel发了处理完成通知。那InputDispatcher这边收到后如何处理呢？</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N25-Android-Input-System-InputDispatcher-handleReceiveCallback.jpg" alt="Markdown"></p>
<p>由前面分析 InputDispatcher会调用handleReceiveCallback()来处理TYPE_FINISHED信号。这里先是往Command队列里放一个处理事务执行doDispatchCycleFinishedLockedInterruptible()，后面在runCommandsLockedInterruptible()中会取出执行。在doDispatchCycleFinishedLockedInterruptible()函数中，会先调用afterKeyEventLockedInterruptible()。Android中可以定义一些Fallback键，即如果一个Key事件App没有处理，可以Fallback成另外默认的Key事件，这是在这里的dispatchUnhandledKey()函数中进行处理的。接着InputDispatcher会将该收到完成信号的事件项从等待队列中移除。同时由于上一个事件已被App处理完，就可以调用startDispatchCycleLocked()来进行下一轮事件的处理了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchEntry == connection-&gt;findWaitQueueEntry(seq)) &#123;  </span><br><span class="line">    connection-&gt;waitQueue.dequeue(dispatchEntry);  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="comment">// Start the next dispatch cycle for this connection.  </span></span><br><span class="line">  startDispatchCycleLocked(now(), connection);</span><br></pre></td></tr></table></figure>

<p>startDispatchCycleLocked函数会检查相应连接的输出缓冲中(connection-&gt;outboundQueue)是否有事件要发送的，有的话会通过InputChannel发送出去。</p>
<p>总结：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N26-Android-Input-System-Input-kernel-driver-framwork-app.png" alt="Markdown"></p>
<h2 id="8、Android-Input子系统之java层按键传递"><a href="#8、Android-Input子系统之java层按键传递" class="headerlink" title="8、Android Input子系统之java层按键传递"></a>8、Android Input子系统之java层按键传递</h2><p>Android开发中在自定义Activity以及View时经常会重写onKeyDown,onKeyUp,dispatchKeyEvent，同时View还有setOnKeyListener等，当一个按键事件发生时，这些方法将会被回调，但是到底哪个先回调，哪个后回调呢，一直不是特别清楚，只知道个大概，下面将详细讲述按键在java层的分发过程，其中重点关注按键事件在View层次中的分发</p>
<p>java层的按键分发从ViewRootImpl.java的WindowInputEventReceiver中的onInputEvent开始，从前面的应用程序注册消息监听过程分析和Input Dispatcher分析，InputDispatcher在处理按键事件时，会通过InputChannel::sendMessage函数将按键消息从server端写入，这里的InputChannel是当前获取焦点的窗口的InputChannel对的server端，这样应用程序端就可以收到该消息，然后调用NativeInputEventReceiver的handleEvent,最后调用到InputEventReceiver的onInputEvent函数（具体的可以看应用程序注册消息监听过程分析 的Step20-Step23）</p>
<p>序列图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N27-Android-Input-System-input-stage.png" alt="Markdown"></p>
<h2 id="Step-1、WindowInputEventReceiver-onInputEvent"><a href="#Step-1、WindowInputEventReceiver-onInputEvent" class="headerlink" title="Step 1、WindowInputEventReceiver.onInputEvent()"></a>Step 1、WindowInputEventReceiver.onInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只列出部分代码，当一个按键按下时onInputEvent方法就会被回调，其中调用了ViewRootImpl::enqueueInputEvent(event, this, 0, true);</p>
<h2 id="Step-2、ViewRootImpl-enqueueInputEvent"><a href="#Step-2、ViewRootImpl-enqueueInputEvent" class="headerlink" title="Step 2、ViewRootImpl.enqueueInputEvent()"></a>Step 2、ViewRootImpl.enqueueInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从队列中获取一个QueuedInputEvent，这里的flags传入的是0</span></span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        doProcessInputEvents();<span class="comment">//这里传入的processImmediately是true，所以调用doProcessInputEvents</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的参数可知，这里表示要立即处理，所以调用doProcessInputEvents函数.</p>
<h2 id="Step-3、ViewRootImpl-doProcessInputEvents"><a href="#Step-3、ViewRootImpl-doProcessInputEvents" class="headerlink" title="Step 3、ViewRootImpl.doProcessInputEvents()"></a>Step 3、ViewRootImpl.doProcessInputEvents()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/ViewRootImpl.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">    <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">        mPendingInputEventHead = q.mNext;</span><br><span class="line">        <span class="keyword">if</span> (mPendingInputEventHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingInputEventTail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.mNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        mPendingInputEventCount -= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 分发按键事件</span></span><br><span class="line">        deliverInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在deliverInputEvent函数中实际做按键的分发</p>
<h2 id="Step-4、ViewRootImpl-deliverInputEvent"><a href="#Step-4、ViewRootImpl-deliverInputEvent" class="headerlink" title="Step 4、ViewRootImpl.deliverInputEvent()"></a>Step 4、ViewRootImpl.deliverInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;deliverInputEvent&quot;</span>,</span><br><span class="line">            q.mEvent.getSequenceNumber());</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStage stage;</span><br><span class="line">    <span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">        stage = mSyntheticInputStage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//选择责任链的模式的入口，如果InputEvent需要跳过IME处理，则从mFirstPostImeInputStage（EarlyPostImeInputStage）开始,否则从mFirstInputStage(NativePreImeInputStage)开始分发</span></span><br><span class="line">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stage.deliver(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了InputStage的deliver方法分发，这里的InputStage代表了输入事件的处理阶段，是一种责任链模式 InputStage将输入事件的处理分成若干个阶段（Stage）, 如果当前有输入法窗口，则事件处理从 NativePreIme 开始，否则的话，从EarlyPostIme 开始。事件会依次经过每个Stage，如果该事件没有被标识为 “Finished”， 该Stage就会处理它，然后返回处理结果，Forward 或 Finish， Forward 运行下一Stage继续处理，而Finished事件将会简单的Forward到下一级，直到最后一级 Synthetic InputStage。流程图和每个阶段完成的事情如下图所示<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N28-Android-Input-System-input-stage-GUI.png" alt="Markdown"></p>
<p>责任链模式： 责任链模式（Chain of Responsibility）的目标是使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<p>按键分发： 在ViewRootImpl的setView函数中会构造一个如图所示的InputStage的链，按键会从入口阶段，进入责任链，顺序处理，入口阶段根据QueuedInputEvent的状态来决定。q.shouldSendToSynthesizer() 这里一般是false，因此主要看stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; 这里的shouldSkipIme其实是一个flag在构造QueuedInputEvent时传入的，从前面的onInputEvent调用的enqueueInputEvent(event, this, 0, true);可知，这里传入的flags是第三个参数0，那这里的shouldSkipIme就是false，那么按键会从mFirstPostImeInputStage 开始分发，就是图中的NativePreImeInputStage分发。</p>
<p>下面只从跟本文前面提到的Activity，View的按键分发流程相关的InputStage（ViewPostImeInputStage）开始分析</p>
<h2 id="Step-5、ViewPostImeInputStage-processKeyEvent"><a href="#Step-5、ViewPostImeInputStage-processKeyEvent" class="headerlink" title="Step 5、ViewPostImeInputStage.processKeyEvent()"></a>Step 5、ViewPostImeInputStage.processKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> KeyEvent event = (KeyEvent)q.mEvent;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Deliver the key to the view hierarchy.</span></span><br><span class="line">    <span class="comment">// 调用成员变量mView的dispatchKeyEvent函数，这里mView是PhoneWindow.DecorView对象</span></span><br><span class="line">    <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果按键是四向键或者是TAB键，则移动焦点</span></span><br><span class="line">    <span class="comment">// Handle automatic focus changes.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">                <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                    direction = View.FOCUS_LEFT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">                <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                    direction = View.FOCUS_FORWARD;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                    direction = View.FOCUS_BACKWARD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>) &#123;</span><br><span class="line">            View focused = mView.findFocus();</span><br><span class="line">            <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                View v = focused.focusSearch(direction);</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != focused) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    focused.getFocusedRect(mTempRect);</span><br><span class="line">                    <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                        ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                                focused, mTempRect);</span><br><span class="line">                        ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                                v, mTempRect);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                        playSoundEffect(SoundEffectConstants</span><br><span class="line">                                .getContantForFocusDirection(direction));</span><br><span class="line">                        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Give the focused view a last chance to handle the dpad key.</span></span><br><span class="line">                <span class="keyword">if</span> (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// find the best view to give focus to in this non-touch-mode with no-focus</span></span><br><span class="line">                View v = focusSearch(<span class="keyword">null</span>, direction);</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.requestFocus(direction)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述主要分两步： 第一步是调用PhoneWindow.DecorView的dispatchKeyEvent函数，DecorView是View层次结构的根节点，按键从根节点开始根据Focuse view的path自上而下的分发。 第二步是判断按键是否是四向键，或者是TAB键，如果是则需要移动焦点</p>
<h2 id="Step-6、mView-dispatchKeyEvent"><a href="#Step-6、mView-dispatchKeyEvent" class="headerlink" title="Step 6、mView.dispatchKeyEvent()"></a>Step 6、mView.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!isDestroyed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled = cb != <span class="keyword">null</span> &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchKeyEvent(event)</span><br><span class="line">                : <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isDown ? PhoneWindow.<span class="keyword">this</span>.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">            : PhoneWindow.<span class="keyword">this</span>.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的分发在下面开始，如果cb不为空并且mFeatureId小于0，则调用cb.dispatchKeyEvent开始分发，否则会调用DecorView的父类（View）的dispatchKeyEvent函数。cb是Window.Callback类型，Activity实现了Window.Callback接口，在attach函数中，会调用Window.setCallback函数将自己注册进PhoneWindow中，所以cb不为空。在PhoneWindow初始化时会调用installDecor函数生成DecorView对象，该函数中传入的mFeatureId是-1，所以mFeatureId也小于0。因此此处会调用Activity的dispatchKeyEvent函数，开始在View中分发按键。</p>
<p>下面来分析按键在View的层次结构中是如何分发的 DecorView的按键分发</p>
<p>接下来来看这里先看看Activity(Callback)的dispatchKeyEvent实现：</p>
<h2 id="Step-7、Activity-dispatchKeyEvent"><a href="#Step-7、Activity-dispatchKeyEvent" class="headerlink" title="Step 7、Activity.dispatchKeyEvent()"></a>Step 7、Activity.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[frameworks/base/core/java/android/app/Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用自定义的onUserInteraction</span></span><br><span class="line">    onUserInteraction();</span><br><span class="line"></span><br><span class="line">    Window win = getWindow();</span><br><span class="line">    <span class="comment">//调用PhoneWindow的superDispatchKeyEvent,实际调用DecorView的superDispatchKeyEvent，从DecorView开始从顶层View往子视图传递</span></span><br><span class="line">    <span class="keyword">if</span> (win.superDispatchKeyEvent(event)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    View decor = mDecor;</span><br><span class="line">    <span class="keyword">if</span> (decor == <span class="keyword">null</span>) decor = win.getDecorView();</span><br><span class="line">    <span class="comment">//到这里如果view层次结构没有返回true则交给KeyEvent本身的dispatch方法，Activity的onKeyDown/onKeyUp/onKeyMultiple就会被触发</span></span><br><span class="line">    <span class="keyword">return</span> event.dispatch(<span class="keyword">this</span>, decor != <span class="keyword">null</span></span><br><span class="line">            ? decor.getKeyDispatcherState() : <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看下PhoneWindow的superDispatchKeyEvent</p>
<h2 id="Step-8、PhoneWindow-superDispatchKeyEvent"><a href="#Step-8、PhoneWindow-superDispatchKeyEvent" class="headerlink" title="Step 8、PhoneWindow.superDispatchKeyEvent()"></a>Step 8、PhoneWindow.superDispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- PhoneWindow.java --&gt;</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- PhoneWindow.DecorView --&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入View的层次结构，调用ViewGroup.dispatchKeyEvent</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看ViewGroup的dispatchKeyEvent函数</p>
<h2 id="Step-9、ViewGroup-dispatchKeyEvent"><a href="#Step-9、ViewGroup-dispatchKeyEvent" class="headerlink" title="Step 9、ViewGroup.dispatchKeyEvent()"></a>Step 9、ViewGroup.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewGroup.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))</span><br><span class="line">            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123;</span><br><span class="line">        <span class="comment">//如果此ViewGroup是focused并且具体的大小被设置了（有边界），则交给它处理，即调用View的实现</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFocused != <span class="keyword">null</span> &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)</span><br><span class="line">            == PFLAG_HAS_BOUNDS) &#123;</span><br><span class="line">        <span class="comment">//否则，如果此ViewGroup中有focused的child，且child有具体的大小，则交给mFocused处理</span></span><br><span class="line">        <span class="keyword">if</span> (mFocused.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看出如果ViewGroup满足条件，则优先处理事件而不发给子视图去处理。</p>
<p>下面看下View的dispatchKeyEvent实现</p>
<h2 id="Step-10、View-dispatchKeyEvent"><a href="#Step-10、View-dispatchKeyEvent" class="headerlink" title="Step 10、View.dispatchKeyEvent()"></a>Step 10、View.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/View.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Give any attached key listener a first crack at the event.</span></span><br><span class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="comment">//调用onKeyListener，如果注册了OnKeyListener,并且View属于Enable状态，则触发</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnKeyListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnKeyListener.onKey(<span class="keyword">this</span>, event.getKeyCode(), event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">//调用KeyEvent.dispatch方法，并将view作为参数传递进去，实际会回调View的onKeyUp/onKeyDown等方法</span></span><br><span class="line">    <span class="keyword">if</span> (event.dispatch(<span class="keyword">this</span>, mAttachInfo != <span class="keyword">null</span></span><br><span class="line">            ? mAttachInfo.mKeyDispatchState : <span class="keyword">null</span>, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-11、View-onKeyDown-View-onKeyUp"><a href="#Step-11、View-onKeyDown-View-onKeyUp" class="headerlink" title="Step 11、View.onKeyDown/View.onKeyUp"></a>Step 11、View.onKeyDown/View.onKeyUp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[-&gt;frameworks/base/core/java/android/view/View.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键</span></span><br><span class="line">    <span class="keyword">if</span> (KeyEvent.isConfirmKey(keyCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="comment">//disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Long clickable items don&#x27;t necessarily have to be clickable</span></span><br><span class="line">        <span class="keyword">if</span> (((mViewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &amp;&amp;</span><br><span class="line">                (event.getRepeatCount() == <span class="number">0</span>)) &#123;<span class="comment">// clickable或者long_clickable且是第一次down事件</span></span><br><span class="line">            setPressed(<span class="keyword">true</span>);<span class="comment">// 标记pressed，你可能设置了View不同的background，这时候就会有所体现（比如高亮效果）</span></span><br><span class="line">            checkForLongClick(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键</span></span><br><span class="line">    <span class="keyword">if</span> (KeyEvent.isConfirmKey(keyCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="comment">//disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; CLICKABLE) == CLICKABLE &amp;&amp; isPressed()) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</span><br><span class="line">                <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="keyword">return</span> performClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-12、Activity-onKeyDown-onKeyUp"><a href="#Step-12、Activity-onKeyDown-onKeyUp" class="headerlink" title="Step 12、Activity.onKeyDown/onKeyUp"></a>Step 12、Activity.onKeyDown/onKeyUp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/app/Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">//如果是back键则启动追踪</span></span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;= Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            event.startTracking();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onBackPressed();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking()</span><br><span class="line">                &amp;&amp; !event.isCanceled()) &#123;</span><br><span class="line">            <span class="comment">//如果是back键并且正在追踪该Event，则调用onBackPressed</span></span><br><span class="line">            onBackPressed();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Android常见Touch事件是通过dispatchPointerEvent(MotionEvent event)分发的，主要跟底层传上来的 输入事件相关，不同类型事件分别处理。 具体Touch事件分发机制可参考博客： <a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9097463/">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9153747/">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yanbober/article/details/45887547">Android触摸屏事件派发机制详解与源码分析一(View篇)</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yanbober/article/details/45912661">Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇)</a> <a target="_blank" rel="noopener" href="http://blog.csdn.net/yanbober/article/details/45932123">Android触摸屏事件派发机制详解与源码分析三(Activity篇)</a> <a target="_blank" rel="noopener" href="http://hukai.me/android-deeper-touch-event-dispatch-process/">Android Deeper(00) - Touch事件分发响应机制</a><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N29-Android-Input-System-touch-event.png" alt="Markdown"></p>
<h2 id="九、总结："><a href="#九、总结：" class="headerlink" title="九、总结："></a>九、总结：</h2><p>再贴一下Input system总体框架图：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N30-Android-Input-System-input-system-framwork.png" alt="Markdown"><br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/android.input/N31-Android-Input-System-Input-kernel-driver-framwork-app.png" alt="Markdown"></p>
<h2 id="（一）、IMS初始化-amp-amp-IMS与App建立通信："><a href="#（一）、IMS初始化-amp-amp-IMS与App建立通信：" class="headerlink" title="（一）、IMS初始化&amp;&amp; IMS与App建立通信："></a>（一）、IMS初始化&amp;&amp; IMS与App建立通信：</h2><ol>
<li><p>SystemServer初始化过程中，创建InputManagerService，IMS第一件事情就是初始化Native层，包括EventHub, InputReader 和 InputDispatcher</p>
</li>
<li><p>IMS以及其他的System Service 初始化完成之后，应用程序就开始启动。如果一个应用程序有Activity（只有Activit能够接受用户输入），它要将自己的Window(ViewRootImpl)通过setView()注册到WindowManagerService 中</p>
</li>
<li><p>用户输入的捕捉和处理发生在不同的进程里（生产者：Input Reader 和 Input Dispatcher 在System Server 进程里，而消费者，应用程序运行在自己的进程里），因此用户输入事件（Event)的传递需要跨进程。在这里，Android使用了Socket + Binder来完成。OpenInputChannelPair 生成了两个Socket的FD， 代表一个双向通道的两端，向一端写入数据，另外一端便可以读出，反之依然，如果一端没有写入数据，另外一端去读，则陷入阻塞等待。OpenInputChannelPair() 发生在WindowManager Service.addWindow()中</p>
</li>
<li><p>通过RegisterInputChannel, WindowManagerService 将刚刚创建的一个Socket FD，封装在InputWindowHandle(代表一个WindowState) 里传给InputManagerService</p>
</li>
<li><p>InputManagerService 通过JNI（NativeInputManager）最终调用到了InputDispatcher 的 RegisterInputChannel()方法，这里，一个Connection 对象被创建出来，代表与远端某个窗口(InputWindowHandle)的一条用户输入数据通道。一个Dispatcher可能有多个Connection（多个Window）同时存在。为了监听来自于Window的消息，InputDispatcher 通过AddFd 将这些个FD 加入到Looper中，这样，只要某个Window在Socket的另一端写入数据，Looper就会马上从睡眠中醒来，进行处理。</p>
</li>
<li><p>到这里，ViewRootImpl mWindowSession.addToDisplay返回，WMS 将SocketPair的另外一个FD 放在返回参数 OutputChannel 里，即返回给APP进程。</p>
</li>
<li><p>接着ViewRootImpl 创建了WindowInputEventReceiver 用于接受InputDispatchor 传过来的事件，App进程同样通过AddFd() 将读端的Socket FD 加入到Looper中，这样一旦InputDispatchor发送Event，Looper就会立即醒来处理。</p>
</li>
</ol>
<h2 id="（二）、Eventhub-和-Input-Reader"><a href="#（二）、Eventhub-和-Input-Reader" class="headerlink" title="（二）、Eventhub 和 Input Reader"></a>（二）、Eventhub 和 Input Reader</h2><ol>
<li><p>NativeInputManager的构造函数里第一件事情就是创建一个EventHub对象，EventHub构造函数里主要生成并初始化几个控制的FD</p>
</li>
<li><p>mINotifyFd: 用来监控””/dev/input”目录下是否有文件生成，有的话说明有新的输入设备接入，EventHub将从epool_wait中唤醒，来打开新加入的设备 mWakeReaderFD， mWakeWriterFD： 一个Pipe的两端，当往mWakeWriteFD 写入数据的时候，等待在mWakeReaderFD的线程被唤醒，这里用来给上层应用提供唤醒等待线程，比如说，当上层应用改变输入属性需要EventHub进行相应更新时</p>
</li>
<li><p>mEpollFD，用于epoll_wait()的阻塞等待，这里通过epoll_ctrl(EPOLL_ADD_FD, fd) 可以等待多个fd的事件，包括上面提到的mINotifyFD, mWakeReaderFD, 以及输入设备的FD。</p>
</li>
<li><p>InputManagerService启动InputReader 线程，进入无限的循环，每次循环调用loopOnce(). 第一次循环，会主动扫描 “/dev/input/“ 目录，并打开下面的所有文件，通过ioctl()从底层驱动获取设备信息，并判断它的设备类型。这里处理的设备类型有：INPUT_DEVICE_CLASS_KEYBOARD， INPUT_DEVICE_CLASS_TOUCH， INPUT_DEVICE_CLASS_DPAD，INPUT_DEVICE_CLASS_JOYSTICK 等。</p>
</li>
<li><p>找到每个设备对应的键值映射文件，读取并生产一个KeyMap 对象。一般来说，设备对应的键值映射文件是 “/system/usr/keylayout/Generic.kl”.</p>
</li>
<li><p>将刚才扫描到的/dev/input 下所有文件的FD 加到epool等待队列中，调用epool_wait() 开始等待事件的发生。</p>
</li>
<li><p>某个时间发生，可能是用户按键输入，也可能是某个设备插入，亦或用户调整了设备属性，epoll_wait() 返回，将发生的Event 存放在mPendingEventItems 里。如果这是一个用户输入，系统调用Read() 从驱动读到这个按键的信息，存放在rawEvents里。</p>
</li>
<li><p>EventHub-&gt;getEvents() 返回,代表有新的input事件到来，进入InputReader的processEventLocked函数。</p>
</li>
<li><p>通过rawEvent 找到产生时间的Device，再找到这个Device对应的InputMapper对象，最终生成一个NotifyArgs对象，将其放到NotifyArgs的队列中。</p>
</li>
<li><p>调用NotifyArgs里面的Notify()方法，最终调用到InputDispatchor 对应的Notify接口（比如NotifyKey) 将接下来的处理交给InputDispatchor，EventHub 和 InputReader 工作结束，但马上又开始新的一轮等待，重复6～9的循环。</p>
</li>
</ol>
<h2 id="（三）、Input-Dispatcher"><a href="#（三）、Input-Dispatcher" class="headerlink" title="（三）、Input Dispatcher"></a>（三）、Input Dispatcher</h2><ol>
<li><p>接上节的最后一步，NotifyKey() 的实现在Input Dispatcher 内部，他首先做简单的校验，对于按键事件，只有Action 是 AKEY_EVENT_ACTION_DOWN 和 AKEY_EVENT_ACTION_UP，即按下和弹起这两个Event别接受。</p>
</li>
<li><p>Input Reader 传给Input Dispather的数据类型是 NotifyKeyArgs， 后者在这里将其转换为 KeyEvent, 然后交由 Policy 来进行第一步的解析和过滤，interceptKeyBeforeDispatching(), 对于手机产品，这个工作是在PhoneWindowManager 里完成，（不同类型的产品可以定义不同的WindowManager, 比如GoogleTV 里用到的是TVWindowManager)。KeyEvent 在这里将会被分为三类：</p>
<ol>
<li>System Key: 比如说 音量键，Power键，以及一些特殊的组合键，如用于截屏的音量+Power，等等。部分System Key 会在这里立即处理，比如说电话键，但有一些会放到后面去做处理，比如说音量键，但不管怎样，这些键不会传给应用程序，所以称为系统键。</li>
<li>Global Key：最终产品中可能会有一些特殊的按键，它不属于某个特定的应用，在所有应用中的行为都是一样，但也不包含在Andrioid的系统键中，比如说GoogleTV 里会有一个”TV” 按键，按它会直接呼起”TV”应用然后收看电视直播，这类按键在Android定义为Global Key.</li>
<li>User Key：除此之外的按键就是User Key, 它最终会传递到当前的应用窗口。</li>
</ol>
</li>
<li><p>此时，InputDispather 还在Looper中睡眠等待，mLooper-&gt;wake();将其唤醒，然后进入Input Dispatcher 线程。</p>
</li>
<li><p>InputDispatcher 大部分的工作在 dispatcherOnce 里完成。首先从mInBoundQueue 中读出队列头部的事件 mPendingEvent, 然后调用 pokeUserActivityLocked()。 poke的英文意思是”搓一下, 捅一下”， 这个函数的目的也就是”捅一下”PowerManagerService 提醒它”别睡眠啊，我还活着呢”，最终调用到PowerManagerService 的 updatePowerStateLocked()，防止手机进入休眠状态。需要注意的是，上述动作不会马上执行，而是存储在命令队列，mCommandQueue里，这里面的命令会在后面依次被执行。</p>
</li>
<li><p>接下来是dispatchOnceInnerLocked()-&gt;dispatchKeyLocked() 第一次进去这个函数的时候，先检查Event是否已经过处理（doInterceptKeyBeforeDispatchingLockedInterruptible), 如果没有，则生成一个命令，同样放入mCommandQueue里。</p>
</li>
<li><p>runCommandsLockedInterruptible() 依次执行mCommandQueue 里的命令，前面说过，pokeUserActivity 会调用PowerManagerService 的 updatePowerStateLocked(), 而 interceptKeyBeforeDispatching() 则最终调用到PhoneWindowManager的同名函数。我们在interceptBeforeQueuing 里面提到的一些系统按键在这个被执行，比如 HOME/MENU/SEARCH 等。</p>
</li>
<li><p>命令运行完之后，退出 dispatchOnce， 然后调用pollOnce 进入下一轮等待。但这里不会被阻塞，因为timeout值被设成了0.</p>
</li>
<li><p>第二次进入dispatchKeyLocked(), 这是Event的状态已经设为”已处理”，这时候才真正进入了发射阶段。</p>
</li>
<li><p>接下来调用 findFocusedWindowTargetLocked() 获取当前的焦点窗口，这里面会做一件非常重要的事情，就是检测目标应用是否有ANR发生，如果下诉条件满足，则说明可能发生了ANR：</p>
<ol>
<li>目标应用不会空，而目标窗口为空。说明应用程序在启动过程中出现了问题。</li>
<li>目标 Activity 的状态是Pause，即不再是Focused的应用。</li>
<li>目标窗口还在处理上一个事件。这个我们下面会说到。</li>
</ol>
</li>
<li><p>如果目标窗口处于正常状态，调用dispatchEventLocked() 进入真正的发送程序。</p>
</li>
<li><p>然后调用prepareDispatchCycleLocked() ,这里事件换了一件马甲，从EventEntry 变成 DispatchEntry, 并送人mOutBoundQueue。然后调用startDispatchCycleLocked() 开始发送。</p>
</li>
<li><p>最终的发送发生在InputChannel的sendMessage()。这里就用到了我们前面提到的SocketPair, 一旦sendMessage() 执行，目标窗口所在进程的Looper线程就会被唤醒，然后读取键值并进行处理。</p>
</li>
<li><p>乖乖，还没走完啊？是的，工作还差最后一步，Input Dispatcher给这个窗口发送下一个命令之前，必须等待该窗口的回复，如果超过5s没有收到，就会通过Input Manager Service 向Activity Manager 汇报，后者会弹出我们熟知的 “Application No Response” 窗口。所以，事件会放入mWaitQueue进行暂存。如果窗口一切正常，完成按键处理后它会调用InputConsumer的sendFinishedSignal() 往SocketPair 里写入完成信号，Input Dispatcher 从 Loop中醒来，并从Socket中读取该信号，然后从mWaitQueue 里清除该事件标志其处理完毕。</p>
</li>
</ol>
<h2 id="（四）、Key-Processing"><a href="#（四）、Key-Processing" class="headerlink" title="（四）、Key Processing"></a>（四）、Key Processing</h2><p>略、请参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/samchen2009/p/3368158.html">图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园</a></p>
<h2 id="参考文档-特别感谢-："><a href="#参考文档-特别感谢-：" class="headerlink" title="参考文档(特别感谢)："></a>参考文档(特别感谢)：</h2><p><a target="_blank" rel="noopener" href="https://github.com/weidongshan">韦东山第4期Android驱动深度开发视频源码-GitHub</a><br><a target="_blank" rel="noopener" href="http://www.100ask.org/index.html">韦东山第4期Android驱动深度开发视频-输入系统-100ask.org</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/chenweiaiyanyan/article/category/6948320">Android输入子系统-ChenWeiaiYanYan</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/innost/article/details/47660387">《深入理解Android 卷III》第五章 深入理解Android输入系统 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/samchen2009/p/3368158.html">图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jinzhuojun/article/details/41909159">Android 5.0(Lollipop)事件输入系统(Input System) - 世事难料，保持低调 - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lcw/p/3506110.html">【Android】Android输入子系统 - Leo.cheng - 博客园</a><br><a target="_blank" rel="noopener" href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/">Android(Linux) 输入子系统解析 | Andy.Lee’s Blog</a><br><a target="_blank" rel="noopener" href="http://www.cheelok.com/aosp/59">INPUT事件的读取和分发：INPUTREADER、INPUTDISPATCHER</a><br><a target="_blank" rel="noopener" href="http://www.hustmeituan.club/tag/android.html">Android 触摸事件分发机制</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/84b2e0038080">深入理解Android之Touch事件的分发</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20180308/">https://zhoujinjian.com/posts/20180308/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Input/">Input</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20180408/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.07.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android N Display System（1）：Android Display System 系统分析之Android Graphics 系统分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20180208/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20180208/" title="Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.09.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-08</div><div class="title">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统分析</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Input%E7%B3%BB%E7%BB%9F%E5%BF%85%E5%A4%87Linux%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">一、Input系统必备Linux知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E5%BF%85%E5%A4%87%E7%9A%84Linux%E7%9F%A5%E8%AF%86-inotify%E5%92%8Cepoll"><span class="toc-number">2.</span> <span class="toc-text">（一）、必备的Linux知识 inotify和epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81INotify%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1、INotify介绍与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Epoll%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2、Epoll介绍与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81INotify%E4%B8%8EEpoll%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">3、INotify与Epoll的小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81%E5%BF%85%E5%A4%87Linux%E7%9F%A5%E8%AF%86-%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1-scoketpair"><span class="toc-number">3.</span> <span class="toc-text">（二）、必备Linux知识_双向通信(scoketpair)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8CAPP%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1、进程和APP通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9B%9E%E9%A1%BEBinder%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2、回顾Binder系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BC%95%E5%85%A5Socketpair"><span class="toc-number">3.3.</span> <span class="toc-text">3、引入Socketpair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81socketpair%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4、socketpair具体使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E5%BF%85%E5%A4%87Linux%E7%9F%A5%E8%AF%86-%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1-scoketpair-binder"><span class="toc-number">4.</span> <span class="toc-text">（三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">二、输入系统的总体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">（一）、输入子系统分层解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">1、输入子系统分层解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81getevent%E4%B8%8Esendevent%E5%B7%A5%E5%85%B7"><span class="toc-number">5.1.2.</span> <span class="toc-text">2、getevent与sendevent工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Input-driver%E6%A8%A1%E6%8B%9F%E9%A9%B1%E5%8A%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">3、Input driver模拟驱动</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Android-Input%E7%B3%BB%E7%BB%9F"><span class="toc-number"></span> <span class="toc-text">三、Android Input系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81Android-Input-%E7%B3%BB%E7%BB%9F%E5%85%B3%E9%94%AE%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">（一）、Android Input 系统关键类介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81IMS%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">（二）、IMS的创建与启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81-SystemServer-startOtherServices"><span class="toc-number">3.</span> <span class="toc-text">Step 1、 SystemServer.startOtherServices()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2%E3%80%81-InputManagerService"><span class="toc-number">4.</span> <span class="toc-text">Step 2、 InputManagerService()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81-InputManagerService-nativeInit"><span class="toc-number">5.</span> <span class="toc-text">Step 3、 InputManagerService.nativeInit()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4%E3%80%81NativeInputManager"><span class="toc-number">6.</span> <span class="toc-text">Step 4、NativeInputManager()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-5%E3%80%81InputManager"><span class="toc-number">7.</span> <span class="toc-text">Step 5、InputManager()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6%E3%80%81InputManager-initialize"><span class="toc-number">8.</span> <span class="toc-text">Step 6、InputManager.initialize()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE3-1%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">图3-1：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMS%E7%9A%84%E6%88%90%E5%91%98%E5%85%B3%E7%B3%BB"><span class="toc-number">9.</span> <span class="toc-text">IMS的成员关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81IMS%E5%90%AF%E5%8A%A8"><span class="toc-number">10.</span> <span class="toc-text">（三）、IMS启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81InputManagerService-start"><span class="toc-number">11.</span> <span class="toc-text">Step 1、InputManagerService.start()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2-InputManagerService-nativeStart"><span class="toc-number">12.</span> <span class="toc-text">Step 2. InputManagerService.nativeStart()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81InputManager-start"><span class="toc-number">13.</span> <span class="toc-text">Step 3、InputManager.start()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4%E3%80%81InputReaderThread-threadLoop"><span class="toc-number">14.</span> <span class="toc-text">Step 4、InputReaderThread.threadLoop()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step5%E3%80%81InputReaderThread-loopOnce"><span class="toc-number">15.</span> <span class="toc-text">Step5、InputReaderThread.loopOnce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6%E3%80%81InputDispatcherThread-threadLoop"><span class="toc-number">16.</span> <span class="toc-text">Step 6、InputDispatcherThread.threadLoop()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-7%E3%80%81InputDispatcher-dispatchOnce"><span class="toc-number">17.</span> <span class="toc-text">Step 7、InputDispatcher.dispatchOnce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">18.</span> <span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3EventHub"><span class="toc-number"></span> <span class="toc-text">四、深入理解EventHub</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3EventHub"><span class="toc-number">1.</span> <span class="toc-text">（1）、深入理解EventHub</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1、设备节点监听的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81getEvents-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2、getEvents()函数的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3、输入设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E3%80%81%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.4.</span> <span class="toc-text">（1）、输入设备的加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E3%80%81%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">1.5.</span> <span class="toc-text">（2）、输入设备的卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E3%80%81%E8%AE%BE%E5%A4%87%E5%A2%9E%E5%88%A0%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">（3）、设备增删事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E3%80%81%E9%80%9A%E8%BF%87INotify%E5%8A%A8%E6%80%81%E5%9C%B0%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AE%BE%E5%A4%87"><span class="toc-number">1.7.</span> <span class="toc-text">（4）、通过INotify动态地加载与卸载设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E3%80%81EventHub%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">（5）、EventHub设备管理总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81EventHub%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">5、EventHub总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Input-Reader"><span class="toc-number">2.</span> <span class="toc-text">五、Input Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81-InputReader-loopOnce"><span class="toc-number">3.</span> <span class="toc-text">Step 1、 InputReader::loopOnce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2%E3%80%81InputReader-processEventsLocked"><span class="toc-number">4.</span> <span class="toc-text">Step 2、InputReader.processEventsLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81InputReader-processEventsForDeviceLocked"><span class="toc-number">5.</span> <span class="toc-text">Step 3、InputReader.processEventsForDeviceLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4%E3%80%81InputDevice-process"><span class="toc-number">6.</span> <span class="toc-text">Step 4、InputDevice.process()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-5%E3%80%81KeyboardInputMapper-process"><span class="toc-number">7.</span> <span class="toc-text">Step 5、KeyboardInputMapper.process()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6%E3%80%81KeyboardInputMapper-processKey"><span class="toc-number">8.</span> <span class="toc-text">Step 6、KeyboardInputMapper.processKey()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-7%E3%80%81-InputDispatcher-notifyKey"><span class="toc-number">9.</span> <span class="toc-text">Step 7、 InputDispatcher.notifyKey()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-8%E3%80%81InputDispatcher-enqueueInboundEventLocked"><span class="toc-number">10.</span> <span class="toc-text">Step 8、InputDispatcher.enqueueInboundEventLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Input-Dispatcher"><span class="toc-number">12.</span> <span class="toc-text">六、Input Dispatcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81InputDispatcher-dispatchOnce"><span class="toc-number">13.</span> <span class="toc-text">Step 1、InputDispatcher.dispatchOnce()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2%E3%80%81InputDispatcher-dispatchOnceInnerLocked"><span class="toc-number">14.</span> <span class="toc-text">Step 2、InputDispatcher.dispatchOnceInnerLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81InputDispatcher-dispatchKeyLocked"><span class="toc-number">15.</span> <span class="toc-text">Step 3、InputDispatcher.dispatchKeyLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-5%E3%80%81InputDispatcher-prepareDispatchCycleLocked"><span class="toc-number">16.</span> <span class="toc-text">Step 5、InputDispatcher.prepareDispatchCycleLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6-InputDispatcher-enqueueDispatchEntriesLocked"><span class="toc-number">17.</span> <span class="toc-text">Step 6. InputDispatcher::enqueueDispatchEntriesLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-7%E3%80%81InputDispatcher-startDispatchCycleLocked"><span class="toc-number">18.</span> <span class="toc-text">Step 7、InputDispatcher.startDispatchCycleLocked()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-8%E3%80%81InputPublisher-publishKeyEvent"><span class="toc-number">19.</span> <span class="toc-text">Step 8、InputPublisher.publishKeyEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-9%E3%80%81InputChannel-sendMessage"><span class="toc-number">20.</span> <span class="toc-text">Step 9、InputChannel.sendMessage()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81App%E6%B3%A8%E5%86%8C%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">21.</span> <span class="toc-text">七、App注册消息监听过程分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81ViewRootImpl-setView"><span class="toc-number">22.</span> <span class="toc-text">Step 1、ViewRootImpl.setView()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2%E3%80%81ViewRootImpl-requestLayout"><span class="toc-number">23.</span> <span class="toc-text">Step 2、ViewRootImpl.requestLayout()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81ViewRootImpl-doTraversal"><span class="toc-number">24.</span> <span class="toc-text">Step 3、ViewRootImpl.doTraversal()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4%E3%80%81InputMonitor-updateInputWindowsLw"><span class="toc-number">25.</span> <span class="toc-text">Step 4、InputMonitor.updateInputWindowsLw()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-5%E3%80%81InputManagerService-setInputWindows"><span class="toc-number">26.</span> <span class="toc-text">Step 5、InputManagerService.setInputWindows()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6%E3%80%81NativeInputManager-setInputWindows"><span class="toc-number">27.</span> <span class="toc-text">Step 6、NativeInputManager.setInputWindows()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-7%E3%80%81InputDispatcher-setInputWindows"><span class="toc-number">28.</span> <span class="toc-text">Step 7、InputDispatcher.setInputWindows()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-8%E3%80%81mWindowSession-addToDisplay"><span class="toc-number">29.</span> <span class="toc-text">Step 8、mWindowSession.addToDisplay()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-10%E3%80%81InputChannel-openInputChannelPair"><span class="toc-number">30.</span> <span class="toc-text">Step 10、InputChannel.openInputChannelPair()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-11%E3%80%81InputChannel-nativeOpenInputChannelPair"><span class="toc-number">31.</span> <span class="toc-text">Step 11、InputChannel.nativeOpenInputChannelPair()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-12%E3%80%81InputChannel-openInputChannelPair"><span class="toc-number">32.</span> <span class="toc-text">Step 12、InputChannel.openInputChannelPair()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-13%E3%80%81InputManagerService-registerInputChannel"><span class="toc-number">33.</span> <span class="toc-text">Step 13、InputManagerService.registerInputChannel()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-14%E3%80%81InputManagerService-nativeRegisterInputChannel"><span class="toc-number">34.</span> <span class="toc-text">Step 14、InputManagerService.nativeRegisterInputChannel()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-15%E3%80%81InputDispatcher-registerInputChannel"><span class="toc-number">35.</span> <span class="toc-text">Step 15、InputDispatcher.registerInputChannel()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-16%E3%80%81InputEventReceiver"><span class="toc-number">36.</span> <span class="toc-text">Step 16、InputEventReceiver()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-17-%E3%80%81InputEventReceiver-nativeInit"><span class="toc-number">37.</span> <span class="toc-text">Step 17.、InputEventReceiver.nativeInit()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-18-%E3%80%81NativeInputEventReceiver-initialize"><span class="toc-number">38.</span> <span class="toc-text">Step 18.、NativeInputEventReceiver.initialize()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-19%E3%80%81NativeInputEventReceiver-setFdEvents"><span class="toc-number">39.</span> <span class="toc-text">Step 19、NativeInputEventReceiver.setFdEvents()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-20%E3%80%81NativeInputEventReceiver-handleEvent"><span class="toc-number">40.</span> <span class="toc-text">Step 20、NativeInputEventReceiver.handleEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-21%E3%80%81NativeInputEventReceiver-consumeEvents"><span class="toc-number">41.</span> <span class="toc-text">Step 21、NativeInputEventReceiver.consumeEvents()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-22%E3%80%81InputConsumer-consume"><span class="toc-number">42.</span> <span class="toc-text">Step 22、InputConsumer.consume()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-23%E3%80%81InputEventReceiver-dispatchInputEvent"><span class="toc-number">43.</span> <span class="toc-text">Step 23、InputEventReceiver.dispatchInputEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Android-Input%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8Bjava%E5%B1%82%E6%8C%89%E9%94%AE%E4%BC%A0%E9%80%92"><span class="toc-number">44.</span> <span class="toc-text">8、Android Input子系统之java层按键传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-1%E3%80%81WindowInputEventReceiver-onInputEvent"><span class="toc-number">45.</span> <span class="toc-text">Step 1、WindowInputEventReceiver.onInputEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-2%E3%80%81ViewRootImpl-enqueueInputEvent"><span class="toc-number">46.</span> <span class="toc-text">Step 2、ViewRootImpl.enqueueInputEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-3%E3%80%81ViewRootImpl-doProcessInputEvents"><span class="toc-number">47.</span> <span class="toc-text">Step 3、ViewRootImpl.doProcessInputEvents()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-4%E3%80%81ViewRootImpl-deliverInputEvent"><span class="toc-number">48.</span> <span class="toc-text">Step 4、ViewRootImpl.deliverInputEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-5%E3%80%81ViewPostImeInputStage-processKeyEvent"><span class="toc-number">49.</span> <span class="toc-text">Step 5、ViewPostImeInputStage.processKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-6%E3%80%81mView-dispatchKeyEvent"><span class="toc-number">50.</span> <span class="toc-text">Step 6、mView.dispatchKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-7%E3%80%81Activity-dispatchKeyEvent"><span class="toc-number">51.</span> <span class="toc-text">Step 7、Activity.dispatchKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-8%E3%80%81PhoneWindow-superDispatchKeyEvent"><span class="toc-number">52.</span> <span class="toc-text">Step 8、PhoneWindow.superDispatchKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-9%E3%80%81ViewGroup-dispatchKeyEvent"><span class="toc-number">53.</span> <span class="toc-text">Step 9、ViewGroup.dispatchKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-10%E3%80%81View-dispatchKeyEvent"><span class="toc-number">54.</span> <span class="toc-text">Step 10、View.dispatchKeyEvent()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-11%E3%80%81View-onKeyDown-View-onKeyUp"><span class="toc-number">55.</span> <span class="toc-text">Step 11、View.onKeyDown&#x2F;View.onKeyUp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Step-12%E3%80%81Activity-onKeyDown-onKeyUp"><span class="toc-number">56.</span> <span class="toc-text">Step 12、Activity.onKeyDown&#x2F;onKeyUp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">57.</span> <span class="toc-text">九、总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81IMS%E5%88%9D%E5%A7%8B%E5%8C%96-amp-amp-IMS%E4%B8%8EApp%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">58.</span> <span class="toc-text">（一）、IMS初始化&amp;&amp; IMS与App建立通信：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81Eventhub-%E5%92%8C-Input-Reader"><span class="toc-number">59.</span> <span class="toc-text">（二）、Eventhub 和 Input Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81Input-Dispatcher"><span class="toc-number">60.</span> <span class="toc-text">（三）、Input Dispatcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Key-Processing"><span class="toc-number">61.</span> <span class="toc-text">（四）、Key Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2-%EF%BC%9A"><span class="toc-number">62.</span> <span class="toc-text">参考文档(特别感谢)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>