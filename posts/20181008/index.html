<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Audio System（2）：Linux ALSA音频系统分析 | zhoujinjian</title><meta name="keywords" content="Android,Linux,Audio"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:type" content="article">
<meta property="og:title" content="Audio System（2）：Linux ALSA音频系统分析">
<meta property="og:url" content="https://zhoujinjian.com/posts/20181008/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。 【特别感">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.14.jpg">
<meta property="article:published_time" content="2018-10-08T01:25:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.968Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Audio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.14.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20181008/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.14.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Audio System（2）：Linux ALSA音频系统分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-10-08T01:25:00.000Z" title="发表于 2018-10-08 09:25:00">2018-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.968Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Audio/">Audio</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyuanyun">【特别感谢 - 雲和山的彼端 - 音频系统分析】</a></p>
<p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a target="_blank" rel="noopener" href="https://github.com/matthewdalex/marlin">Kernel source for Pixel and Pixel XL - GitHub</a></p>
<p>AOSP 源码（Android 7.1.2）：<br> <a target="_blank" rel="noopener" href="https://testerhome.com/topics/2229"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p>
<hr>
<p>源码（主要源码路径）：</p>
<blockquote>
<p>User space audio code 源码：</p>
</blockquote>
<p>• <strong>/hardware/qcom/audio/hal/ – (Audio HAL 源码)</strong> </p>
<p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p>
<p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p>
<p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p>
<p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p>
<p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p>
<p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p>
<p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p>
<p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p>
<p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p>
<blockquote>
<p>Kernel space audio code 源码：</p>
</blockquote>
<p>• **/kernel/sound/soc/msm/ –  msm8996.c machine driver 源码 **</p>
<p>• <strong>/kernel/sound/soc/msm/qdsp6v2 –  platform drivers, front end (FE), and back-end (BE) DAI driver, Hexagon DSP drivers for AFE, ADM, and ASM, voice driver 相关源码</strong></p>
<p>• <strong>kernel/sound/soc/soc-<em>.c – All the SoC-</em>.c  ALSA SoCs framework 源码</strong></p>
<p>• **kernel/drivers/slimbus/ –  SLIMbus driver 源码 **</p>
<p>• <strong>kernel/arch/arm/mach-msm/ – 包含比如 acpuclock-8996.c, board-8996-gpiomux.c, board-8996.c, and clock-8996.c related to the GPIO, clock, and board-specific information on the MSM8996 相关源码</strong></p>
<p>• <strong>/kernel/arch/arm/mach-msm/qdsp6v2/ – Contains the drivers for DSP-based encoders and decoders, code for the aDSP loader, APR driver, Ion memory driver, and other utility files</strong></p>
<p>• <strong>/kernel/arch/arm/boot/dts – Contains MSM8996-<em>.its and MSM8996-</em>.Dtsi files that contain MSM8996-specific information; audio-related customization is available in files such as MSM8996.dtsi, msm8996-mtp.dtsi, and msm8996-cdp.dtsi</strong></p>
<p>• <strong>/kernel/sound/soc/codecs/ – Contains the source code for the codec driver for WCD9335; codec driver-related source files are wcd9335.c, wcd9xxx-mbhc.c, wcd9xxx-resmgr.c, wcd9xxx-common.c, and so on.</strong></p>
<p>• <strong>/kernel/drivers/mfd/ – Contains the source code for the codec driver; wcd9xxx-core.c, wcd9xxx-slimslave.c, and wcd9xxx-irq.c are the codec driverrelated files</strong></p>
<h4 id="（一）-Overview"><a href="#（一）-Overview" class="headerlink" title="（一） Overview"></a>（一） Overview</h4><p>硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p>
<p>Linux ALSA 音频系统架构大致如下：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/21-Audio-system-Android-Linux-ASoc-arc.png.png" alt="Alt text"></p>
<p>• Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>• ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>• ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>• ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>• Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p>
<p>Platform：指某款 SoC 平台的音频模块，如 exynos、omap、qcom 等等。Platform 又可细分两部分：</p>
<p>  • cpu dai：在嵌入式系统里面通常指 SoC 的 I2S、PCM 总线控制器，负责把音频数据从 I2S tx FIFO 搬运到 CODEC（这是回放的情形，录制则方向相反）。cpu_dai 通过 <strong>snd_soc_register_dai()</strong> 来注册。注：DAI 是 Digital Audio Interface 的简称，分为 cpu_dai 和 codec_dai，这两者通过 I2S/PCM 总线连接；AIF 是 Audio Interface 的简称，嵌入式系统中一般是 I2S 和 PCM 接口。<br>  • pcm dma：负责把 dma buffer 中的音频数据搬运到 I2S tx FIFO。值得留意的是：某些情形下是不需要 dma 操作的，比如 Modem 和 CODEC 直连，因为 Modem 本身已经把数据送到 FIFO 了，这时只需启动 codec_dai 接收数据即可；该情形下，Machine 驱动 dai_link 中需要设定 .platform_name = “msm-pcm-xxx”。</p>
<p>Codec：对于回放来说，userspace 送过来的音频数据是经过采样量化的数字信号，在 codec 经过 DAC 转换成模拟信号然后输出到外放或耳机，这样我们就可以听到声音了。Codec 字面意思是编解码器，但芯片里面的功能部件很多，常见的有 AIF、DAC、ADC、Mixer、PGA、Line-in、Line-out，有些高端的 codec 芯片还有 EQ、DSP、SRC、DRC、AGC、Echo-Canceller、Noise-Suppression 等部件。</p>
<p>Machine：指某款机器，通过配置 dai_link 把 cpu_dai、codec_dai、modem_dai 各个音频接口给链结成一条条音频链路，然后注册 snd_soc_card。和上面两个不一样，Platform 和 CODEC 驱动一般是可以重用的，而 Machine 有它特定的硬件特性，几乎是不可重用的。所谓的硬件特性指：SoC Platform 与 Codec 的差异；DAIs 之间的链结方式；通过某个 GPIO 打开 Amplifier；通过某个 GPIO 检测耳机插拔；使用某个时钟如 MCLK/External-OSC 作为 I2S、CODEC 的时钟源等等。</p>
<p>从上面的描述来看，对于回放的情形，PCM 数据流向大致是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        copy_from_user           DMA                 I2S           DAC</span><br><span class="line">              ^                   ^                   ^             ^</span><br><span class="line">+---------+   |    +----------+   |   +-----------+   |   +-----+   |   +------+</span><br><span class="line">|userspace+--------&gt;DMA Buffer+-------&gt;I2S TX FIFO+-------&gt;CODEC+-------&gt;SPK/HP|</span><br><span class="line">+---------+        +----------+       +-----------+       +-----+       +------+</span><br></pre></td></tr></table></figure>

<p>几个音频物理链路的概念：</p>
<p>dai_link：machine 驱动中定义的音频数据链路，它指定链路用到的 codec、codec_dai、cpu_dai、platform。比如对于 WCD9335 平台的 media 链路：.codec_dai_name = “snd-soc-dummy-dai”, .codec_name = “snd-soc-dummy”, .cpu_dai_name = “MultiMediaX”, .platform_name = “msm-pcm-dsp.0”，这四者就构成了一条音频数据链路用于多媒体声音的回放和录制。一个系统可能有多个音频数据链路，比如 media 和 voice，因此可以定义多个 dai_link 。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;MSM8996 Media1&quot;</span>,</span><br><span class="line">        .stream_name = <span class="string">&quot;MultiMedia1&quot;</span>,</span><br><span class="line">        .cpu_dai_name = <span class="string">&quot;MultiMedia1&quot;</span>,</span><br><span class="line">        .platform_name = <span class="string">&quot;msm-pcm-dsp.0&quot;</span>,</span><br><span class="line">        .dynamic = <span class="number">1</span>,</span><br><span class="line">        .async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">        .dpcm_playback = <span class="number">1</span>,</span><br><span class="line">        .dpcm_capture = <span class="number">1</span>,</span><br><span class="line">        .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">            SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">        .codec_dai_name = <span class="string">&quot;snd-soc-dummy-dai&quot;</span>,</span><br><span class="line">        .codec_name = <span class="string">&quot;snd-soc-dummy&quot;</span>,</span><br><span class="line">        .ignore_suspend = <span class="number">1</span>,</span><br><span class="line">        <span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">        .ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">        .be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/22-MSM8996-Linux-Android-Audio-ASoc-Architectre.png" alt="Alt text"></p>
<p>高通平台因DSP而存在特殊性，如上图，Frontend 链接 “Platform”，经由 “Platform”-&gt;Backend链接到Codec。<br>Front-end DAI：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm-dai-fe.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">msm_fe_dais</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .playback = &#123;</span><br><span class="line">            .stream_name = <span class="string">&quot;MultiMedia1 Playback&quot;</span>,</span><br><span class="line">            .aif_name = <span class="string">&quot;MM_DL1&quot;</span>,</span><br><span class="line">            .rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">                    SNDRV_PCM_RATE_KNOT),</span><br><span class="line">            .formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">                        SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">                        SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">            .channels_min = <span class="number">1</span>,</span><br><span class="line">            .channels_max = <span class="number">8</span>,</span><br><span class="line">            .rate_min =     <span class="number">8000</span>,</span><br><span class="line">            .rate_max =    <span class="number">192000</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .capture = &#123;</span><br><span class="line">            .stream_name = <span class="string">&quot;MultiMedia1 Capture&quot;</span>,</span><br><span class="line">            .aif_name = <span class="string">&quot;MM_UL1&quot;</span>,</span><br><span class="line">            .rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">                    SNDRV_PCM_RATE_KNOT),</span><br><span class="line">            .formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">                    SNDRV_PCM_FMTBIT_S24_LE|</span><br><span class="line">                    SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">            .channels_min = <span class="number">1</span>,</span><br><span class="line">            .channels_max = <span class="number">4</span>,</span><br><span class="line">            .rate_min =     <span class="number">8000</span>,</span><br><span class="line">            .rate_max =    <span class="number">48000</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;msm_fe_Multimedia_dai_ops,</span><br><span class="line">        .name = <span class="string">&quot;MultiMedia1&quot;</span>,</span><br><span class="line">        .probe = fe_dai_probe,</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Back-end DAI：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_tasha_be_dai_links</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">/* Backend DAI Links */</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = LPASS_BE_SLIMBUS_0_RX,</span><br><span class="line">        .stream_name = <span class="string">&quot;Slimbus Playback&quot;</span>,</span><br><span class="line">        .cpu_dai_name = <span class="string">&quot;msm-dai-q6-dev.16384&quot;</span>,</span><br><span class="line">        .platform_name = <span class="string">&quot;msm-pcm-routing&quot;</span>,</span><br><span class="line">        .codec_name = <span class="string">&quot;tasha_codec&quot;</span>,</span><br><span class="line">        .codec_dai_name = <span class="string">&quot;tasha_mix_rx1&quot;</span>,</span><br><span class="line">        .no_pcm = <span class="number">1</span>,</span><br><span class="line">        .dpcm_playback = <span class="number">1</span>,</span><br><span class="line">        .be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,</span><br><span class="line">        .init = &amp;msm_audrx_init,</span><br><span class="line">        .be_hw_params_fixup = msm_slim_0_rx_be_hw_params_fixup,</span><br><span class="line">        <span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">        .ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">        .ignore_suspend = <span class="number">1</span>,</span><br><span class="line">        .ops = &amp;msm8996_be_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> struct snd_soc_dai_link msm8996_tasha_fe_dai_links[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = LPASS_BE_SLIMBUS_4_TX,</span><br><span class="line">        .stream_name = <span class="string">&quot;Slimbus4 Capture&quot;</span>,</span><br><span class="line">        .cpu_dai_name = <span class="string">&quot;msm-dai-q6-dev.16393&quot;</span>,</span><br><span class="line">        .platform_name = <span class="string">&quot;msm-pcm-hostless&quot;</span>,</span><br><span class="line">        .codec_name = <span class="string">&quot;tasha_codec&quot;</span>,</span><br><span class="line">        .codec_dai_name = <span class="string">&quot;tasha_vifeedback&quot;</span>,</span><br><span class="line">        .be_id = MSM_BACKEND_DAI_SLIMBUS_4_TX,</span><br><span class="line">        .be_hw_params_fixup = msm_slim_4_tx_be_hw_params_fixup,</span><br><span class="line">        .ops = &amp;msm8996_be_ops,</span><br><span class="line">        .no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">        .ignore_suspend = <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hw constraints：指平台本身的硬件限制，如所能支持的通道数/采样率/数据格式、DMA 支持的数据周期大小（period size）、周期次数（period count）等，通过 snd_pcm_hardware 结构体描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hardware</span> <span class="title">msm_pcm_hardware_capture</span> = &#123;</span></span><br><span class="line">    .info =                 (SNDRV_PCM_INFO_MMAP |</span><br><span class="line">                SNDRV_PCM_INFO_BLOCK_TRANSFER |</span><br><span class="line">                SNDRV_PCM_INFO_MMAP_VALID |</span><br><span class="line">                SNDRV_PCM_INFO_INTERLEAVED |</span><br><span class="line">                SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),</span><br><span class="line">    .formats =              (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">                SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">                SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">    .rates =                SNDRV_PCM_RATE_8000_48000,</span><br><span class="line">    .rate_min =             <span class="number">8000</span>,</span><br><span class="line">    .rate_max =             <span class="number">48000</span>,</span><br><span class="line">    .channels_min =         <span class="number">1</span>,</span><br><span class="line">    .channels_max =         <span class="number">4</span>,</span><br><span class="line">    .buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS *</span><br><span class="line">                CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">    .period_bytes_min =    CAPTURE_MIN_PERIOD_SIZE,</span><br><span class="line">    .period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">    .periods_min =          CAPTURE_MIN_NUM_PERIODS,</span><br><span class="line">    .periods_max =          CAPTURE_MAX_NUM_PERIODS,</span><br><span class="line">    .fifo_size =            <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hw params：用户层设置的硬件参数，如 channels、sample rate、pcm format、period size、period count；这些参数受 hw constraints 约束。</p>
<p>sw params：用户层设置的软件参数，如 start threshold、stop threshold、silence threshold。</p>
<h4 id="（二）ASoC-Core"><a href="#（二）ASoC-Core" class="headerlink" title="（二）ASoC Core"></a>（二）ASoC Core</h4><p>ASoC：ALSA System on Chip，是建立在标准 ALSA 驱动之上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系，它依赖于标准 ALSA 驱动框架。内核文档 Documentation/alsa/soc/overview.txt 中详细介绍了 ASoC 的设计初衷，这里不一一引用，简单陈述如下：</p>
<p>• 独立的 codec 驱动，标准的 ALSA 驱动框架里面 codec 驱动往往与 SoC/CPU 耦合过于紧密，不利于在多样化的平台/机器上移植复用<br>• 方便 codec 与 SoC 通过 PCM/I2S 总线建立链接<br>• 动态音频电源管理 DAPM，使得 codec 任何时候都工作在最低功耗状态，同时负责音频路由的创建<br>• POPs 和 click 音抑制弱化处理，在 ASoC 中通过正确的音频部件上下电次序来实现<br>• Machine 驱动的特定控制，比如耳机、麦克风的插拔检测，外放功放的开关<br>在概述中已经介绍了 ASoC 硬件设备驱动的三大构成：Codec、Platform 和 Machine，下面列举各驱动的功能构成：</p>
<p>ASoC Codec Driver：</p>
<p>• Codec DAI 和 PCM 的配置信息<br>• Codec 的控制接口，如 I2C/SPI<br>• Mixer 和其他音频控件<br>• Codec 的音频接口函数，见 snd_soc_dai_ops 结构体定义<br>• DAPM 描述信息<br>• DAPM 事件处理句柄<br>• DAC 数字静音控制</p>
<p>ASoC Platform Driver： 包括 dma 和 cpu_dai 两部分：</p>
<p>• dma 驱动实现音频 dma 操作，具体见 snd_pcm_ops 结构体定义<br>• cpu_dai 驱动实现音频数字接口控制器的描述和配置<br>• ASoC Machine Driver：</p>
<p>作为链结 Platform 和 Codec 的载体，它必须配置 dai_link 为音频数据链路指定 Platform 和 Codec<br>处理机器特有的音频控件和音频事件，例如回放时打开外放功放<br>硬件设备驱动相关结构体：</p>
<p>• snd_soc_codec_driver：音频编解码芯片描述及操作函数，如控件/微件/音频路由的描述信息、时钟配置、IO 控制等<br>• snd_soc_dai_driver：音频数据接口描述及操作函数，根据 codec 端和 soc 端，分为 codec_dai 和 cpu_dai<br>• snd_soc_platform_driver：音频 dma 设备描述及操作函数<br>• snd_soc_dai_link：音频链路描述及板级操作函数</p>
<h4 id="（三）Codec-Driver"><a href="#（三）Codec-Driver" class="headerlink" title="（三）Codec Driver"></a>（三）Codec Driver</h4><p>基本是以内核文档 Documentation/sound/alsa/soc/codec.txt 中的内容为脉络来分析的。Codec 的作用，之前已有描述，本章主要罗列下 Codec driver 中重要的数据结构及注册流程。<br>其中有着各种功能部件，包括但不限于 ：</p>
<blockquote>
<p>ADC    把麦克风拾取的模拟信号转换成数字信号<br>DAC    把音频接口过来的数字信号转换成模拟信号<br>MIXER    混音器，把多路输入信号混合成单路输出</p>
</blockquote>
<h5 id="3-1-Codec-DAI-and-PCM-configuration"><a href="#3-1-Codec-DAI-and-PCM-configuration" class="headerlink" title="3.1. Codec DAI and PCM configuration"></a>3.1. Codec DAI and PCM configuration</h5><p>codec_dai 和 pcm 配置信息通过结构体 snd_soc_dai_driver 描述，包括 dai 的能力描述和操作接口，snd_soc_dai_driver 最终会被注册到 soc-core 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment"> * operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment"> * structure for every DAI they have.</span></span><br><span class="line"><span class="comment"> * This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> ac97_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name：codec_dai 的名称标识，dai_link 通过配置 codec_dai_name 来找到对应的 codec_dai；<br>probe：codec_dai 的初始化函数，注册声卡时回调；<br>playback：回放能力描述，如回放设备所支持的声道数、采样率、音频格式；<br>capture：录制能力描述，如录制设备所支持声道数、采样率、音频格式；<br>ops：codec_dai 的操作函数集，这些函数集非常重要，用于 dai 的时钟配置、格式配置、硬件参数配置。</p>
<p>codec_dai：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">tasha_i2s_dai</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;tasha_i2s_rx1&quot;</span>,</span><br><span class="line">        .id = AIF1_PB,</span><br><span class="line">        .playback = &#123;</span><br><span class="line">            .stream_name = <span class="string">&quot;AIF1 Playback&quot;</span>,</span><br><span class="line">            .rates = WCD9335_RATES_MASK,</span><br><span class="line">            .formats = TASHA_FORMATS_S16_S24_LE,</span><br><span class="line">            .rate_max = <span class="number">192000</span>,</span><br><span class="line">            .rate_min = <span class="number">8000</span>,</span><br><span class="line">            .channels_min = <span class="number">1</span>,</span><br><span class="line">            .channels_max = <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;tasha_dai_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;tasha_i2s_tx1&quot;</span>,</span><br><span class="line">        .id = AIF1_CAP,</span><br><span class="line">        .capture = &#123;</span><br><span class="line">            .stream_name = <span class="string">&quot;AIF1 Capture&quot;</span>,</span><br><span class="line">            .rates = WCD9335_RATES_MASK,</span><br><span class="line">            .formats = TASHA_FORMATS,</span><br><span class="line">            .rate_max = <span class="number">192000</span>,</span><br><span class="line">            .rate_min = <span class="number">8000</span>,</span><br><span class="line">            .channels_min = <span class="number">1</span>,</span><br><span class="line">            .channels_max = <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        .ops = &amp;tasha_dai_ops,</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Codec-control-IO"><a href="#3-2-Codec-control-IO" class="headerlink" title="3.2. Codec control IO"></a>3.2. Codec control IO</h5><p>移动设备的音频 Codec，其控制接口一般是 I2C 或 SPI，控制接口用于读写 codec 的寄存器。在 snd_soc_codec_driver 结构体中，有如下字段描述 Codec 的控制接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="comment">/* codec driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_driver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec IO */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *(*<span class="title">get_regmap</span>)(<span class="title">struct</span> <span class="title">device</span> *);</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*read)</span><span class="params">(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*write)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*display_register)(struct snd_soc_codec *, <span class="keyword">char</span> *,</span><br><span class="line">                <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*volatile_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*readable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*writable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> reg_cache_size;</span><br><span class="line">    <span class="keyword">short</span> reg_cache_step;</span><br><span class="line">    <span class="keyword">short</span> reg_word_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *reg_cache_default;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>• read：读寄存器；<br>• write：写寄存器；<br>• volatile_register：判断指定的寄存器是否是 volatile 属性；假如是，则读取寄存器时不是读 cache，而直接访问硬件；<br>• readable_register：判断指定的寄存器是否可读；<br>• reg_cache_default：寄存器的缺省值；<br>• reg_cache_size：缺省的寄存器值数组大小；<br>• reg_word_size：寄存器宽度。<br>在 Linux-3.4.5 中，很多 codec 的控制接口都改用 regmap 了。soc-core 中判断是否用的是 regmap，如果是，则调用 regmap 接口。</p>
<h5 id="3-3-Mixers-and-audio-controls"><a href="#3-3-Mixers-and-audio-controls" class="headerlink" title="3.3. Mixers and audio controls"></a>3.3. Mixers and audio controls</h5><p>音频控件多用于部件开关和音量的设定，音频控件可通过 soc.h 中的宏来定义，例如单一型控件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;   .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) &#125;</span><br></pre></td></tr></table></figure>
<p>这种控件只有一个设置量，一般用于部件开关。宏定义的参数说明：</p>
<p>• xname：控件的名称标识；<br>• reg：控件对应的寄存器地址；<br>• shift：控件控制位在寄存器中的偏移；<br>• max：控件设置值范围；<br>• invert：设定值是否取反。<br>其他类型控件类似，不一一介绍了。</p>
<p>上述只是宏定义，音频控件真正的结构是 snd_kcontrol_new：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="keyword">snd_ctl_elem_iface_t</span> iface; <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;     <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;  <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;     <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;     <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Codec 初始化时，通过 snd_soc_add_codec_controls() 把所有定义好的音频控件注册到 alsa-core ，上层可以通过 tinymix、alsa_amixer 等工具查看修改这些控件的设定。</p>
<h5 id="3-4-Codec-audio-operations"><a href="#3-4-Codec-audio-operations" class="headerlink" title="3.4. Codec audio operations"></a>3.4. Codec audio operations</h5><p>Codec 音频操作接口通过结构体 snd_soc_dai_ops 描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment">     * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_sysclk)(struct snd_soc_dai *dai,</span><br><span class="line">        <span class="keyword">int</span> clk_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line">    <span class="keyword">int</span> (*set_pll)(struct snd_soc_dai *dai, <span class="keyword">int</span> pll_id, <span class="keyword">int</span> source,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line">    <span class="keyword">int</span> (*set_clkdiv)(struct snd_soc_dai *dai, <span class="keyword">int</span> div_id, <span class="keyword">int</span> div);</span><br><span class="line">    <span class="keyword">int</span> (*set_bclk_ratio)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> ratio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DAI format configuration</span></span><br><span class="line"><span class="comment">     * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> (*set_fmt)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> fmt);</span><br><span class="line">    <span class="keyword">int</span> (*xlate_tdm_slot_mask)(<span class="keyword">unsigned</span> <span class="keyword">int</span> slots,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_mask);</span><br><span class="line">    <span class="keyword">int</span> (*set_tdm_slot)(struct snd_soc_dai *dai,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask,</span><br><span class="line">        <span class="keyword">int</span> slots, <span class="keyword">int</span> slot_width);</span><br><span class="line">    <span class="keyword">int</span> (*set_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line">    <span class="keyword">int</span> (*set_tristate)(struct snd_soc_dai *dai, <span class="keyword">int</span> tristate);</span><br><span class="line">    <span class="keyword">int</span> (*get_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注释比较详细的了，Codec 音频操作接口分为 5 大部分：时钟配置、格式配置、数字静音、PCM 音频接口、FIFO 延迟。着重说下时钟配置及格式配置接口：</p>
<p>• set_sysclk：codec_dai 系统时钟设置，当上层打开 pcm 设备时，需要回调该接口设置 Codec 的系统时钟，Codec 才能正常工作；<br>• set_pll：Codec FLL 设置，Codec 一般接了一个 MCLK 输入时钟，回调该接口基于 MCLK 来产生 Codec FLL 时钟，接着 codec_dai 的 sysclk、bclk、lrclk 均可从 FLL 分频出来（假设 Codec 作为 master）；<br>• set_fmt：codec_dai 格式设置，具体见 soc-dai.h；<br>  • SND_SOC_DAIFMT_I2S：音频数据是 I2S 格式，常用于多媒体音频；<br>  • SND_SOC_DAIFMT_DSP_A：音频数据是 PCM 格式，常用于通话语音；<br>  • SND_SOC_DAIFMT_CBM_CFM：Codec 作为 master，BCLK 和 LRCLK 由 Codec 提供；<br>  • SND_SOC_DAIFMT_CBS_CFS：Codec 作为 slave，BCLK 和 LRCLK 由 SoC/CPU 提供；<br>• hw_params：codec_dai 硬件参数设置，根据上层设定的声道数、采样率、数据格式，来配置 codec_dai 相关寄存器。</p>
<p>WCD9335的snd_soc_dai_ops ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">tasha_dai_ops</span> = &#123;</span></span><br><span class="line">    .startup = tasha_startup,</span><br><span class="line">    .shutdown = tasha_shutdown,</span><br><span class="line">    .hw_params = tasha_hw_params,</span><br><span class="line">    .prepare = tasha_prepare,</span><br><span class="line">    .set_sysclk = tasha_set_dai_sysclk,</span><br><span class="line">    .set_fmt = tasha_set_dai_fmt,</span><br><span class="line">    .set_channel_map = tasha_set_channel_map,</span><br><span class="line">    .get_channel_map = tasha_get_channel_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="3-5-Codec-register"><a href="#3-5-Codec-register" class="headerlink" title="3.5. Codec register"></a>3.5. Codec register</h5><p>当 platform_driver：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">tasha_codec_driver</span> = &#123;</span></span><br><span class="line">    .probe = tasha_probe,</span><br><span class="line">    .remove = tasha_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;tasha_codec&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">        .pm = &amp;tasha_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与.name = “tasha_codec”  的 platform_device（该 platform_device 在 drivers/mfd/wcd9xxx-core.c 中注册wcd9xxx_device_init-&gt;wcd9xxx_check_codec_type-&gt;tasha_devs）匹配后，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/mfd/wcd9xxx-core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> <span class="title">tasha_devs</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;tasha_codec&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>立即回调 tasha_probe() 注册 Codec：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tasha_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasha_priv</span> *<span class="title">tasha</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">wcd_ext_clk</span>, *<span class="title">wcd_native_clk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_resmgr_v2</span> *<span class="title">resmgr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_power_region</span> *<span class="title">cdc_pwr</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    tasha = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct tasha_priv),</span><br><span class="line">                GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    tasha-&gt;resmgr = resmgr;</span><br><span class="line">    tasha-&gt;swr_plat_data.handle = (<span class="keyword">void</span> *) tasha;</span><br><span class="line">    tasha-&gt;swr_plat_data.read = tasha_swrm_read;</span><br><span class="line">    tasha-&gt;swr_plat_data.write = tasha_swrm_write;</span><br><span class="line">    tasha-&gt;swr_plat_data.bulk_write = tasha_swrm_bulk_write;</span><br><span class="line">    tasha-&gt;swr_plat_data.clk = tasha_swrm_clock;</span><br><span class="line">    tasha-&gt;swr_plat_data.handle_irq = tasha_swrm_handle_irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register for Clock */</span></span><br><span class="line">    wcd_ext_clk = clk_get(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">&quot;wcd_clk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(wcd_ext_clk)) &#123;</span><br><span class="line">        dev_err(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">&quot;%s: clk get %s failed\n&quot;</span>,</span><br><span class="line">            __func__, <span class="string">&quot;wcd_ext_clk&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_clk;</span><br><span class="line">    &#125;</span><br><span class="line">    tasha-&gt;wcd_ext_clk = wcd_ext_clk;</span><br><span class="line">    tasha-&gt;sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;</span><br><span class="line">    set_bit(AUDIO_NOMINAL, &amp;tasha-&gt;status_mask);</span><br><span class="line">    tasha-&gt;sido_ccl_cnt = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)</span><br><span class="line">        ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">                         tasha_dai, ARRAY_SIZE(tasha_dai));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)</span><br><span class="line">        ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">                         tasha_i2s_dai,</span><br><span class="line">                         ARRAY_SIZE(tasha_i2s_dai));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>snd_soc_register_codec：将 codec_driver 和 codec_dai_driver 注册到 soc-core。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_soc_register_codec - Register a codec with the ASoC core</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @codec: codec to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_register_codec</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct snd_soc_codec_driver *codec_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct snd_soc_dai_driver *dai_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> num_dai)</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个 snd_soc_codec 实例，包含 codec_drv（snd_soc_dai_driver）相关信息，封装给 soc-core 使用，相关代码段如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"></span><br><span class="line">    dev_dbg(dev, <span class="string">&quot;codec register %s\n&quot;</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line">    codec = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_codec), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create CODEC component name */</span></span><br><span class="line">    codec-&gt;name = fmt_single_name(dev, &amp;codec-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(codec);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Codec 的寄存器缓存配置及读写接口</span></span><br><span class="line">    codec-&gt;write = codec_drv-&gt;write;</span><br><span class="line">    codec-&gt;read = codec_drv-&gt;read;</span><br><span class="line">    codec-&gt;volatile_register = codec_drv-&gt;volatile_register;</span><br><span class="line">    codec-&gt;readable_register = codec_drv-&gt;readable_register;</span><br><span class="line">    codec-&gt;writable_register = codec_drv-&gt;writable_register;</span><br><span class="line">    codec-&gt;ignore_pmdown_time = codec_drv-&gt;ignore_pmdown_time;</span><br><span class="line">    codec-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;</span><br><span class="line">    codec-&gt;dapm.dev = dev;</span><br><span class="line">    codec-&gt;dapm.codec = codec;</span><br><span class="line">    codec-&gt;dapm.seq_notifier = codec_drv-&gt;seq_notifier;</span><br><span class="line">    codec-&gt;dapm.stream_event = codec_drv-&gt;stream_event;</span><br><span class="line">    codec-&gt;dev = dev;</span><br><span class="line">    codec-&gt;driver = codec_drv;</span><br><span class="line">    codec-&gt;num_dai = num_dai;</span><br><span class="line">    mutex_init(&amp;codec-&gt;mutex);</span><br></pre></td></tr></table></figure>
<p>把以上 codec 实例插入到 codec_list链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec 并绑定）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;codec-&gt;<span class="built_in">list</span>, &amp;codec_list);</span><br></pre></td></tr></table></figure>
<p>把 codec_drv 中的 snd_soc_dai_driver（tasha_dai 或者tasha_i2s_dai ）注册到 soc-core：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">snd_soc_register_dais(&amp;codec-&gt;component, dai_drv, num_dai, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>snd_soc_register_dais() 会把 dai 插入到 dai_list 链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec_dai 并绑定）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;dai_list);</span><br></pre></td></tr></table></figure>
<p>最后顺便提下 codec 和 codec_dai 的区别：codec 指音频芯片共有的部分，包括 codec 初始化函数、控制接口、寄存器缓存、控件、dapm 部件、音频路由、偏置电压设置函数等描述信息；而 codec_dai 指 codec 上的音频接口驱动描述，包括时钟配置、格式配置、能力描述等等，各个接口的描述信息不一定都是一致的，所以每个音频接口都有着各自的驱动描述。</p>
<h4 id="（四）Platform-Driver"><a href="#（四）Platform-Driver" class="headerlink" title="（四）Platform Driver"></a>（四）Platform Driver</h4><p>概述中提到音频 Platform 驱动主要用于音频数据传输，这里又细分为两步：</p>
<p>启动 dma 设备，把音频数据从 dma buffer 搬运到 cpu_dai FIFO，这部分驱动用 snd_soc_platform_driver 描述，后面分析用 pcm_dma 指代它。<br>启动数字音频接口控制器（I2S/PCM/AC97），把音频数据从 cpu_dai FIFO 传送到 codec_dai（高通平台会将数据传送到ADSP）这部分驱动用 snd_soc_dai_driver 描述，后面分析用 cpu_dai 指代它。</p>
<blockquote>
<p>MSM8996 包含三个 Hexagon DSP ：application, modem, and sensor。<br>Application  DSP：不仅可以处理语音和音频，还可以处理计算机 视觉、视频、图像和Camera。<br> Sensor DSP：也叫做SLPI，所有的sensor都链接到SLPI上面，它管理所有的Sensor及相关算法。</p>
</blockquote>
<p>对于 cpu_dai 驱动，从上面的类图我们可知，主要工作有：</p>
<p>实现 dai 操作函数，见 snd_soc_dai_ops 定义，用于配置和操作音频数字接口控制器，如时钟配置 set_sysclk()、格式配置 set_fmt()、硬件参数配置 hw_params()、启动/停止数据传输 trigger() 等；<br>实现 probe 函数（初始化）、remove 函数（卸载）、suspend/resume 函数（电源管理）；<br>初始化 snd_soc_dai_driver 实例，包括回放和录制的能力描述、dai 操作函数集、probe/remove 回调、电源管理相关的 suspend/resume 回调；<br>通过 snd_soc_register_dai() 把初始化完成的 snd_soc_dai_driver 注册到 soc-core：首先创建一个 snd_soc_dai 实例，然后把该 snd_soc_dai 实例插入到 dai_list 链表（声卡注册时会遍历该链表，找到 dai_link 声明的 cpu_dai 并绑定）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_register_dais</span><span class="params">(struct snd_soc_component *component,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct snd_soc_dai_driver *dai_drv, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> legacy_dai_naming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">component</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">dai</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dev_dbg(dev, <span class="string">&quot;ASoC: dai register %s #%Zu\n&quot;</span>, dev_name(dev), count);</span><br><span class="line"></span><br><span class="line">    component-&gt;dai_drv = dai_drv;</span><br><span class="line">    component-&gt;num_dai = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        dai = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dai), GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; legacy_dai_naming) &#123;</span><br><span class="line">            dai-&gt;name = fmt_single_name(dev, &amp;dai-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dai-&gt;name = fmt_multiple_name(dev, &amp;dai_drv[i]);</span><br><span class="line">            <span class="keyword">if</span> (dai_drv[i].id)</span><br><span class="line">                dai-&gt;id = dai_drv[i].id;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dai-&gt;id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        dai-&gt;component = component;</span><br><span class="line">        dai-&gt;dev = dev;</span><br><span class="line">        dai-&gt;driver = &amp;dai_drv[i];</span><br><span class="line">        <span class="keyword">if</span> (!dai-&gt;driver-&gt;ops)</span><br><span class="line">            dai-&gt;driver-&gt;ops = &amp;null_dai_ops;</span><br><span class="line"></span><br><span class="line">        list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;component-&gt;dai_list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dai 操作函数的实现是 cpu_dai 驱动的主体，需要配置好相关寄存器让 I2S/PCM 总线控制器正常运转，snd_soc_dai_ops 字段的详细说明见 3.6. Codec audio operations 章节。</p>
<p>cpu_dai 驱动应该算是这个系列中最简单的一环，因此不多花费笔墨在这里了。倒是某些平台上，dma 设备信息（总线地址、通道号、传输单元大小）是在这里初始化的，这点要留意，这些 dma 设备信息在 pcm_dma 驱动中用到。</p>
<h5 id="4-1-pcm-operations"><a href="#4-1-pcm-operations" class="headerlink" title="4.1. pcm operations"></a>4.1. pcm operations</h5><p>操作函数的实现是本模块的主体，见 snd_pcm_ops 结构体描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/pcm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*close)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct snd_pcm_substream * substream,</span><br><span class="line">             <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line">    <span class="keyword">int</span> (*compat_ioctl)(struct snd_pcm_substream *substream,</span><br><span class="line">             <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line">    <span class="keyword">int</span> (*hw_params)(struct snd_pcm_substream *substream,</span><br><span class="line">             struct snd_pcm_hw_params *params);</span><br><span class="line">    <span class="keyword">int</span> (*hw_free)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*prepare)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*trigger)(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd);</span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> (*pointer)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*delay_blk)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*wall_clock)(struct snd_pcm_substream *substream,</span><br><span class="line">              struct timespec *audio_ts);</span><br><span class="line">    <span class="keyword">int</span> (*copy)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">            <span class="keyword">snd_pcm_uframes_t</span> pos,</span><br><span class="line">            <span class="keyword">void</span> __user *buf, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line">    <span class="keyword">int</span> (*silence)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">               <span class="keyword">snd_pcm_uframes_t</span> pos, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">page</span>)(<span class="title">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">unsigned</span> <span class="title">long</span> <span class="title">offset</span>);</span></span><br><span class="line">    <span class="keyword">int</span> (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);</span><br><span class="line">    <span class="keyword">int</span> (*ack)(struct snd_pcm_substream *substream);</span><br><span class="line">    <span class="keyword">int</span> (*restart)(struct snd_pcm_substream *substream);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-1-platform-driver-注册"><a href="#4-1-platform-driver-注册" class="headerlink" title="4.1. platform_driver 注册"></a>4.1. platform_driver 注册</h5><p>当 platform_driver：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_pcm_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;msm-pcm-dsp&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = msm_pcm_dt_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = msm_pcm_probe,</span><br><span class="line">    .remove = msm_pcm_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与 .name = “msm-pcm-dsp” 的 platform_device 注册 匹配后，系统会回调 msm_pcm_probe() 注册 platform：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_pcm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msm_plat_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *latency_level;</span><br><span class="line"></span><br><span class="line">    rc = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">                <span class="string">&quot;qcom,msm-pcm-dsp-id&quot;</span>, &amp;id);</span><br><span class="line">    ......</span><br><span class="line">    pdata = kzalloc(<span class="keyword">sizeof</span>(struct msm_plat_data), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_property_read_bool(pdev-&gt;dev.of_node,</span><br><span class="line">                <span class="string">&quot;qcom,msm-pcm-low-latency&quot;</span>)) &#123;</span><br><span class="line">        pdata-&gt;perf_mode = LOW_LATENCY_PCM_MODE;</span><br><span class="line">        rc = of_property_read_string(pdev-&gt;dev.of_node,</span><br><span class="line">            <span class="string">&quot;qcom,latency-level&quot;</span>, &amp;latency_level);</span><br><span class="line">        <span class="keyword">if</span> (!rc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">&quot;ultra&quot;</span>))</span><br><span class="line">                pdata-&gt;perf_mode = ULTRA_LOW_LATENCY_PCM_MODE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">&quot;ull-pp&quot;</span>))</span><br><span class="line">                pdata-&gt;perf_mode =</span><br><span class="line">                    ULL_POST_PROCESSING_PCM_MODE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pdata-&gt;perf_mode = LEGACY_PCM_MODE;</span><br><span class="line"></span><br><span class="line">    dev_set_drvdata(&amp;pdev-&gt;dev, pdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> snd_soc_register_platform(&amp;pdev-&gt;dev,</span><br><span class="line">                   &amp;msm_soc_platform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>snd_soc_register_platform：将 platform_drv 注册到 soc-core。<br>创建一个 snd_soc_platform 实例，包含 platform_drv（snd_soc_platform_driver）的相关信息，封装给 soc-core 使用；<br>把以上创建的 platform 实例插入到 platform_list 链表上（声卡注册时会遍历该链表，找到 dai_link 声明的 platform 并绑定）。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_register_platform</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct snd_soc_platform_driver *platform_drv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    platform = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_platform), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    ret = snd_soc_add_platform(dev, platform, platform_drv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，完成了 Platform 驱动的实现。回放情形下，pcm_dma 设备负责把 dma buffer 中的数据搬运到 I2S tx FIFO，I2S 总线控制器负责把 I2S tx FIFO 中的数据传送DSP，DSP经处理后传送到到 Codec。</p>
<h4 id="（五）-Machine-Driver"><a href="#（五）-Machine-Driver" class="headerlink" title="（五）  Machine Driver"></a>（五）  Machine Driver</h4><p>章节 3. Codec 和 4. Platform 介绍了 Codec、Platform 驱动，但仅有 Codec、Platform 驱动是不能工作的，需要一个角色把 codec、codec_dai、cpu_dai、platform 给链结起来才能构成一个完整的音频链路，这个角色就由 machine_drv 承担了。</p>
<p>snd_soc_dai_link 结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;            <span class="comment">/* Codec name */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *stream_name;        <span class="comment">/* Stream name */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cpu_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu_of_node</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cpu_dai_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *codec_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">codec_of_node</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *codec_dai_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *platform_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">platform_of_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> be_id;    <span class="comment">/* optional ID for machine driver BE identification */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line">    <span class="keyword">enum</span> snd_soc_dpcm_trigger trigger[<span class="number">2</span>]; <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> no_host_mode:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> (*init)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line">    <span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">            struct snd_pcm_hw_params *params);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> playback_only;</span><br><span class="line">    <span class="keyword">bool</span> capture_only;</span><br><span class="line">    <span class="keyword">enum</span> snd_soc_async_ops async_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点介绍如下几个字段：</p>
<p>• codec_name：音频链路需要绑定的 codec 名称，声卡注册时会遍历 codec_list，找到同名的 codec 并绑定；<br>• platform_name：音频链路需要绑定的 platform 名称，声卡注册时会遍历 platform_list，找到同名的 platform 并绑定；<br>• cpu_dai_name：音频链路需要绑定的 cpu_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>• codec_dai_name：音频链路需要绑定的 codec_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>ops：重点留意 hw_params() 回调，一般来说这个回调是要实现的，用于配置 codec、codec_dai、cpu_dai 的数据格式和系统时钟。在 3.6. Codec audio operations 小节中有描述。<br>/sound/soc/msm/msm8996.c 中的 dai_link 定义，两个音频链路分别用于 Media和 Voice：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line">    <span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;MSM8996 Media1&quot;</span>,</span><br><span class="line">        .stream_name = <span class="string">&quot;MultiMedia1&quot;</span>,</span><br><span class="line">        .cpu_dai_name = <span class="string">&quot;MultiMedia1&quot;</span>,</span><br><span class="line">        .platform_name = <span class="string">&quot;msm-pcm-dsp.0&quot;</span>,</span><br><span class="line">        .dynamic = <span class="number">1</span>,</span><br><span class="line">        .async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">        .dpcm_playback = <span class="number">1</span>,</span><br><span class="line">        .dpcm_capture = <span class="number">1</span>,</span><br><span class="line">        .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">            SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">        .codec_dai_name = <span class="string">&quot;snd-soc-dummy-dai&quot;</span>,</span><br><span class="line">        .codec_name = <span class="string">&quot;snd-soc-dummy&quot;</span>,</span><br><span class="line">        .ignore_suspend = <span class="number">1</span>,</span><br><span class="line">        <span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">        .ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">        .be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;VoiceMMode1&quot;</span>,</span><br><span class="line">        .stream_name = <span class="string">&quot;VoiceMMode1&quot;</span>,</span><br><span class="line">        .cpu_dai_name = <span class="string">&quot;VoiceMMode1&quot;</span>,</span><br><span class="line">        .platform_name = <span class="string">&quot;msm-pcm-voice&quot;</span>,</span><br><span class="line">        .dynamic = <span class="number">1</span>,</span><br><span class="line">        .dpcm_playback = <span class="number">1</span>,</span><br><span class="line">        .dpcm_capture = <span class="number">1</span>,</span><br><span class="line">        .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">                SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">        .no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">        .ignore_suspend = <span class="number">1</span>,</span><br><span class="line">        .ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">        .codec_dai_name = <span class="string">&quot;snd-soc-dummy-dai&quot;</span>,</span><br><span class="line">        .codec_name = <span class="string">&quot;snd-soc-dummy&quot;</span>,</span><br><span class="line">        .be_id = MSM_FRONTEND_DAI_VOICEMMODE1,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 dai_link，机器中一些特定的音频控件和音频事件也可以在 machine_drv 定义，如耳机插拔检测、外部功放打开关闭等。</p>
<p>我们再分析 machine_drv 初始化过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm8996_asoc_machine_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = DRV_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .pm = &amp;snd_soc_pm_ops,</span><br><span class="line">        .of_match_table = msm8996_asoc_machine_of_match,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = msm8996_asoc_machine_probe,</span><br><span class="line">    .remove = msm8996_asoc_machine_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm8996_asoc_machine_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msm8996_asoc_mach_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mbhc_audio_jack_type = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *mclk_freq_prop_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line">    pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct msm8996_asoc_mach_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    match = of_match_node(msm8996_asoc_machine_of_match,</span><br><span class="line">            pdev-&gt;dev.of_node);</span><br><span class="line">    ret = msm8996_populate_dai_link_component_of_node(card);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    ret = snd_soc_register_card(card);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置dailinks后，继而调用 snd_soc_register_card() 注册声卡。由于该过程很冗长，这里不一一贴代码分析了，但整个流程是比较简单的，流程图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/23-Audio-system-msm8996-probe-snd-card-register.png" alt="Alt text"></p>
<p>• 取出 platform_device 的私有数据，该私有数据就是 snd_soc_card ；<br>• snd_soc_register_card() 为每个 dai_link 分配一个 snd_soc_pcm_runtime 实例，别忘了之前提过 snd_soc_pcm_runtime 是 ASoC 的桥梁，保存着 codec、codec_dai、cpu_dai、platform 等硬件设备实例。<br>• 随后的工作都在 snd_soc_instantiate_card() 进行：<br>• 遍历 dai_list、codec_list、platform_list 链表，为每个音频链路找到对应的 cpu_dai、codec_dai、codec、platform；找到的 cpu_dai、codec_dai、codec、platform 保存到 snd_soc_pcm_runtime ，完成音频链路的设备绑定；<br>• 调用 snd_card_create() 创建声卡；<br>• soc_probe_dai_link() 依次回调 cpu_dai、codec、platform、codec_dai 的 probe() 函数，完成各音频设备的初始化，随后调用<br>• soc_new_pcm() 创建 pcm 逻辑设备（因为涉及到本系列的重点内容，后面具体分析这个函数）；<br>最后调用 snd_card_register() 注册声卡。</p>
<p>[-&gt;sound/soc/soc-core.c]</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/24-Audio-system-msm8996-probe-snd-card.png" alt="Alt text"></p>
<p>soc_new_pcm 源码分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-pcm.c]</span><br><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span> = <span class="title">rtd</span>-&gt;<span class="title">platform</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">codec_dai</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">cpu_dai</span> = <span class="title">rtd</span>-&gt;<span class="title">cpu_dai</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">    <span class="keyword">char</span> new_name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, playback = <span class="number">0</span>, capture = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic || rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">        playback = rtd-&gt;dai_link-&gt;dpcm_playback;</span><br><span class="line">        capture = rtd-&gt;dai_link-&gt;dpcm_capture;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rtd-&gt;num_codecs; i++) &#123;</span><br><span class="line">            codec_dai = rtd-&gt;codec_dais[i];</span><br><span class="line">            <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;playback.channels_min)</span><br><span class="line">                playback = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (codec_dai-&gt;driver-&gt;capture.channels_min)</span><br><span class="line">                capture = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span><br><span class="line">        playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;playback_only) &#123;</span><br><span class="line">        playback = <span class="number">1</span>;</span><br><span class="line">        capture = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;capture_only) &#123;</span><br><span class="line">        playback = <span class="number">0</span>;</span><br><span class="line">        capture = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the PCM */</span></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">&quot;(%s)&quot;</span>,</span><br><span class="line">            rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"></span><br><span class="line">        ret = snd_pcm_new_internal(rtd-&gt;card-&gt;snd_card, new_name, num,</span><br><span class="line">                playback, capture, &amp;pcm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic)</span><br><span class="line">            <span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">&quot;%s (*)&quot;</span>,</span><br><span class="line">                rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">&quot;%s %s-%d&quot;</span>,</span><br><span class="line">                rtd-&gt;dai_link-&gt;stream_name,</span><br><span class="line">                (rtd-&gt;num_codecs &gt; <span class="number">1</span>) ?</span><br><span class="line">                <span class="string">&quot;multicodec&quot;</span> : rtd-&gt;codec_dai-&gt;name, num);</span><br><span class="line"></span><br><span class="line">        ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback,</span><br><span class="line">            capture, &amp;pcm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(rtd-&gt;card-&gt;dev, <span class="string">&quot;ASoC: can&#x27;t create pcm for %s\n&quot;</span>,</span><br><span class="line">            rtd-&gt;dai_link-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    dev_dbg(rtd-&gt;card-&gt;dev, <span class="string">&quot;ASoC: registered pcm #%d %s\n&quot;</span>,num, new_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAPM dai link stream work */</span></span><br><span class="line">    INIT_DELAYED_WORK(&amp;rtd-&gt;delayed_work, close_delayed_work);</span><br><span class="line"></span><br><span class="line">    rtd-&gt;pcm = pcm;</span><br><span class="line">    pcm-&gt;private_data = rtd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (playback)</span><br><span class="line">            pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;private_data = rtd;</span><br><span class="line">        <span class="keyword">if</span> (capture)</span><br><span class="line">            pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;private_data = rtd;</span><br><span class="line">        <span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new)</span><br><span class="line">            rtd-&gt;platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup any hostless PCMs - i.e. no host IO is performed */</span></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_host_mode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) &#123;</span><br><span class="line">            pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">            snd_soc_set_runtime_hwparams(</span><br><span class="line">                pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream,</span><br><span class="line">                &amp;no_host_hardware);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream) &#123;</span><br><span class="line">            pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">            snd_soc_set_runtime_hwparams(</span><br><span class="line">                pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream,</span><br><span class="line">                &amp;no_host_hardware);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ASoC PCM operations */</span></span><br><span class="line">    <span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">        rtd-&gt;ops.open        = dpcm_fe_dai_open;</span><br><span class="line">        rtd-&gt;ops.hw_params    = dpcm_fe_dai_hw_params;</span><br><span class="line">        rtd-&gt;ops.prepare    = dpcm_fe_dai_prepare;</span><br><span class="line">        rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;</span><br><span class="line">        rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;</span><br><span class="line">        rtd-&gt;ops.close        = dpcm_fe_dai_close;</span><br><span class="line">        rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;</span><br><span class="line">        rtd-&gt;ops.ioctl        = soc_pcm_ioctl;</span><br><span class="line">        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rtd-&gt;ops.open        = soc_pcm_open;</span><br><span class="line">        rtd-&gt;ops.hw_params    = soc_pcm_hw_params;</span><br><span class="line">        rtd-&gt;ops.prepare    = soc_pcm_prepare;</span><br><span class="line">        rtd-&gt;ops.trigger    = soc_pcm_trigger;</span><br><span class="line">        rtd-&gt;ops.hw_free    = soc_pcm_hw_free;</span><br><span class="line">        rtd-&gt;ops.close        = soc_pcm_close;</span><br><span class="line">        rtd-&gt;ops.pointer    = soc_pcm_pointer;</span><br><span class="line">        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;</span><br><span class="line">        rtd-&gt;ops.ioctl        = soc_pcm_ioctl;</span><br><span class="line">        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">        rtd-&gt;ops.ack        = platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">        rtd-&gt;ops.copy        = platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">        rtd-&gt;ops.silence    = platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">        rtd-&gt;ops.page        = platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">        rtd-&gt;ops.mmap        = platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">        rtd-&gt;ops.restart    = platform-&gt;driver-&gt;ops-&gt;restart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (playback)</span><br><span class="line">        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capture)</span><br><span class="line">        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new) &#123;</span><br><span class="line">        ret = platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dev_err(platform-&gt;dev,</span><br><span class="line">                <span class="string">&quot;ASoC: pcm constructor failed: %d\n&quot;</span>,</span><br><span class="line">                ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pcm-&gt;private_free = platform-&gt;driver-&gt;pcm_free;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 soc_new_pcm() 最主要的工作是创建 pcm 逻辑设备，创建回放子流和录制子流实例，并初始化回放子流和录制子流的 pcm 操作函数（数据搬运时，需要调用这些函数来驱动 codec、codec_dai、cpu_dai、dma 设备工作）。</p>
<h4 id="（六）、声卡和-PCM-设备的建立过程"><a href="#（六）、声卡和-PCM-设备的建立过程" class="headerlink" title="（六）、声卡和 PCM 设备的建立过程"></a>（六）、声卡和 PCM 设备的建立过程</h4><p>前面几章分析了 Codec、Platform、Machine 驱动的组成部分及其注册过程，这三者都是物理设备相关的，大家应该对音频物理链路有了一定的认知。接着分析音频驱动的中间层，由于这些并不是真正的物理设备，故我们称之为逻辑设备。</p>
<p>PCM 逻辑设备，我们又习惯称之为 PCM 中间层或 pcm native，起着承上启下的作用：往上是与用户态接口的交互，实现音频数据在用户态和内核态之间的拷贝；往下是触发 codec、platform、machine 的操作函数，实现音频数据在 dma_buffer &lt;-&gt; cpu_dai &lt;-&gt; codec 之间的传输。后面章节将会详细分析这个过程，这里还是先从声卡的注册谈起。<br>声卡驱动中，一般挂载着多个逻辑设备，看看我们计算机的声卡驱动有几个逻辑设备：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/asound/devices </span><br><span class="line">  <span class="number">2</span>: [ <span class="number">0</span>]   : control</span><br><span class="line">  <span class="number">3</span>: [ <span class="number">0</span>- <span class="number">0</span>]: digital audio playback</span><br><span class="line">  <span class="number">4</span>: [ <span class="number">0</span>- <span class="number">0</span>]: digital audio capture</span><br><span class="line">  <span class="number">5</span>: [ <span class="number">0</span>- <span class="number">1</span>]: digital audio playback</span><br><span class="line">  <span class="number">6</span>: [ <span class="number">0</span>- <span class="number">1</span>]: digital audio capture</span><br><span class="line"> ......</span><br><span class="line"> <span class="number">27</span>: [ <span class="number">0</span><span class="number">-16</span>]: digital audio playback</span><br><span class="line"> <span class="number">28</span>: [ <span class="number">0</span><span class="number">-16</span>]: digital audio capture</span><br><span class="line"> <span class="number">29</span>: [ <span class="number">0</span><span class="number">-17</span>]: digital audio playback</span><br><span class="line"> <span class="number">30</span>: [ <span class="number">0</span><span class="number">-17</span>]: digital audio capture</span><br><span class="line"> <span class="number">33</span>:        : timer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>digital audio playback    用于回放的 PCM 设备<br>digital audio capture    用于录制的 PCM 设备<br>control    用于声卡控制的 CTL 设备，如通路控制、音量调整等<br>timer    定时器设备<br>手机系统中，通常我们更关心 PCM 和 CTL 这两种设备。</p>
</blockquote>
<p>设备节点如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adb shell ls -l /dev/snd</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">51</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> comprC0D24</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">52</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> comprC0D27</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">53</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> comprC0D28</span><br><span class="line">......</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,   <span class="number">2</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> controlC0</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">59</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> hwC0D1000</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">66</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> hwC0D11</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">67</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> hwC0D12</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">76</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> hwC0D13</span><br><span class="line">......</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">13</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> pcmC0D6c</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">14</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> pcmC0D7p</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">15</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> pcmC0D8c</span><br><span class="line">crw-rw---- <span class="number">1</span> system audio <span class="number">116</span>,  <span class="number">33</span> <span class="number">1970</span><span class="number">-06</span><span class="number">-19</span> <span class="number">02</span>:<span class="number">07</span> timer</span><br></pre></td></tr></table></figure>

<p>可以看到这些设备节点的 Major=116，Minor 则与 /proc/asound/devices 所列的对应起来，都是字符设备。上层可以通过 open/close/read/write/ioctl 等系统调用来操作声卡设备，这和其他字符设备类似，但一般情况下我们会使用已封装好的用户接口库如 tinyalsa、alsa-lib。</p>
<h5 id="6-1-声卡结构概述"><a href="#6-1-声卡结构概述" class="headerlink" title="6.1. 声卡结构概述"></a>6.1. 声卡结构概述</h5><p>回顾下 ASoC 是如何注册声卡的，详细请参考章节 5. ASoC machine driver，这里仅简单陈述下：</p>
<p>• Machine 驱动初始化时，.name = “soc-audio” 的 platform_device 与 platform_driver 匹配成功，触发 soc_probe() 调用；<br>• 继而调用 snd_soc_register_card()：<br>  ﹋• 为每个音频物理链路找到对应的 codec、codec_dai、cpu_dai、platform 设备实例，完成 dai_link 的绑定；<br>  ﹋ • 调用 snd_card_create() 创建声卡；<br>  ﹋ • 依次回调 cpu_dai、codec、platform 的 probe() 函数，完成物理设备的初始化；<br>• 随后调用 soc_new_pcm()：<br>  ﹋ • 设置 pcm native 中要使用的 pcm 操作函数，这些函数用于驱动音频物理设备，包括 machine、codec_dai、cpu_dai、platform；<br>  ﹋ • 调用 snd_pcm_new() 创建 pcm 逻辑设备，回放子流和录制子流都在这里创建；<br>  ﹋ • 回调 platform 驱动的 pcm_new()，完成音频 dma 设备初始化和 dma buffer 内存分配；<br>• 最后调用 snd_card_register() 注册声卡。<br>关于音频物理设备部分（Codec/Platform/Machine）不再累述，下面详细分析声卡和 PCM 逻辑设备的注册过程。</p>
<p>上面提到声卡驱动上挂着多个逻辑子设备，有 pcm 音频数据流、control 混音器、midi 迷笛、timer 定时器等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                  +-----------+</span><br><span class="line">                  | snd_card  |</span><br><span class="line">                  +-----------+</span><br><span class="line">                    |   |   |</span><br><span class="line">        +-----------+   |   +------------+</span><br><span class="line">        |               |                |</span><br><span class="line">+-----------+    +-----------+    +-----------+</span><br><span class="line"> |  snd_pcm  |    |snd_control|    | snd_timer |    ...</span><br><span class="line"> +-----------+    +-----------+    +-----------+</span><br></pre></td></tr></table></figure>
<p>这些与声音相关的逻辑设备都在结构体 snd_card 管理之下，可以说 snd_card 是 alsa 中最顶层的结构。我们再看看 alsa 声卡驱动的大致结构图（不是严格的 UML 类图，有结构体定义、模块关系、函数调用，方便标示结构模块的层次及关系）：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/25-Audio-system-snd-card-uml.png" alt="Alt text"></p>
<p>snd_cards：记录着所注册的声卡实例，每个声卡实例有着各自的逻辑设备，如 PCM 设备、CTL 设备、MIDI 设备等，并一一记录到 snd_card 的 devices 链表上<br>snd_minors：记录着所有逻辑设备的上下文信息，它是声卡逻辑设备与系统调用 API 之间的桥梁；每个 snd_minor 在逻辑设备注册时被填充，在逻辑设备使用时就可以从该结构体中得到相应的信息（主要是系统调用函数集 file_operations）</p>
<h5 id="6-2-声卡的创建snd-card-create"><a href="#6-2-声卡的创建snd-card-create" class="headerlink" title="6.2. 声卡的创建snd_card_create()"></a>6.2. 声卡的创建snd_card_create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/core/init.c]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  snd_card_new - create and initialize a soundcard structure</span></span><br><span class="line"><span class="comment"> *  @parent: the parent device object</span></span><br><span class="line"><span class="comment"> *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]</span></span><br><span class="line"><span class="comment"> *  @xid: card identification (ASCII string)</span></span><br><span class="line"><span class="comment"> *  @module: top level module for locking</span></span><br><span class="line"><span class="comment"> *  @extra_size: allocate this extra size after the main soundcard structure</span></span><br><span class="line"><span class="comment"> *  @card_ret: the pointer to store the created card instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Creates and initializes a soundcard structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The function allocates snd_card instance via kzalloc with the given</span></span><br><span class="line"><span class="comment"> *  space for the driver to use freely.  The allocated struct is stored</span></span><br><span class="line"><span class="comment"> *  in the given card_ret pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Return: Zero if successful or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_card_new</span><span class="params">(struct device *parent, <span class="keyword">int</span> idx, <span class="keyword">const</span> <span class="keyword">char</span> *xid,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">int</span> extra_size,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct snd_card **card_ret)</span></span></span><br></pre></td></tr></table></figure>

<p>注释非常详细，简单说下：<br>idx：声卡的编号，如为 -1，则由系统自动分配<br>xid：声卡标识符，如为 NULL，则以 snd_card 的 shortname 或 longname 代替<br>card_ret：返回所创建的声卡实例的指针<br>如下是Google Pixel手机的声卡信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">sailfish:/ $ cat /proc/asound/cards</span><br><span class="line"> <span class="number">0</span> [msm8996tashamar]: msm8996-tasha-m - msm8996-tasha-marlin-snd-card</span><br><span class="line">                      msm8996-tasha-marlin-snd-card</span><br></pre></td></tr></table></figure>

<h5 id="6-3-逻辑设备的创建"><a href="#6-3-逻辑设备的创建" class="headerlink" title="6.3. 逻辑设备的创建"></a>6.3. 逻辑设备的创建</h5><p>当声卡实例建立后，接着可以创建声卡下面的各个逻辑设备了。每个逻辑设备创建时，都会调用 snd_device_new() 生成一个 snd_device 实例，并把该实例挂到声卡 snd_card 的 devices 链表上。alsa 驱动为各种逻辑设备提供了创建接口，如下：</p>
<blockquote>
<p>PCM    snd_pcm_new()<br>CONTROL    snd_ctl_create()<br>MIDI    snd_rawmidi_new()<br>TIMER    snd_timer_new()<br>SEQUENCER    snd_seq_device_new()<br>JACK    snd_jack_new()</p>
</blockquote>
<p>这些接口的一般过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_xxx_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这些接口供逻辑设备注册时回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_device_ops</span> <span class="title">ops</span> = &#123;</span></span><br><span class="line">        .dev_free = snd_xxx_dev_free,</span><br><span class="line">        .dev_register = snd_xxx_dev_register,</span><br><span class="line">        .dev_disconnect = snd_xxx_dev_disconnect,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑设备实例初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个设备实例 snd_device，挂到 snd_card 的 devices 链表上，把该逻辑设备纳入声卡的管理当中，SNDRV_DEV_xxx 是逻辑设备的类型</span></span><br><span class="line">    <span class="keyword">return</span> snd_device_new(card, SNDRV_DEV_xxx, card, &amp;ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 snd_device_ops 是声卡逻辑设备的注册函数集，dev_register() 回调尤其重要，它在声卡注册时被调用，用于建立系统的设备节点，/dev/snd/ 目录的设备节点都是在这里创建的，通过这些设备节点可系统调用 open/release/read/write/ioctl… 访问操作该逻辑设备。</p>
<p>例如 snd_ctl_dev_register()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/control.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">snd_ctl_f_ops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    .owner =    THIS_MODULE,</span><br><span class="line">    .read =        snd_ctl_read,</span><br><span class="line">    .open =        snd_ctl_open,</span><br><span class="line">    .release =    snd_ctl_release,</span><br><span class="line">    .llseek =    no_llseek,</span><br><span class="line">    .poll =        snd_ctl_poll,</span><br><span class="line">    .unlocked_ioctl =    snd_ctl_ioctl,</span><br><span class="line">    .compat_ioctl =    snd_ctl_ioctl_compat,</span><br><span class="line">    .fasync =    snd_ctl_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * registration of the control device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_ctl_dev_register</span><span class="params">(struct snd_device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span> = <span class="title">device</span>-&gt;<span class="title">device_data</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, cardnum;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snd_BUG_ON(!card))</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    cardnum = card-&gt;number;</span><br><span class="line">    <span class="keyword">if</span> (snd_BUG_ON(cardnum &lt; <span class="number">0</span> || cardnum &gt;= SNDRV_CARDS))</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    <span class="built_in">sprintf</span>(name, <span class="string">&quot;controlC%i&quot;</span>, cardnum);</span><br><span class="line">    <span class="keyword">if</span> ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, <span class="number">-1</span>,</span><br><span class="line">                       &amp;snd_ctl_f_ops, card, name)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实是调用 snd_register_device_for_dev ()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/sound.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_register_device_for_dev</span><span class="params">(<span class="keyword">int</span> type, struct snd_card *card, <span class="keyword">int</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct file_operations *f_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *private_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *name, struct device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_minor</span> *<span class="title">preg</span>;</span></span><br><span class="line">    preg = kmalloc(<span class="keyword">sizeof</span> *preg, GFP_KERNEL);</span><br><span class="line">    </span><br><span class="line">    preg-&gt;type = type;</span><br><span class="line">    preg-&gt;card = card ? card-&gt;number : <span class="number">-1</span>;</span><br><span class="line">    preg-&gt;device = dev;</span><br><span class="line">    preg-&gt;f_ops = f_ops;</span><br><span class="line">    preg-&gt;private_data = private_data;</span><br><span class="line">    preg-&gt;card_ptr = card;</span><br><span class="line">    mutex_lock(&amp;sound_mutex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_DYNAMIC_MINORS</span></span><br><span class="line">    minor = snd_find_free_minor(type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    minor = snd_kernel_minor(type, card, dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    snd_minors[minor] = preg;</span><br><span class="line">    preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),</span><br><span class="line">                  private_data, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;sound_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配并初始化一个 snd_minor 实例；<br>保存该 snd_minor 实例到 snd_minors 数组中；<br>调用 device_create() 生成设备文件节点。</p>
<p>上面过程是声卡注册时才被回调的。</p>
<h5 id="6-4-声卡的注册"><a href="#6-4-声卡的注册" class="headerlink" title="6.4. 声卡的注册"></a>6.4. 声卡的注册</h5><p>当声卡下的所有逻辑设备都已经准备就绪后，就可以调用 snd_card_register() 注册声卡了：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/26-Audio-system-snd-card-register.png.png" alt="Alt text"></p>
<p>• 创建声卡的 sysfs 设备；<br>• 调用 snd_device_register_all() 注册所有挂在该声卡下的逻辑设备；<br>• 建立 proc 信息文件和 sysfs 属性文件。</p>
<h4 id="（七）、DAPM分析"><a href="#（七）、DAPM分析" class="headerlink" title="（七）、DAPM分析"></a>（七）、DAPM分析</h4><h5 id="7-1、DAPM简介"><a href="#7-1、DAPM简介" class="headerlink" title="7.1、DAPM简介"></a>7.1、DAPM简介</h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p>
<p>DAPM是基于kcontrol改进过后的相应框架，增加了相应的电源管理机制，其电源管理机制其实就是按照相应的音频路径，完美的对各种部件的电源进行控制，而且按照某种顺序进行。</p>
<h5 id="7-1、kcontrol"><a href="#7-1、kcontrol" class="headerlink" title="7.1、kcontrol"></a>7.1、kcontrol</h5><p>通常，一个kcontrol代表着一个mixer（混音器），或者是一个mux（多路开关），又或者是一个音量控制器等等。 从上述文章中我们知道，定义一个kcontrol主要就是定义一个snd_kcontrol_new 结构，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="keyword">snd_ctl_elem_iface_t</span> iface;    <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;        <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;    <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;        <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;        <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个控件，我们需要定义一个和他对应的snd_kcontrol_new结构，这些snd_kcontrol_new结构会在声卡的初始化阶段，通过snd_soc_dapm_new_controls()函数注册到系统中，用户空间就可以通过tinymix查看和设定这些控件的状态。<br>编译/external/tinyalsa/得到tinymix, tinyplay, tinycap，Push到手机执行tinymix可得到如下类似信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="number">990</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia10    Off</span><br><span class="line"><span class="number">991</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia11    Off</span><br><span class="line"><span class="number">992</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia12    Off</span><br><span class="line"><span class="number">993</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia13    Off</span><br><span class="line"><span class="number">994</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia14    Off</span><br><span class="line"><span class="number">995</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia15    Off</span><br><span class="line"><span class="number">996</span>    BOOL    <span class="number">1</span>    QUAT_MI2S_RX Audio Mixer MultiMedia16    Off</span><br><span class="line"><span class="number">997</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia1          Off</span><br><span class="line"><span class="number">998</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia2          Off</span><br><span class="line"><span class="number">999</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia3          Off</span><br><span class="line"><span class="number">1000</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia4          Off</span><br><span class="line"><span class="number">1001</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia5          Off</span><br><span class="line"><span class="number">1002</span>    BOOL    <span class="number">1</span>    MI2S_RX Audio Mixer MultiMedia6          Off</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>snd_kcontrol_new结构中，几个主要的字段是get，put，private_value，get回调函数用于获取该控件当前的状态值，而put回调函数则用于设置控件的状态值，而private_value字段则根据不同的控件类型有不同的意义，比如对于普通的控件，private_value字段可以用来定义该控件所对应的寄存器的地址以及对应的控制位在寄存器中的位置信息。值得庆幸的是，ASoc系统已经为我们准备了大量的宏定义，用于定义常用的控件，这些宏定义位于include/sound/soc.h中。下面我们分别讨论一下如何用这些预设的宏定义来定义一些常用的控件。</p>
<h5 id="7-1-1、简单型的控件"><a href="#7-1-1、简单型的控件" class="headerlink" title="7.1.1、简单型的控件"></a>7.1.1、简单型的控件</h5><p>SOC_SINGLE    SOC_SINGLE应该算是最简单的控件了，这种控件只有一个控制量，比如一个开关，或者是一个数值变量（比如Codec中某个频率，FIFO大小等等）。我们看看这个宏是如何定义的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;    .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>宏定义的参数分别是：xname（该控件的名字），reg（该控件对应的寄存器的地址），shift（控制位在寄存器中的位移），max（控件可设置的最大值），invert（设定值是否逻辑取反）。这里又使用了一个宏来定义private_value字段：SOC_SINGLE_VALUE，我们看看它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(struct soc_mixer_control) \</span><br><span class="line">    &#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \</span><br><span class="line">    .rshift = shift_right, .max = xmax, .platform_max = xmax, \</span><br><span class="line">    .invert = xinvert, .autodisable = xautodisable&#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \</span></span><br><span class="line">    SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)</span><br></pre></td></tr></table></figure>
<p>这里实际上是定义了一个soc_mixer_control结构，然后把该结构的地址赋值给了private_value字段，soc_mixer_control结构是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* mixer control */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_mixer_control</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> min, max, platform_max;</span><br><span class="line">    <span class="keyword">int</span> reg, rreg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shift, rshift;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sign_bit;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> invert:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> autodisable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看来soc_mixer_control是控件特征的真正描述者，它确定了该控件对应寄存器的地址，位移值，最大值和是否逻辑取反等特性，控件的put回调函数和get回调函数需要借助该结构来访问实际的寄存器。<br><strong>SOC_SINGLE_TLV</strong>    <strong>SOC_SINGLE_TLV</strong>是SOC_SINGLE的一种扩展，主要用于定义那些有增益控制的控件，例如音量控制器，EQ均衡器等等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span></span><br><span class="line">&#123;    .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span><br><span class="line">         SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span><br><span class="line">    .tlv.p = (tlv_array), \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>从他的定义可以看出，用于设定寄存器信息的private_value字段的定义和SOC_SINGLE是一样的，甚至put、get回调函数也是使用同一套，唯一不同的是增加了一个tlv_array参数，并把它赋值给了tlv.p字段。用户空间可以通过对声卡的control设备发起以下两种ioctl来访问tlv字段所指向的数组：<br>  •  SNDRV_CTL_IOCTL_TLV_READ<br>  •  SNDRV_CTL_IOCTL_TLV_WRITE<br>  •  SNDRV_CTL_IOCTL_TLV_COMMAND</p>
<p>SOC_DOUBLE    与SOC_SINGLE相对应，区别是SOC_SINGLE只控制一个变量，而SOC_DOUBLE则可以同时在一个寄存器中控制两个相似的变量，最常用的就是用于一些立体声的控件，我们需要同时对左右声道进行控制，因为多了一个声道，参数也就相应地多了一个shift位移值</p>
<p>SOC_DOUBLE_R    与SOC_DOUBLE类似，对于左右声道的控制寄存器不一样的情况，使用SOC_DOUBLE_R来定义，参数中需要指定两个寄存器地址。<br>SOC_DOUBLE_TLV    与SOC_SINGLE_TLV对应的立体声版本，通常用于立体声音量控件的定义。</p>
<p>SOC_DOUBLE_R_TLV    左右声道有独立寄存器控制的SOC_DOUBLE_TLV版本</p>
<h5 id="7-1-2、Mixer控件"><a href="#7-1-2、Mixer控件" class="headerlink" title="7.1.2、Mixer控件"></a>7.1.2、Mixer控件</h5><p>Mixer控件用于音频通道的路由控制，由多个输入和一个输出组成，多个输入可以自由地混合在一起，形成混合后的输出：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/27-Audio-system-mixer-1525417497024.png" alt="Alt text"></p>
<p>对于Mixer控件，我们可以认为是多个简单控件的组合，通常，我们会为mixer的每个输入端都单独定义一个简单控件来控制该路输入的开启和关闭，反应在代码上，就是定义一个soc_kcontrol_new数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">aif4_vi_mixer</span>[] = &#123;</span></span><br><span class="line">    SOC_SINGLE_EXT(<span class="string">&quot;SPKR_VI_1&quot;</span>, SND_SOC_NOPM, TASHA_TX14, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">            tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">    SOC_SINGLE_EXT(<span class="string">&quot;SPKR_VI_2&quot;</span>, SND_SOC_NOPM, TASHA_TX15, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">            tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="7-1-3、Mux控件"><a href="#7-1-3、Mux控件" class="headerlink" title="7.1.3、Mux控件"></a>7.1.3、Mux控件</h5><p>mux控件与mixer控件类似，也是多个输入端和一个输出端的组合控件，与mixer控件不同的是，mux控件的多个输入端同时只能有一个被选中。因此，mux控件所对应的寄存器，通常可以设定一段连续的数值，每个不同的数值对应不同的输入端被打开，与上述的mixer控件不同，ASoc用soc_enum结构来描述mux控件的寄存器信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* enumerated kcontrol */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> reg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> shift_l;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> shift_r;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> items;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *texts;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两个寄存器地址和位移字段：reg，reg2，shift_l，shift_r，用于描述左右声道的控制寄存器信息。字符串数组指针用于描述每个输入端对应的名字，value字段则指向一个数组，该数组定义了寄存器可以选择的值，每个值对应一个输入端，如果value是一组连续的值，通常我们可以忽略values参数。</p>
<h5 id="7-2、widget、path、route"><a href="#7-2、widget、path、route" class="headerlink" title="7.2、widget、path、route"></a>7.2、widget、path、route</h5><p>前面一节中，我们介绍了音频驱动中对基本控制单元的封装：kcontrol。利用kcontrol，我们可以完成对音频系统中的mixer，mux，音量控制，音效控制，以及各种开关量的控制，通过对各种kcontrol的控制，使得音频硬件能够按照我们预想的结果进行工作。同时我们可以看到，kcontrol还是有以下几点不足：<br>只能描述自身，无法描述各个kcontrol之间的连接关系；<br>没有相应的电源管理机制；<br>没有相应的时间处理机制来响应播放、停止、上电、下电等音频事件；<br>为了防止pop-pop声，需要用户程序关注各个kcontrol上电和下电的顺序；<br>当一个音频路径不再有效时，不能自动关闭该路径上的所有的kcontrol；<br>为此，DAPM框架正是为了要解决以上这些问题而诞生的，DAPM目前已经是ASoc中的重要组成部分，让我们先从DAPM的数据结构开始，了解它的设计思想和工作原理。</p>
<h5 id="7-2-1、DAPM的基本单元：widget"><a href="#7-2-1、DAPM的基本单元：widget" class="headerlink" title="7.2.1、DAPM的基本单元：widget"></a>7.2.1、DAPM的基本单元：widget</h5><p>文章的开头，我们说明了一下目前kcontrol的一些不足，而DAPM框架为了解决这些问题，引入了widget这一概念，所谓widget，其实可以理解为是kcontrol的进一步升级和封装，她同样是指音频系统中的某个部件，比如mixer，mux，输入输出引脚，电源供应器等等，甚至，我们可以定义虚拟的widget，例如playback stream widget。widget把kcontrol和动态电源管理进行了有机的结合，同时还具备音频路径的连结功能，一个widget可以与它相邻的widget有某种动态的连结关系。在DAPM框架中，widget用结构体snd_soc_dapm_widget来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> snd_soc_dapm_type id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;        <span class="comment">/* widget name */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sname;    <span class="comment">/* stream name */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *priv;                <span class="comment">/* widget specific data */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span>        <span class="comment">/* attached regulator */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span> <span class="comment">/* params for dai links */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dapm control */</span></span><br><span class="line">    <span class="keyword">int</span> reg;                <span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> shift;            <span class="comment">/* bits to shift */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;            <span class="comment">/* non-shifted mask */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> on_val;            <span class="comment">/* on state value */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> off_val;            <span class="comment">/* off state value */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> power:<span class="number">1</span>;            <span class="comment">/* block power status */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> active:<span class="number">1</span>;            <span class="comment">/* active stream on DAC, ADC&#x27;s */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> connected:<span class="number">1</span>;        <span class="comment">/* connected codec pin */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">new</span>:<span class="number">1</span>;            <span class="comment">/* cnew complete */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ext:<span class="number">1</span>;            <span class="comment">/* has external widgets */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> force:<span class="number">1</span>;            <span class="comment">/* force state */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> new_power:<span class="number">1</span>;        <span class="comment">/* power from this run */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> power_checked:<span class="number">1</span>;        <span class="comment">/* power checked this run */</span></span><br><span class="line">    <span class="keyword">int</span> subseq;                <span class="comment">/* sort within widget type */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* widget input and outputs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sources</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sinks</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>snd_soc_dapm_widget结构比较大，为了简洁一些，这里我没有列出该结构体的完整字段，不过不用担心，下面我会说明每个字段的意义：<br>id    该widget的类型值，比如snd_soc_dapm_output，snd_soc_dapm_mixer等等。</p>
<p>*name    该widget的名字</p>
<p>*sname    代表该widget所在stream的名字，比如对于snd_soc_dapm_dai_in类型的widget，会使用该字段。</p>
<p>*codec *platform    指向该widget所属的codec和platform。</p>
<p>list    所有注册到系统中的widget都会通过该list，链接到代表声卡的snd_soc_card结构的widgets链表头字段中。</p>
<p>*dapm    snd_soc_dapm_context结构指针，ASoc把系统划分为多个dapm域，每个widget属于某个dapm域，同一个域代表着同样的偏置电压供电策略，比如，同一个codec中的widget通常位于同一个dapm域，而平台上的widget可能又会位于另外一个platform域中。</p>
<p>*priv    有些widget可能需要一些专有的数据，可以使用该字段来保存，像snd_soc_dapm_dai_in类型的widget，会使用该字段来记住与之相关联的snd_soc_dai结构指针。</p>
<p>*regulator    对于snd_soc_dapm_regulator_supply类型的widget，该字段指向与之相关的regulator结构指针。</p>
<p>*params    目前对于snd_soc_dapm_dai_link类型的widget，指向该dai的配置信息的snd_soc_pcm_stream结构。</p>
<p>reg shift mask     这3个字段用来控制该widget的电源状态，分别对应控制信息所在的寄存器地址，位移值和屏蔽值。</p>
<p>value  on_val  off_val    电源状态的当前只，开启时和关闭时所对应的值。</p>
<p>power invert    用于指示该widget当前是否处于上电状态，invert则用于表明power字段是否需要逻辑反转。</p>
<p>active connected    分别表示该widget是否处于激活状态和连接状态，当和相邻的widget有连接关系时，connected位会被置1，否则置0。</p>
<p>new   我们定义好的widget（snd_soc_dapm_widget结构），在注册到声卡中时需要进行实例化，该字段用来表示该widget是否已经被实例化。</p>
<p>ext    表示该widget当前是否有外部连接，比如连接mic，耳机，喇叭等等。</p>
<p>force    该位被设置后，将会不管widget当前的状态，强制更新至新的电源状态。</p>
<p>ignore_suspend new_power power_checked    这些电源管理相关的字段。</p>
<p>subseq    该widget目前在上电或下电队列中的排序编号，为了防止在上下电的过程中出现pop-pop声，DAPM会给每个widget分配合理的上下电顺序。</p>
<p>*power_check    用于检查该widget是否应该上电或下电的回调函数指针。<br>event_flags    该字段是一个位或字段，每个位代表该widget会关注某个DAPM事件通知。只有被关注的通知事件会被发送到widget的事件处理回调函数中。</p>
<p>*event    DAPM事件处理回调函数指针。</p>
<p>num_kcontrols *kcontrol_news **kcontrols    这3个字段用来描述与该widget所包含的kcontrol控件，例如一个mixer控件或者是一个mux控件。</p>
<p>sources sinks    两个链表字段，两个widget如果有连接关系，会通过一个snd_soc_dapm_path结构进行连接，sources链表用于链接所有的输入path，sinks链表用于链接所有的输出path。</p>
<p>power_list    每次更新整个dapm的电源状态时，会根据一定的算法扫描所有的widget，然后把需要变更电源状态的widget利用该字段链接到一个上电或下电的链表中，扫描完毕后，dapm系统会遍历这两个链表执行相应的上电或下电操作。</p>
<p>dirty    链表字段，widget的状态变更后，dapm系统会利用该字段，把该widget加入到一个dirty链表中，稍后会对dirty链表进行扫描，以执行整个路径的更新。</p>
<p>inputs    该widget的所有有效路径中，连接到输入端的路径数量。</p>
<p>outputs    该widget的所有有效路径中，连接到输出端的路径数量。</p>
<p>*clk    对于snd_soc_dapm_clock_supply类型的widget，指向相关联的clk结构指针。</p>
<p>以上我们对snd_soc_dapm_widget结构的各个字段所代表的意义一一做出了说明，这里只是让大家现有个概念</p>
<h5 id="7-2-2、widget的种类"><a href="#7-2-2、widget的种类" class="headerlink" title="7.2.2、widget的种类"></a>7.2.2、widget的种类</h5><p>在DAPM框架中，把各种不同的widget划分为不同的种类，snd_soc_dapm_widget结构中的id字段用来表示该widget的种类，可选的种类都定义在一个枚举中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget types */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type &#123;</span><br><span class="line">    snd_soc_dapm_input = <span class="number">0</span>,        <span class="comment">/* input pin */</span></span><br><span class="line">    snd_soc_dapm_output,        <span class="comment">/* output pin */</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>下面我们逐个解释一下这些widget的种类：<br>snd_soc_dapm_input     该widget对应一个输入引脚。<br>snd_soc_dapm_output    该widget对应一个输出引脚。<br>snd_soc_dapm_mux    该widget对应一个mux控件。<br>snd_soc_dapm_virt_mux    该widget对应一个虚拟的mux控件。<br>snd_soc_dapm_value_mux    该widget对应一个value类型的mux控件。<br>snd_soc_dapm_mixer    该widget对应一个mixer控件。<br>snd_soc_dapm_mixer_named_ctl    该widget对应一个mixer控件，但是对应的kcontrol的名字不会加入widget的名字作为前缀。<br>snd_soc_dapm_pga    该widget对应一个pga控件（可编程增益控件）。<br>snd_soc_dapm_out_drv    该widget对应一个输出驱动控件<br>snd_soc_dapm_adc    该widget对应一个ADC<br>snd_soc_dapm_dac    该widget对应一个DAC<br>snd_soc_dapm_micbias    该widget对应一个麦克风偏置电压控件<br>snd_soc_dapm_mic    该widget对应一个麦克风。<br>snd_soc_dapm_hp    该widget对应一个耳机。<br>snd_soc_dapm_spk    该widget对应一个扬声器。<br>snd_soc_dapm_line     该widget对应一个线路输入。<br>snd_soc_dapm_switch       该widget对应一个模拟开关。<br>snd_soc_dapm_vmid      该widget对应一个codec的vmid偏置电压。<br>snd_soc_dapm_pre      machine级别的专用widget，会先于其它widget执行检查操作。<br>snd_soc_dapm_post    machine级别的专用widget，会后于其它widget执行检查操作。<br>snd_soc_dapm_supply           对应一个电源或是时钟源。<br>snd_soc_dapm_regulator_supply  对应一个外部regulator稳压器。<br>snd_soc_dapm_clock_supply      对应一个外部时钟源。<br>snd_soc_dapm_aif_in            对应一个数字音频输入接口，比如I2S接口的输入端。<br>snd_soc_dapm_aif_out          对应一个数字音频输出接口，比如I2S接口的输出端。<br>snd_soc_dapm_siggen            对应一个信号发生器。<br>snd_soc_dapm_dai_in           对应一个platform或codec域的输入DAI结构。<br>snd_soc_dapm_dai_out        对应一个platform或codec域的输出DAI结构。<br>snd_soc_dapm_dai_link         用于链接一对输入/输出DAI结构。</p>
<h5 id="7-2-3、widget之间的连接器：path"><a href="#7-2-3、widget之间的连接器：path" class="headerlink" title="7.2.3、widget之间的连接器：path"></a>7.2.3、widget之间的连接器：path</h5><p>之前已经提到，一个widget是有输入和输出的，而且widget之间是可以动态地进行连接的，那它们是用什么来连接两个widget的呢？DAPM为我们提出了path这一概念，path相当于电路中的一根跳线，它把一个widget的输出端和另一个widget的输入端连接在一起，path用snd_soc_dapm_path结构来描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm audio path between two widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* source (input) and sink (output) widgets */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">source</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">sink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* status */</span></span><br><span class="line">    u32 connect:<span class="number">1</span>;    <span class="comment">/* source and sink widgets are connected */</span></span><br><span class="line">    u32 walked:<span class="number">1</span>;    <span class="comment">/* path has been walked */</span></span><br><span class="line">    u32 walking:<span class="number">1</span>;  <span class="comment">/* path is in the process of being walked */</span></span><br><span class="line">    u32 weak:<span class="number">1</span>;    <span class="comment">/* path ignored for power management */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line">             struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_source</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_sink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_kcontrol</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当widget之间发生连接关系时，snd_soc_dapm_path作为连接者，它的source字段会指向该连接的起始端widget，而它的sink字段会指向该连接的到达端widget，还记得前面snd_soc_dapm_widget结构中的两个链表头字段：sources和sinks么？widget的输入端和输出端可能连接着多个path，所有输入端的snd_soc_dapm_path结构通过list_sink字段挂在widget的souces链表中，同样，所有输出端的snd_soc_dapm_path结构通过list_source字段挂在widget的sinks链表中。这里可能大家会被搞得晕呼呼的，一会source，一会sink，不要紧，只要记住，连接的路径是这样的：起始端widget的输出–&gt;path的输入–&gt;path的输出–&gt;到达端widget输入。<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/28-Audio-system-snd_soc_dapm_path.png" alt="Alt text"><br>另外，snd_soc_dapm_path结构的list字段用于把所有的path注册到声卡中，其实就是挂在snd_soc_card结构的paths链表头字段中。如果你要自己定义方法来检查path的当前连接状态，你可以提供自己的connected回调函数指针。</p>
<p>connect，walked，walking，weak是几个辅助字段，用于帮助所有path的遍历。</p>
<h5 id="7-2-4、widget的连接关系：route"><a href="#7-2-4、widget的连接关系：route" class="headerlink" title="7.2.4、widget的连接关系：route"></a>7.2.4、widget的连接关系：route</h5><p>通过上一节的内容，我们知道，一个路径的连接至少包含以下几个元素：起始端widget，跳线path，到达端widget，在DAPM中，用snd_soc_dapm_route结构来描述这样一个连接关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sink;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *control;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line">    <span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line">             struct snd_soc_dapm_widget *sink);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sink指向到达端widget的名字字符串，source指向起始端widget的名字字符串，control指向负责控制该连接所对应的kcontrol名字字符串，connected回调则定义了上一节所提到的自定义连接检查回调函数。该结构的意义很明显就是：source通过一个kcontrol，和sink连接在一起，现在是否处于连接状态，请调用connected回调函数检查。<br>这里直接使用名字字符串来描述连接关系，所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构，正确地处理各个链表和指针的关系，实现两个widget之间的连接</p>
<h5 id="7-3、建立widget之间的连接关系"><a href="#7-3、建立widget之间的连接关系" class="headerlink" title="7.3、建立widget之间的连接关系"></a>7.3、建立widget之间的连接关系</h5><p>前面我们主要着重于codec、platform、machine驱动程序中如何使用和建立dapm所需要的widget，route，这些是音频驱动开发人员必须要了解的内容，经过前几章的介绍，我们应该知道如何在alsa音频驱动的3大部分（codec、platform、machine）中，按照所使用的音频硬件结构，定义出相应的widget，kcontrol，以及必要的音频路径，而在本节中，我们将会深入dapm的核心部分，看看各个widget之间是如何建立连接关系，形成一条完整的音频路径。</p>
<p>前面我们已经简单地介绍过，驱动程序需要使用以下api函数创建widget：</p>
<p>• snd_soc_dapm_new_controls()<br>实际上，这个函数只是创建widget的第一步，它为每个widget分配内存，初始化必要的字段，然后把这些widget挂在代表声卡的snd_soc_card的widgets链表字段中。要使widget之间具备连接能力，我们还需要第二个函数：<br>• snd_soc_dapm_new_widgets()<br>这个函数会根据widget的信息，创建widget所需要的dapm kcontrol，这些dapm kcontol的状态变化，代表着音频路径的变化，从而影响着各个widget的电源状态。看到函数的名称可能会迷惑一下，实际上，snd_soc_dapm_new_controls的作用更多地是创建widget，而snd_soc_dapm_new_widget的作用则更多地是创建widget所包含的kcontrol，所以在我看来，这两个函数名称应该换过来叫更好！下面我们分别介绍一下这两个函数是如何工作的。</p>
<h5 id="7-3-1、创建widget"><a href="#7-3-1、创建widget" class="headerlink" title="7.3.1、创建widget"></a>7.3.1、创建widget</h5><p>snd_soc_dapm_new_controls()函数完成widget的创建工作，并把这些创建好的widget注册在声卡的widgets链表中，我们看看他的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_controls</span><span class="params">(struct snd_soc_dapm_context *dapm,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct snd_soc_dapm_widget *widget,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        w = snd_soc_dapm_new_control(dapm, widget);</span><br><span class="line">        <span class="keyword">if</span> (!w) &#123;</span><br><span class="line">            dev_err(dapm-&gt;dev,</span><br><span class="line">                <span class="string">&quot;ASoC: Failed to create DAPM control %s\n&quot;</span>,</span><br><span class="line">                widget-&gt;name);</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        widget++;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数只是简单的一个循环，为传入的widget模板数组依次调用snd_soc_dapm_new_control函数，实际的工作由snd_soc_dapm_new_control完成，继续进入该函数，看看它做了那些工作。<br>我们之前已经说过，驱动中定义的snd_soc_dapm_widget数组，只是作为一个模板，所以，snd_soc_dapm_new_control所做的第一件事，就是为该widget重新分配内存，并把模板的内容拷贝过来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *</span></span><br><span class="line"><span class="class"><span class="title">snd_soc_dapm_new_control</span>(<span class="title">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>,</span></span><br><span class="line"><span class="class">             <span class="title">const</span> <span class="title">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">widget</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *prefix;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((w = dapm_cnew_widget(widget)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//由dapm_cnew_widget完成内存申请和拷贝模板的动作。接下来，根据widget的类型做不同的处理：</span></span><br><span class="line">    <span class="keyword">switch</span> (w-&gt;id) &#123;</span><br><span class="line">    <span class="keyword">case</span> snd_soc_dapm_regulator_supply:</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    prefix = soc_dapm_prefix(dapm);</span><br><span class="line">    <span class="comment">//对于snd_soc_dapm_regulator_supply类型的widget，根据widget的名称获取对应的regulator结构，对于snd_soc_dapm_clock_supply类型的widget，根据widget的名称，获取对应的clock结构。接下来，根据需要，在widget的名称前加入必要的前缀：</span></span><br><span class="line">    <span class="keyword">if</span> (prefix) &#123;</span><br><span class="line">        w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s %s&quot;</span>, prefix, widget-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">            w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">&quot;%s %s&quot;</span>, prefix,</span><br><span class="line">                         widget-&gt;sname);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s&quot;</span>, widget-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">            w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">&quot;%s&quot;</span>, widget-&gt;sname);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/29-Audio-system-widget-1525420992983.png" alt="Alt text"><br>当音频路径发生变化时，power_check回调会被调用，用于检查该widget的电源状态是否需要更新。power_check设置完成后，需要设置widget所属的codec、platform和dapm context，几个用于音频路径的链表也需要初始化，然后，把该widget加入到声卡的widgets链表中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line">w-&gt;dapm = dapm;  </span><br><span class="line">w-&gt;codec = dapm-&gt;codec;  </span><br><span class="line">w-&gt;platform = dapm-&gt;platform;  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sources);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sinks);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;<span class="built_in">list</span>);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;dirty);  </span><br><span class="line">list_add(&amp;w-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;widgets);  </span><br></pre></td></tr></table></figure>

<p>几个链表的作用如下：<br>sources    用于链接所有连接到该widget输入端的snd_soc_path结构<br>sinks    用于链接所有连接到该widget输出端的snd_soc_path结构<br>list    用于链接到声卡的widgets链表<br>dirty    用于链接到声卡的dapm_dirty链表<br>最后，把widget设置为connect状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line"><span class="comment">/* machine layer set ups unconnected pins and insertions */</span>  </span><br><span class="line">w-&gt;connected = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">return</span> w;  </span><br></pre></td></tr></table></figure>
<p>connected字段代表着引脚的连接状态，目前，只有以下这些widget使用connected字段：<br>snd_soc_dapm_output<br>snd_soc_dapm_input<br>snd_soc_dapm_hp<br>snd_soc_dapm_spk<br>snd_soc_dapm_line<br>snd_soc_dapm_vmid<br>snd_soc_dapm_mic<br>snd_soc_dapm_siggen<br>驱动程序可以使用以下这些api来设置引脚的连接状态：<br>snd_soc_dapm_enable_pin<br>snd_soc_dapm_force_enable_pin<br>snd_soc_dapm_disable_pin<br>snd_soc_dapm_nc_pin<br>到此，widget已经被正确地创建并初始化，而且被挂在声卡的widgets链表中，以后我们就可以通过声卡的widgets链表来遍历所有的widget，再次强调一下snd_soc_dapm_new_controls函数所完成的主要功能：<br>为widget分配内存，并拷贝参数中传入的在驱动中定义好的模板<br>设置power_check回调函数<br>把widget挂在声卡的widgets链表中</p>
<h5 id="7-3-2、为widget建立dapm-kcontrol"><a href="#7-3-2、为widget建立dapm-kcontrol" class="headerlink" title="7.3.2、为widget建立dapm kcontrol"></a>7.3.2、为widget建立dapm kcontrol</h5><p>定义一个widget，我们需要指定两个很重要的内容：一个是用于控制widget的电源状态的reg/shift等寄存器信息，另一个是用于控制音频路径切换的dapm kcontrol信息，这些dapm kcontrol有它们自己的reg/shift寄存器信息用于切换widget的路径连接方式。前一节的内容中，我们只是创建了widget的实例，并把它们注册到声卡的widgts链表中，但是到目前为止，包含在widget中的dapm kcontrol并没有建立起来，dapm框架在声卡的初始化阶段，等所有的widget（包括machine、platform、codec）都创建好之后，通过snd_soc_dapm_new_widgets函数，创建widget内包含的dapm kcontrol，并初始化widget的初始电源状态和音频路径的初始连接状态。我们看看声卡的初始化函数，都有那些初始化与dapm有关：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_instantiate_card</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="comment">/* card bind complete so register a sound card */</span>  </span><br><span class="line">        ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,  </span><br><span class="line">                        card-&gt;owner, <span class="number">0</span>, &amp;card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">   </span><br><span class="line">        card-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;  </span><br><span class="line">        card-&gt;dapm.dev = card-&gt;dev;  </span><br><span class="line">        card-&gt;dapm.card = card;  </span><br><span class="line">        list_add(&amp;card-&gt;dapm.<span class="built_in">list</span>, &amp;card-&gt;dapm_list);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_widgets)    <span class="comment">/* 创建machine级别的widget  */</span>  </span><br><span class="line">                snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets,  </span><br><span class="line">                                          card-&gt;num_dapm_widgets);  </span><br><span class="line">        ......  </span><br><span class="line">        snd_soc_dapm_link_dai_widgets(card);  <span class="comment">/*  连接dai widget  */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;controls)    <span class="comment">/*  建立machine级别的普通kcontrol控件  */</span>  </span><br><span class="line">                snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_routes)    <span class="comment">/*  注册machine级别的路径连接信息  */</span>  </span><br><span class="line">                snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes,  </span><br><span class="line">                                        card-&gt;num_dapm_routes);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;fully_routed)    <span class="comment">/*  如果该标志被置位，自动把codec中没有路径连接信息的引脚设置为无用widget  */</span>  </span><br><span class="line">                list_for_each_entry(codec, &amp;card-&gt;codec_dev_list, card_list)  </span><br><span class="line">                        snd_soc_dapm_auto_nc_codec_pins(codec);  </span><br><span class="line">  </span><br><span class="line">        snd_soc_dapm_new_widgets(card);    <span class="comment">/*初始化widget包含的dapm kcontrol、电源状态和连接状态*/</span>  </span><br><span class="line">  </span><br><span class="line">        ret = snd_card_register(card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">        card-&gt;instantiated = <span class="number">1</span>;  </span><br><span class="line">        snd_soc_dapm_sync(&amp;card-&gt;dapm);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>正如我添加的注释中所示，在完成machine级别的widget和route处理之后，调用的snd_soc_dapm_new_widgets函数，来为所有已经注册的widget初始化他们所包含的dapm kcontrol，并初始化widget的电源状态和路径连接状态。下面我们看看snd_soc_dapm_new_widgets函数的工作过程。</p>
<h5 id="7-3-2-1、snd-soc-dapm-new-widgets函数"><a href="#7-3-2-1、snd-soc-dapm-new-widgets函数" class="headerlink" title="7.3.2.1、snd_soc_dapm_new_widgets函数"></a>7.3.2.1、snd_soc_dapm_new_widgets函数</h5><p>该函数通过声卡的widgets链表，遍历所有已经注册了的widget，其中的new字段用于判断该widget是否已经执行过snd_soc_dapm_new_widgets函数，如果num_kcontrols字段有数值，表明该widget包含有若干个dapm kcontrol，那么就需要为这些kcontrol分配一个指针数组，并把数组的首地址赋值给widget的kcontrols字段，该数组存放着指向这些kcontrol的指针，当然现在这些都是空指针，因为实际的kcontrol现在还没有被创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_widgets</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;card-&gt;widgets, <span class="built_in">list</span>)  </span><br><span class="line">        &#123;                 </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;<span class="keyword">new</span>) <span class="keyword">continue</span>;  </span><br><span class="line">                                  </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;num_kcontrols) &#123;  </span><br><span class="line">                        w-&gt;kcontrols = kzalloc(w-&gt;num_kcontrols *  </span><br><span class="line">                                                <span class="keyword">sizeof</span>(struct snd_kcontrol *),  </span><br><span class="line">                                                GFP_KERNEL);  </span><br><span class="line">                        ......  </span><br><span class="line">                &#125;  </span><br></pre></td></tr></table></figure>
<p>接着，对几种能影响音频路径的widget，创建并初始化它们所包含的dapm kcontrol：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="keyword">switch</span>(w-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        dapm_new_mixer(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        dapm_new_mux(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line">        dapm_new_pga(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>需要用到的创建函数分别是：<br>dapm_new_mixer()    对于mixer类型，用该函数创建dapm kcontrol；<br>dapm_new_mux()   对于mux类型，用该函数创建dapm kcontrol；<br>dapm_new_pga()   对于pga类型，用该函数创建dapm kcontrol；<br>然后，根据widget寄存器的当前值，初始化widget的电源状态，并设置到power字段中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="comment">/* Read the initial power state from the device */</span>  </span><br><span class="line"><span class="keyword">if</span> (w-&gt;reg &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        val = soc_widget_read(w, w-&gt;reg) &gt;&gt; w-&gt;shift;  </span><br><span class="line">        val &amp;= w-&gt;mask;  </span><br><span class="line">        <span class="keyword">if</span> (val == w-&gt;on_val)  </span><br><span class="line">                w-&gt;power = <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>接着，设置new字段，表明该widget已经初始化完成，我们还要吧该widget加入到声卡的dapm_dirty链表中，表明该widget的状态发生了变化，稍后在合适的时刻，dapm框架会扫描dapm_dirty链表，统一处理所有已经变化的widget。为什么要统一处理？因为dapm要控制各种widget的上下电顺序，同时也是为了减少寄存器的读写次数（多个widget可能使用同一个寄存器）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">w-&gt;<span class="keyword">new</span> = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">dapm_mark_dirty(w, <span class="string">&quot;new widget&quot;</span>);  </span><br><span class="line">dapm_debugfs_add_widget(w);  </span><br></pre></td></tr></table></figure>

<p>最后，通过dapm_power_widgets函数，统一处理所有位于dapm_dirty链表上的widget的状态改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);  </span><br><span class="line">......  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br></pre></td></tr></table></figure>
<h5 id="7-3-2-2、dapm-mixer-kcontrol"><a href="#7-3-2-2、dapm-mixer-kcontrol" class="headerlink" title="7.3.2.2、dapm mixer kcontrol"></a>7.3.2.2、dapm mixer kcontrol</h5><p>上一节中，我们提到，对于mixer类型的dapm kcontrol，我们会使用dapm_new_mixer来完成具体的创建工作，先看代码后分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mixer</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, ret;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* add kcontrol */</span>  </span><br><span class="line">（<span class="number">1</span>）        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w-&gt;num_kcontrols; i++) &#123;                                  </span><br><span class="line">                <span class="comment">/* match name */</span>  </span><br><span class="line">（<span class="number">2</span>）                list_for_each_entry(path, &amp;w-&gt;sources, list_sink) &#123;               </span><br><span class="line">                        <span class="comment">/* mixer/mux paths name must match control name */</span>  </span><br><span class="line">（<span class="number">3</span>）                        <span class="keyword">if</span> (path-&gt;name != (<span class="keyword">char</span> *)w-&gt;kcontrol_news[i].name)       </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">4</span>）                        <span class="keyword">if</span> (w-&gt;kcontrols[i]) &#123;                                   </span><br><span class="line">                                dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);  </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">5</span>）                        ret = dapm_create_or_share_mixmux_kcontrol(w, i);        </span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                                <span class="keyword">return</span> ret;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">6</span>）                        dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);           </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>（1）  因为一个mixer是由多个kcontrol组成的，每个kcontrol控制着mixer的一个输入端的开启和关闭，所以，该函数会根据kcontrol的数量做循环，逐个建立对应的kcontrol。<br>（2）（3）  之前多次提到，widget之间使用snd_soc_path进行连接，widget的sources链表保存着所有和输入端连接的snd_soc_path结构，所以我们可以用kcontrol模板中指定的名字来匹配对应的snd_soc_path结构。<br>（4）  因为一个输入脚可能会连接多个输入源，所以可能在上一个输入源的path关联时已经创建了这个kcontrol，所以这里判断kcontrols指针数组中对应索引中的指针值，如果已经赋值，说明kcontrol已经在之前创建好了，所以我们只要简单地把连接该输入端的path加入到kcontrol的path_list链表中，并且增加一个虚拟的影子widget，该影子widget连接和输入端对应的源widget，因为使用了kcontrol本身的reg/shift等寄存器信息，所以实际上控制的是该kcontrol的开和关，这个影子widget只有在kcontrol的autodisable字段被设置的情况下才会被创建，该特性使得source的关闭时，与之连接的mixer的输入端也可以自动关闭，这个特性通过dapm_kcontrol_add_path来实现这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dapm_kcontrol_add_path</span><span class="params">(<span class="keyword">const</span> struct snd_kcontrol *kcontrol,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dapm_kcontrol_data</span> *<span class="title">data</span> = <span class="title">snd_kcontrol_chip</span>(<span class="title">kcontrol</span>);</span>  </span><br><span class="line">        <span class="comment">/*  把kcontrol连接的path加入到paths链表中  */</span>  </span><br><span class="line">        <span class="comment">/*  paths链表所在的dapm_kcontrol_data结构会保存在kcontrol的private_data字段中  */</span>  </span><br><span class="line">        list_add_tail(&amp;path-&gt;list_kcontrol, &amp;data-&gt;paths);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (data-&gt;widget) &#123;  </span><br><span class="line">                snd_soc_dapm_add_path(data-&gt;widget-&gt;dapm, data-&gt;widget,  </span><br><span class="line">                    path-&gt;source, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>（5）  如果kcontrol之前没有被创建，则通过dapm_create_or_share_mixmux_kcontrol创建这个输入端的kcontrol，同理，kcontrol对应的影子widget也会通过dapm_kcontrol_add_path判断是否需要创建。</p>
<h5 id="7-3-2-3、dapm-mux-kcontrol"><a href="#7-3-2-3、dapm-mux-kcontrol" class="headerlink" title="7.3.2.3、dapm mux kcontrol"></a>7.3.2.3、dapm mux kcontrol</h5><p>因为一个widget最多只会包含一个mux类型的damp kcontrol，所以他的创建方法稍有不同，dapm框架使用dapm_new_mux函数来创建mux类型的dapm kcontrol：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mux</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span> = <span class="title">w</span>-&gt;<span class="title">dapm</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">          </span><br><span class="line">(<span class="number">1</span>)     <span class="keyword">if</span> (w-&gt;num_kcontrols != <span class="number">1</span>) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev,  </span><br><span class="line">                        <span class="string">&quot;ASoC: mux %s has incorrect number of controls\n&quot;</span>,  </span><br><span class="line">                        w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;w-&gt;sources)) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev, <span class="string">&quot;ASoC: mux %s has no paths\n&quot;</span>, w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">(<span class="number">2</span>)     ret = dapm_create_or_share_mixmux_kcontrol(w, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> ret;  </span><br><span class="line">(<span class="number">3</span>)       list_for_each_entry(path, &amp;w-&gt;sources, list_sink)  </span><br><span class="line">                dapm_kcontrol_add_path(w-&gt;kcontrols[<span class="number">0</span>], path);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>（1）  对于mux类型的widget，因为只会有一个kcontrol，所以在这里做一下判断。<br>（2）  同样地，和mixer类型一样，也使用dapm_create_or_share_mixmux_kcontrol来创建这个kcontrol。<br>（3）  对每个输入端所连接的path都加入dapm_kcontrol_data结构的paths链表中，并且创建一个影子widget，用于支持autodisable特性。</p>
<h5 id="7-3-2-4、dapm-pga-kcontrol"><a href="#7-3-2-4、dapm-pga-kcontrol" class="headerlink" title="7.3.2.4、dapm pga kcontrol"></a>7.3.2.4、dapm pga kcontrol</h5><p>目前对于pga类型的widget，kcontrol的创建函数是个空函数，所以我们不用太关注它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_pga</span><span class="params">(struct snd_soc_dapm_widget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;num_kcontrols)</span><br><span class="line">        dev_err(w-&gt;dapm-&gt;dev,</span><br><span class="line">            <span class="string">&quot;ASoC: PGA controls not supported: &#x27;%s&#x27;\n&quot;</span>, w-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dapm_create_or_share_mixmux_kcontrol函数<br>上面所说的mixer类型和mux类型的widget，在创建他们所包含的dapm kcontrol时，最后其实都是使用了dapm_create_or_share_mixmux_kcontrol函数来完成创建工作的，所以在这里我们有必要分析一下这个函数的工作原理。这个函数中有很大一部分代码实在处理kcontrol的名字是否要加入codec的前缀，我们会忽略这部分的代码，感兴趣的读者可以自己查看内核的代码，路径在：sound/soc/soc-dapm.c中，简化后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_create_or_share_mixmux_kcontrol</span><span class="params">(struct snd_soc_dapm_widget *w,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> kci)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">          ......  </span><br><span class="line">(<span class="number">1</span>)       shared = dapm_is_shared_kcontrol(dapm, w, &amp;w-&gt;kcontrol_news[kci],  </span><br><span class="line">                                         &amp;kcontrol);  </span><br><span class="line">     </span><br><span class="line">(<span class="number">2</span>)       <span class="keyword">if</span> (!kcontrol) &#123;  </span><br><span class="line">(<span class="number">3</span>)            kcontrol = snd_soc_cnew(&amp;w-&gt;kcontrol_news[kci], <span class="literal">NULL</span>, name,prefix）;  </span><br><span class="line">               ......  </span><br><span class="line">               kcontrol-&gt;private_free = dapm_kcontrol_free;  </span><br><span class="line">(<span class="number">4</span>)            ret = dapm_kcontrol_data_alloc(w, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">(<span class="number">5</span>)            ret = snd_ctl_add(card, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">        &#125;  </span><br><span class="line">(<span class="number">6</span>)     ret = dapm_kcontrol_add_widget(kcontrol, w);  </span><br><span class="line">        ......  </span><br><span class="line">(<span class="number">7</span>)     w-&gt;kcontrols[kci] = kcontrol;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>（1）  为了节省内存，通过kcontrol名字的匹配查找，如果这个kcontrol已经在其他widget中已经创建好了，那我们不再创建，dapm_is_shared_kcontrol的参数kcontrol会返回已经创建好的kcontrol的指针。<br>（2）  如果kcontrol指针被赋值，说明在（1）中查找到了其他widget中同名的kcontrol，我们不用再次创建，只要共享该kcontrol即可。<br>（3）  标准的kcontrol创建函数，<br>（4）  如果widget支持autodisable特性，创建与该kcontrol所对应的影子widget，该影子widget的类型是：snd_soc_dapm_kcontrol。<br>（5）  标准的kcontrol创建函数，<br>（6）  把所有共享该kcontrol的影子widget（snd_soc_dapm_kcontrol），加入到kcontrol的private_data字段所指向的dapm_kcontrol_data结构中。<br>（7）  把创建好的kcontrol指针赋值到widget的kcontrols数组中。<br>需要注意的是，如果kcontol支持autodisable特性，一旦kcontrol由于source的关闭而被自动关闭，则用户空间只能操作该kcontrol的cache值，只有该kcontrol再次打开时，该cache值才会被真正地更新到寄存器中。<br>现在。我们总结一下，创建一个widget所包含的kcontrol所做的工作：<br>• 循环每一个输入端，为每个输入端依次执行下面的一系列操作<br>• 为每个输入端创建一个kcontrol，能共享的则直接使用创建好的kcontrol<br>• kcontrol的private_data字段保存着这些共享widget的信息<br>• 如果支持autodisable特性，每个输入端还要额外地创建一个虚拟的snd_soc_dapm_kcontrol类型的影子widget，该影子widget也记录在private_data字段中<br>• 创建好的kcontrol会依次存放在widget的kcontrols数组中，供路径的控制和匹配之用。</p>
<h5 id="7-3-2-5、为widget建立连接关系"><a href="#7-3-2-5、为widget建立连接关系" class="headerlink" title="7.3.2.5、为widget建立连接关系"></a>7.3.2.5、为widget建立连接关系</h5><p>如果widget之间没有连接关系，dapm就无法实现动态的电源管理工作，正是widget之间有了连结关系，这些连接关系形成了一条所谓的完成的音频路径，dapm可以顺着这条路径，统一控制路径上所有widget的电源状态，前面我们已经知道，widget之间是使用snd_soc_path结构进行连接的，驱动要做的是定义一个snd_soc_route结构数组，该数组的每个条目描述了目的widget的和源widget的名称，以及控制这个连接的kcontrol的名称，最终，驱动程序使用api函数snd_soc_dapm_add_routes来注册这些连接信息，接下来我们就是要分析该函数的具体实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_add_routes</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct snd_soc_dapm_route *route, <span class="keyword">int</span> num)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, r, ret = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">                r = snd_soc_dapm_add_route(dapm, route);  </span><br><span class="line">                ......  </span><br><span class="line">                route++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>该函数只是一个循环，依次对参数传入的数组调用snd_soc_dapm_add_route，主要的工作由snd_soc_dapm_add_route完成。我们进入snd_soc_dapm_add_route函数看看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_route</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> struct snd_soc_dapm_route *route)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wsource</span> = <span class="title">NULL</span>, *<span class="title">wsink</span> = <span class="title">NULL</span>, *<span class="title">w</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wtsource</span> = <span class="title">NULL</span>, *<span class="title">wtsink</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *sink;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *source;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;dapm-&gt;card-&gt;widgets, <span class="built_in">list</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!wsink &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, sink))) &#123;  </span><br><span class="line">                        wtsink = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsink = w;  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!wsource &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, source))) &#123;  </span><br><span class="line">                        wtsource = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsource = w;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br></pre></td></tr></table></figure>
<p>上面的代码我再次省略了关于名称前缀的处理部分。我们可以看到，用widget的名字来比较，遍历声卡的widgets链表，找出源widget和目的widget的指针，这段代码虽然正确，但我总感觉少了一个判断退出循环的条件，如果链表的开头就找到了两个widget，还是要遍历整个链表才结束循环，好浪费时间。<br>下面，如果在本dapm context中没有找到，则使用别的dapm context中找到的widget：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line"><span class="keyword">if</span> (!wsink)  </span><br><span class="line">        wsink = wtsink;  </span><br><span class="line"><span class="keyword">if</span> (!wsource)  </span><br><span class="line">        wsource = wtsource; </span><br></pre></td></tr></table></figure>
<p>最后，使用来增加一条连接信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line">        ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route-&gt;control,  </span><br><span class="line">                route-&gt;connected);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>snd_soc_dapm_add_path函数是整个调用链条中的关键，我们来分析一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_path</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *control,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,  </span></span></span><br><span class="line"><span class="function"><span class="params">                         struct snd_soc_dapm_widget *sink))</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">  </span><br><span class="line">        path = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dapm_path), GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!path)  </span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;  </span><br><span class="line">  </span><br><span class="line">        path-&gt;source = wsource;  </span><br><span class="line">        path-&gt;sink = wsink;  </span><br><span class="line">        path-&gt;connected = connected;  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;<span class="built_in">list</span>);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_kcontrol);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_source);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_sink);  </span><br></pre></td></tr></table></figure>
<p>函数的一开始，首先为这个连接分配了一个snd_soc_path结构，path的source和sink字段分别指向源widget和目的widget，connected字段保存connected回调函数，初始化几个snd_soc_path结构中的几个链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* check for external widgets */</span>  </span><br><span class="line">        <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_input) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_micbias ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_mic ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_output)  </span><br><span class="line">                        wsink-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_output) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_spk ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_hp ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_input)  </span><br><span class="line">                        wsource-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br></pre></td></tr></table></figure>
<p>这段代码用于判断是否有外部连接关系，如果有，置位widget的ext字段。判断方法从代码中可以方便地看出：<br>目的widget是一个输入脚，如果源widget是mic、line、micbias或output，则认为目的widget具有外部连接关系。<br>源widget是一个输出脚，如果目的widget是spk、hp、line或input，则认为源widget具有外部连接关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">dapm_mark_dirty(wsource, <span class="string">&quot;Route added&quot;</span>);  </span><br><span class="line">dapm_mark_dirty(wsink, <span class="string">&quot;Route added&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* connect static paths */</span>  </span><br><span class="line"><span class="keyword">if</span> (control == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>因为增加了连结关系，所以把源widget和目的widget加入到dapm_dirty链表中。如果没有kcontrol来控制该连接关系，则这是一个静态连接，直接用path把它们连接在一起。在接着往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* connect dynamic paths */</span>  </span><br><span class="line"><span class="keyword">switch</span> (wsink-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_adc:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dac:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_input:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_output:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_siggen:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_micbias:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_vmid:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pre:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_post:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_clock_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_link:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_kcontrol:  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br></pre></td></tr></table></figure>
<p>按照目的widget来判断，如果属于以上这些类型，直接把它们连接在一起即可，这段感觉有点多余，因为通常以上这些类型的widget本来也没有kcontrol，直接用上一段代码就可以了，也许是dapm的作者们想着以后可能会有所扩展吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        ret = dapm_connect_mux(dapm, wsource, wsink, path, control,  </span><br><span class="line">                &amp;wsink-&gt;kcontrol_news[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br></pre></td></tr></table></figure>
<p>目的widget如果是mixer和mux类型，分别用dapm_connect_mixer和dapm_connect_mux函数完成连接工作，这两个函数我们后面再讲。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_hp:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_mic:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_line:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_spk:  </span><br><span class="line">                list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">                list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">                path-&gt;connect = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">err:  </span><br><span class="line">        kfree(path);  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>hp、mic、line和spk这几种widget属于外部器件，也只是简单地连接在一起，不过connect字段默认为是未连接状态。<br>现在，我们回过头来看看目的widget是mixer和mux这两种类型时的连接方式：<br>dapm_connect_mixer  用该函数连接一个目的widget为mixer类型的所有输入端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mixer</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* search for mixer kcontrol */</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dest-&gt;num_kcontrols; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(control_name, dest-&gt;kcontrol_news[i].name)) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = dest-&gt;kcontrol_news[i].name;  </span><br><span class="line">                        dapm_set_path_status(dest, path, i);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>用需要用来连接的kcontrol的名字，和目的widget中的kcontrol模板数组中的名字相比较，找出该kcontrol在widget中的编号，path的名字设置为该kcontrol的名字，然后用dapm_set_path_status函数来初始化该输入端的连接状态。连接两个widget的链表操作和其他widget是一样的。</p>
<p>dapm_connect_mux 用该函数连接一个目的widget是mux类型的所有输入端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mux</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct snd_kcontrol_new *kcontrol)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> *<span class="title">e</span> = (<span class="title">struct</span> <span class="title">soc_enum</span> *)<span class="title">kcontrol</span>-&gt;<span class="title">private_value</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;max; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">strcmp</span>(control_name, e-&gt;texts[i]))) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = (<span class="keyword">char</span>*)e-&gt;texts[i];  </span><br><span class="line">                        dapm_set_path_status(dest, path, <span class="number">0</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>和mixer类型一样用名字进行匹配，只不过mux类型的kcontrol只需一个，所以要通过private_value字段所指向的soc_enum结构找出匹配的输入脚编号，最后也是通过dapm_set_path_status函数来初始化该输入端的连接状态，因为只有一个kcontrol，所以第三个参数是0。连接两个widget的链表操作和其他widget也是一样的。<br>dapm_set_path_status    该函数根据传入widget中的kcontrol编号，读取实际寄存器的值，根据寄存器的值来初始化这个path是否处于连接状态，详细的代码这里就不贴了。<br>当widget之间通过path进行连接之后，他们之间的关系就如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/210-Audio-system-snd_soc_dapm_path.png" alt="Alt text"></p>
<p>到这里为止，我们为声卡创建并初始化好了所需的widget，各个widget也通过path连接在了一起，接下来，dapm等待用户的指令，一旦某个dapm kcontrol被用户空间改变，利用这些连接关系，dapm会重新创建音频路径，脱离音频路径的widget会被下电，加入音频路径的widget会被上电，所有的上下电动作都会自动完成，用户空间的应用程序无需关注这些变化，它只管按需要改变某个dapm kcontrol即可。</p>
<h4 id="（八）、tinyplay-playback、capture"><a href="#（八）、tinyplay-playback、capture" class="headerlink" title="（八）、tinyplay playback、capture"></a>（八）、tinyplay playback、capture</h4><h5 id="8-1、tinyplay-playback"><a href="#8-1、tinyplay-playback" class="headerlink" title="8.1、tinyplay playback"></a>8.1、tinyplay playback</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/211-tiny-capture.png" alt="Alt text"></p>
<p>有时序图可知：主要涉及pcm_open()、pcm_write()、pcm_prepare()、pcm_start()。</p>
<h5 id="8-1-1、使用耳机播放"><a href="#8-1-1、使用耳机播放" class="headerlink" title="8.1.1、使用耳机播放"></a>8.1.1、使用耳机播放</h5><ol>
<li>启动音频播放</li>
<li>启用 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘RX1’<br>tinymix ‘RX2 MIX1 INP1’ ‘RX2’<br>tinymix ‘RDAC2 MUX’ ‘RX2’<br>tinymix ‘HPHL’ ‘Switch’<br>tinymix ‘HPHR’ ‘Switch’<br>tinymix ‘MI2S_RX Channels’ ‘Two</li>
<li>启用用于通过 MI2S 接口进行播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 1</li>
<li>播放 PCM 音频<br>tinyplay &lt;filename.wav&gt; </li>
<li>停止音频播放</li>
<li>禁用接收 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RX2 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RDAC2 MUX’ ‘ZERO’<br>tinymix ‘HPHL’ ‘ZERO’<br>tinymix ‘HPHR’ ‘ZERO’<br>tinymix ‘MI2S_RX Channels’ ‘One’</li>
<li>禁用用于通过 I2S 接口进行音频播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 0</li>
</ol>
<h5 id="8-2、tinyplay-capture"><a href="#8-2、tinyplay-capture" class="headerlink" title="8.2、tinyplay capture"></a>8.2、tinyplay capture</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/audio.system/212-tiny-playback.png" alt="Alt text"></p>
<p>有时序图可知：主要涉及pcm_open()、pcm_read()、pcm_start()。</p>
<h5 id="8-2-1、使用音频录制"><a href="#8-2-1、使用音频录制" class="headerlink" title="8.2.1、使用音频录制"></a>8.2.1、使用音频录制</h5><ol>
<li>输入以下命令：<br>//Enable DSP AFE for Audio Recording over I2S<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 1<br>//Enable Codec TX Path<br>tinymix ‘DEC1 MUX’ ‘ADC2’<br>tinymix ‘ADC2 MUX’ ‘INP2’</li>
<li>启动录音功能：<br>tinycap /data/rec.wav</li>
<li>禁用 HeadsetX 设备 (AMIC2)：<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 0<br>tinymix ‘DEC1 MUX’ ‘ZERO’<br>tinymix ‘ADC2 MUX’ ‘ZERO’</li>
</ol>
<h4 id="（九）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（九）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（九）、参考资料(特别感谢各位前辈的分析和图示)："></a>（九）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27480328">Android音频模块启动流程分析</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/jhuster">Jhuster的专栏​ Android音频开发</a><br><a target="_blank" rel="noopener" href="http://thinks.me/2016/09/13/audio_qcom_offload/">高通audio offload学习 | Thinking</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/droidphone/article/category/1118446">DroidPhone的专栏 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/orz415678659/article/details/8866071">alsa音频架构1-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/orz415678659/article/details/8982771">alsa音频架构2-ASoc - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/orz415678659/article/details/8995163">alsa音频架构3-Pcm - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/orz415678659/article/details/8999364">alsa音频架构4-声卡控制 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyuanyun/article/details/59180272">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyuanyun/article/details/59170418">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/column/details/12812.html">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyuanyun/article/details/60890534">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/azloong/article/category/778492">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/azloong/article/category/777239">AZURE - CSDN博客 - ANDROID音频系统</a><br><a target="_blank" rel="noopener" href="https://winddoing.github.io/2017/07/10/audio_alsa/">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/muhe221/articles/4461543.html">audio HAL - 牧 天 - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuesen_lin/article/category/1390680">林学森的Android专栏 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangwen123/article/category/2589087">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/">播放框架 - 标签 - Tocy - 博客园</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaomiao12345678/article/details/57415505">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaomiao12345678/article/details/56961370">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/harman_zjc/article/details/53386010">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/harman_zjc/article/details/53397945">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liu1314you/article/category/6344583">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/nonmarking/article/details/78746671">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014310046/article/category/6571854">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiashaohua/article/details/53638780">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiashaohua/article/category/6549668">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/liu1314you/article/details/59119144">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/78007568">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/linhaostudy/category/1145404.html">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20181008/">https://zhoujinjian.com/posts/20181008/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Audio/">Audio</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20181108/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.15.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Audio System（3）：Android audio system(音频系统)分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/20180908/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.13.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20200208/" title="Android Audio System 源码分析（1）：Linux && Android Audio 系统框架简述（Android 5.0.2 && Kernel 3.0.86）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00007.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-08</div><div class="title">Android Audio System 源码分析（1）：Linux && Android Audio 系统框架简述（Android 5.0.2 && Kernel 3.0.86）</div></div></a></div><div><a href="/posts/20200308/" title="Android Audio System源码分析（2）：Linux && Android Audio 系统驱动源码分析（Android 5.0.2 && Kernel 3.0.86）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00008.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="title">Android Audio System源码分析（2）：Linux && Android Audio 系统驱动源码分析（Android 5.0.2 && Kernel 3.0.86）</div></div></a></div><div><a href="/posts/20200408/" title="Android Audio System源码分析（3）：Android Audio 系统源码分析（Android 5.0.2 && Kernel 3.0.86）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/personal.website/post.cover.pictures.00009.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-08</div><div class="title">Android Audio System源码分析（3）：Android Audio 系统源码分析（Android 5.0.2 && Kernel 3.0.86）</div></div></a></div><div><a href="/posts/20180908/" title="Audio System（1）：Linux && Android Audio 系统框架分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-08</div><div class="title">Audio System（1）：Linux && Android Audio 系统框架分析</div></div></a></div><div><a href="/posts/20181108/" title="Audio System（3）：Android audio system(音频系统)分析"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/hexo.themes/bing-wallpaper-2018.04.15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-08</div><div class="title">Audio System（3）：Android audio system(音频系统)分析</div></div></a></div><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89-Overview"><span class="toc-number">1.</span> <span class="toc-text">（一） Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89ASoC-Core"><span class="toc-number">2.</span> <span class="toc-text">（二）ASoC Core</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Codec-Driver"><span class="toc-number">3.</span> <span class="toc-text">（三）Codec Driver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-Codec-DAI-and-PCM-configuration"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Codec DAI and PCM configuration</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Codec-control-IO"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. Codec control IO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Mixers-and-audio-controls"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. Mixers and audio controls</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-Codec-audio-operations"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. Codec audio operations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-Codec-register"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. Codec register</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Platform-Driver"><span class="toc-number">4.</span> <span class="toc-text">（四）Platform Driver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-pcm-operations"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. pcm operations</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-platform-driver-%E6%B3%A8%E5%86%8C"><span class="toc-number">4.2.</span> <span class="toc-text">4.1. platform_driver 注册</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89-Machine-Driver"><span class="toc-number">5.</span> <span class="toc-text">（五）  Machine Driver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81%E5%A3%B0%E5%8D%A1%E5%92%8C-PCM-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">（六）、声卡和 PCM 设备的建立过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E5%A3%B0%E5%8D%A1%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 声卡结构概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E5%A3%B0%E5%8D%A1%E7%9A%84%E5%88%9B%E5%BB%BAsnd-card-create"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 声卡的创建snd_card_create()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 逻辑设备的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-%E5%A3%B0%E5%8D%A1%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 声卡的注册</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81DAPM%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">（七）、DAPM分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1%E3%80%81DAPM%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">7.1、DAPM简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1%E3%80%81kcontrol"><span class="toc-number">7.2.</span> <span class="toc-text">7.1、kcontrol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-1%E3%80%81%E7%AE%80%E5%8D%95%E5%9E%8B%E7%9A%84%E6%8E%A7%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">7.1.1、简单型的控件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-2%E3%80%81Mixer%E6%8E%A7%E4%BB%B6"><span class="toc-number">7.4.</span> <span class="toc-text">7.1.2、Mixer控件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-3%E3%80%81Mux%E6%8E%A7%E4%BB%B6"><span class="toc-number">7.5.</span> <span class="toc-text">7.1.3、Mux控件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2%E3%80%81widget%E3%80%81path%E3%80%81route"><span class="toc-number">7.6.</span> <span class="toc-text">7.2、widget、path、route</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-1%E3%80%81DAPM%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%EF%BC%9Awidget"><span class="toc-number">7.7.</span> <span class="toc-text">7.2.1、DAPM的基本单元：widget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2%E3%80%81widget%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">7.8.</span> <span class="toc-text">7.2.2、widget的种类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-3%E3%80%81widget%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%99%A8%EF%BC%9Apath"><span class="toc-number">7.9.</span> <span class="toc-text">7.2.3、widget之间的连接器：path</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-4%E3%80%81widget%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB%EF%BC%9Aroute"><span class="toc-number">7.10.</span> <span class="toc-text">7.2.4、widget的连接关系：route</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3%E3%80%81%E5%BB%BA%E7%AB%8Bwidget%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-number">7.11.</span> <span class="toc-text">7.3、建立widget之间的连接关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-1%E3%80%81%E5%88%9B%E5%BB%BAwidget"><span class="toc-number">7.12.</span> <span class="toc-text">7.3.1、创建widget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2%E3%80%81%E4%B8%BAwidget%E5%BB%BA%E7%AB%8Bdapm-kcontrol"><span class="toc-number">7.13.</span> <span class="toc-text">7.3.2、为widget建立dapm kcontrol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-1%E3%80%81snd-soc-dapm-new-widgets%E5%87%BD%E6%95%B0"><span class="toc-number">7.14.</span> <span class="toc-text">7.3.2.1、snd_soc_dapm_new_widgets函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-2%E3%80%81dapm-mixer-kcontrol"><span class="toc-number">7.15.</span> <span class="toc-text">7.3.2.2、dapm mixer kcontrol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-3%E3%80%81dapm-mux-kcontrol"><span class="toc-number">7.16.</span> <span class="toc-text">7.3.2.3、dapm mux kcontrol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-4%E3%80%81dapm-pga-kcontrol"><span class="toc-number">7.17.</span> <span class="toc-text">7.3.2.4、dapm pga kcontrol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-5%E3%80%81%E4%B8%BAwidget%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-number">7.18.</span> <span class="toc-text">7.3.2.5、为widget建立连接关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%81tinyplay-playback%E3%80%81capture"><span class="toc-number">8.</span> <span class="toc-text">（八）、tinyplay playback、capture</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1%E3%80%81tinyplay-playback"><span class="toc-number">8.1.</span> <span class="toc-text">8.1、tinyplay playback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1%E3%80%81%E4%BD%BF%E7%94%A8%E8%80%B3%E6%9C%BA%E6%92%AD%E6%94%BE"><span class="toc-number">8.2.</span> <span class="toc-text">8.1.1、使用耳机播放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2%E3%80%81tinyplay-capture"><span class="toc-number">8.3.</span> <span class="toc-text">8.2、tinyplay capture</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-1%E3%80%81%E4%BD%BF%E7%94%A8%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6"><span class="toc-number">8.4.</span> <span class="toc-text">8.2.1、使用音频录制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E7%89%B9%E5%88%AB%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%89%8D%E8%BE%88%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E5%9B%BE%E7%A4%BA-%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">（九）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>