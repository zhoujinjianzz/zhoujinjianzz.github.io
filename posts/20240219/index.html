<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android 11 Display System V2（2）：Rockchip RK3399 - DRM驱动程序 | zhoujinjian</title><meta name="keywords" content="Linux"><meta name="author" content="zhoujinjian"><meta name="copyright" content="zhoujinjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 11 Display System V2（2）：Rockchip RK3399 - DRM驱动程序">
<meta property="og:url" content="https://zhoujinjian.com/posts/20240219/index.html">
<meta property="og:site_name" content="zhoujinjian">
<meta property="og:description" content="注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。 （">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.58.jpg">
<meta property="article:published_time" content="2024-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-14T13:01:32.936Z">
<meta property="article:author" content="zhoujinjian">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.58.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhoujinjian.com/posts/20240219/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 21:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"><meta name="generator" content="Hexo 5.0.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.58.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zhoujinjian</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 媒体</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/home/"><i class="fa-fw fa fa-cloud-sun-rain"></i><span> 主页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/navigation/"><i class="fa-fw fab fa-safari"></i><span> 导航</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Android 11 Display System V2（2）：Rockchip RK3399 - DRM驱动程序</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-18T16:00:00.000Z" title="发表于 2024-02-19 00:00:00">2024-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-14T13:01:32.936Z" title="更新于 2024-04-14 21:01:32">2024-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>注：文章都是通过阅读各位前辈总结的资料 Android 11.0 &amp;&amp; Linux（Kernel 4.19）Rockchip平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除（◕‿◕），转载请注明出处（©Rockchip ©Android @Linux 版权所有），谢谢。</p>
<p>（==<strong>文章基于 Kernel-4.19</strong>==）&amp;&amp;（==<strong>文章基于 Android 11.0</strong>==）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/zhoujinjianzz">【zhoujinjian.com博客原图链接】</a> </p>
<p><a target="_blank" rel="noopener" href="https://shop.allnetchina.cn/collections/frontpage/products/rock-pi-4-model-b-board-only-2-4-5ghz-wlan-bluetooth-5-0">【开发板 RockPi4bPlusV1.6】</a></p>
<p><a href="">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）源码链接】</a>：（repo init -u <a target="_blank" rel="noopener" href="https://github.com/radxa/manifests.git">https://github.com/radxa/manifests.git</a> -b Android11_Radxa_rk11.1 -m rockchip-r-release.xml）</p>
<p><a target="_blank" rel="noopener" href="https://wiki.radxa.com/Rockpi4/rockpi-android11">【开发板 RockPi4bPlusV1.6 Android 11.0 &amp;&amp; Linux（Kernel 4.19）编译指南】</a></p>
<p>正是由于前人（各位大神）的分析和总结，帮助我节约了大量的时间和精力，特别感谢，由于不喜欢图片水印，去除了水印，敬请谅解！！！</p>
<p>本文转自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17686403.html">Rockchip RK3399 - DRM驱动程序</a>，如有侵权，请联系删除。</p>
<hr>
<p>开发板 ：<code>ROCK Pi 4B+</code>开发板<br><code>eMMC</code> ：<code>32GB</code><br><code>LPDDR4</code> ：<code>4GB</code><br>显示屏 ：<code>7</code>英寸<code>HDMI</code>接口显示屏<br><code>u-boot</code> ：<code>2017.09</code><br><code>linux</code> ：<code>4.19</code>  </p>
<hr>
<p>如果我们需要编写一个<code>DRM</code>驱动，我们应该怎么做呢？具体流程如下：</p>
<p>(1) 定义<code>struct drm_driver</code>，并初始化成员<code>name</code>、<code>desc</code>、<code>data</code>、<code>major</code>、<code>minor</code>、<code>driver_features</code>、<code>fops</code>、<code>dumb_create</code>等；</p>
<p>(2)调用<code>drm_dev_alloc</code>函数分配并初始化一个<code>struct drm_device</code>；</p>
<p>(3) 调用<code>drm_mode_config_init</code>初始化<code>drm_device</code>中<code>mode_config</code>结构体；</p>
<p>(4) 调用<code>drm_xxx_init</code>创建 <code>framebuffer</code>、<code>plane</code>、<code>crtc</code>、<code>encoder</code>、<code>connector</code> 这5个 <code>drm_mode_object</code>；</p>
<p>(5) 调用<code>drm_dev_register</code>注册<code>drm_device</code>；</p>
<h3 id="一、显示子系统概述"><a href="#一、显示子系统概述" class="headerlink" title="一、显示子系统概述"></a>一、显示子系统概述</h3><p>显示子系统是<code>Rockchip</code>平台显示输出相关软硬件系统的统称，<code>linux</code>内核采用<code>component</code>框架来构建显示子系统，一个显示子系统由显示处理器（<code>vop</code>，<code>video output processor</code>）、接口控制器（<code>mipi</code>，<code>lvds</code>，<code>hdmi</code>、<code>edp</code>、<code>dp</code>、<code>rgb</code>、<code>BT1120</code>、<code>BT656</code>、<code>I8080</code>（<code>MCU</code> 显示接口）等)、液晶背光，电源等多个独立的功能模块构成。</p>
<p>那么问题来了，什么是显示处理器？</p>
<ul>
<li>将在内存中的图像数据，转化为电信号送到显示设备称为显示控制器，比如早期的<code>LCDC</code>；</li>
<li>后面进行了拓展，可以处理一些简单的图像，比如缩放、旋转、合成等，如瑞芯的<code>vop</code>，高通的<code>sde</code>称为显示处理器；</li>
</ul>
<p>显示处理器可以在没有<code>CPU</code>参与的情况下可以做一些简单的图像处理，比如：</p>
<ul>
<li>缩放，旋转等操作；</li>
<li>支持多层，并可以进行合成，支持<code>porter-duff</code>；</li>
<li>支持多种显存格式（<code>ARGB888</code>,<code>RGB565</code>, 包括<code>GPU</code>输出的<code>tile</code>格式以及<code>fbdc</code>压缩格式）等；</li>
<li>支持生成时序信号如<code>tcon</code>，送给如<code>mipi</code>、<code>lvds</code>等接口；</li>
<li>支持多种分辨率；</li>
</ul>
<h4 id="1-1-硬件框图"><a href="#1-1-硬件框图" class="headerlink" title="1.1 硬件框图"></a>1.1 硬件框图</h4><p>整个显示系统的硬件框架如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm02/202310172239889.png"></p>
<p>VOP 1.0显示子系统架构</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm02/202309112229672.png"></p>
<p>VOP 2.0显示子系统架构</p>
<p>从上面的框图可以看到，在整个显示通路的最后端，是由<code>RGA</code>，<code>GPU</code>、<code>VPU</code>组成的显示图形加速模块，他们是专门针对图像处理优化设计的硬件<code>IP</code>，能够高效的进行图像的⽣成和进一步处理（比如<code>GPU</code>通过<code>opengl</code>功能提供图像渲染功能，<code>RGA</code>可以对图像数据进行缩放，旋转，合成等<code>2D</code>处理，<code>VPU</code>可以高效的进行视频解码），从而减轻<code>CPU</code>负担。</p>
<p>经过这些图像加速模块处理后的数据会存放在<code>DDR</code>中，然后由<code>VOP</code>读取，根据应用需求进行<code>Alpha</code>叠加，颜色空间转换，<code>gamma</code>矫正，<code>HDR</code>转换 等处理后，再发送到对应的显示接口模块（<code>HDMI</code>、<code>eDP/DP</code>、<code>DSI</code>、<code>RGB/BT1120/BT656</code>、<code>LVDS</code>）, 这些接口模块会把接收到的数据转换成符合各⾃协议的数据流，发送到显示器或者屏幕上，呈现在最终用户眼前。</p>
<p>目前<code>Rockchip</code>平台上存在两种<code>VOP</code>架构：</p>
<ul>
<li><code>VOP 1.0</code>：<code>VOP 1.0</code>是用多<code>VOP</code>的方式来实现多屏幕显示，即正常情况下，一个<code>VOP</code>在同一时刻只能输出一路独立的显示时序，驱动一个屏幕显示独立的内容。如果需要实现双屏显示，则需要有两个<code>VOP</code>来实现，所以在<code>RK3288</code>，<code>RK3399</code>，<code>PX30</code>等⽀持双显的平台上，都有两个独立的<code>VOP</code>；</li>
<li><code>VOP 2.0</code>：<code>VOP 2.0</code>采用了统一显示架构，即整个<code>SoC</code>上只存在一个<code>VOP</code>，但是在<code>VOP</code>的后端设计了多路独立的<code>Video Port</code>(简称 <code>VP</code>) 输出接口，这些 <code>VP</code>能够同时独立⼯作，并且输出相互独立的显示时序。比如在上面的<code>VOP 2.0</code>框图中，有三个<code>VP</code>，就能同时实现三屏异显；</li>
</ul>
<h5 id="1-1-1-RK3399"><a href="#1-1-1-RK3399" class="headerlink" title="1.1.1 RK3399"></a>1.1.1 <code>RK3399</code></h5><p><code>RK3399</code>有2个<code>VOP</code>：</p>
<ul>
<li><code>Video Output Processor</code>(<code>VOP_BIG</code>)：<code>supports 4096x2160 with AFBC</code>;</li>
<li><code>Video Output Processor</code>(<code>VOP_LIT</code>)：<code>supports 2560x1600</code>；</li>
</ul>
<p>支持的显示接口：</p>
<ul>
<li>双通道<code>MIPI DSI</code>(4线/通道)显示接口；</li>
<li>1个<code>eDP</code>显示接口；</li>
<li>1个<code>DP</code>显示接口；</li>
<li>1个<code>HDMI</code>显示接口；</li>
</ul>
<p><code>RK3399</code>支持的最大输出分辨率和协议标准如下：</p>
<table>
<thead>
<tr>
<th>显示接口</th>
<th>最大输出</th>
<th>协议标准</th>
</tr>
</thead>
<tbody><tr>
<td>eDP</td>
<td>VOP BIG: 3840x2160@60hz</td>
<td></td>
</tr>
<tr>
<td>VOP LITE: 2560x1600@60hz</td>
<td>支持 DP1.2a 和 eDP1.3 协议标准</td>
<td></td>
</tr>
<tr>
<td>MIPI</td>
<td>单通道：1920x1080@60hz</td>
<td></td>
</tr>
<tr>
<td>双通道：2560x1600@60hz</td>
<td>支持 DSI v1.1，DCS v1.1，DPHY v1.1 协议标准</td>
<td></td>
</tr>
<tr>
<td>HDMI</td>
<td>VOP BIG:：4096X2160@60hz</td>
<td></td>
</tr>
<tr>
<td>VOP LITE: 2560x1600@60hz</td>
<td>支持 HDMI 1.4a 和 2.0a 协议标准</td>
<td></td>
</tr>
<tr>
<td>DP</td>
<td>VOP BIG:：4096X2160@60hz</td>
<td></td>
</tr>
<tr>
<td>VOP LITE: 2560x1600@60hz</td>
<td>支持 DP 1.2 协议标准</td>
<td></td>
</tr>
</tbody></table>
<h5 id="1-1-2-ROCK-Pi-4B"><a href="#1-1-2-ROCK-Pi-4B" class="headerlink" title="1.1.2 ROCK Pi 4B+"></a>1.1.2 <code>ROCK Pi 4B+</code></h5><p>我们所使用的的<code>ROCK Pi 4B+</code>开发板，视频输出支持：</p>
<ul>
<li><code>LCD Interface</code>: 一个<code>eDP 1.3</code>（4线，<code>10.8Gbps</code>）, 一个或2个4线<code>MIPI DSI</code>；</li>
<li><code>DP on Type-C</code>: <code>DisplayPort 1.2 Alt Mode on USB Type-C</code> ;</li>
<li><code>HDMI</code>: <code>HDMI 2.0a</code>, 支持<code>4K@60Hz</code>显示，支持<code>HDCP 1.4/2.2</code>;</li>
</ul>
<h4 id="1-2-DRM加载顺序"><a href="#1-2-DRM加载顺序" class="headerlink" title="1.2 DRM加载顺序"></a>1.2 <code>DRM</code>加载顺序</h4><p><code>DRM</code>驱动是由一系列相关功能模块的驱动的结合，它包含了<code>vop</code>、<code>mipi</code>、<code>lvds</code>、<code>hdmi</code>、<code>edp</code>、<code>dp</code>、<code>backlight</code>等等显示通路上的依赖模块。只有这些相互依赖的模块都加载完整，整个<code>drm</code>系统才算启动完成。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17666031.html#_label1_2"><code>DRM</code>子系统</a>中我们介绍了如何去抽象显示硬件到具体的<code>DRM object</code>；这里我们结合<code>Rockchip</code>平台以<code>MIPI DSI</code>显示接口为例来介绍显示硬件到具体的<code>DRM object</code>抽象，</p>
<table>
<thead>
<tr>
<th>object</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plane</td>
<td>图层；对Overlay硬件的抽象，同样需要访问Display Controller寄存器，因此也放在Display Controller驱动中</td>
</tr>
<tr>
<td>在Rockchip平台里对应SoC内部vop模块的win图层</td>
<td></td>
</tr>
<tr>
<td>crtc</td>
<td>显示控制器；RGB timing的产生，以及显示数据的更新，都需要访问Dislay Controller硬件寄存器，因此放在Display Controller驱动中</td>
</tr>
<tr>
<td>在Rockchip平台里对应SoC内部的vop模块</td>
<td></td>
</tr>
<tr>
<td>encoder</td>
<td>编码器；将RGB并行信号转换为DSI行信号，需要配置DSI硬件寄存器，因此放在DSI Controller驱动中</td>
</tr>
<tr>
<td>connector</td>
<td>连接器；可以通过drm_panel来获取LCD的mode信息，但是encoder在哪，connector就在哪，因此放在DSI Controller驱动中</td>
</tr>
<tr>
<td>drm_panel</td>
<td>用于获取LCD mode参数，并提供LCD休眠唤醒的回调接口，供encoder调用，因此放在LCD驱动中</td>
</tr>
<tr>
<td>bridge</td>
<td>桥接设备；一般用于注册encoder后面另外再接的转换芯片，如DSI2HDMI转换芯片</td>
</tr>
</tbody></table>
<p>接下来我们将会以<code>RK3399 DRM</code>驱动为例对显示子系统的各个模块进行介绍；</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>文件清单</th>
</tr>
</thead>
<tbody><tr>
<td>core</td>
<td>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</td>
</tr>
<tr>
<td>framebuffer</td>
<td>drivers/gpu/drm/rockchip/rockchip_drm_fb.c</td>
</tr>
<tr>
<td>gem</td>
<td>drivers/gpu/drm/rockchip/rockchip_drm_gem.c</td>
</tr>
<tr>
<td>vop</td>
<td>drivers/gpu/drm/rockchip/rockchip_drm_vop.c</td>
</tr>
<tr>
<td>drivers/gpu/drm/rockchip/rockchip_vop_reg.c</td>
<td></td>
</tr>
<tr>
<td>drivers/gpu/drm/rockchip/rockchip_drm_vop2.c</td>
<td></td>
</tr>
<tr>
<td>drivers/gpu/drm/rockchip/rockchip_vop2_reg.c</td>
<td></td>
</tr>
<tr>
<td>lvds</td>
<td>drivers/gpu/drm/rockchip/rockchip_lvds.c</td>
</tr>
<tr>
<td>rgb</td>
<td>drivers/gpu/drm/rockchip/rockchip_rgb.c</td>
</tr>
<tr>
<td>mipi</td>
<td>drivers/gpu/drm/rockchip/dw-mipi-dsi-rockchip.c</td>
</tr>
<tr>
<td>hdmi</td>
<td>drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c</td>
</tr>
<tr>
<td>drivers/gpu/drm/rockchip/inno_hdmi.c</td>
<td></td>
</tr>
<tr>
<td>edp</td>
<td>drivers/gpu/drm/rockchip/analogix_dp-rockchip.c</td>
</tr>
<tr>
<td>drivers/gpu/drm/bridge/analogix/analogix_dp_core.c drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c</td>
<td></td>
</tr>
<tr>
<td>dp</td>
<td>drivers/gpu/drm/rockchip/cdn-dp-core.c</td>
</tr>
<tr>
<td>drivers/gpu/drm/rockchip/cdn-dp-reg.c</td>
<td></td>
</tr>
</tbody></table>
<p>显示子系统各个模块驱动加载顺序如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm02/202309102233517.png" alt="img"></p>
<p>这里我们对驱动加载顺序图简单说明一下：</p>
<ul>
<li>在各种<code>encoder driver</code>和<code>crtc driver</code>的<code>probe</code>函数中：通过<code>component_add</code>将自己注册进系统；</li>
<li>在<code>Rockchip DRM Master driver</code>的<code>probe</code>函数中；<ul>
<li>通过<code>rockchip_drm_match_add</code>为每个<code>component</code>（各种<code>encoder</code>和<code>crtc</code> ）注册一个<code>component_match_array</code>到<code>component_match</code>；</li>
<li>通过<code>component_master_add_with_match</code>触发各种<code>encoder</code>和<code>crtc</code> <code>component</code>的<code>bind</code>操作，例如<code>vop_bind</code>、<code>dw_hdmi_rockchip_bind</code>等；</li>
</ul>
</li>
<li><code>bind</code>的含义就是将<code>DRM</code>框架里的组件关联在一起，以<code>vop_bind</code>为例：<ul>
<li><code>VOP driver</code>对应<code>crtc driver</code>，<code>crtc</code> 负责连接<code>plane</code>和<code>encoder</code>;</li>
<li><code>vop_create_crtc</code> -&gt; <code>drm_crtc_init_with_planes</code>初始化<code>crtc</code>对象，并和<code>plane</code>关联在一起;</li>
</ul>
</li>
<li>剩下的就是边边角角的工作，例如注册<code>framebuffer</code>以兼容<code>FBDEV</code>，显示<code>logo</code>等。</li>
</ul>
<p>因为这些复杂的依赖关系，在<code>DRM</code>系统初始化的过程中，可能会出现某个资源暂时未就绪，而导致某个模块暂时无法顺利加载的情况。</p>
<p>为了解决这种问题，<code>DRM</code>驱动利用了<code>Linux</code>驱动中的<code>deferred probe</code>机制，当发现某个依赖的资源未就绪的时候，驱动返回<code>-EPROBE_DEFER(-517)</code> , 然后退出。<code>Linux kernel</code>会在稍后再次尝试加载这个驱动，直到依赖的资源就绪，驱动顺利加载为止。</p>
<h3 id="二、设备树配置"><a href="#二、设备树配置" class="headerlink" title="二、设备树配置"></a>二、设备树配置</h3><p>在<code>RK3399</code>上，包含两个<code>VOP</code>、以及1个<code>MIPI</code>、1个<code>DP</code>、1个<code>eDP</code>、双通道<code>MIPI DSI</code>(4线/通道)显示接口；根据不用的显示屏，我们选择不同的模块来组成显示通路。具体使用那些模块，以及这些模块之间如何衔接通过<code>dts</code>配置。</p>
<h4 id="2-1-display-subsystem设备节点"><a href="#2-1-display-subsystem设备节点" class="headerlink" title="2.1 display_subsystem设备节点"></a>2.1 <code>display_subsystem</code>设备节点</h4><p>在每⼀个⽀持<code>DRM</code>显⽰功能的<code>SoC</code>的核⼼设备树⾥⾯，都会有<code>display_subsystem</code>节点：所有的子设备信息都通过设备树描述关联起来，这样系统开机后，就能统一的管理各个设备。</p>
<p><code>display_subsystem</code>设备节点定义在<code>arch/arm64/boot/dts/rockchip/rk3399.dtsi</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> display_subsystem: display-subsystem &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,display-subsystem&quot;</span>;</span><br><span class="line">        ports = &lt;&amp;vopl_out&gt;, &lt;&amp;vopb_out&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该节点描述的是<code>Rockchip DRM</code>主设备，也就是我们在<code>component</code>框架中介绍的<code>aggregate_device</code> ，这是一个虚拟设备，用于列出组成图形子系统的所有<code>vop</code>设备或其他显示接口节点。该设备节点对应的驱动代码位于<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</code>。</p>
<p>其中<code>ports</code>属性描述<code>vop</code>硬件资源，列出了指向各个<code>vop</code>设备的<code>phandle</code>，<code>vopl_out</code>、<code>vopb_out</code>对应着<code>VOP_LITE</code>、<code>VOP_BIG</code>。</p>
<p>更多属性信息可以参考：</p>
<ul>
<li><code>Documentation/devicetree/bindings/display/rockchip/rockchip-drm.yaml</code>；</li>
<li><code>Documentation/devicetree/bindings/display/rockchip/rockchip-vop.yaml</code>。</li>
</ul>
<h4 id="2-2-vop设备节点"><a href="#2-2-vop设备节点" class="headerlink" title="2.2 vop设备节点"></a>2.2 <code>vop</code>设备节点</h4><p><code>vop</code>设备节点描述了<code>vop</code>硬件资源，控制<code>vop</code>驱动的加载<code>rockchip_drm_vop.c</code>、 <code>rockchip_drm_vop2.c</code>。</p>
<p>以设备节点<code>vopb_out</code>为例，<code>vopb_out</code>设备节点定义在<code>arch/arm64/boot/dts/rockchip/rk3399.dtsi</code>;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">vopb: vop@ff900000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;rockchip,rk3399-vop-big&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0xff900000</span> <span class="number">0x0</span> <span class="number">0x2000</span>&gt;, &lt;<span class="number">0x0</span> <span class="number">0xff902000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">118</span> IRQ_TYPE_LEVEL_HIGH <span class="number">0</span>&gt;;</span><br><span class="line">        assigned-clocks = &lt;&amp;cru ACLK_VOP0&gt;, &lt;&amp;cru HCLK_VOP0&gt;;</span><br><span class="line">        assigned-clock-rates = &lt;<span class="number">400000000</span>&gt;, &lt;<span class="number">100000000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;cru ACLK_VOP0&gt;, &lt;&amp;cru DCLK_VOP0&gt;, &lt;&amp;cru HCLK_VOP0&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;aclk_vop&quot;</span>, <span class="string">&quot;dclk_vop&quot;</span>, <span class="string">&quot;hclk_vop&quot;</span>;</span><br><span class="line">        iommus = &lt;&amp;vopb_mmu&gt;;</span><br><span class="line">        power-domains = &lt;&amp;power RK3399_PD_VOPB&gt;;</span><br><span class="line">        resets = &lt;&amp;cru SRST_A_VOP0&gt;, &lt;&amp;cru SRST_H_VOP0&gt;, &lt;&amp;cru SRST_D_VOP0&gt;;</span><br><span class="line">        reset-names = <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;ahb&quot;</span>, <span class="string">&quot;dclk&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"></span><br><span class="line">        vopb_out: port &#123;</span><br><span class="line">                <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">                <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">                vopb_out_edp: endpoint@<span class="number">0</span> &#123;</span><br><span class="line">                        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">                        remote-endpoint = &lt;&amp;edp_in_vopb&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                vopb_out_mipi: endpoint@<span class="number">1</span> &#123;</span><br><span class="line">                        reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">                        remote-endpoint = &lt;&amp;mipi_in_vopb&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                vopb_out_hdmi: endpoint@<span class="number">2</span> &#123;</span><br><span class="line">                        reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">                        remote-endpoint = &lt;&amp;hdmi_in_vopb&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                vopb_out_mipi1: endpoint@<span class="number">3</span> &#123;</span><br><span class="line">                        reg = &lt;<span class="number">3</span>&gt;;</span><br><span class="line">                        remote-endpoint = &lt;&amp;mipi1_in_vopb&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                vopb_out_dp: endpoint@<span class="number">4</span> &#123;</span><br><span class="line">                        reg = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">                        remote-endpoint = &lt;&amp;dp_in_vopb&gt;;</span><br><span class="line">                &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>子节点<code>port</code>下的<code>endpoint</code>描述的是<code>vop</code>和显示接口的连接关系，<code>vopb_out</code>节点下有<code>vopb_out_edp</code>，<code>vopb_out_mipi</code>，<code>vopb_out_hdmi</code>，<code>vopb_out_mipi1</code>、<code>vopb_out_dp</code>五个节点，说明<code>vopb</code>可以和<code>mipi dsi0</code>、<code>edp</code>、<code>hdmi</code>、<code>mipi dsi1</code>、<code>dp</code>五个显示接口连接。</p>
<p>每个<code>endpoint</code>通过<code>remote-endpoint</code>属性和对应的显示接口组成一个连接通路，例如<code>vopb_out_hdmi</code> —&gt; <code>hdmi_in_vopb</code>。</p>
<p>设备节点<code>vopl_out</code>同理，这里就不在介绍了；</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/Android_Display_System/Android11_Drm02/202310192133896.svg"></p>
<h4 id="2-3-内核配置"><a href="#2-3-内核配置" class="headerlink" title="2.3 内核配置"></a>2.3 内核配置</h4><p><code>make menuconfig</code>配置内核：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">  Graphics support ---&gt;</span><br><span class="line">        &lt;*&gt; Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)  ---&gt; </span><br><span class="line">       &lt;*&gt;  <span class="function">DRM Support <span class="keyword">for</span> <span class="title">Rockchip</span> <span class="params">(DRM_ROCKCHIP [=y])</span>     </span></span><br><span class="line">     [*]   Rockchip VOP driver</span><br><span class="line">     [ ]   Rockchip VOP2 driver</span><br><span class="line">     [*]   <span class="function">Rockchip specific extensions <span class="keyword">for</span> Analogix DP <span class="title">driver</span>  <span class="params">(ROCKCHIP_ANALOGIX_DP [=y])</span> </span></span><br><span class="line">     [*]   Rockchip cdn DP</span><br><span class="line">     [*]   Rockchip specific extensions <span class="keyword">for</span> Synopsys DW HDMI </span><br><span class="line">     [*]   Rockchip specific extensions <span class="keyword">for</span> Synopsys DW MIPI DSI</span><br><span class="line">     [*]   Rockchip specific extensions <span class="keyword">for</span> Innosilicon HDMI</span><br><span class="line">     [*]   Rockchip LVDS support</span><br><span class="line">     [ ]   Rockchip RGB support</span><br></pre></td></tr></table></figure>



<h3 id="三、DRM驱动入口"><a href="#三、DRM驱动入口" class="headerlink" title="三、DRM驱动入口"></a>三、<code>DRM</code>驱动入口</h3><p>DRM驱动模块入口函数为<code>rockchip_drm_init</code>，位于<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_ROCKCHIP_SUB_DRIVER(drv, cond) &#123; \</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ENABLED(cond) &amp;&amp; \</span><br><span class="line">            !WARN_ON(num_rockchip_sub_drivers &gt;= MAX_ROCKCHIP_SUB_DRIVERS)) \</span><br><span class="line">                rockchip_sub_drivers[num_rockchip_sub_drivers++] = &amp;drv; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">rockchip_drm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drm_firmware_drivers_only())</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据配置来决定是否添加xxx_xxx_driver到数组rockchip_sub_drivers</span></span><br><span class="line">        num_rockchip_sub_drivers = <span class="number">0</span>;</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(vop_platform_driver, CONFIG_ROCKCHIP_VOP);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(vop2_platform_driver, CONFIG_ROCKCHIP_VOP2);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(rockchip_lvds_driver,</span><br><span class="line">                                CONFIG_ROCKCHIP_LVDS);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(rockchip_dp_driver,</span><br><span class="line">                                CONFIG_ROCKCHIP_ANALOGIX_DP);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(cdn_dp_driver, CONFIG_ROCKCHIP_CDN_DP);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(dw_hdmi_rockchip_pltfm_driver,</span><br><span class="line">                                CONFIG_ROCKCHIP_DW_HDMI);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(dw_mipi_dsi_rockchip_driver,</span><br><span class="line">                                CONFIG_ROCKCHIP_DW_MIPI_DSI);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(inno_hdmi_driver, CONFIG_ROCKCHIP_INNO_HDMI);</span><br><span class="line">        ADD_ROCKCHIP_SUB_DRIVER(rk3066_hdmi_driver,</span><br><span class="line">                                CONFIG_ROCKCHIP_RK3066_HDMI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 注册多个platform driver    </span></span><br><span class="line">        ret = platform_register_drivers(rockchip_sub_drivers,</span><br><span class="line">                                        num_rockchip_sub_drivers);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册rockchip_drm_platform_driver</span></span><br><span class="line">        ret = platform_driver_register(&amp;rockchip_drm_platform_driver);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_unreg_drivers;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_unreg_drivers:</span><br><span class="line">        platform_unregister_drivers(rockchip_sub_drivers,</span><br><span class="line">                                    num_rockchip_sub_drivers);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(rockchip_drm_init);</span><br></pre></td></tr></table></figure>

<p>(1) 函数内部多次调用宏<code>ADD_ROCKCHIP_SUB_DRIVER</code>，完成<code>vop</code>、以及显示接口（<code>lvds</code>、<code>dp</code>、<code>hdmi</code>、<code>mipi dsi</code>）的添加。</p>
<p>咱们以<code>hdmi</code>如下代码为例；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_ROCKCHIP_SUB_DRIVER(dw_hdmi_rockchip_pltfm_driver,</span><br><span class="line">            CONFIG_ROCKCHIP_DW_HDMI);</span><br></pre></td></tr></table></figure>

<p>展开得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_ROCKCHIP_DW_HDMI) &amp;&amp; </span><br><span class="line">   !WARN_ON(num_rockchip_sub_drivers &gt;= MAX_ROCKCHIP_SUB_DRIVERS)) </span><br><span class="line">      rockchip_sub_drivers[num_rockchip_sub_drivers++] = &amp;dw_hdmi_rockchip_pltfm_driver; </span><br></pre></td></tr></table></figure>

<p>如果定义了<code>CONFIG_ROCKCHIP_DW_HDMI</code>，会将<code>dw_hdmi_rockchip_pltfm_driver</code>保存到<code>rockchip_sub_drivers</code>数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ROCKCHIP_SUB_DRIVERS 16</span></span><br><span class="line"><span class="comment">// 数组长度为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">rockchip_sub_drivers</span>[<span class="title">MAX_ROCKCHIP_SUB_DRIVERS</span>];</span> </span><br></pre></td></tr></table></figure>

<p>那么宏<code>CONFIG_ROCKCHIP_DW_HDMI</code>到底是什么呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@zhengyang:/work/sambashare/rk3399/linux-6.3# grep &quot;CONFIG_ROCKCHIP_DW_HDMI&quot; drivers/gpu/* -nR</span><br><span class="line">drivers/gpu/drm/rockchip/Makefile:13:rockchipdrm-$(CONFIG_ROCKCHIP_DW_HDMI) += dw_hdmi-rockchip.o</span><br></pre></td></tr></table></figure>

<p>可以看到宏<code>CONFIG_ROCKCHIP_DW_HDMI</code>决定了是否将<code>dw_hdmi-rockchip.c</code>编译到内核。</p>
<p>有关<code>vop</code>、以及显示接口（<code>lvds</code>、<code>dp</code>、<code>hdmi</code>、<code>mipi dsi</code>）的驱动咱们在后面章节单独介绍。</p>
<p>（2）调用<code>platform_register_drivers</code>注册<code>num_rockchip_sub_drivers</code>个<code>platform driver</code>；该函数内部遍历<code>rockchip_sub_drivers</code>数组，多次调用<code>platform_driver_register</code>注册<code>platform driver</code>，函数定义在<code>drivers/base/platform.c</code>；</p>
<p>(3) 最后调用<code>platform_driver_register</code>注册<code>rockchip_drm_platform_driver</code>。</p>
<h4 id="3-1-rockchip-drm-platform-driver"><a href="#3-1-rockchip-drm-platform-driver" class="headerlink" title="3.1 rockchip_drm_platform_driver"></a>3.1 <code>rockchip_drm_platform_driver</code></h4><p><code>dw_hdmi_rockchip_pltfm_driver</code>定义在<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">rockchip_drm_platform_driver</span> = &#123;</span></span><br><span class="line">        .probe = rockchip_drm_platform_probe,</span><br><span class="line">        .remove = rockchip_drm_platform_remove,</span><br><span class="line">        .shutdown = rockchip_drm_platform_shutdown,</span><br><span class="line">        .driver = &#123;</span><br><span class="line">                .name = <span class="string">&quot;rockchip-drm&quot;</span>,</span><br><span class="line">                .of_match_table = rockchip_drm_dt_ids,</span><br><span class="line">                .pm = &amp;rockchip_drm_pm_ops,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-1-of-match-table"><a href="#3-1-1-of-match-table" class="headerlink" title="3.1.1 of_match_table"></a>3.1.1 <code>of_match_table</code></h5><p>其中<code>of_match_table</code>用于设备树匹配，匹配设备树中<code>compatible = &quot;rockchip,display-subsystem&quot;</code>的设备节点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">rockchip_drm_dt_ids</span>[] = &#123;</span></span><br><span class="line">        &#123; .compatible = <span class="string">&quot;rockchip,display-subsystem&quot;</span>, &#125;,</span><br><span class="line">        &#123; <span class="comment">/* sentinel */</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-rockchip-drm-platform-probe"><a href="#3-1-2-rockchip-drm-platform-probe" class="headerlink" title="3.1.2 rockchip_drm_platform_probe"></a>3.1.2 <code>rockchip_drm_platform_probe</code></h5><p>在<code>plaftrom</code>总线设备驱动模型中，我们知道当内核中有<code>platform</code>设备和<code>platform</code>驱动匹配，会调用到<code>platform_driver</code>里的成员<code>.probe</code>，在这里就是<code>rockchip_drm_platform_probe</code>函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">component_master_ops</span> <span class="title">rockchip_drm_ops</span> = &#123;</span></span><br><span class="line">        .bind = rockchip_drm_bind,</span><br><span class="line">        .unbind = rockchip_drm_unbind,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验display-subsystem设备节点的属性ports是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rockchip_drm_platform_of_probe</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> = <span class="title">dev</span>-&gt;<span class="title">of_node</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">port</span>;</span></span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!np)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取ports属性第i个元素指向的设备节点</span></span><br><span class="line">                <span class="comment">// 例如：ports = &lt;&amp;vopl_out&gt;, &lt;&amp;vopb_out&gt; 保存了指向vop设备的phandle，返回指向设备节点的指针</span></span><br><span class="line">                port = of_parse_phandle(np, <span class="string">&quot;ports&quot;</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (!port)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// port的父设备节点存在，则不会进入</span></span><br><span class="line">                <span class="keyword">if</span> (!of_device_is_available(port-&gt;parent)) &#123;</span><br><span class="line">                        of_node_put(port);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置为true</span></span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                of_node_put(port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                DRM_DEV_ERROR(dev, <span class="string">&quot;missing &#x27;ports&#x27; property\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                DRM_DEV_ERROR(dev,</span><br><span class="line">                              <span class="string">&quot;No available vop found for display-subsystem.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rockchip_drm_platform_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = &amp;<span class="title">pdev</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">component_match</span> *<span class="title">match</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验display-subsystem设备节点的属性ports是否有效</span></span><br><span class="line">        ret = rockchip_drm_platform_of_probe(dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个带release函数的component_match</span></span><br><span class="line">        match = rockchip_drm_match_add(dev);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(match))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(match);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向系统注册一个aggregate_device,触发执行rockchip_drm_ops.bind，即rockchip_drm_bind</span></span><br><span class="line">        ret = component_master_add_with_match(dev, &amp;rockchip_drm_ops, match);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                rockchip_drm_match_remove(dev);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 这里代码很简单，首先使用<code>rockchip_drm_match_add</code>来构建一个带<code>release</code>函数的<code>component_match</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct component_match *<span class="title">rockchip_drm_match_add</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">component_match</span> *<span class="title">match</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_rockchip_sub_drivers; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取第i个platform_driver</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">drv</span> = <span class="title">rockchip_sub_drivers</span>[<span class="title">i</span>];</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">p</span> = <span class="title">NULL</span>, *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                        d = platform_find_device_by_driver(p, &amp;drv-&gt;driver);</span><br><span class="line">                        put_device(p);</span><br><span class="line">                        p = d;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!d)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        device_link_add(dev, d, DL_FLAG_STATELESS);</span><br><span class="line">                        <span class="comment">// component_match注册</span></span><br><span class="line">                        component_match_add(dev, &amp;match, component_compare_dev, d);</span><br><span class="line">                &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(match))</span><br><span class="line">                rockchip_drm_match_remove(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> match ?: ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 最后为设备<code>pdev-&gt;dev</code>向系统注册一个<code>aggregate_device</code>，其中系统可执行的初始化操作被设置为了<code>rockchip_drm_ops</code>，我们需要重点关注<code>bind</code>函数的实现，即<code>rockchip_drm_bind</code>，这个我们单独小节介绍。</p>
<h4 id="3-2-rockchip-drm-bind"><a href="#3-2-rockchip-drm-bind" class="headerlink" title="3.2 rockchip_drm_bind"></a>3.2 <code>rockchip_drm_bind</code></h4><p>我们定位到<code>drivers/gpu/drm/rockchip/rockchip_drm_drv.c</code>文件的函数<code>rockchip_drm_bind</code>，该函数用于绑定设备并初始化<code>DRM</code>驱动；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rockchip_drm_bind</span><span class="params">(struct device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">drm_dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_drm_private</span> *<span class="title">private</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. Remove existing drivers that may own the framebuffer memory. */</span></span><br><span class="line">        ret = drm_aperture_remove_framebuffers(<span class="literal">false</span>, &amp;rockchip_drm_driver);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DRM_DEV_ERROR(dev,</span><br><span class="line">                              <span class="string">&quot;Failed to remove existing framebuffers - %d.\n&quot;</span>,</span><br><span class="line">                              ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 动态分配并初始化struct drm_device实例</span></span><br><span class="line">        drm_dev = drm_dev_alloc(&amp;rockchip_drm_driver, dev); </span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(drm_dev))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(drm_dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置drm设备驱动私有数据为drm设备</span></span><br><span class="line">        dev_set_drvdata(dev, drm_dev); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 动态分配rockchip_drm_private</span></span><br><span class="line">        <span class="keyword">private</span> = devm_kzalloc(drm_dev-&gt;dev, <span class="keyword">sizeof</span>(*<span class="keyword">private</span>), GFP_KERNEL); </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">private</span>) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> err_free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drm_dev-&gt;dev_private = <span class="keyword">private</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 初始化drm_device中mode_config结构体</span></span><br><span class="line">        ret = drmm_mode_config_init(drm_dev); </span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化drm_device中mode_config的中成员</span></span><br><span class="line">        rockchip_drm_mode_config_init(drm_dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 6. Try to bind all sub drivers. 执行按顺序执行显示子系统的各个组件的bind函数 */</span></span><br><span class="line">        ret = component_bind_all(dev, drm_dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 初始化IOMMU</span></span><br><span class="line">        ret = rockchip_drm_init_iommu(drm_dev);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_unbind_all;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.初始化vblank</span></span><br><span class="line">        ret = drm_vblank_init(drm_dev, drm_dev-&gt;mode_config.num_crtc);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_iommu_cleanup;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9. 重置模式配置</span></span><br><span class="line">        drm_mode_config_reset(drm_dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 10.init kms poll for handling hpd */</span></span><br><span class="line">        drm_kms_helper_poll_init(drm_dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.注册drm设备</span></span><br><span class="line">        ret = drm_dev_register(drm_dev, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">goto</span> err_kms_helper_poll_fini;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12.设置帧缓冲设备</span></span><br><span class="line">        drm_fbdev_generic_setup(drm_dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_kms_helper_poll_fini:</span><br><span class="line">        drm_kms_helper_poll_fini(drm_dev);</span><br><span class="line">err_iommu_cleanup:</span><br><span class="line">        rockchip_iommu_cleanup(drm_dev);</span><br><span class="line">err_unbind_all:</span><br><span class="line">        component_unbind_all(dev, drm_dev);</span><br><span class="line">err_free:</span><br><span class="line">        drm_dev_put(drm_dev);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数主要步骤如下：</p>
<p>(1) 首先，通过调用<code>drm_aperture_remove_framebuffers</code>函数，移除可能拥有<code>framebuffer memory</code>的现有驱动程序；</p>
<p>为什么要执行这个操作呢？对于一个图形设备来说，可能有多个驱动程序提供支持，但在任何给定的事件只能有一个驱动程序处于活动状态。许多系统在引导过程的早期加载通用图形驱动程序，例如<code>EFI-GOP</code>或<code>VESA</code>，在后续的引导阶段，它们会将通用驱动程序替换为专用的、针对具体硬件的驱动程序。为了接管该设备，专用驱动程序首先必须移除通用驱动程序。<code>DRM aperture</code>函数负责管理<code>DRM framebuffer</code>内存的所有权和驱动程序之间的交接；</p>
<p>更多内容可以参考：<a target="_blank" rel="noopener" href="https://docs.kernel.org/gpu/drm-internals.html#managing-ownership-of-the-framebuffer-aperture"><code>Managing Ownership of the Framebuffer Aperture</code></a>。</p>
<p>(2) 接下来，使用<code>drm_dev_alloc</code>函数为设备动态分配和初始化一个<code>struct drm_device</code>结构体，并将其保存在<code>drm_dev</code>指针中，其<code>driver</code>被设置为<code>rockchip_drm_driver</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drm_dev = drm_dev_alloc(&amp;rockchip_drm_driver, dev); </span><br></pre></td></tr></table></figure>

<p>(3) 然后，使用<code>dev_set_drvdata</code>函数将设备的驱动私有数据设置为<code>drm_dev</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev_set_drvdata(dev, drm_dev); </span><br></pre></td></tr></table></figure>

<p>(4) 使用<code>devm_kzalloc</code>函数为<code>drm_dev</code>动态分配一个<code>rockchip_drm_private</code>结构体，并将其保存在<code>drm_dev-&gt;dev_private</code>指针中；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> = devm_kzalloc(drm_dev-&gt;dev, <span class="keyword">sizeof</span>(*<span class="keyword">private</span>), GFP_KERNEL)</span><br></pre></td></tr></table></figure>

<p>(5) 调用<code>drmm_mode_config_init</code>函数和<code>rockchip_drm_mode_config_init</code>函数对<code>drm_dev</code>进行模式配置的初始化；</p>
<p>(6) 调用<code>component_bind_all</code>函数，执行按顺序执行显示子系统的各个组件的<code>bind</code>函数；</p>
<p>(7) 调用<code>rockchip_drm_init_iommu</code>函数初始化<code>IOMMU</code>；</p>
<p>(8) 调用<code>drm_vblank_init</code>函数初始化<code>vblank</code>；</p>
<p>(9) 调用<code>drm_mode_config_reset</code>函数重置模式配置；</p>
<p>(10) 调用<code>drm_kms_helper_poll_init</code>函数初始化<code>KMS</code>轮询以处理<code>HPD（Hot Plug Detect）</code>；</p>
<p>(11) 在所有准备工作都完成后，调用<code>drm_dev_register</code>函数注册<code>DRM</code>设备；</p>
<p>(12) 调用<code>drm_fbdev_generic_setup</code>函数设置帧缓冲设备；</p>
<h5 id="3-2-1-初始化drm设备"><a href="#3-2-1-初始化drm设备" class="headerlink" title="3.2.1 初始化drm设备"></a>3.2.1 初始化<code>drm</code>设备</h5><p>一个<code>drm</code>驱动的设备由<code>struct drm_device</code>来表示，这里调用<code>drm_dev_alloc</code>进行分配和初始化一个<code>struct drm_device</code>实例，其<code>driver</code>被设置为<code>rockchip_drm_driver</code>，有关<code>rockchip_drm_driver</code>单独小节介绍。</p>
<p><code>drm_dev_alloc</code>函数定义在<code>drivers/gpu/drm/drm_drv.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_dev_alloc - Allocate new DRM device</span></span><br><span class="line"><span class="comment"> * @driver: DRM driver to allocate device for</span></span><br><span class="line"><span class="comment"> * @parent: Parent device object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the deprecated version of devm_drm_dev_alloc(), which does not support</span></span><br><span class="line"><span class="comment"> * subclassing through embedding the struct &amp;drm_device in a driver private</span></span><br><span class="line"><span class="comment"> * structure, and which does not support automatic cleanup through devres.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * Pointer to new DRM device, or ERR_PTR on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct drm_device *<span class="title">drm_dev_alloc</span><span class="params">(<span class="keyword">const</span> struct drm_driver *driver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 struct device *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态分配一个struct drm_device </span></span><br><span class="line">        dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!dev)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化drm_device</span></span><br><span class="line">        ret = drm_dev_init(dev, driver, parent);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                kfree(dev);</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drmm_add_final_kfree(dev, dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>drm_dev_alloc</code>函数时一个已废弃版本，它不支持在驱动程序的私有结构中嵌入<code>struct drm_device</code>来实现子类化，并且不支持通过<code>devres</code>进行自动清理。</p>
<p><code>drm_dev_alloc</code>函数内部调用<code>drm_dev_init</code>去初始化<code>struct drm_device</code>实例。</p>
<h5 id="3-2-2-模式配置初始化"><a href="#3-2-2-模式配置初始化" class="headerlink" title="3.2.2 模式配置初始化"></a>3.2.2 模式配置初始化</h5><p>下面我们分析一下<code>drmm_mode_config_init</code>函数和<code>rockchip_drm_mode_config_init</code>函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用drm_mode_config_init初始化drm_device中mode_config</span></span><br><span class="line">ret = drmm_mode_config_init(drm_dev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充mode_config中min_width, min_height、max_width, max_height的值，这些值是framebuffer的大小限制</span></span><br><span class="line"><span class="comment">// 设置mode_config-&gt;funcs指针，本质是一组由驱动实现的回调函数</span></span><br><span class="line">rockchip_drm_mode_config_init(drm_dev);</span><br></pre></td></tr></table></figure>

<p><code>rockchip_drm_mode_config_init</code>函数定义在<code>drivers/gpu/drm/rockchip/rockchip_drm_fb.c</code>，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rockchip_drm_mode_config_init</span><span class="params">(struct drm_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        dev-&gt;mode_config.min_width = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;mode_config.min_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * set max width and height as default value(4096x4096).</span></span><br><span class="line"><span class="comment">         * this value would be used to check framebuffer size limitation</span></span><br><span class="line"><span class="comment">         * at drm_mode_addfb().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dev-&gt;mode_config.max_width = <span class="number">4096</span>;  <span class="comment">// 设备上支持的最大帧缓冲区像素高度</span></span><br><span class="line">        dev-&gt;mode_config.max_height = <span class="number">4096</span>; <span class="comment">// 设备上支持的最大帧缓冲区像素高度</span></span><br><span class="line"></span><br><span class="line">        dev-&gt;mode_config.funcs = &amp;rockchip_drm_mode_config_funcs;</span><br><span class="line">        dev-&gt;mode_config.helper_private = &amp;rockchip_mode_config_helpers;</span><br><span class="line"></span><br><span class="line">        dev-&gt;mode_config.normalize_zpos = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1） <code>drm</code>显示器模式设置<code>mode_config</code>回调函数<code>funcs</code>被设置为<code>rockchip_drm_mode_config_funcs</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config_funcs</span> <span class="title">rockchip_drm_mode_config_funcs</span> = &#123;</span></span><br><span class="line">        .fb_create = rockchip_fb_create,</span><br><span class="line">        .atomic_check = drm_atomic_helper_check,</span><br><span class="line">        .atomic_commit = drm_atomic_helper_commit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fb_create</code> 回调接口用于创建<code>framebuffer object</code>，该函数我们在后面<code>GEM</code>章节单独介绍。</p>
<p>(2) <code>drm</code>显示器模式设置<code>mode_config</code>中间层私有数据<code>helper_private</code>被设置为了<code>rockchip_mode_config_helpers</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_mode_config_helper_funcs</span> <span class="title">rockchip_mode_config_helpers</span> = &#123;</span></span><br><span class="line">        .atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-component-bind-all"><a href="#3-2-3-component-bind-all" class="headerlink" title="3.2.3 component_bind_all"></a>3.2.3 <code>component_bind_all</code></h5><p>在<code>component_bind_all</code>函数我们已经在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/17678424.html#_label2_4"><code>《Rockchip RK3399 - component</code>框架》</a>详细介绍了；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * component_bind_all - bind all components of an aggregate driver</span></span><br><span class="line"><span class="comment"> * @parent: parent device of the aggregate driver</span></span><br><span class="line"><span class="comment"> * @data: opaque pointer, passed to all components</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Binds all components of the aggregate @dev by passing @data to their</span></span><br><span class="line"><span class="comment"> * &amp;component_ops.bind functions. Should be called from</span></span><br><span class="line"><span class="comment"> * &amp;component_master_ops.bind.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">component_bind_all</span><span class="params">(struct device *parent, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">aggregate_device</span> *<span class="title">adev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">component</span> *<span class="title">c</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        WARN_ON(!mutex_is_locked(&amp;component_mutex));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据parent查找到aggregate_device</span></span><br><span class="line">        adev = __aggregate_find(parent, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!adev)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bind components in match order */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adev-&gt;match-&gt;num; i++)</span><br><span class="line">                <span class="comment">// duplicate为false时进入</span></span><br><span class="line">                <span class="keyword">if</span> (!adev-&gt;match-&gt;compare[i].duplicate) &#123;</span><br><span class="line">                        c = adev-&gt;match-&gt;compare[i].component;</span><br><span class="line">                        <span class="comment">// 执行component的bind函数</span></span><br><span class="line">                        ret = component_bind(c, adev, data);</span><br><span class="line">                        <span class="keyword">if</span> (ret)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123; <span class="comment">// 正常不会走这里</span></span><br><span class="line">                <span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">                        <span class="keyword">if</span> (!adev-&gt;match-&gt;compare[i - <span class="number">1</span>].duplicate) &#123;</span><br><span class="line">                                c = adev-&gt;match-&gt;compare[i - <span class="number">1</span>].component;</span><br><span class="line">                                component_unbind(c, adev, data);</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过设备<code>parent</code>找到与之关联的的<code>aggregate_device</code>，再按照<code>aggregate_device</code>→<code>component_match_array</code>→<code>component</code>的顺序找到<code>component</code>，然后就能调用<code>component</code>的<code>bind</code>函数。</p>
<h5 id="3-2-4-注册drm设备"><a href="#3-2-4-注册drm设备" class="headerlink" title="3.2.4 注册drm设备"></a>3.2.4 注册<code>drm</code>设备</h5><p>最后调用<code>drm_dev_register</code>注册<code>drm</code>设备。</p>
<h3 id="四、rockchip-drm-driver"><a href="#四、rockchip-drm-driver" class="headerlink" title="四、rockchip_drm_driver"></a>四、<code>rockchip_drm_driver</code></h3><p>接下来我们以源码<code>rockchip_drm_drv.c</code>中的<code>rockchip_drm_driver</code>全局变量作为切入点进行介绍；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">drm_driver</span> <span class="title">rockchip_drm_driver</span> = &#123;</span></span><br><span class="line">        .driver_features        = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,</span><br><span class="line">        .dumb_create            = rockchip_gem_dumb_create,</span><br><span class="line">        .prime_handle_to_fd     = drm_gem_prime_handle_to_fd,</span><br><span class="line">        .prime_fd_to_handle     = drm_gem_prime_fd_to_handle,</span><br><span class="line">        .gem_prime_import_sg_table      = rockchip_gem_prime_import_sg_table,</span><br><span class="line">        .gem_prime_mmap         = drm_gem_prime_mmap,</span><br><span class="line">        .fops                   = &amp;rockchip_drm_driver_fops,</span><br><span class="line">        .name   = DRIVER_NAME,</span><br><span class="line">        .desc   = DRIVER_DESC,</span><br><span class="line">        .date   = DRIVER_DATE,</span><br><span class="line">        .major  = DRIVER_MAJOR,</span><br><span class="line">        .minor  = DRIVER_MINOR,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-driver-features"><a href="#4-1-driver-features" class="headerlink" title="4.1 driver_features"></a>4.1 <code>driver_features</code></h4><ul>
<li>添加上 <code>DRIVER_GEM</code> 标志位，告诉<code>DRM Core</code>该驱动支持<code>GEM</code>操作；</li>
<li>添加上 <code>DRIVER_MODESET</code> 标志位，告诉<code>DRM Core</code> 该驱动支持<code>kernel Mode Setting</code>操作；</li>
<li>添加上 <code>DRIVER_ATOMIC</code> 标志位，告诉 <code>DRM Core</code>该驱动支持<code>Atomic</code>操作。</li>
</ul>
<h4 id="4-2-宏变量"><a href="#4-2-宏变量" class="headerlink" title="4.2 宏变量"></a>4.2 宏变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME     <span class="meta-string">&quot;rockchip&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_DESC     <span class="meta-string">&quot;RockChip Soc DRM&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_DATE     <span class="meta-string">&quot;20140818&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_MAJOR    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_MINOR    0</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-dumb-create"><a href="#4-3-dumb-create" class="headerlink" title="4.3 dumb_create"></a>4.3 <code>dumb_create</code></h4><p>其中<code>dumb_create</code>配置为<code>rockchip_gem_dumb_create</code>，该函数用于分配物理内存<code>dumb buffer</code>，<code>gem</code>相关的内容后面我们单独章节介绍。</p>
<h4 id="4-4、DRM设备节点文件操作集"><a href="#4-4、DRM设备节点文件操作集" class="headerlink" title="4.4、DRM设备节点文件操作集"></a>4.4、<code>DRM</code>设备节点文件操作集</h4><p><code>DRM</code>驱动程序必须定义文件操作结构，形成<code>DRM</code>用户空间<code>API</code>的入口点，在<code>rockchip_drm_driver</code>中将<code>DRM</code>设备节点文件操作集<code>fops</code>设置为<code>rockchip_drm_driver_fops</code>，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_DRM_GEM_FOPS(rockchip_drm_driver_fops);</span><br></pre></td></tr></table></figure>

<p><code>DEFINE_DRM_GEM_FOPS</code>宏定义在<code>include/drm/drm_gem.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DRM_GEM_FOPS - Default drm GEM file operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro provides a shorthand for setting the GEM file ops in the</span></span><br><span class="line"><span class="comment"> * &amp;file_operations structure.  If all you need are the default ops, use</span></span><br><span class="line"><span class="comment"> * DEFINE_DRM_GEM_FOPS instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRM_GEM_FOPS \</span></span><br><span class="line">        .open           = drm_open,\</span><br><span class="line">        .release        = drm_release,\</span><br><span class="line">        .unlocked_ioctl = drm_ioctl,\</span><br><span class="line">        .compat_ioctl   = drm_compat_ioctl,\</span><br><span class="line">        .poll           = drm_poll,\</span><br><span class="line">        .read           = drm_read,\</span><br><span class="line">        .llseek         = noop_llseek,\</span><br><span class="line">        .mmap           = drm_gem_mmap</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DEFINE_DRM_GEM_FOPS() - macro to generate file operations for GEM drivers</span></span><br><span class="line"><span class="comment"> * @name: name for the generated structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro autogenerates a suitable &amp;struct file_operations for GEM based</span></span><br><span class="line"><span class="comment"> * drivers, which can be assigned to &amp;drm_driver.fops. Note that this structure</span></span><br><span class="line"><span class="comment"> * cannot be shared between drivers, because it contains a reference to the</span></span><br><span class="line"><span class="comment"> * current module using THIS_MODULE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the declaration is already marked as static - if you need a</span></span><br><span class="line"><span class="comment"> * non-static version of this you&#x27;re probably doing it wrong and will break the</span></span><br><span class="line"><span class="comment"> * THIS_MODULE reference by accident.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#define DEFINE_DRM_GEM_FOPS(name) \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> struct file_operations name = &#123;\</span><br><span class="line">                .owner          = THIS_MODULE,\</span><br><span class="line">                DRM_GEM_FOPS,\</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>宏展开后得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rockchip_drm_driver_fops</span> = &#123;</span></span><br><span class="line">        .owner          = THIS_MODULE,</span><br><span class="line">        .open           = drm_open,</span><br><span class="line">        .release        = drm_release,</span><br><span class="line">        .unlocked_ioctl = drm_ioctl,</span><br><span class="line">        .compat_ioctl   = drm_compat_ioctl,</span><br><span class="line">        .poll           = drm_poll,</span><br><span class="line">        .read           = drm_read,</span><br><span class="line">        .llseek         = noop_llseek,</span><br><span class="line">        .mmap           = drm_gem_mmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制要求的函数是<code>drm_open</code>、<code>drm_read</code>、<code>drm_ioctl</code>和<code>drm_compat_ioctl</code>（如果启用了<code>CONFIG_COMPAT</code>）；<br><code>drm_read</code>和<code>drm_poll</code>提供了对<code>DRM</code>事件的支持。<code>DRM</code>事件是一种通用且可扩展的方式，通过文件描述符向用户空间发送异步事件。它们用于通过<code>KMS API</code>发送<code>vblank</code>事件和页面翻转完成事件。但是驱动程序也可以根据自己的需求使用它，例如用于信号渲染完成。<br>内存映射的实现方式将根据驱动程序如何管理内存而有所不同：</p>
<ul>
<li>过时驱动程序将使用<code>drm_legacy_mmap</code>函数；</li>
<li>现代驱动程序应该使用提供的特定于内存管理器的实现之一；对于基于<code>GEM</code>的驱动程序，可以使用<code>drm_gem_mmap</code>。</li>
</ul>
<h5 id="4-4-1-drm-open"><a href="#4-4-1-drm-open" class="headerlink" title="4.4.1 drm_open"></a>4.4.1 <code>drm_open</code></h5><p>在上一篇博客中，我们说过当打开一个<code>drm</code>设备时，比如<code>/dev/dri/card0</code>，最终回调用<code>drm driver</code>的文件操作集<code>fops</code>中的<code>open</code>函数，即<code>drm_open</code>；<code>drm_open</code>函数定义在<code>drivers/gpu/drm/drm_file.c</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_open - open method for DRM file</span></span><br><span class="line"><span class="comment"> * @inode: device inode</span></span><br><span class="line"><span class="comment"> * @filp: file pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be used by drivers as their &amp;file_operations.open method.</span></span><br><span class="line"><span class="comment"> * It looks up the correct DRM device and instantiates all the per-file</span></span><br><span class="line"><span class="comment"> * resources for it. It also calls the &amp;drm_driver.open driver callback.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 on success or negative errno value on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_minor</span> *<span class="title">minor</span>;</span></span><br><span class="line">        <span class="keyword">int</span> retcode;</span><br><span class="line">        <span class="keyword">int</span> need_setup = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据设备节点获取struct drm_minor</span></span><br><span class="line">        minor = drm_minor_acquire(iminor(inode));</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(minor))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(minor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取drm device</span></span><br><span class="line">        dev = minor-&gt;dev;</span><br><span class="line">        <span class="keyword">if</span> (drm_dev_needs_global_mutex(dev))</span><br><span class="line">                mutex_lock(&amp;drm_global_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!atomic_fetch_inc(&amp;dev-&gt;open_count))</span><br><span class="line">                need_setup = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* share address_space across all char-devs of a single device */</span></span><br><span class="line">        filp-&gt;f_mapping = dev-&gt;anon_inode-&gt;i_mapping;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用drm open helper函数</span></span><br><span class="line">        retcode = drm_open_helper(filp, minor);</span><br><span class="line">        <span class="keyword">if</span> (retcode)</span><br><span class="line">                <span class="keyword">goto</span> err_undo;</span><br><span class="line">        <span class="keyword">if</span> (need_setup) &#123;</span><br><span class="line">                retcode = drm_legacy_setup(dev);</span><br><span class="line">                <span class="keyword">if</span> (retcode) &#123;</span><br><span class="line">                        drm_close_helper(filp);</span><br><span class="line">                        <span class="keyword">goto</span> err_undo;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drm_dev_needs_global_mutex(dev))</span><br><span class="line">                mutex_unlock(&amp;drm_global_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_undo:</span><br><span class="line">        atomic_dec(&amp;dev-&gt;open_count);</span><br><span class="line">        <span class="keyword">if</span> (drm_dev_needs_global_mutex(dev))</span><br><span class="line">                mutex_unlock(&amp;drm_global_mutex);</span><br><span class="line">        drm_minor_release(minor);</span><br><span class="line">        <span class="keyword">return</span> retcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里核心实现为<code>drm_open_helper</code>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called whenever a process opens a drm node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param filp file pointer.</span></span><br><span class="line"><span class="comment"> * \param minor acquired minor-object.</span></span><br><span class="line"><span class="comment"> * \return zero on success or a negative number on failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates and initializes a drm_file structure for the file private data in \p</span></span><br><span class="line"><span class="comment"> * filp and add it into the double linked list in \p dev.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_open_helper</span><span class="params">(struct file *filp, struct drm_minor *minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">minor</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_file</span> *<span class="title">priv</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_EXCL)</span><br><span class="line">                <span class="keyword">return</span> -EBUSY;  <span class="comment">/* No exclusive opens */</span></span><br><span class="line">        <span class="keyword">if</span> (!drm_cpu_valid())</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;switch_power_state != DRM_SWITCH_POWER_ON &amp;&amp;</span><br><span class="line">            dev-&gt;switch_power_state != DRM_SWITCH_POWER_DYNAMIC_OFF)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        drm_dbg_core(dev, <span class="string">&quot;comm=\&quot;%s\&quot;, pid=%d, minor=%d\n&quot;</span>,</span><br><span class="line">                     current-&gt;comm, task_pid_nr(current), minor-&gt;index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态分配并初始化struct drm_file</span></span><br><span class="line">        priv = drm_file_alloc(minor);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(priv))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(priv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drm_is_primary_client(priv)) &#123;</span><br><span class="line">                ret = drm_master_open(priv);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                        drm_file_free(priv);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存为file的私有数据</span></span><br><span class="line">        filp-&gt;private_data = priv;</span><br><span class="line">        filp-&gt;f_mode |= FMODE_UNSIGNED_OFFSET;</span><br><span class="line">        priv-&gt;filp = filp;</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dev-&gt;filelist_mutex);</span><br><span class="line">        list_add(&amp;priv-&gt;lhead, &amp;dev-&gt;filelist);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;filelist_mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-2-内存映射"><a href="#4-4-2-内存映射" class="headerlink" title="4.4.2 内存映射"></a>4.4.2 内存映射</h5><p><code>mmap</code>用于将物理内存<code>dumb buffer</code>映射到用户空间，让应用程序可以直接访问物理内存。<br><code>drm_gem_mmap</code>函数定义在<code>drivers/gpu/drm/drm_gem.c</code>，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_gem_mmap - memory map routine for GEM objects</span></span><br><span class="line"><span class="comment"> * @filp: DRM file pointer</span></span><br><span class="line"><span class="comment"> * @vma: VMA for the area to be mapped</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If a driver supports GEM object mapping, mmap calls on the DRM file</span></span><br><span class="line"><span class="comment"> * descriptor will end up here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Look up the GEM object based on the offset passed in (vma-&gt;vm_pgoff will</span></span><br><span class="line"><span class="comment"> * contain the fake offset we created when the GTT map ioctl was called on</span></span><br><span class="line"><span class="comment"> * the object) and map it with a call to drm_gem_mmap_obj().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the caller is not granted access to the buffer object, the mmap will fail</span></span><br><span class="line"><span class="comment"> * with EACCES. Please see the vma manager for more information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drm_gem_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_file</span> *<span class="title">priv</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_device</span> *<span class="title">dev</span> = <span class="title">priv</span>-&gt;<span class="title">minor</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_gem_object</span> *<span class="title">obj</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">drm_vma_offset_node</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查drm设备是否已被拔出</span></span><br><span class="line">        <span class="keyword">if</span> (drm_dev_is_unplugged(dev))</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定VMA管理器</span></span><br><span class="line">        drm_vma_offset_lock_lookup(dev-&gt;vma_offset_manager);</span><br><span class="line">        node = drm_vma_offset_exact_lookup_locked(dev-&gt;vma_offset_manager,</span><br><span class="line">                                                  vma-&gt;vm_pgoff,</span><br><span class="line">                                                  vma_pages(vma));</span><br><span class="line">        <span class="keyword">if</span> (likely(node)) &#123;</span><br><span class="line">                obj = container_of(node, struct drm_gem_object, vma_node);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * When the object is being freed, after it hits 0-refcnt it</span></span><br><span class="line"><span class="comment">                 * proceeds to tear down the object. In the process it will</span></span><br><span class="line"><span class="comment">                 * attempt to remove the VMA offset and so acquire this</span></span><br><span class="line"><span class="comment">                 * mgr-&gt;vm_lock.  Therefore if we find an object with a 0-refcnt</span></span><br><span class="line"><span class="comment">                 * that matches our range, we know it is in the process of being</span></span><br><span class="line"><span class="comment">                 * destroyed and will be freed as soon as we release the lock -</span></span><br><span class="line"><span class="comment">                 * so we have to check for the 0-refcnted object and treat it as</span></span><br><span class="line"><span class="comment">                 * invalid.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!kref_get_unless_zero(&amp;obj-&gt;refcount))</span><br><span class="line">                        obj = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁VMA管理器</span></span><br><span class="line">        drm_vma_offset_unlock_lookup(dev-&gt;vma_offset_manager);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!obj)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!drm_vma_node_is_allowed(node, priv)) &#123;</span><br><span class="line">                drm_gem_object_put(obj);</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the VMA to prepare mapping of the GEM object using the GEM object&#x27;s vm_ops</span></span><br><span class="line">        ret = drm_gem_mmap_obj(obj, drm_vma_node_size(node) &lt;&lt; PAGE_SHIFT,</span><br><span class="line">                               vma);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GEM对象引用计数-1</span></span><br><span class="line">        drm_gem_object_put(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong></p>
<p><strong>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/hexiaolong2009/category_9281458.html"><code>DRM (Direct Rendering Manager)</code></a></strong></p>
<p><strong>[2] <a target="_blank" rel="noopener" href="https://docs.kernel.org/gpu/drm-internals.html#display-driver-example"><code>linux Display driver example</code></a></strong></p>
<p><strong>[3] <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/55c12c4e01cb"><code>Linux DRM</code>那些事-<code>component bind</code>解析</a></strong></p>
<p><strong>[4] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/534267979?utm_id=0&wd=&eqid=c86633fc0001a4990000000664883112"><code>DRM Display Driver Guide</code></a></strong></p>
<p><strong>[5] <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012080932/article/details/114385873"><code>rockchip</code>中的<code>vop</code></a></strong></p>
<p><strong>[6] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/339989406?utm_id=0"><code>RK3399</code>探索之旅/<code>Display</code>子系统/基础概念</a></strong></p>
<p><strong>[7] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rzX3PRlS5zJ-0zs2-JE_tQ"><code>Linux MIPI DSI</code>驱动开发 | 基于<code>RK3399</code></a></strong></p>
<p><strong>[8] <a target="_blank" rel="noopener" href="https://blog.csdn.net/fengchaochao123/article/details/123945687"><code>DRM</code>驱动（一）之显示处理器介绍</a></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">zhoujinjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhoujinjian.com/posts/20240219/">https://zhoujinjian.com/posts/20240219/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zhoujinjian.com" target="_blank">zhoujinjian</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.58.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20240220/"><img class="prev-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.59.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 11 Display System V2（3）：Rockchip RK3399 - DRM framebuffer、plane基础知识</div></div></a></div><div class="next-post pull-right"><a href="/posts/20240218/"><img class="next-cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.57.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 11 Display System V2（1）：Rockchip RK3399 - DRM子系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20210310/" title="Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Android 10 Display System源码分析（1）：LCD显示原理（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210410/" title="Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">Android 10 Display System源码分析（2）：Display System 精彩世界（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210510/" title="Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">Android 10 Display System源码分析（3）：U-boot Display 显示过程源码分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210610/" title="Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Android 10 Display System源码分析（4）：DRM/KMS分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210710/" title="Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-10</div><div class="title">Android 10 Display System源码分析（5）：ModeTest分析（Android 10.0 && Kernel 4.15）</div></div></a></div><div><a href="/posts/20210810/" title="Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）"><img class="cover" data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-10</div><div class="title">Android 10 Display System源码分析（6）：【DRM/KMS】HWComposer && Gralloc2 分析（Android 10.0 && Kernel 4.15）</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%98%BE%E7%A4%BA%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、显示子系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A1%AC%E4%BB%B6%E6%A1%86%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 硬件框图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-RK3399"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 RK3399</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-ROCK-Pi-4B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 ROCK Pi 4B+</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-DRM%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 DRM加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">二、设备树配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-display-subsystem%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 display_subsystem设备节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-vop%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 vop设备节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 内核配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81DRM%E9%A9%B1%E5%8A%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">三、DRM驱动入口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-rockchip-drm-platform-driver"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 rockchip_drm_platform_driver</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-of-match-table"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 of_match_table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-rockchip-drm-platform-probe"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 rockchip_drm_platform_probe</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-rockchip-drm-bind"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 rockchip_drm_bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96drm%E8%AE%BE%E5%A4%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 初始化drm设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 模式配置初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-component-bind-all"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 component_bind_all</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E6%B3%A8%E5%86%8Cdrm%E8%AE%BE%E5%A4%87"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 注册drm设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81rockchip-drm-driver"><span class="toc-number">4.</span> <span class="toc-text">四、rockchip_drm_driver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-driver-features"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 driver_features</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%AE%8F%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 宏变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-dumb-create"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 dumb_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E3%80%81DRM%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%9B%86"><span class="toc-number">4.4.</span> <span class="toc-text">4.4、DRM设备节点文件操作集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1-drm-open"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 drm_open</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2 内存映射</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序"/></a><div class="content"><a class="title" href="/posts/20240225/" title="Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序">Android 11 Display System V2（8）：Rockchip RK3399 - DRM HDMI驱动程序</a><time datetime="2024-02-24T16:00:00.000Z" title="发表于 2024-02-25 00:00:00">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍"/></a><div class="content"><a class="title" href="/posts/20240224/" title="Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍">Android 11 Display System V2（7）：Rockchip RK3399 - DRM HDMI介绍</a><time datetime="2024-02-23T16:00:00.000Z" title="发表于 2024-02-24 00:00:00">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识"/></a><div class="content"><a class="title" href="/posts/20240223/" title="Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识">Android 11 Display System V2（6）：Rockchip RK3399 - DRM encoder、bridge、connector基础知识</a><time datetime="2024-02-22T16:00:00.000Z" title="发表于 2024-02-23 00:00:00">2024-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240222/" title="Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（5）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-21T16:00:00.000Z" title="发表于 2024-02-22 00:00:00">2024-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"><img data-lazy-src="https://raw.githubusercontent.com/zhoujinjianzz/zhoujinjian.com.images/master/post.cover.pictures/bing-wallpaper-2018.04.60.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识"/></a><div class="content"><a class="title" href="/posts/20240221/" title="Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识">Android 11 Display System V2（4）：Rockchip RK3399 - DRM gem基础知识</a><time datetime="2024-02-20T16:00:00.000Z" title="发表于 2024-02-21 00:00:00">2024-02-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zhoujinjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/calendar.js"></script><script src="/js/languages.js"></script><script src="/js/fishes.js"></script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>